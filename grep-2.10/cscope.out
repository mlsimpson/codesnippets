cscope 15 $HOME/codesnippets/grep-2.10 -c               0002113799
	@build-aux/snippet/_Noreturn.h

1 #ifndef 
_Noreturn


2 #if (3 <= 
__GNUC__
 || (__GNUC__ == 2 && 8 <= 
__GNUC_MINOR__
) \

3 || 0x5110 <= 
__SUNPRO_C
)

4 #define 
	#_Noreturn
 
	`__attribute__
 ((
__noreturn__
))

	)

5 #elif 1200 <= 
_MSC_VER


6 #define 
	#_Noreturn
 
	`__declspec
 (
noreturn
)

	)

8 #define 
	#_Noreturn


	)

	@build-aux/snippet/arg-nonnull.h

22 #ifndef 
_GL_ARG_NONNULL


23 #if (
__GNUC__
 == 3 && 
__GNUC_MINOR__
 >= 3) || __GNUC__ > 3

24 #define 
	#_GL_ARG_NONNULL
(
params
) 
	`__attribute__
 ((
__nonnull__
 params))

	)

26 #define 
	#_GL_ARG_NONNULL
(
params
)

	)

	@build-aux/snippet/c++defs.h

19 #ifndef 
_GL_CXXDEFS_H


20 #define 
	#_GL_CXXDEFS_H


	)

83 #if 
defined
 
__cplusplus


84 #define 
	#_GL_EXTERN_C
 extern "C"

	)

86 #define 
	#_GL_EXTERN_C
 extern

	)

96 #define 
	#_GL_FUNCDECL_RPL
(
func
,
rettype
,
parameters_and_attributes
) \

97 
	`_GL_FUNCDECL_RPL_1
 (
rpl_
##
func
, 
rettype
, 
parameters_and_attributes
)

	)

98 #define 
	#_GL_FUNCDECL_RPL_1
(
rpl_func
,
rettype
,
parameters_and_attributes
) \

99 
_GL_EXTERN_C
 
rettype
 
rpl_func
 
parameters_and_attributes


	)

108 #define 
	#_GL_FUNCDECL_SYS
(
func
,
rettype
,
parameters_and_attributes
) \

109 
_GL_EXTERN_C
 
rettype
 
func
 
parameters_and_attributes


	)

117 #define 
	#_GL_CXXALIAS_RPL
(
func
,
rettype
,
parameters
) \

118 
	`_GL_CXXALIAS_RPL_1
 (
func
, 
rpl_
##func, 
rettype
, 
parameters
)

	)

119 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE


120 #define 
	#_GL_CXXALIAS_RPL_1
(
func
,
rpl_func
,
rettype
,
parameters
) \

121 
namespace
 
GNULIB_NAMESPACE
 \

123 
	`rettype
 (*const 
func
) 
parameters
 = ::
rpl_func
; \

125 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

127 #define 
	#_GL_CXXALIAS_RPL_1
(
func
,
rpl_func
,
rettype
,
parameters
) \

128 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

136 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE


137 #define 
	#_GL_CXXALIAS_RPL_CAST_1
(
func
,
rpl_func
,
rettype
,
parameters
) \

138 
namespace
 
GNULIB_NAMESPACE
 \

140 
	`rettype
 (*const 
func
) 
parameters
 = \

141 
reinterpret_cast
<
	`rettype
(*)
parameters
>(::
rpl_func
); \

143 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

145 #define 
	#_GL_CXXALIAS_RPL_CAST_1
(
func
,
rpl_func
,
rettype
,
parameters
) \

146 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

156 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE


163 #define 
	#_GL_CXXALIAS_SYS
(
func
,
rettype
,
parameters
) \

164 
namespace
 
GNULIB_NAMESPACE
 \

166 static 
	`rettype
 (*
func
) 
parameters
 = ::func; \

168 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

170 #define 
	#_GL_CXXALIAS_SYS
(
func
,
rettype
,
parameters
) \

171 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

179 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE


180 #define 
	#_GL_CXXALIAS_SYS_CAST
(
func
,
rettype
,
parameters
) \

181 
namespace
 
GNULIB_NAMESPACE
 \

183 static 
	`rettype
 (*
func
) 
parameters
 = \

184 
reinterpret_cast
<
	`rettype
(*)
parameters
>(::
func
); \

186 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

188 #define 
	#_GL_CXXALIAS_SYS_CAST
(
func
,
rettype
,
parameters
) \

189 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

198 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE


204 #define 
	#_GL_CXXALIAS_SYS_CAST2
(
func
,
rettype
,
parameters
,
rettype2
,
parameters2
) \

205 
namespace
 
GNULIB_NAMESPACE
 \

207 static 
	`rettype
 (*
func
) 
parameters
 = \

208 
reinterpret_cast
<
	`rettype
(*)
parameters
>( \

209 (
	`rettype2
(*)
parameters2
)(::
func
)); \

211 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

213 #define 
	#_GL_CXXALIAS_SYS_CAST2
(
func
,
rettype
,
parameters
,
rettype2
,
parameters2
) \

214 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

221 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE


222 #define 
	#_GL_CXXALIASWARN
(
func
) \

223 
	`_GL_CXXALIASWARN_1
 (
func
, 
GNULIB_NAMESPACE
)

	)

224 #define 
	#_GL_CXXALIASWARN_1
(
func
,
namespace
) \

225 
	`_GL_CXXALIASWARN_2
 (
func
, 
namespace
)

	)

228 #if !
__OPTIMIZE__


229 #define 
	#_GL_CXXALIASWARN_2
(
func
,
namespace
) \

230 
	`_GL_WARN_ON_USE
 (
func
, \

232 "Use " #namespace "::" #func " instead.")

	)

233 #elif 
__GNUC__
 >= 3 && 
GNULIB_STRICT_CHECKING


234 #define 
	#_GL_CXXALIASWARN_2
(
func
,
namespace
) \

235 extern 
	`__typeof__
 (
func
) 
	)
func

237 #define 
	#_GL_CXXALIASWARN_2
(
func
,
namespace
) \

238 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

241 #define 
	#_GL_CXXALIASWARN
(
func
) \

242 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

248 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE


249 #define 
	#_GL_CXXALIASWARN1
(
func
,
rettype
,
parameters_and_attributes
) \

250 
	`_GL_CXXALIASWARN1_1
 (
func
, 
rettype
, 
parameters_and_attributes
, \

251 
GNULIB_NAMESPACE
)

	)

252 #define 
	#_GL_CXXALIASWARN1_1
(
func
,
rettype
,
parameters_and_attributes
,
namespace
) \

253 
	`_GL_CXXALIASWARN1_2
 (
func
, 
rettype
, 
parameters_and_attributes
, 
namespace
)

	)

256 #if !
__OPTIMIZE__


257 #define 
	#_GL_CXXALIASWARN1_2
(
func
,
rettype
,
parameters_and_attributes
,
namespace
) \

258 
	`_GL_WARN_ON_USE_CXX
 (
func
, 
rettype
, 
parameters_and_attributes
, \

260 "Use " #namespace "::" #func " instead.")

	)

261 #elif 
__GNUC__
 >= 3 && 
GNULIB_STRICT_CHECKING


262 #define 
	#_GL_CXXALIASWARN1_2
(
func
,
rettype
,
parameters_and_attributes
,
namespace
) \

263 extern 
	`__typeof__
 (
func
) 
	)
func

265 #define 
	#_GL_CXXALIASWARN1_2
(
func
,
rettype
,
parameters_and_attributes
,
namespace
) \

266 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

269 #define 
	#_GL_CXXALIASWARN1
(
func
,
rettype
,
parameters_and_attributes
) \

270 
_GL_EXTERN_C
 int 
_gl_cxxalias_dummy


	)

	@build-aux/snippet/unused-parameter.h

32 #ifndef 
_GL_UNUSED_PARAMETER


33 #if 
__GNUC__
 >= 3 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 7)

34 #define 
	#_GL_UNUSED_PARAMETER
 
	`__attribute__
 ((
__unused__
))

	)

36 #define 
	#_GL_UNUSED_PARAMETER


	)

	@build-aux/snippet/warn-on-use.h

66 #ifndef 
_GL_WARN_ON_USE


68 #if 4 < 
__GNUC__
 || (__GNUC__ == 4 && 3 <= 
__GNUC_MINOR__
)

70 #define 
	#_GL_WARN_ON_USE
(
function
, 
message
) \

71 extern 
	`__typeof__
 (
function
) function 
	`__attribute__
 ((
	`__warning__
 (
message
)))

	)

72 #elif 
__GNUC__
 >= 3 && 
GNULIB_STRICT_CHECKING


74 #define 
	#_GL_WARN_ON_USE
(
function
, 
message
) \

75 extern 
	`__typeof__
 (
function
) 
	)
function

77 #define 
	#_GL_WARN_ON_USE
(
function
, 
message
) \

78 
_GL_WARN_EXTERN_C
 int 
_gl_warn_on_use


	)

88 #ifndef 
_GL_WARN_ON_USE_CXX


89 #if 4 < 
__GNUC__
 || (__GNUC__ == 4 && 3 <= 
__GNUC_MINOR__
)

90 #define 
	#_GL_WARN_ON_USE_CXX
(
function
,
rettype
,
parameters_and_attributes
,
msg
) \

91 extern 
rettype
 
function
 
parameters_and_attributes
 \

92 
	`__attribute__
 ((
	`__warning__
 (
msg
)))

	)

93 #elif 
__GNUC__
 >= 3 && 
GNULIB_STRICT_CHECKING


95 #define 
	#_GL_WARN_ON_USE_CXX
(
function
,
rettype
,
parameters_and_attributes
,
msg
) \

96 extern 
rettype
 
function
 
parameters_and_attributes


	)

98 #define 
	#_GL_WARN_ON_USE_CXX
(
function
,
rettype
,
parameters_and_attributes
,
msg
) \

99 
_GL_WARN_EXTERN_C
 int 
_gl_warn_on_use


	)

105 #ifndef 
_GL_WARN_EXTERN_C


106 #if 
defined
 
__cplusplus


107 #define 
	#_GL_WARN_EXTERN_C
 extern "C"

	)

109 #define 
	#_GL_WARN_EXTERN_C
 extern

	)

	@gnulib-tests/anytostr.c

23 #if (
__GNUC__
 == 4 && 3 <= 
__GNUC_MINOR__
) || 4 < __GNUC__

24 #pragma 
GCC
 
diagnostic
 
ignored
 "-Wtype-limits"

27 #include 
	~<config.h
>

29 #include 
	~"inttostr.h
"

35 char * 
__attribute_warn_unused_result__


36 
	$anytostr
 (
inttype
 
i
, char *
buf
)

38 char *
p
 = 
buf
 + 
	`INT_STRLEN_BOUND
 (
inttype
);

39 *
p
 = 0;

41 if (
i
 < 0)

44 *--
p
 = '0' - 
i
 % 10;

45 while ((
i
 /= 10) != 0);

47 *--
p
 = '-';

52 *--
p
 = '0' + 
i
 % 10;

53 while ((
i
 /= 10) != 0);

56 return 
p
;

57 
	}
}

	@gnulib-tests/asnprintf.c

20 #include 
	~<config.h
>

23 #include 
	~"vasnprintf.h
"

25 #include 
	~<stdarg.h
>

28 
	$asnprintf
 (char *
resultbuf
, 
size_t
 *
lengthp
, const char *
format
, ...)

30 
va_list
 
args
;

31 char *
result
;

33 
	`va_start
 (
args
, 
format
);

34 
result
 = 
	`vasnprintf
 (
resultbuf
, 
lengthp
, 
format
, 
args
);

35 
	`va_end
 (
args
);

36 return 
result
;

37 
	}
}

	@gnulib-tests/close.c

19 #include 
	~<config.h
>

22 #include 
	~<unistd.h
>

24 #include 
	~<errno.h
>

26 #include 
	~"fd-hook.h
"

27 #include 
	~"msvc-inval.h
"

29 #undef 
close


31 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER


33 
	$close_nothrow
 (int 
fd
)

35 int 
result
;

37 
TRY_MSVC_INVAL


39 
result
 = 
	`close
 (
fd
);

41 
CATCH_MSVC_INVAL


43 
result
 = -1;

44 
errno
 = 
EBADF
;

46 
DONE_MSVC_INVAL
;

48 return 
result
;

49 
	}
}

51 #define 
	#close_nothrow
 
close


	)

57 
	$rpl_close
 (int 
fd
)

59 #if 
WINDOWS_SOCKETS


60 int 
retval
 = 
	`execute_all_close_hooks
 (
close_nothrow
, 
fd
);

62 int 
retval
 = 
	`close_nothrow
 (
fd
);

65 #if 
REPLACE_FCHDIR


66 if (
retval
 >= 0)

67 
	`_gl_unregister_fd
 (
fd
);

70 return 
retval
;

71 
	}
}

	@gnulib-tests/dup2.c

22 #include 
	~<config.h
>

25 #include 
	~<unistd.h
>

27 #include 
	~<errno.h
>

28 #include 
	~<fcntl.h
>

30 #if 
HAVE_DUP2


32 #undef 
dup2


34 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


37 #define 
	#WIN32_LEAN_AND_MEAN


	)

38 #include 
	~<windows.h
>

40 #include 
	~"msvc-inval.h
"

43 #include 
	~"msvc-nothrow.h
"

46 
	$ms_windows_dup2
 (int 
fd
, int 
desired_fd
)

48 int 
result
;

53 if (
fd
 == 
desired_fd
)

55 if ((
HANDLE
) 
	`_get_osfhandle
 (
fd
) == 
INVALID_HANDLE_VALUE
)

57 
errno
 = 
EBADF
;

60 return 
fd
;

65 if (
desired_fd
 < 0)

67 
errno
 = 
EBADF
;

71 
TRY_MSVC_INVAL


73 
result
 = 
	`dup2
 (
fd
, 
desired_fd
);

75 
CATCH_MSVC_INVAL


77 
errno
 = 
EBADF
;

78 
result
 = -1;

80 
DONE_MSVC_INVAL
;

82 if (
result
 == 0)

83 
result
 = 
desired_fd
;

85 return 
result
;

86 
	}
}

88 #define 
	#dup2
 
ms_windows_dup2


	)

93 
	$rpl_dup2
 (int 
fd
, int 
desired_fd
)

95 int 
result
;

97 #ifdef 
F_GETFL


101 if (
fd
 == 
desired_fd
)

102 return 
	`fcntl
 (
fd
, 
F_GETFL
) == -1 ? -1 : fd;

105 
result
 = 
	`dup2
 (
fd
, 
desired_fd
);

108 if (
result
 == -1 && 
errno
 == 
EMFILE
)

109 
errno
 = 
EBADF
;

110 #if 
REPLACE_FCHDIR


111 if (
fd
 != 
desired_fd
 && 
result
 != -1)

112 
result
 = 
	`_gl_register_dup
 (
fd
, result);

114 return 
result
;

115 
	}
}

121 #ifndef 
F_DUPFD


123 
	$dupfd
 (int 
fd
, int 
desired_fd
)

125 int 
duplicated_fd
 = 
	`dup
 (
fd
);

126 if (
duplicated_fd
 < 0 || duplicated_fd == 
desired_fd
)

127 return 
duplicated_fd
;

130 int 
r
 = 
	`dupfd
 (
fd
, 
desired_fd
);

131 int 
e
 = 
errno
;

132 
	`close
 (
duplicated_fd
);

133 
errno
 = 
e
;

134 return 
r
;

136 
	}
}

140 
	$dup2
 (int 
fd
, int 
desired_fd
)

142 int 
result
 = 
	`fcntl
 (
fd
, 
F_GETFL
) < 0 ? -1 : fd;

143 if (
result
 == -1 || 
fd
 == 
desired_fd
)

144 return 
result
;

145 
	`close
 (
desired_fd
);

146 #ifdef 
F_DUPFD


147 
result
 = 
	`fcntl
 (
fd
, 
F_DUPFD
, 
desired_fd
);

148 #if 
REPLACE_FCHDIR


149 if (0 <= 
result
)

150 
result
 = 
	`_gl_register_dup
 (
fd
, result);

153 
result
 = 
	`dupfd
 (
fd
, 
desired_fd
);

155 if (
result
 == -1 && (
errno
 == 
EMFILE
 || errno == 
EINVAL
))

156 
errno
 = 
EBADF
;

157 return 
result
;

158 
	}
}

	@gnulib-tests/fd-hook.c

20 #include 
	~<config.h
>

23 #include 
	~"fd-hook.h
"

25 #include 
	~<stdlib.h
>

29 #if 
WINDOWS_SOCKETS


33 static struct 
fd_hook
 
	ganchor
 = { &
anchor
, &anchor, 
NULL
, NULL };

36 
	$execute_close_hooks
 (const struct 
fd_hook
 *
remaining_list
, 
gl_close_fn
 
primary
,

37 int 
fd
)

39 if (
remaining_list
 == &
anchor
)

41 return 
	`primary
 (
fd
);

43 return 
remaining_list
->
	`private_close_fn
 (remaining_list->
private_next
,

44 
primary
, 
fd
);

45 
	}
}

48 
	$execute_all_close_hooks
 (
gl_close_fn
 
primary
, int 
fd
)

50 return 
	`execute_close_hooks
 (
anchor
.
private_next
, 
primary
, 
fd
);

51 
	}
}

54 
	$execute_ioctl_hooks
 (const struct 
fd_hook
 *
remaining_list
, 
gl_ioctl_fn
 
primary
,

55 int 
fd
, int 
request
, void *
arg
)

57 if (
remaining_list
 == &
anchor
)

59 return 
	`primary
 (
fd
, 
request
, 
arg
);

61 return 
remaining_list
->
	`private_ioctl_fn
 (remaining_list->
private_next
,

62 
primary
, 
fd
, 
request
, 
arg
);

63 
	}
}

66 
	$execute_all_ioctl_hooks
 (
gl_ioctl_fn
 
primary
,

67 int 
fd
, int 
request
, void *
arg
)

69 return 
	`execute_ioctl_hooks
 (
anchor
.
private_next
, 
primary
, 
fd
, 
request
, 
arg
);

70 
	}
}

73 
	$register_fd_hook
 (
close_hook_fn
 
close_hook
, 
ioctl_hook_fn
 
ioctl_hook
, struct 
fd_hook
 *
link
)

75 if (
close_hook
 == 
NULL
)

76 
close_hook
 = 
execute_close_hooks
;

77 if (
ioctl_hook
 == 
NULL
)

78 
ioctl_hook
 = 
execute_ioctl_hooks
;

80 if (
link
->
private_next
 == 
NULL
 && link->
private_prev
 == NULL)

83 
link
->
private_next
 = 
anchor
.private_next;

84 
link
->
private_prev
 = &
anchor
;

85 
link
->
private_close_fn
 = 
close_hook
;

86 
link
->
private_ioctl_fn
 = 
ioctl_hook
;

87 
anchor
.
private_next
->
private_prev
 = 
link
;

88 
anchor
.
private_next
 = 
link
;

93 if (
link
->
private_close_fn
 != 
close_hook


94 || 
link
->
private_ioctl_fn
 != 
ioctl_hook
)

95 
	`abort
 ();

97 
	}
}

100 
	$unregister_fd_hook
 (struct 
fd_hook
 *
link
)

102 struct 
fd_hook
 *
next
 = 
link
->
private_next
;

103 struct 
fd_hook
 *
prev
 = 
link
->
private_prev
;

105 if (
next
 != 
NULL
 && 
prev
 != NULL)

108 
prev
->
private_next
 = 
next
;

109 
next
->
private_prev
 = 
prev
;

111 
link
->
private_next
 = 
NULL
;

112 
link
->
private_prev
 = 
NULL
;

113 
link
->
private_close_fn
 = 
NULL
;

114 
link
->
private_ioctl_fn
 = 
NULL
;

116 
	}
}

	@gnulib-tests/fd-hook.h

20 #ifndef 
FD_HOOK_H


21 #define 
	#FD_HOOK_H


	)

23 #ifdef 
__cplusplus


30 #if 
WINDOWS_SOCKETS


34 typedef int (*
	tgl_close_fn
) (int 
	tfd
);

37 typedef int (*
	tgl_ioctl_fn
) (int 
	tfd
, int 
	trequest
, void *
	targ
);

44 struct 
	sfd_hook


47 struct 
fd_hook
 *
private_next
;

48 struct 
fd_hook
 *
private_prev
;

51 int (*
private_close_fn
) (const struct 
fd_hook
 *
remaining_list
,

52 
gl_close_fn
 
primary
,

53 int 
fd
);

57 int (*
private_ioctl_fn
) (const struct 
fd_hook
 *
remaining_list
,

58 
gl_ioctl_fn
 
primary
,

59 int 
fd
, int 
request
, void *
arg
);

68 typedef int (*
	tclose_hook_fn
) (const struct 
	tfd_hook
 *
	tremaining_list
,

69 
	tgl_close_fn
 
	tprimary
,

70 int 
	tfd
);

74 extern int 
	`execute_close_hooks
 (const struct 
fd_hook
 *
remaining_list
,

75 
gl_close_fn
 
primary
,

76 int 
fd
);

80 extern int 
	`execute_all_close_hooks
 (
gl_close_fn
 
primary
, int 
fd
);

88 typedef int (*
	tioctl_hook_fn
) (const struct 
	tfd_hook
 *
	tremaining_list
,

89 
	tgl_ioctl_fn
 
	tprimary
,

90 int 
	tfd
, int 
	trequest
, void *
	targ
);

94 extern int 
	`execute_ioctl_hooks
 (const struct 
fd_hook
 *
remaining_list
,

95 
gl_ioctl_fn
 
primary
,

96 int 
fd
, int 
request
, void *
arg
);

100 extern int 
	`execute_all_ioctl_hooks
 (
gl_ioctl_fn
 
primary
,

101 int 
fd
, int 
request
, void *
arg
);

107 extern void 
	`register_fd_hook
 (
close_hook_fn
 
close_hook
, 
ioctl_hook_fn
 
ioctl_hook
,

108 struct 
fd_hook
 *
link
);

111 extern void 
	`unregister_fd_hook
 (struct 
fd_hook
 *
link
);

117 #ifdef 
__cplusplus


118 
	}
}

	@gnulib-tests/fdopen.c

19 #include 
	~<config.h
>

22 #include 
	~<stdio.h
>

24 #include 
	~<errno.h
>

26 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER


27 #include 
	~"msvc-inval.h
"

30 #undef 
fdopen


32 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER


33 static 
FILE
 *

34 
	$fdopen_nothrow
 (int 
fd
, const char *
mode
)

36 
FILE
 *
result
;

38 
TRY_MSVC_INVAL


40 
result
 = 
	`fdopen
 (
fd
, 
mode
);

42 
CATCH_MSVC_INVAL


44 
result
 = 
NULL
;

46 
DONE_MSVC_INVAL
;

48 return 
result
;

49 
	}
}

51 #define 
	#fdopen_nothrow
 
fdopen


	)

54 
FILE
 *

55 
	$rpl_fdopen
 (int 
fd
, const char *
mode
)

57 int 
saved_errno
 = 
errno
;

58 
FILE
 *
fp
;

60 
errno
 = 0;

61 
fp
 = 
	`fdopen_nothrow
 (
fd
, 
mode
);

62 if (
fp
 == 
NULL
)

64 if (
errno
 == 0)

65 
errno
 = 
EBADF
;

68 
errno
 = 
saved_errno
;

70 return 
fp
;

71 
	}
}

	@gnulib-tests/float+.h

21 #ifndef 
_FLOATPLUS_H


22 #define 
	#_FLOATPLUS_H


	)

24 #include 
	~<float.h
>

25 #include 
	~<limits.h
>

29 #if 
FLT_RADIX
 == 2

30 #define 
	#FLT_MANT_BIT
 
FLT_MANT_DIG


	)

31 #define 
	#DBL_MANT_BIT
 
DBL_MANT_DIG


	)

32 #define 
	#LDBL_MANT_BIT
 
LDBL_MANT_DIG


	)

33 #elif 
FLT_RADIX
 == 4

34 #define 
	#FLT_MANT_BIT
 (
FLT_MANT_DIG
 * 2)

	)

35 #define 
	#DBL_MANT_BIT
 (
DBL_MANT_DIG
 * 2)

	)

36 #define 
	#LDBL_MANT_BIT
 (
LDBL_MANT_DIG
 * 2)

	)

37 #elif 
FLT_RADIX
 == 16

38 #define 
	#FLT_MANT_BIT
 (
FLT_MANT_DIG
 * 4)

	)

39 #define 
	#DBL_MANT_BIT
 (
DBL_MANT_DIG
 * 4)

	)

40 #define 
	#LDBL_MANT_BIT
 (
LDBL_MANT_DIG
 * 4)

	)

44 #define 
	#FLT_EXP_MASK
 ((
FLT_MAX_EXP
 - 
FLT_MIN_EXP
) | 7)

	)

45 #define 
	#DBL_EXP_MASK
 ((
DBL_MAX_EXP
 - 
DBL_MIN_EXP
) | 7)

	)

46 #define 
	#LDBL_EXP_MASK
 ((
LDBL_MAX_EXP
 - 
LDBL_MIN_EXP
) | 7)

	)

50 #define 
	#FLT_EXP_BIT
 \

51 (
FLT_EXP_MASK
 < 0x100 ? 8 : \

52 
FLT_EXP_MASK
 < 0x200 ? 9 : \

53 
FLT_EXP_MASK
 < 0x400 ? 10 : \

54 
FLT_EXP_MASK
 < 0x800 ? 11 : \

55 
FLT_EXP_MASK
 < 0x1000 ? 12 : \

56 
FLT_EXP_MASK
 < 0x2000 ? 13 : \

57 
FLT_EXP_MASK
 < 0x4000 ? 14 : \

58 
FLT_EXP_MASK
 < 0x8000 ? 15 : \

59 
FLT_EXP_MASK
 < 0x10000 ? 16 : \

60 
FLT_EXP_MASK
 < 0x20000 ? 17 : \

61 
FLT_EXP_MASK
 < 0x40000 ? 18 : \

62 
FLT_EXP_MASK
 < 0x80000 ? 19 : \

63 
FLT_EXP_MASK
 < 0x100000 ? 20 : \

64 
FLT_EXP_MASK
 < 0x200000 ? 21 : \

65 
FLT_EXP_MASK
 < 0x400000 ? 22 : \

66 
FLT_EXP_MASK
 < 0x800000 ? 23 : \

67 
FLT_EXP_MASK
 < 0x1000000 ? 24 : \

68 
FLT_EXP_MASK
 < 0x2000000 ? 25 : \

69 
FLT_EXP_MASK
 < 0x4000000 ? 26 : \

70 
FLT_EXP_MASK
 < 0x8000000 ? 27 : \

71 
FLT_EXP_MASK
 < 0x10000000 ? 28 : \

72 
FLT_EXP_MASK
 < 0x20000000 ? 29 : \

73 
FLT_EXP_MASK
 < 0x40000000 ? 30 : \

74 
FLT_EXP_MASK
 <= 0x7fffffff ? 31 : \

75 32)

	)

76 #define 
	#DBL_EXP_BIT
 \

77 (
DBL_EXP_MASK
 < 0x100 ? 8 : \

78 
DBL_EXP_MASK
 < 0x200 ? 9 : \

79 
DBL_EXP_MASK
 < 0x400 ? 10 : \

80 
DBL_EXP_MASK
 < 0x800 ? 11 : \

81 
DBL_EXP_MASK
 < 0x1000 ? 12 : \

82 
DBL_EXP_MASK
 < 0x2000 ? 13 : \

83 
DBL_EXP_MASK
 < 0x4000 ? 14 : \

84 
DBL_EXP_MASK
 < 0x8000 ? 15 : \

85 
DBL_EXP_MASK
 < 0x10000 ? 16 : \

86 
DBL_EXP_MASK
 < 0x20000 ? 17 : \

87 
DBL_EXP_MASK
 < 0x40000 ? 18 : \

88 
DBL_EXP_MASK
 < 0x80000 ? 19 : \

89 
DBL_EXP_MASK
 < 0x100000 ? 20 : \

90 
DBL_EXP_MASK
 < 0x200000 ? 21 : \

91 
DBL_EXP_MASK
 < 0x400000 ? 22 : \

92 
DBL_EXP_MASK
 < 0x800000 ? 23 : \

93 
DBL_EXP_MASK
 < 0x1000000 ? 24 : \

94 
DBL_EXP_MASK
 < 0x2000000 ? 25 : \

95 
DBL_EXP_MASK
 < 0x4000000 ? 26 : \

96 
DBL_EXP_MASK
 < 0x8000000 ? 27 : \

97 
DBL_EXP_MASK
 < 0x10000000 ? 28 : \

98 
DBL_EXP_MASK
 < 0x20000000 ? 29 : \

99 
DBL_EXP_MASK
 < 0x40000000 ? 30 : \

100 
DBL_EXP_MASK
 <= 0x7fffffff ? 31 : \

101 32)

	)

102 #define 
	#LDBL_EXP_BIT
 \

103 (
LDBL_EXP_MASK
 < 0x100 ? 8 : \

104 
LDBL_EXP_MASK
 < 0x200 ? 9 : \

105 
LDBL_EXP_MASK
 < 0x400 ? 10 : \

106 
LDBL_EXP_MASK
 < 0x800 ? 11 : \

107 
LDBL_EXP_MASK
 < 0x1000 ? 12 : \

108 
LDBL_EXP_MASK
 < 0x2000 ? 13 : \

109 
LDBL_EXP_MASK
 < 0x4000 ? 14 : \

110 
LDBL_EXP_MASK
 < 0x8000 ? 15 : \

111 
LDBL_EXP_MASK
 < 0x10000 ? 16 : \

112 
LDBL_EXP_MASK
 < 0x20000 ? 17 : \

113 
LDBL_EXP_MASK
 < 0x40000 ? 18 : \

114 
LDBL_EXP_MASK
 < 0x80000 ? 19 : \

115 
LDBL_EXP_MASK
 < 0x100000 ? 20 : \

116 
LDBL_EXP_MASK
 < 0x200000 ? 21 : \

117 
LDBL_EXP_MASK
 < 0x400000 ? 22 : \

118 
LDBL_EXP_MASK
 < 0x800000 ? 23 : \

119 
LDBL_EXP_MASK
 < 0x1000000 ? 24 : \

120 
LDBL_EXP_MASK
 < 0x2000000 ? 25 : \

121 
LDBL_EXP_MASK
 < 0x4000000 ? 26 : \

122 
LDBL_EXP_MASK
 < 0x8000000 ? 27 : \

123 
LDBL_EXP_MASK
 < 0x10000000 ? 28 : \

124 
LDBL_EXP_MASK
 < 0x20000000 ? 29 : \

125 
LDBL_EXP_MASK
 < 0x40000000 ? 30 : \

126 
LDBL_EXP_MASK
 <= 0x7fffffff ? 31 : \

127 32)

	)

132 #define 
	#FLT_TOTAL_BIT
 ((
FLT_MANT_BIT
 - 1) + 
FLT_EXP_BIT
 + 1)

	)

133 #define 
	#DBL_TOTAL_BIT
 ((
DBL_MANT_BIT
 - 1) + 
DBL_EXP_BIT
 + 1)

	)

134 #define 
	#LDBL_TOTAL_BIT
 ((
LDBL_MANT_BIT
 - 1) + 
LDBL_EXP_BIT
 + 1)

	)

141 #define 
	#SIZEOF_FLT
 ((
FLT_TOTAL_BIT
 + 
CHAR_BIT
 - 1) / CHAR_BIT)

	)

142 #define 
	#SIZEOF_DBL
 ((
DBL_TOTAL_BIT
 + 
CHAR_BIT
 - 1) / CHAR_BIT)

	)

143 #define 
	#SIZEOF_LDBL
 ((
LDBL_TOTAL_BIT
 + 
CHAR_BIT
 - 1) / CHAR_BIT)

	)

146 typedef int 
	tverify_sizeof_flt
[
SIZEOF_FLT
 <= sizeof (float) ? 1 : -1];

147 typedef int 
	tverify_sizeof_dbl
[
SIZEOF_DBL
 <= sizeof (double) ? 1 : - 1];

148 typedef int 
	tverify_sizeof_ldbl
[
SIZEOF_LDBL
 <= sizeof (long double) ? 1 : - 1];

	@gnulib-tests/float.c

20 #include 
	~<config.h
>

23 #include 
	~<float.h
>

25 #if (
defined
 
_ARCH_PPC
 || defined 
_POWER
) && (defined 
_AIX
 || defined 
__linux__
) && (
LDBL_MANT_DIG
 == 106) && defined 
__GNUC__


26 const union 
gl_long_double_union
 
	ggl_LDBL_MAX
 =

27 { { 
DBL_MAX
, DBL_MAX / (double)134217728UL / (double)134217728UL } };

28 #elif 
defined
 
__i386__


29 const union 
gl_long_double_union
 
	ggl_LDBL_MAX
 =

34 typedef int 
	tdummy
;

	@gnulib-tests/float.in.h

20 #ifndef 
_
@
GUARD_PREFIX
@
_FLOAT_H


22 #if 
__GNUC__
 >= 3

23 @
	gPRAGMA_SYSTEM_HEADER
@

25 @
	gPRAGMA_COLUMNS
@

28 #@
INCLUDE_NEXT
@ @
NEXT_FLOAT_H
@

30 #ifndef 
_
@
GUARD_PREFIX
@
_FLOAT_H


31 #define 
	#_
@
GUARD_PREFIX
@
_FLOAT_H


	)

35 #if 
defined
 
__i386__
 && (defined 
__BEOS__
 || defined 
__OpenBSD__
)

37 #undef 
LDBL_MANT_DIG


38 #define 
	#LDBL_MANT_DIG
 64

	)

40 #undef 
LDBL_DIG


41 #define 
	#LDBL_DIG
 18

	)

43 #undef 
LDBL_EPSILON


44 #define 
	#LDBL_EPSILON
 1.0842021724855044340E-19L

	)

46 #undef 
LDBL_MIN_EXP


47 #define 
	#LDBL_MIN_EXP
 (-16381)

	)

49 #undef 
LDBL_MAX_EXP


50 #define 
	#LDBL_MAX_EXP
 16384

	)

52 #undef 
LDBL_MIN


53 #define 
	#LDBL_MIN
 3.3621031431120935063E-4932L

	)

55 #undef 
LDBL_MAX


56 #define 
	#LDBL_MAX
 1.1897314953572317650E+4932L

	)

58 #undef 
LDBL_MIN_10_EXP


59 #define 
	#LDBL_MIN_10_EXP
 (-4931)

	)

61 #undef 
LDBL_MAX_10_EXP


62 #define 
	#LDBL_MAX_10_EXP
 4932

	)

68 #if 
defined
 
__i386__
 && defined 
__FreeBSD__


70 #undef 
LDBL_MANT_DIG


71 #define 
	#LDBL_MANT_DIG
 64

	)

73 #undef 
LDBL_DIG


74 #define 
	#LDBL_DIG
 18

	)

76 #undef 
LDBL_EPSILON


77 #define 
	#LDBL_EPSILON
 1.084202172485504434007452800869941711426e-19L

	)

79 #undef 
LDBL_MIN_EXP


80 #define 
	#LDBL_MIN_EXP
 (-16381)

	)

82 #undef 
LDBL_MAX_EXP


83 #define 
	#LDBL_MAX_EXP
 16384

	)

85 #undef 
LDBL_MIN


86 #define 
	#LDBL_MIN
 3.3621031431120935E-4932L

	)

88 #undef 
LDBL_MAX


98 union 
	ugl_long_double_union


100 struct { unsigned int 
	mlo
; unsigned int 
	mhi
; unsigned int 
	mexponent
; } 
	mxd
;

101 long double 
	mld
;

103 extern const union 
gl_long_double_union
 
gl_LDBL_MAX
;

104 #define 
	#LDBL_MAX
 (
gl_LDBL_MAX
.
ld
)

	)

106 #undef 
LDBL_MIN_10_EXP


107 #define 
	#LDBL_MIN_10_EXP
 (-4931)

	)

109 #undef 
LDBL_MAX_10_EXP


110 #define 
	#LDBL_MAX_10_EXP
 4932

	)

116 #if (
defined
 
_ARCH_PPC
 || defined 
_POWER
) && defined 
_AIX
 && (
LDBL_MANT_DIG
 == 106) && defined 
__GNUC__


117 #undef 
LDBL_MIN_EXP


118 #define 
	#LDBL_MIN_EXP
 
DBL_MIN_EXP


	)

119 #undef 
LDBL_MIN_10_EXP


120 #define 
	#LDBL_MIN_10_EXP
 
DBL_MIN_10_EXP


	)

121 #undef 
LDBL_MIN


122 #define 
	#LDBL_MIN
 2.22507385850720138309023271733240406422e-308L

	)

124 #if (
defined
 
_ARCH_PPC
 || defined 
_POWER
) && (defined 
_AIX
 || defined 
__linux__
) && (
LDBL_MANT_DIG
 == 106) && defined 
__GNUC__


125 #undef 
LDBL_MAX


151 union 
	ugl_long_double_union


153 struct { double 
	mhi
; double 
	mlo
; } 
	mdd
;

154 long double 
	mld
;

156 extern const union 
gl_long_double_union
 
gl_LDBL_MAX
;

157 #define 
	#LDBL_MAX
 (
gl_LDBL_MAX
.
ld
)

	)

163 #if 
defined
 
__sgi
 && (
LDBL_MANT_DIG
 >= 106)

164 #undef 
LDBL_MANT_DIG


165 #define 
	#LDBL_MANT_DIG
 106

	)

166 #if 
defined
 
__GNUC__


167 #undef 
LDBL_MIN_EXP


168 #define 
	#LDBL_MIN_EXP
 
DBL_MIN_EXP


	)

169 #undef 
LDBL_MIN_10_EXP


170 #define 
	#LDBL_MIN_10_EXP
 
DBL_MIN_10_EXP


	)

171 #undef 
LDBL_MIN


172 #define 
	#LDBL_MIN
 2.22507385850720138309023271733240406422e-308L

	)

173 #undef 
LDBL_EPSILON


174 #define 
	#LDBL_EPSILON
 2.46519032881566189191165176650870696773e-32L

	)

178 #if @
REPLACE_ITOLD
@

182 #ifdef 
__cplusplus


185 void 
_Qp_itoq
 (long double *, int);

186 static void (*
_gl_float_fix_itold
) (long double *, int) = 
_Qp_itoq
;

	@gnulib-tests/fpucw.h

20 #ifndef 
_FPUCW_H


21 #define 
	#_FPUCW_H


	)

66 #if (
defined
 
__i386__
 || defined 
__x86_64__
) && defined 
__GNUC__


68 typedef unsigned short 
	tfpucw_t
;

70 #define 
	#FPU_PC_MASK
 0x0300

	)

71 #define 
	#FPU_PC_DOUBLE
 0x200

	)

72 #define 
	#FPU_PC_EXTENDED
 0x300

	)

74 #define 
	#GET_FPUCW
() \

75 ({ 
fpucw_t
 
_cw
; \

76 
__asm__
 
	`__volatile__
 ("fnstcw %0" : "=m" (*&
_cw
)); \

77 
_cw
; \

78 })

	)

79 #define 
	#SET_FPUCW
(
word
) \

80 (void)({ 
fpucw_t
 
_ncw
 = (
word
); \

81 
__asm__
 
	`__volatile__
 ("fldcw %0" : : "m" (*&
_ncw
)); \

82 })

	)

84 #define 
	#DECL_LONG_DOUBLE_ROUNDING
 \

85 
fpucw_t
 
oldcw
;

	)

86 #define 
	#BEGIN_LONG_DOUBLE_ROUNDING
() \

87 (void)(
oldcw
 = 
	`GET_FPUCW
 (), \

88 
	`SET_FPUCW
 ((
oldcw
 & ~
FPU_PC_MASK
) | 
FPU_PC_EXTENDED
))

	)

89 #define 
	#END_LONG_DOUBLE_ROUNDING
() \

90 
	`SET_FPUCW
 (
oldcw
)

	)

94 typedef unsigned int 
	tfpucw_t
;

96 #define 
	#FPU_PC_MASK
 0

	)

97 #define 
	#FPU_PC_DOUBLE
 0

	)

98 #define 
	#FPU_PC_EXTENDED
 0

	)

100 #define 
	#GET_FPUCW
() 0

	)

101 #define 
	#SET_FPUCW
(
word
) (void)(word)

	)

103 #define 
	#DECL_LONG_DOUBLE_ROUNDING


	)

104 #define 
	#BEGIN_LONG_DOUBLE_ROUNDING
()

	)

105 #define 
	#END_LONG_DOUBLE_ROUNDING
()

	)

	@gnulib-tests/getcwd-lgpl.c

19 #include 
	~<config.h
>

22 #include 
	~<unistd.h
>

24 #include 
	~<errno.h
>

25 #include 
	~<string.h
>

27 #if 
GNULIB_GETCWD


29 typedef int 
	tdummy
;

41 #undef 
getcwd


43 
	$rpl_getcwd
 (char *
buf
, 
size_t
 
size
)

45 char *
ptr
;

46 char *
result
;

49 if (
buf
)

51 if (!
size
)

53 
errno
 = 
EINVAL
;

54 return 
NULL
;

56 return 
	`getcwd
 (
buf
, 
size
);

59 if (
size
)

61 
buf
 = 
	`malloc
 (
size
);

62 if (!
buf
)

64 
errno
 = 
ENOMEM
;

65 return 
NULL
;

67 
result
 = 
	`getcwd
 (
buf
, 
size
);

68 if (!
result
)

70 int 
saved_errno
 = 
errno
;

71 
	`free
 (
buf
);

72 
errno
 = 
saved_errno
;

74 return 
result
;

81 char 
tmp
[4032];

82 
size
 = sizeof 
tmp
;

83 
ptr
 = 
	`getcwd
 (
tmp
, 
size
);

84 if (
ptr
)

86 
result
 = 
	`strdup
 (
ptr
);

87 if (!
result
)

88 
errno
 = 
ENOMEM
;

89 return 
result
;

91 if (
errno
 != 
ERANGE
)

92 return 
NULL
;

98 
size
 <<= 1;

99 
ptr
 = 
	`realloc
 (
buf
, 
size
);

100 if (
ptr
 == 
NULL
)

102 
	`free
 (
buf
);

103 
errno
 = 
ENOMEM
;

104 return 
NULL
;

106 
buf
 = 
ptr
;

107 
result
 = 
	`getcwd
 (
buf
, 
size
);

109 while (!
result
 && 
errno
 == 
ERANGE
);

111 if (!
result
)

113 int 
saved_errno
 = 
errno
;

114 
	`free
 (
buf
);

115 
errno
 = 
saved_errno
;

120 
result
 = 
	`realloc
 (
buf
, 
	`strlen
 (buf) + 1);

121 if (!
result
)

122 
result
 = 
buf
;

124 return 
result
;

125 
	}
}

	@gnulib-tests/glthread/lock.c

24 #include 
	~<config.h
>

26 #include 
	~"glthread/lock.h
"

30 #if 
USE_POSIX_THREADS


36 #if 
HAVE_PTHREAD_RWLOCK


38 #if !
defined
 
PTHREAD_RWLOCK_INITIALIZER


41 
	$glthread_rwlock_init_multithreaded
 (
gl_rwlock_t
 *
lock
)

43 int 
err
;

45 
err
 = 
	`pthread_rwlock_init
 (&
lock
->
rwlock
, 
NULL
);

46 if (
err
 != 0)

47 return 
err
;

48 
lock
->
initialized
 = 1;

50 
	}
}

53 
	$glthread_rwlock_rdlock_multithreaded
 (
gl_rwlock_t
 *
lock
)

55 if (!
lock
->
initialized
)

57 int 
err
;

59 
err
 = 
	`pthread_mutex_lock
 (&
lock
->
guard
);

60 if (
err
 != 0)

61 return 
err
;

62 if (!
lock
->
initialized
)

64 
err
 = 
	`glthread_rwlock_init_multithreaded
 (
lock
);

65 if (
err
 != 0)

67 
	`pthread_mutex_unlock
 (&
lock
->
guard
);

68 return 
err
;

71 
err
 = 
	`pthread_mutex_unlock
 (&
lock
->
guard
);

72 if (
err
 != 0)

73 return 
err
;

75 return 
	`pthread_rwlock_rdlock
 (&
lock
->
rwlock
);

76 
	}
}

79 
	$glthread_rwlock_wrlock_multithreaded
 (
gl_rwlock_t
 *
lock
)

81 if (!
lock
->
initialized
)

83 int 
err
;

85 
err
 = 
	`pthread_mutex_lock
 (&
lock
->
guard
);

86 if (
err
 != 0)

87 return 
err
;

88 if (!
lock
->
initialized
)

90 
err
 = 
	`glthread_rwlock_init_multithreaded
 (
lock
);

91 if (
err
 != 0)

93 
	`pthread_mutex_unlock
 (&
lock
->
guard
);

94 return 
err
;

97 
err
 = 
	`pthread_mutex_unlock
 (&
lock
->
guard
);

98 if (
err
 != 0)

99 return 
err
;

101 return 
	`pthread_rwlock_wrlock
 (&
lock
->
rwlock
);

102 
	}
}

105 
	$glthread_rwlock_unlock_multithreaded
 (
gl_rwlock_t
 *
lock
)

107 if (!
lock
->
initialized
)

108 return 
EINVAL
;

109 return 
	`pthread_rwlock_unlock
 (&
lock
->
rwlock
);

110 
	}
}

113 
	$glthread_rwlock_destroy_multithreaded
 (
gl_rwlock_t
 *
lock
)

115 int 
err
;

117 if (!
lock
->
initialized
)

118 return 
EINVAL
;

119 
err
 = 
	`pthread_rwlock_destroy
 (&
lock
->
rwlock
);

120 if (
err
 != 0)

121 return 
err
;

122 
lock
->
initialized
 = 0;

124 
	}
}

131 
	$glthread_rwlock_init_multithreaded
 (
gl_rwlock_t
 *
lock
)

133 int 
err
;

135 
err
 = 
	`pthread_mutex_init
 (&
lock
->lock, 
NULL
);

136 if (
err
 != 0)

137 return 
err
;

138 
err
 = 
	`pthread_cond_init
 (&
lock
->
waiting_readers
, 
NULL
);

139 if (
err
 != 0)

140 return 
err
;

141 
err
 = 
	`pthread_cond_init
 (&
lock
->
waiting_writers
, 
NULL
);

142 if (
err
 != 0)

143 return 
err
;

144 
lock
->
waiting_writers_count
 = 0;

145 
lock
->
runcount
 = 0;

147 
	}
}

150 
	$glthread_rwlock_rdlock_multithreaded
 (
gl_rwlock_t
 *
lock
)

152 int 
err
;

154 
err
 = 
	`pthread_mutex_lock
 (&
lock
->lock);

155 if (
err
 != 0)

156 return 
err
;

163 while (!(
lock
->
runcount
 + 1 > 0 && lock->
waiting_writers_count
 == 0))

167 
err
 = 
	`pthread_cond_wait
 (&
lock
->
waiting_readers
, &lock->lock);

168 if (
err
 != 0)

170 
	`pthread_mutex_unlock
 (&
lock
->lock);

171 return 
err
;

174 
lock
->
runcount
++;

175 return 
	`pthread_mutex_unlock
 (&
lock
->lock);

176 
	}
}

179 
	$glthread_rwlock_wrlock_multithreaded
 (
gl_rwlock_t
 *
lock
)

181 int 
err
;

183 
err
 = 
	`pthread_mutex_lock
 (&
lock
->lock);

184 if (
err
 != 0)

185 return 
err
;

187 while (!(
lock
->
runcount
 == 0))

191 
lock
->
waiting_writers_count
++;

192 
err
 = 
	`pthread_cond_wait
 (&
lock
->
waiting_writers
, &lock->lock);

193 if (
err
 != 0)

195 
lock
->
waiting_writers_count
--;

196 
	`pthread_mutex_unlock
 (&
lock
->lock);

197 return 
err
;

199 
lock
->
waiting_writers_count
--;

201 
lock
->
runcount
--;

202 return 
	`pthread_mutex_unlock
 (&
lock
->lock);

203 
	}
}

206 
	$glthread_rwlock_unlock_multithreaded
 (
gl_rwlock_t
 *
lock
)

208 int 
err
;

210 
err
 = 
	`pthread_mutex_lock
 (&
lock
->lock);

211 if (
err
 != 0)

212 return 
err
;

213 if (
lock
->
runcount
 < 0)

216 if (!(
lock
->
runcount
 == -1))

218 
	`pthread_mutex_unlock
 (&
lock
->lock);

219 return 
EINVAL
;

221 
lock
->
runcount
 = 0;

226 if (!(
lock
->
runcount
 > 0))

228 
	`pthread_mutex_unlock
 (&
lock
->lock);

229 return 
EINVAL
;

231 
lock
->
runcount
--;

233 if (
lock
->
runcount
 == 0)

237 if (
lock
->
waiting_writers_count
 > 0)

240 
err
 = 
	`pthread_cond_signal
 (&
lock
->
waiting_writers
);

241 if (
err
 != 0)

243 
	`pthread_mutex_unlock
 (&
lock
->lock);

244 return 
err
;

250 
err
 = 
	`pthread_cond_broadcast
 (&
lock
->
waiting_readers
);

251 if (
err
 != 0)

253 
	`pthread_mutex_unlock
 (&
lock
->lock);

254 return 
err
;

258 return 
	`pthread_mutex_unlock
 (&
lock
->lock);

259 
	}
}

262 
	$glthread_rwlock_destroy_multithreaded
 (
gl_rwlock_t
 *
lock
)

264 int 
err
;

266 
err
 = 
	`pthread_mutex_destroy
 (&
lock
->lock);

267 if (
err
 != 0)

268 return 
err
;

269 
err
 = 
	`pthread_cond_destroy
 (&
lock
->
waiting_readers
);

270 if (
err
 != 0)

271 return 
err
;

272 
err
 = 
	`pthread_cond_destroy
 (&
lock
->
waiting_writers
);

273 if (
err
 != 0)

274 return 
err
;

276 
	}
}

282 #if 
HAVE_PTHREAD_MUTEX_RECURSIVE


284 #if 
defined
 
PTHREAD_RECURSIVE_MUTEX_INITIALIZER
 || defined 
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP


287 
	$glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

289 
pthread_mutexattr_t
 
attributes
;

290 int 
err
;

292 
err
 = 
	`pthread_mutexattr_init
 (&
attributes
);

293 if (
err
 != 0)

294 return 
err
;

295 
err
 = 
	`pthread_mutexattr_settype
 (&
attributes
, 
PTHREAD_MUTEX_RECURSIVE
);

296 if (
err
 != 0)

298 
	`pthread_mutexattr_destroy
 (&
attributes
);

299 return 
err
;

301 
err
 = 
	`pthread_mutex_init
 (
lock
, &
attributes
);

302 if (
err
 != 0)

304 
	`pthread_mutexattr_destroy
 (&
attributes
);

305 return 
err
;

307 
err
 = 
	`pthread_mutexattr_destroy
 (&
attributes
);

308 if (
err
 != 0)

309 return 
err
;

311 
	}
}

316 
	$glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

318 
pthread_mutexattr_t
 
attributes
;

319 int 
err
;

321 
err
 = 
	`pthread_mutexattr_init
 (&
attributes
);

322 if (
err
 != 0)

323 return 
err
;

324 
err
 = 
	`pthread_mutexattr_settype
 (&
attributes
, 
PTHREAD_MUTEX_RECURSIVE
);

325 if (
err
 != 0)

327 
	`pthread_mutexattr_destroy
 (&
attributes
);

328 return 
err
;

330 
err
 = 
	`pthread_mutex_init
 (&
lock
->
recmutex
, &
attributes
);

331 if (
err
 != 0)

333 
	`pthread_mutexattr_destroy
 (&
attributes
);

334 return 
err
;

336 
err
 = 
	`pthread_mutexattr_destroy
 (&
attributes
);

337 if (
err
 != 0)

338 return 
err
;

339 
lock
->
initialized
 = 1;

341 
	}
}

344 
	$glthread_recursive_lock_lock_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

346 if (!
lock
->
initialized
)

348 int 
err
;

350 
err
 = 
	`pthread_mutex_lock
 (&
lock
->
guard
);

351 if (
err
 != 0)

352 return 
err
;

353 if (!
lock
->
initialized
)

355 
err
 = 
	`glthread_recursive_lock_init_multithreaded
 (
lock
);

356 if (
err
 != 0)

358 
	`pthread_mutex_unlock
 (&
lock
->
guard
);

359 return 
err
;

362 
err
 = 
	`pthread_mutex_unlock
 (&
lock
->
guard
);

363 if (
err
 != 0)

364 return 
err
;

366 return 
	`pthread_mutex_lock
 (&
lock
->
recmutex
);

367 
	}
}

370 
	$glthread_recursive_lock_unlock_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

372 if (!
lock
->
initialized
)

373 return 
EINVAL
;

374 return 
	`pthread_mutex_unlock
 (&
lock
->
recmutex
);

375 
	}
}

378 
	$glthread_recursive_lock_destroy_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

380 int 
err
;

382 if (!
lock
->
initialized
)

383 return 
EINVAL
;

384 
err
 = 
	`pthread_mutex_destroy
 (&
lock
->
recmutex
);

385 if (
err
 != 0)

386 return 
err
;

387 
lock
->
initialized
 = 0;

389 
	}
}

396 
	$glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

398 int 
err
;

400 
err
 = 
	`pthread_mutex_init
 (&
lock
->
mutex
, 
NULL
);

401 if (
err
 != 0)

402 return 
err
;

403 
lock
->
owner
 = (
pthread_t
) 0;

404 
lock
->
depth
 = 0;

406 
	}
}

409 
	$glthread_recursive_lock_lock_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

411 
pthread_t
 
self
 = 
	`pthread_self
 ();

412 if (
lock
->
owner
 != 
self
)

414 int 
err
;

416 
err
 = 
	`pthread_mutex_lock
 (&
lock
->
mutex
);

417 if (
err
 != 0)

418 return 
err
;

419 
lock
->
owner
 = 
self
;

421 if (++(
lock
->
depth
) == 0)

423 
lock
->
depth
--;

424 return 
EAGAIN
;

427 
	}
}

430 
	$glthread_recursive_lock_unlock_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

432 if (
lock
->
owner
 != 
	`pthread_self
 ())

433 return 
EPERM
;

434 if (
lock
->
depth
 == 0)

435 return 
EINVAL
;

436 if (--(
lock
->
depth
) == 0)

438 
lock
->
owner
 = (
pthread_t
) 0;

439 return 
	`pthread_mutex_unlock
 (&
lock
->
mutex
);

443 
	}
}

446 
	$glthread_recursive_lock_destroy_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

448 if (
lock
->
owner
 != (
pthread_t
) 0)

449 return 
EBUSY
;

450 return 
	`pthread_mutex_destroy
 (&
lock
->
mutex
);

451 
	}
}

457 static const 
pthread_once_t
 
	gfresh_once
 = 
PTHREAD_ONCE_INIT
;

460 
	$glthread_once_singlethreaded
 (
pthread_once_t
 *
once_control
)

464 char *
firstbyte
 = (char *)
once_control
;

465 if (*
firstbyte
 == *(const char *)&
fresh_once
)

468 *
firstbyte
 = ~ *(const char *)&
fresh_once
;

473 
	}
}

479 #if 
USE_PTH_THREADS


492 
	$glthread_once_call
 (void *
arg
)

494 void (**
gl_once_temp_addr
) (void) = (void (**) (void)) 
arg
;

495 void (*
initfunction
) (void) = *
gl_once_temp_addr
;

496 
	`initfunction
 ();

497 
	}
}

500 
glthread_once_multithreaded
 (
pth_once_t
 *
once_control
, void (*
initfunction
) (void))

502 void (*
temp
) (void) = 
initfunction
;

503 return (!
	`pth_once
 (
once_control
, 
glthread_once_call
, &
temp
) ? 
errno
 : 0);

504 
	}
}

507 
	$glthread_once_singlethreaded
 (
pth_once_t
 *
once_control
)

510 if (*
once_control
 == 
PTH_ONCE_INIT
)

513 *
once_control
 = ~ 
PTH_ONCE_INIT
;

518 
	}
}

524 #if 
USE_SOLARIS_THREADS


535 
	$glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

537 int 
err
;

539 
err
 = 
	`mutex_init
 (&
lock
->
mutex
, 
USYNC_THREAD
, 
NULL
);

540 if (
err
 != 0)

541 return 
err
;

542 
lock
->
owner
 = (
thread_t
) 0;

543 
lock
->
depth
 = 0;

545 
	}
}

548 
	$glthread_recursive_lock_lock_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

550 
thread_t
 
self
 = 
	`thr_self
 ();

551 if (
lock
->
owner
 != 
self
)

553 int 
err
;

555 
err
 = 
	`mutex_lock
 (&
lock
->
mutex
);

556 if (
err
 != 0)

557 return 
err
;

558 
lock
->
owner
 = 
self
;

560 if (++(
lock
->
depth
) == 0)

562 
lock
->
depth
--;

563 return 
EAGAIN
;

566 
	}
}

569 
	$glthread_recursive_lock_unlock_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

571 if (
lock
->
owner
 != 
	`thr_self
 ())

572 return 
EPERM
;

573 if (
lock
->
depth
 == 0)

574 return 
EINVAL
;

575 if (--(
lock
->
depth
) == 0)

577 
lock
->
owner
 = (
thread_t
) 0;

578 return 
	`mutex_unlock
 (&
lock
->
mutex
);

582 
	}
}

585 
	$glthread_recursive_lock_destroy_multithreaded
 (
gl_recursive_lock_t
 *
lock
)

587 if (
lock
->
owner
 != (
thread_t
) 0)

588 return 
EBUSY
;

589 return 
	`mutex_destroy
 (&
lock
->
mutex
);

590 
	}
}

595 
glthread_once_multithreaded
 (
gl_once_t
 *
once_control
, void (*
initfunction
) (void))

597 if (!
once_control
->
inited
)

599 int 
err
;

603 
err
 = 
	`mutex_lock
 (&
once_control
->
mutex
);

604 if (
err
 != 0)

605 return 
err
;

606 if (!
once_control
->
inited
)

608 
once_control
->
inited
 = 1;

609 
	`initfunction
 ();

611 return 
	`mutex_unlock
 (&
once_control
->
mutex
);

615 
	}
}

618 
	$glthread_once_singlethreaded
 (
gl_once_t
 *
once_control
)

621 if (!
once_control
->
inited
)

624 
once_control
->
inited
 = ~ 0;

629 
	}
}

635 #if 
USE_WIN32_THREADS


640 
	$glthread_lock_init_func
 (
gl_lock_t
 *
lock
)

642 
	`InitializeCriticalSection
 (&
lock
->lock);

643 
lock
->
guard
.
done
 = 1;

644 
	}
}

647 
	$glthread_lock_lock_func
 (
gl_lock_t
 *
lock
)

649 if (!
lock
->
guard
.
done
)

651 if (
	`InterlockedIncrement
 (&
lock
->
guard
.
started
) == 0)

653 
	`glthread_lock_init
 (
lock
);

657 while (!
lock
->
guard
.
done
)

658 
	`Sleep
 (0);

660 
	`EnterCriticalSection
 (&
lock
->lock);

662 
	}
}

665 
	$glthread_lock_unlock_func
 (
gl_lock_t
 *
lock
)

667 if (!
lock
->
guard
.
done
)

668 return 
EINVAL
;

669 
	`LeaveCriticalSection
 (&
lock
->lock);

671 
	}
}

674 
	$glthread_lock_destroy_func
 (
gl_lock_t
 *
lock
)

676 if (!
lock
->
guard
.
done
)

677 return 
EINVAL
;

678 
	`DeleteCriticalSection
 (&
lock
->lock);

679 
lock
->
guard
.
done
 = 0;

681 
	}
}

686 #define 
	#gl_waitqueue_t
 
gl_carray_waitqueue_t


	)

688 static 
inline
 void

689 
	$gl_waitqueue_init
 (
gl_waitqueue_t
 *
wq
)

691 
wq
->
array
 = 
NULL
;

692 
wq
->
count
 = 0;

693 
wq
->
alloc
 = 0;

694 
wq
->
offset
 = 0;

695 
	}
}

699 static 
HANDLE


700 
	$gl_waitqueue_add
 (
gl_waitqueue_t
 *
wq
)

702 
HANDLE
 
event
;

703 unsigned int 
index
;

705 if (
wq
->
count
 == wq->
alloc
)

707 unsigned int 
new_alloc
 = 2 * 
wq
->
alloc
 + 1;

708 
HANDLE
 *
new_array
 =

709 (
HANDLE
 *) 
	`realloc
 (
wq
->
array
, 
new_alloc
 * sizeof (HANDLE));

710 if (
new_array
 == 
NULL
)

712 return 
INVALID_HANDLE_VALUE
;

715 if (
wq
->
offset
 > 0)

717 unsigned int 
old_count
 = 
wq
->
count
;

718 unsigned int 
old_alloc
 = 
wq
->
alloc
;

719 unsigned int 
old_offset
 = 
wq
->
offset
;

720 unsigned int 
i
;

721 if (
old_offset
 + 
old_count
 > 
old_alloc
)

723 unsigned int 
limit
 = 
old_offset
 + 
old_count
 - 
old_alloc
;

724 for (
i
 = 0; i < 
limit
; i++)

725 
new_array
[
old_alloc
 + 
i
] = new_array[i];

727 for (
i
 = 0; i < 
old_count
; i++)

728 
new_array
[
i
] = new_array[
old_offset
 + i];

729 
wq
->
offset
 = 0;

731 
wq
->
array
 = 
new_array
;

732 
wq
->
alloc
 = 
new_alloc
;

736 
event
 = 
	`CreateEvent
 (
NULL
, 
TRUE
, 
FALSE
, NULL);

737 if (
event
 == 
INVALID_HANDLE_VALUE
)

739 return 
INVALID_HANDLE_VALUE
;

740 
index
 = 
wq
->
offset
 + wq->
count
;

741 if (
index
 >= 
wq
->
alloc
)

742 
index
 -= 
wq
->
alloc
;

743 
wq
->
array
[
index
] = 
event
;

744 
wq
->
count
++;

745 return 
event
;

746 
	}
}

749 static 
inline
 void

750 
	$gl_waitqueue_notify_first
 (
gl_waitqueue_t
 *
wq
)

752 
	`SetEvent
 (
wq
->
array
[wq->
offset
 + 0]);

753 
wq
->
offset
++;

754 
wq
->
count
--;

755 if (
wq
->
count
 == 0 || wq->
offset
 == wq->
alloc
)

756 
wq
->
offset
 = 0;

757 
	}
}

760 static 
inline
 void

761 
	$gl_waitqueue_notify_all
 (
gl_waitqueue_t
 *
wq
)

763 unsigned int 
i
;

765 for (
i
 = 0; i < 
wq
->
count
; i++)

767 unsigned int 
index
 = 
wq
->
offset
 + 
i
;

768 if (
index
 >= 
wq
->
alloc
)

769 
index
 -= 
wq
->
alloc
;

770 
	`SetEvent
 (
wq
->
array
[
index
]);

772 
wq
->
count
 = 0;

773 
wq
->
offset
 = 0;

774 
	}
}

777 
	$glthread_rwlock_init_func
 (
gl_rwlock_t
 *
lock
)

779 
	`InitializeCriticalSection
 (&
lock
->lock);

780 
	`gl_waitqueue_init
 (&
lock
->
waiting_readers
);

781 
	`gl_waitqueue_init
 (&
lock
->
waiting_writers
);

782 
lock
->
runcount
 = 0;

783 
lock
->
guard
.
done
 = 1;

784 
	}
}

787 
	$glthread_rwlock_rdlock_func
 (
gl_rwlock_t
 *
lock
)

789 if (!
lock
->
guard
.
done
)

791 if (
	`InterlockedIncrement
 (&
lock
->
guard
.
started
) == 0)

793 
	`glthread_rwlock_init
 (
lock
);

797 while (!
lock
->
guard
.
done
)

798 
	`Sleep
 (0);

800 
	`EnterCriticalSection
 (&
lock
->lock);

803 if (!(
lock
->
runcount
 + 1 > 0))

807 
HANDLE
 
event
 = 
	`gl_waitqueue_add
 (&
lock
->
waiting_readers
);

808 if (
event
 != 
INVALID_HANDLE_VALUE
)

810 
DWORD
 
result
;

811 
	`LeaveCriticalSection
 (&
lock
->lock);

813 
result
 = 
	`WaitForSingleObject
 (
event
, 
INFINITE
);

814 if (
result
 == 
WAIT_FAILED
 || result == 
WAIT_TIMEOUT
)

815 
	`abort
 ();

816 
	`CloseHandle
 (
event
);

819 if (!(
lock
->
runcount
 > 0))

820 
	`abort
 ();

828 
	`LeaveCriticalSection
 (&
lock
->lock);

829 
	`Sleep
 (1);

830 
	`EnterCriticalSection
 (&
lock
->lock);

832 while (!(
lock
->
runcount
 + 1 > 0));

835 
lock
->
runcount
++;

836 
	`LeaveCriticalSection
 (&
lock
->lock);

838 
	}
}

841 
	$glthread_rwlock_wrlock_func
 (
gl_rwlock_t
 *
lock
)

843 if (!
lock
->
guard
.
done
)

845 if (
	`InterlockedIncrement
 (&
lock
->
guard
.
started
) == 0)

847 
	`glthread_rwlock_init
 (
lock
);

851 while (!
lock
->
guard
.
done
)

852 
	`Sleep
 (0);

854 
	`EnterCriticalSection
 (&
lock
->lock);

856 if (!(
lock
->
runcount
 == 0))

860 
HANDLE
 
event
 = 
	`gl_waitqueue_add
 (&
lock
->
waiting_writers
);

861 if (
event
 != 
INVALID_HANDLE_VALUE
)

863 
DWORD
 
result
;

864 
	`LeaveCriticalSection
 (&
lock
->lock);

866 
result
 = 
	`WaitForSingleObject
 (
event
, 
INFINITE
);

867 if (
result
 == 
WAIT_FAILED
 || result == 
WAIT_TIMEOUT
)

868 
	`abort
 ();

869 
	`CloseHandle
 (
event
);

872 if (!(
lock
->
runcount
 == -1))

873 
	`abort
 ();

881 
	`LeaveCriticalSection
 (&
lock
->lock);

882 
	`Sleep
 (1);

883 
	`EnterCriticalSection
 (&
lock
->lock);

885 while (!(
lock
->
runcount
 == 0));

888 
lock
->
runcount
--;

889 
	`LeaveCriticalSection
 (&
lock
->lock);

891 
	}
}

894 
	$glthread_rwlock_unlock_func
 (
gl_rwlock_t
 *
lock
)

896 if (!
lock
->
guard
.
done
)

897 return 
EINVAL
;

898 
	`EnterCriticalSection
 (&
lock
->lock);

899 if (
lock
->
runcount
 < 0)

902 if (!(
lock
->
runcount
 == -1))

903 
	`abort
 ();

904 
lock
->
runcount
 = 0;

909 if (!(
lock
->
runcount
 > 0))

911 
	`LeaveCriticalSection
 (&
lock
->lock);

912 return 
EPERM
;

914 
lock
->
runcount
--;

916 if (
lock
->
runcount
 == 0)

920 if (
lock
->
waiting_writers
.
count
 > 0)

923 
lock
->
runcount
--;

924 
	`gl_waitqueue_notify_first
 (&
lock
->
waiting_writers
);

929 
lock
->
runcount
 += lock->
waiting_readers
.
count
;

930 
	`gl_waitqueue_notify_all
 (&
lock
->
waiting_readers
);

933 
	`LeaveCriticalSection
 (&
lock
->lock);

935 
	}
}

938 
	$glthread_rwlock_destroy_func
 (
gl_rwlock_t
 *
lock
)

940 if (!
lock
->
guard
.
done
)

941 return 
EINVAL
;

942 if (
lock
->
runcount
 != 0)

943 return 
EBUSY
;

944 
	`DeleteCriticalSection
 (&
lock
->lock);

945 if (
lock
->
waiting_readers
.
array
 != 
NULL
)

946 
	`free
 (
lock
->
waiting_readers
.
array
);

947 if (
lock
->
waiting_writers
.
array
 != 
NULL
)

948 
	`free
 (
lock
->
waiting_writers
.
array
);

949 
lock
->
guard
.
done
 = 0;

951 
	}
}

956 
	$glthread_recursive_lock_init_func
 (
gl_recursive_lock_t
 *
lock
)

958 
lock
->
owner
 = 0;

959 
lock
->
depth
 = 0;

960 
	`InitializeCriticalSection
 (&
lock
->lock);

961 
lock
->
guard
.
done
 = 1;

962 
	}
}

965 
	$glthread_recursive_lock_lock_func
 (
gl_recursive_lock_t
 *
lock
)

967 if (!
lock
->
guard
.
done
)

969 if (
	`InterlockedIncrement
 (&
lock
->
guard
.
started
) == 0)

971 
	`glthread_recursive_lock_init
 (
lock
);

975 while (!
lock
->
guard
.
done
)

976 
	`Sleep
 (0);

979 
DWORD
 
self
 = 
	`GetCurrentThreadId
 ();

980 if (
lock
->
owner
 != 
self
)

982 
	`EnterCriticalSection
 (&
lock
->lock);

983 
lock
->
owner
 = 
self
;

985 if (++(
lock
->
depth
) == 0)

987 
lock
->
depth
--;

988 return 
EAGAIN
;

992 
	}
}

995 
	$glthread_recursive_lock_unlock_func
 (
gl_recursive_lock_t
 *
lock
)

997 if (
lock
->
owner
 != 
	`GetCurrentThreadId
 ())

998 return 
EPERM
;

999 if (
lock
->
depth
 == 0)

1000 return 
EINVAL
;

1001 if (--(
lock
->
depth
) == 0)

1003 
lock
->
owner
 = 0;

1004 
	`LeaveCriticalSection
 (&
lock
->lock);

1007 
	}
}

1010 
	$glthread_recursive_lock_destroy_func
 (
gl_recursive_lock_t
 *
lock
)

1012 if (
lock
->
owner
 != 0)

1013 return 
EBUSY
;

1014 
	`DeleteCriticalSection
 (&
lock
->lock);

1015 
lock
->
guard
.
done
 = 0;

1017 
	}
}

1022 
glthread_once_func
 (
gl_once_t
 *
once_control
, void (*
initfunction
) (void))

1024 if (
once_control
->
inited
 <= 0)

1026 if (
	`InterlockedIncrement
 (&
once_control
->
started
) == 0)

1029 
	`InitializeCriticalSection
 (&
once_control
->
lock
);

1030 
	`EnterCriticalSection
 (&
once_control
->
lock
);

1031 
once_control
->
inited
 = 0;

1032 
	`initfunction
 ();

1033 
once_control
->
inited
 = 1;

1034 
	`LeaveCriticalSection
 (&
once_control
->
lock
);

1039 
	`InterlockedDecrement
 (&
once_control
->
started
);

1043 while (
once_control
->
inited
 < 0)

1044 
	`Sleep
 (0);

1045 if (
once_control
->
inited
 <= 0)

1049 
	`EnterCriticalSection
 (&
once_control
->
lock
);

1050 
	`LeaveCriticalSection
 (&
once_control
->
lock
);

1051 if (!(
once_control
->
inited
 > 0))

1052 
	`abort
 ();

1056 
	}
}

	@gnulib-tests/glthread/lock.h

81 #ifndef 
_LOCK_H


82 #define 
	#_LOCK_H


	)

84 #include 
	~<errno.h
>

85 #include 
	~<stdlib.h
>

89 #if 
USE_POSIX_THREADS


93 #include 
	~<pthread.h
>

95 #ifdef 
__cplusplus


99 #if 
PTHREAD_IN_USE_DETECTION_HARD


102 #define 
	#pthread_in_use
() \

103 
	`glthread_in_use
 ()

	)

104 extern int 
glthread_in_use
 (void);

108 #if 
USE_POSIX_THREADS_WEAK


127 #pragma 
weak
 
pthread_mutex_init


128 #pragma 
weak
 
pthread_mutex_lock


129 #pragma 
weak
 
pthread_mutex_unlock


130 #pragma 
weak
 
pthread_mutex_destroy


131 #pragma 
weak
 
pthread_rwlock_init


132 #pragma 
weak
 
pthread_rwlock_rdlock


133 #pragma 
weak
 
pthread_rwlock_wrlock


134 #pragma 
weak
 
pthread_rwlock_unlock


135 #pragma 
weak
 
pthread_rwlock_destroy


136 #pragma 
weak
 
pthread_once


137 #pragma 
weak
 
pthread_cond_init


138 #pragma 
weak
 
pthread_cond_wait


139 #pragma 
weak
 
pthread_cond_signal


140 #pragma 
weak
 
pthread_cond_broadcast


141 #pragma 
weak
 
pthread_cond_destroy


142 #pragma 
weak
 
pthread_mutexattr_init


143 #pragma 
weak
 
pthread_mutexattr_settype


144 #pragma 
weak
 
pthread_mutexattr_destroy


145 #ifndef 
pthread_self


146 #pragma 
weak
 
pthread_self


149 #if !
PTHREAD_IN_USE_DETECTION_HARD


150 #pragma 
weak
 
pthread_cancel


151 #define 
	#pthread_in_use
() (
pthread_cancel
 != 
NULL
)

	)

156 #if !
PTHREAD_IN_USE_DETECTION_HARD


157 #define 
	#pthread_in_use
() 1

	)

164 typedef 
pthread_mutex_t
 
	tgl_lock_t
;

165 #define 
	#gl_lock_define
(
STORAGECLASS
, 
NAME
) \

166 
STORAGECLASS
 
pthread_mutex_t
 
NAME
;

	)

167 #define 
	#gl_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

168 
STORAGECLASS
 
pthread_mutex_t
 
NAME
 = 
gl_lock_initializer
;

	)

169 #define 
	#gl_lock_initializer
 \

170 
PTHREAD_MUTEX_INITIALIZER


	)

171 #define 
	#glthread_lock_init
(
LOCK
) \

172 (
	`pthread_in_use
 () ? 
	`pthread_mutex_init
 (
LOCK
, 
NULL
) : 0)

	)

173 #define 
	#glthread_lock_lock
(
LOCK
) \

174 (
	`pthread_in_use
 () ? 
	`pthread_mutex_lock
 (
LOCK
) : 0)

	)

175 #define 
	#glthread_lock_unlock
(
LOCK
) \

176 (
	`pthread_in_use
 () ? 
	`pthread_mutex_unlock
 (
LOCK
) : 0)

	)

177 #define 
	#glthread_lock_destroy
(
LOCK
) \

178 (
	`pthread_in_use
 () ? 
	`pthread_mutex_destroy
 (
LOCK
) : 0)

	)

182 #if 
HAVE_PTHREAD_RWLOCK


184 #ifdef 
PTHREAD_RWLOCK_INITIALIZER


186 typedef 
pthread_rwlock_t
 
	tgl_rwlock_t
;

187 #define 
	#gl_rwlock_define
(
STORAGECLASS
, 
NAME
) \

188 
STORAGECLASS
 
pthread_rwlock_t
 
NAME
;

	)

189 #define 
	#gl_rwlock_define_initialized
(
STORAGECLASS
, 
NAME
) \

190 
STORAGECLASS
 
pthread_rwlock_t
 
NAME
 = 
gl_rwlock_initializer
;

	)

191 #define 
	#gl_rwlock_initializer
 \

192 
PTHREAD_RWLOCK_INITIALIZER


	)

193 #define 
	#glthread_rwlock_init
(
LOCK
) \

194 (
	`pthread_in_use
 () ? 
	`pthread_rwlock_init
 (
LOCK
, 
NULL
) : 0)

	)

195 #define 
	#glthread_rwlock_rdlock
(
LOCK
) \

196 (
	`pthread_in_use
 () ? 
	`pthread_rwlock_rdlock
 (
LOCK
) : 0)

	)

197 #define 
	#glthread_rwlock_wrlock
(
LOCK
) \

198 (
	`pthread_in_use
 () ? 
	`pthread_rwlock_wrlock
 (
LOCK
) : 0)

	)

199 #define 
	#glthread_rwlock_unlock
(
LOCK
) \

200 (
	`pthread_in_use
 () ? 
	`pthread_rwlock_unlock
 (
LOCK
) : 0)

	)

201 #define 
	#glthread_rwlock_destroy
(
LOCK
) \

202 (
	`pthread_in_use
 () ? 
	`pthread_rwlock_destroy
 (
LOCK
) : 0)

	)

208 int 
	ginitialized
;

209 
pthread_mutex_t
 
	gguard
;

210 
pthread_rwlock_t
 
	grwlock
;

212 
	tgl_rwlock_t
;

213 #define 
	#gl_rwlock_define
(
STORAGECLASS
, 
NAME
) \

214 
STORAGECLASS
 
gl_rwlock_t
 
NAME
;

	)

215 #define 
	#gl_rwlock_define_initialized
(
STORAGECLASS
, 
NAME
) \

216 
STORAGECLASS
 
gl_rwlock_t
 
NAME
 = 
gl_rwlock_initializer
;

	)

217 #define 
	#gl_rwlock_initializer
 \

218 { 0, 
PTHREAD_MUTEX_INITIALIZER
 }

	)

219 #define 
	#glthread_rwlock_init
(
LOCK
) \

220 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_init_multithreaded
 (
LOCK
) : 0)

	)

221 #define 
	#glthread_rwlock_rdlock
(
LOCK
) \

222 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_rdlock_multithreaded
 (
LOCK
) : 0)

	)

223 #define 
	#glthread_rwlock_wrlock
(
LOCK
) \

224 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_wrlock_multithreaded
 (
LOCK
) : 0)

	)

225 #define 
	#glthread_rwlock_unlock
(
LOCK
) \

226 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_unlock_multithreaded
 (
LOCK
) : 0)

	)

227 #define 
	#glthread_rwlock_destroy
(
LOCK
) \

228 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_destroy_multithreaded
 (
LOCK
) : 0)

	)

229 extern int 
glthread_rwlock_init_multithreaded
 (
gl_rwlock_t
 *
lock
);

230 extern int 
glthread_rwlock_rdlock_multithreaded
 (
gl_rwlock_t
 *
lock
);

231 extern int 
glthread_rwlock_wrlock_multithreaded
 (
gl_rwlock_t
 *
lock
);

232 extern int 
glthread_rwlock_unlock_multithreaded
 (
gl_rwlock_t
 *
lock
);

233 extern int 
glthread_rwlock_destroy_multithreaded
 (
gl_rwlock_t
 *
lock
);

241 
pthread_mutex_t
 
	glock
;

242 
pthread_cond_t
 
	gwaiting_readers
;

243 
pthread_cond_t
 
	gwaiting_writers
;

244 unsigned int 
	gwaiting_writers_count
;

245 int 
	gruncount
;

247 
	tgl_rwlock_t
;

248 #define 
	#gl_rwlock_define
(
STORAGECLASS
, 
NAME
) \

249 
STORAGECLASS
 
gl_rwlock_t
 
NAME
;

	)

250 #define 
	#gl_rwlock_define_initialized
(
STORAGECLASS
, 
NAME
) \

251 
STORAGECLASS
 
gl_rwlock_t
 
NAME
 = 
gl_rwlock_initializer
;

	)

252 #define 
	#gl_rwlock_initializer
 \

253 { 
PTHREAD_MUTEX_INITIALIZER
, 
PTHREAD_COND_INITIALIZER
, PTHREAD_COND_INITIALIZER, 0, 0 }

	)

254 #define 
	#glthread_rwlock_init
(
LOCK
) \

255 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_init_multithreaded
 (
LOCK
) : 0)

	)

256 #define 
	#glthread_rwlock_rdlock
(
LOCK
) \

257 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_rdlock_multithreaded
 (
LOCK
) : 0)

	)

258 #define 
	#glthread_rwlock_wrlock
(
LOCK
) \

259 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_wrlock_multithreaded
 (
LOCK
) : 0)

	)

260 #define 
	#glthread_rwlock_unlock
(
LOCK
) \

261 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_unlock_multithreaded
 (
LOCK
) : 0)

	)

262 #define 
	#glthread_rwlock_destroy
(
LOCK
) \

263 (
	`pthread_in_use
 () ? 
	`glthread_rwlock_destroy_multithreaded
 (
LOCK
) : 0)

	)

264 extern int 
glthread_rwlock_init_multithreaded
 (
gl_rwlock_t
 *
lock
);

265 extern int 
glthread_rwlock_rdlock_multithreaded
 (
gl_rwlock_t
 *
lock
);

266 extern int 
glthread_rwlock_wrlock_multithreaded
 (
gl_rwlock_t
 *
lock
);

267 extern int 
glthread_rwlock_unlock_multithreaded
 (
gl_rwlock_t
 *
lock
);

268 extern int 
glthread_rwlock_destroy_multithreaded
 (
gl_rwlock_t
 *
lock
);

274 #if 
HAVE_PTHREAD_MUTEX_RECURSIVE


276 #if 
defined
 
PTHREAD_RECURSIVE_MUTEX_INITIALIZER
 || defined 
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP


278 typedef 
pthread_mutex_t
 
	tgl_recursive_lock_t
;

279 #define 
	#gl_recursive_lock_define
(
STORAGECLASS
, 
NAME
) \

280 
STORAGECLASS
 
pthread_mutex_t
 
NAME
;

	)

281 #define 
	#gl_recursive_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

282 
STORAGECLASS
 
pthread_mutex_t
 
NAME
 = 
gl_recursive_lock_initializer
;

	)

283 #ifdef 
PTHREAD_RECURSIVE_MUTEX_INITIALIZER


284 #define 
	#gl_recursive_lock_initializer
 \

285 
PTHREAD_RECURSIVE_MUTEX_INITIALIZER


	)

287 #define 
	#gl_recursive_lock_initializer
 \

288 
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP


	)

290 #define 
	#glthread_recursive_lock_init
(
LOCK
) \

291 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_init_multithreaded
 (
LOCK
) : 0)

	)

292 #define 
	#glthread_recursive_lock_lock
(
LOCK
) \

293 (
	`pthread_in_use
 () ? 
	`pthread_mutex_lock
 (
LOCK
) : 0)

	)

294 #define 
	#glthread_recursive_lock_unlock
(
LOCK
) \

295 (
	`pthread_in_use
 () ? 
	`pthread_mutex_unlock
 (
LOCK
) : 0)

	)

296 #define 
	#glthread_recursive_lock_destroy
(
LOCK
) \

297 (
	`pthread_in_use
 () ? 
	`pthread_mutex_destroy
 (
LOCK
) : 0)

	)

298 extern int 
glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

304 
pthread_mutex_t
 
	grecmutex
;

305 
pthread_mutex_t
 
	gguard
;

306 int 
	ginitialized
;

308 
	tgl_recursive_lock_t
;

309 #define 
	#gl_recursive_lock_define
(
STORAGECLASS
, 
NAME
) \

310 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
;

	)

311 #define 
	#gl_recursive_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

312 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
 = 
gl_recursive_lock_initializer
;

	)

313 #define 
	#gl_recursive_lock_initializer
 \

314 { 
PTHREAD_MUTEX_INITIALIZER
, PTHREAD_MUTEX_INITIALIZER, 0 }

	)

315 #define 
	#glthread_recursive_lock_init
(
LOCK
) \

316 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_init_multithreaded
 (
LOCK
) : 0)

	)

317 #define 
	#glthread_recursive_lock_lock
(
LOCK
) \

318 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_lock_multithreaded
 (
LOCK
) : 0)

	)

319 #define 
	#glthread_recursive_lock_unlock
(
LOCK
) \

320 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_unlock_multithreaded
 (
LOCK
) : 0)

	)

321 #define 
	#glthread_recursive_lock_destroy
(
LOCK
) \

322 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_destroy_multithreaded
 (
LOCK
) : 0)

	)

323 extern int 
glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

324 extern int 
glthread_recursive_lock_lock_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

325 extern int 
glthread_recursive_lock_unlock_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

326 extern int 
glthread_recursive_lock_destroy_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

337 
pthread_mutex_t
 
	gmutex
;

338 
pthread_t
 
	gowner
;

339 unsigned long 
	gdepth
;

341 
	tgl_recursive_lock_t
;

342 #define 
	#gl_recursive_lock_define
(
STORAGECLASS
, 
NAME
) \

343 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
;

	)

344 #define 
	#gl_recursive_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

345 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
 = 
gl_recursive_lock_initializer
;

	)

346 #define 
	#gl_recursive_lock_initializer
 \

347 { 
PTHREAD_MUTEX_INITIALIZER
, (
pthread_t
) 0, 0 }

	)

348 #define 
	#glthread_recursive_lock_init
(
LOCK
) \

349 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_init_multithreaded
 (
LOCK
) : 0)

	)

350 #define 
	#glthread_recursive_lock_lock
(
LOCK
) \

351 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_lock_multithreaded
 (
LOCK
) : 0)

	)

352 #define 
	#glthread_recursive_lock_unlock
(
LOCK
) \

353 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_unlock_multithreaded
 (
LOCK
) : 0)

	)

354 #define 
	#glthread_recursive_lock_destroy
(
LOCK
) \

355 (
	`pthread_in_use
 () ? 
	`glthread_recursive_lock_destroy_multithreaded
 (
LOCK
) : 0)

	)

356 extern int 
glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

357 extern int 
glthread_recursive_lock_lock_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

358 extern int 
glthread_recursive_lock_unlock_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

359 extern int 
glthread_recursive_lock_destroy_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

365 typedef 
pthread_once_t
 
	tgl_once_t
;

366 #define 
	#gl_once_define
(
STORAGECLASS
, 
NAME
) \

367 
STORAGECLASS
 
pthread_once_t
 
NAME
 = 
PTHREAD_ONCE_INIT
;

	)

368 #define 
	#glthread_once
(
ONCE_CONTROL
, 
INITFUNCTION
) \

369 (
	`pthread_in_use
 () \

370 ? 
	`pthread_once
 (
ONCE_CONTROL
, 
INITFUNCTION
) \

371 : (
	`glthread_once_singlethreaded
 (
ONCE_CONTROL
) ? (
	`INITFUNCTION
 (), 0) : 0))

	)

372 extern int 
glthread_once_singlethreaded
 (
pthread_once_t
 *
once_control
);

374 #ifdef 
__cplusplus


382 #if 
USE_PTH_THREADS


386 #include 
	~<pth.h
>

388 #ifdef 
__cplusplus


392 #if 
USE_PTH_THREADS_WEAK


396 #pragma 
weak
 
pth_mutex_init


397 #pragma 
weak
 
pth_mutex_acquire


398 #pragma 
weak
 
pth_mutex_release


399 #pragma 
weak
 
pth_rwlock_init


400 #pragma 
weak
 
pth_rwlock_acquire


401 #pragma 
weak
 
pth_rwlock_release


402 #pragma 
weak
 
pth_once


404 #pragma 
weak
 
pth_cancel


405 #define 
	#pth_in_use
() (
pth_cancel
 != 
NULL
)

	)

409 #define 
	#pth_in_use
() 1

	)

415 typedef 
pth_mutex_t
 
	tgl_lock_t
;

416 #define 
	#gl_lock_define
(
STORAGECLASS
, 
NAME
) \

417 
STORAGECLASS
 
pth_mutex_t
 
NAME
;

	)

418 #define 
	#gl_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

419 
STORAGECLASS
 
pth_mutex_t
 
NAME
 = 
gl_lock_initializer
;

	)

420 #define 
	#gl_lock_initializer
 \

421 
PTH_MUTEX_INIT


	)

422 #define 
	#glthread_lock_init
(
LOCK
) \

423 (
	`pth_in_use
 () && !
	`pth_mutex_init
 (
LOCK
) ? 
errno
 : 0)

	)

424 #define 
	#glthread_lock_lock
(
LOCK
) \

425 (
	`pth_in_use
 () && !
	`pth_mutex_acquire
 (
LOCK
, 0, 
NULL
) ? 
errno
 : 0)

	)

426 #define 
	#glthread_lock_unlock
(
LOCK
) \

427 (
	`pth_in_use
 () && !
	`pth_mutex_release
 (
LOCK
) ? 
errno
 : 0)

	)

428 #define 
	#glthread_lock_destroy
(
LOCK
) \

429 ((void)(
LOCK
), 0)

	)

433 typedef 
pth_rwlock_t
 
	tgl_rwlock_t
;

434 #define 
	#gl_rwlock_define
(
STORAGECLASS
, 
NAME
) \

435 
STORAGECLASS
 
pth_rwlock_t
 
NAME
;

	)

436 #define 
	#gl_rwlock_define_initialized
(
STORAGECLASS
, 
NAME
) \

437 
STORAGECLASS
 
pth_rwlock_t
 
NAME
 = 
gl_rwlock_initializer
;

	)

438 #define 
	#gl_rwlock_initializer
 \

439 
PTH_RWLOCK_INIT


	)

440 #define 
	#glthread_rwlock_init
(
LOCK
) \

441 (
	`pth_in_use
 () && !
	`pth_rwlock_init
 (
LOCK
) ? 
errno
 : 0)

	)

442 #define 
	#glthread_rwlock_rdlock
(
LOCK
) \

443 (
	`pth_in_use
 () && !
	`pth_rwlock_acquire
 (
LOCK
, 
PTH_RWLOCK_RD
, 0, 
NULL
) ? 
errno
 : 0)

	)

444 #define 
	#glthread_rwlock_wrlock
(
LOCK
) \

445 (
	`pth_in_use
 () && !
	`pth_rwlock_acquire
 (
LOCK
, 
PTH_RWLOCK_RW
, 0, 
NULL
) ? 
errno
 : 0)

	)

446 #define 
	#glthread_rwlock_unlock
(
LOCK
) \

447 (
	`pth_in_use
 () && !
	`pth_rwlock_release
 (
LOCK
) ? 
errno
 : 0)

	)

448 #define 
	#glthread_rwlock_destroy
(
LOCK
) \

449 ((void)(
LOCK
), 0)

	)

454 typedef 
pth_mutex_t
 
	tgl_recursive_lock_t
;

455 #define 
	#gl_recursive_lock_define
(
STORAGECLASS
, 
NAME
) \

456 
STORAGECLASS
 
pth_mutex_t
 
NAME
;

	)

457 #define 
	#gl_recursive_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

458 
STORAGECLASS
 
pth_mutex_t
 
NAME
 = 
gl_recursive_lock_initializer
;

	)

459 #define 
	#gl_recursive_lock_initializer
 \

460 
PTH_MUTEX_INIT


	)

461 #define 
	#glthread_recursive_lock_init
(
LOCK
) \

462 (
	`pth_in_use
 () && !
	`pth_mutex_init
 (
LOCK
) ? 
errno
 : 0)

	)

463 #define 
	#glthread_recursive_lock_lock
(
LOCK
) \

464 (
	`pth_in_use
 () && !
	`pth_mutex_acquire
 (
LOCK
, 0, 
NULL
) ? 
errno
 : 0)

	)

465 #define 
	#glthread_recursive_lock_unlock
(
LOCK
) \

466 (
	`pth_in_use
 () && !
	`pth_mutex_release
 (
LOCK
) ? 
errno
 : 0)

	)

467 #define 
	#glthread_recursive_lock_destroy
(
LOCK
) \

468 ((void)(
LOCK
), 0)

	)

472 typedef 
pth_once_t
 
	tgl_once_t
;

473 #define 
	#gl_once_define
(
STORAGECLASS
, 
NAME
) \

474 
STORAGECLASS
 
pth_once_t
 
NAME
 = 
PTH_ONCE_INIT
;

	)

475 #define 
	#glthread_once
(
ONCE_CONTROL
, 
INITFUNCTION
) \

476 (
	`pth_in_use
 () \

477 ? 
	`glthread_once_multithreaded
 (
ONCE_CONTROL
, 
INITFUNCTION
) \

478 : (
	`glthread_once_singlethreaded
 (
ONCE_CONTROL
) ? (
	`INITFUNCTION
 (), 0) : 0))

	)

479 extern int 
glthread_once_multithreaded
 (
pth_once_t
 *
once_control
, void (*
initfunction
) (void));

480 extern int 
glthread_once_singlethreaded
 (
pth_once_t
 *
once_control
);

482 #ifdef 
__cplusplus


490 #if 
USE_SOLARIS_THREADS


494 #include 
	~<thread.h
>

495 #include 
	~<synch.h
>

497 #ifdef 
__cplusplus


501 #if 
USE_SOLARIS_THREADS_WEAK


505 #pragma 
weak
 
mutex_init


506 #pragma 
weak
 
mutex_lock


507 #pragma 
weak
 
mutex_unlock


508 #pragma 
weak
 
mutex_destroy


509 #pragma 
weak
 
rwlock_init


510 #pragma 
weak
 
rw_rdlock


511 #pragma 
weak
 
rw_wrlock


512 #pragma 
weak
 
rw_unlock


513 #pragma 
weak
 
rwlock_destroy


514 #pragma 
weak
 
thr_self


516 #pragma 
weak
 
thr_suspend


517 #define 
	#thread_in_use
() (
thr_suspend
 != 
NULL
)

	)

521 #define 
	#thread_in_use
() 1

	)

527 typedef 
mutex_t
 
	tgl_lock_t
;

528 #define 
	#gl_lock_define
(
STORAGECLASS
, 
NAME
) \

529 
STORAGECLASS
 
mutex_t
 
NAME
;

	)

530 #define 
	#gl_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

531 
STORAGECLASS
 
mutex_t
 
NAME
 = 
gl_lock_initializer
;

	)

532 #define 
	#gl_lock_initializer
 \

533 
DEFAULTMUTEX


	)

534 #define 
	#glthread_lock_init
(
LOCK
) \

535 (
	`thread_in_use
 () ? 
	`mutex_init
 (
LOCK
, 
USYNC_THREAD
, 
NULL
) : 0)

	)

536 #define 
	#glthread_lock_lock
(
LOCK
) \

537 (
	`thread_in_use
 () ? 
	`mutex_lock
 (
LOCK
) : 0)

	)

538 #define 
	#glthread_lock_unlock
(
LOCK
) \

539 (
	`thread_in_use
 () ? 
	`mutex_unlock
 (
LOCK
) : 0)

	)

540 #define 
	#glthread_lock_destroy
(
LOCK
) \

541 (
	`thread_in_use
 () ? 
	`mutex_destroy
 (
LOCK
) : 0)

	)

545 typedef 
rwlock_t
 
	tgl_rwlock_t
;

546 #define 
	#gl_rwlock_define
(
STORAGECLASS
, 
NAME
) \

547 
STORAGECLASS
 
rwlock_t
 
NAME
;

	)

548 #define 
	#gl_rwlock_define_initialized
(
STORAGECLASS
, 
NAME
) \

549 
STORAGECLASS
 
rwlock_t
 
NAME
 = 
gl_rwlock_initializer
;

	)

550 #define 
	#gl_rwlock_initializer
 \

551 
DEFAULTRWLOCK


	)

552 #define 
	#glthread_rwlock_init
(
LOCK
) \

553 (
	`thread_in_use
 () ? 
	`rwlock_init
 (
LOCK
, 
USYNC_THREAD
, 
NULL
) : 0)

	)

554 #define 
	#glthread_rwlock_rdlock
(
LOCK
) \

555 (
	`thread_in_use
 () ? 
	`rw_rdlock
 (
LOCK
) : 0)

	)

556 #define 
	#glthread_rwlock_wrlock
(
LOCK
) \

557 (
	`thread_in_use
 () ? 
	`rw_wrlock
 (
LOCK
) : 0)

	)

558 #define 
	#glthread_rwlock_unlock
(
LOCK
) \

559 (
	`thread_in_use
 () ? 
	`rw_unlock
 (
LOCK
) : 0)

	)

560 #define 
	#glthread_rwlock_destroy
(
LOCK
) \

561 (
	`thread_in_use
 () ? 
	`rwlock_destroy
 (
LOCK
) : 0)

	)

570 
mutex_t
 
mutex
;

571 
thread_t
 
owner
;

572 unsigned long 
depth
;

574 
	tgl_recursive_lock_t
;

575 #define 
	#gl_recursive_lock_define
(
STORAGECLASS
, 
NAME
) \

576 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
;

	)

577 #define 
	#gl_recursive_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

578 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
 = 
gl_recursive_lock_initializer
;

	)

579 #define 
	#gl_recursive_lock_initializer
 \

580 { 
DEFAULTMUTEX
, (
thread_t
) 0, 0 }

	)

581 #define 
	#glthread_recursive_lock_init
(
LOCK
) \

582 (
	`thread_in_use
 () ? 
	`glthread_recursive_lock_init_multithreaded
 (
LOCK
) : 0)

	)

583 #define 
	#glthread_recursive_lock_lock
(
LOCK
) \

584 (
	`thread_in_use
 () ? 
	`glthread_recursive_lock_lock_multithreaded
 (
LOCK
) : 0)

	)

585 #define 
	#glthread_recursive_lock_unlock
(
LOCK
) \

586 (
	`thread_in_use
 () ? 
	`glthread_recursive_lock_unlock_multithreaded
 (
LOCK
) : 0)

	)

587 #define 
	#glthread_recursive_lock_destroy
(
LOCK
) \

588 (
	`thread_in_use
 () ? 
	`glthread_recursive_lock_destroy_multithreaded
 (
LOCK
) : 0)

	)

589 extern int 
glthread_recursive_lock_init_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

590 extern int 
glthread_recursive_lock_lock_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

591 extern int 
glthread_recursive_lock_unlock_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

592 extern int 
glthread_recursive_lock_destroy_multithreaded
 (
gl_recursive_lock_t
 *
lock
);

598 volatile int 
	ginited
;

599 
mutex_t
 
	gmutex
;

601 
	tgl_once_t
;

602 #define 
	#gl_once_define
(
STORAGECLASS
, 
NAME
) \

603 
STORAGECLASS
 
gl_once_t
 
NAME
 = { 0, 
DEFAULTMUTEX
 };

	)

604 #define 
	#glthread_once
(
ONCE_CONTROL
, 
INITFUNCTION
) \

605 (
	`thread_in_use
 () \

606 ? 
	`glthread_once_multithreaded
 (
ONCE_CONTROL
, 
INITFUNCTION
) \

607 : (
	`glthread_once_singlethreaded
 (
ONCE_CONTROL
) ? (
	`INITFUNCTION
 (), 0) : 0))

	)

608 extern int 
glthread_once_multithreaded
 (
gl_once_t
 *
once_control
, void (*
initfunction
) (void));

609 extern int 
glthread_once_singlethreaded
 (
gl_once_t
 *
once_control
);

611 #ifdef 
__cplusplus


619 #if 
USE_WIN32_THREADS


621 #define 
	#WIN32_LEAN_AND_MEAN


	)

622 #include 
	~<windows.h
>

624 #ifdef 
__cplusplus


639 typedef struct { volatile int 
done
; volatile long 
started
; } 
	tgl_spinlock_t
;

645 
gl_spinlock_t
 
guard
;

646 
CRITICAL_SECTION
 
lock
;

648 
	tgl_lock_t
;

649 #define 
	#gl_lock_define
(
STORAGECLASS
, 
NAME
) \

650 
STORAGECLASS
 
gl_lock_t
 
NAME
;

	)

651 #define 
	#gl_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

652 
STORAGECLASS
 
gl_lock_t
 
NAME
 = 
gl_lock_initializer
;

	)

653 #define 
	#gl_lock_initializer
 \

654 { { 0, -1 } }

	)

655 #define 
	#glthread_lock_init
(
LOCK
) \

656 (
	`glthread_lock_init_func
 (
LOCK
), 0)

	)

657 #define 
	#glthread_lock_lock
(
LOCK
) \

658 
	`glthread_lock_lock_func
 (
LOCK
)

	)

659 #define 
	#glthread_lock_unlock
(
LOCK
) \

660 
	`glthread_lock_unlock_func
 (
LOCK
)

	)

661 #define 
	#glthread_lock_destroy
(
LOCK
) \

662 
	`glthread_lock_destroy_func
 (
LOCK
)

	)

663 extern void 
glthread_lock_init_func
 (
gl_lock_t
 *
lock
);

664 extern int 
glthread_lock_lock_func
 (
gl_lock_t
 *
lock
);

665 extern int 
glthread_lock_unlock_func
 (
gl_lock_t
 *
lock
);

666 extern int 
glthread_lock_destroy_func
 (
gl_lock_t
 *
lock
);

676 
HANDLE
 *
	garray
;

677 unsigned int 
	gcount
;

678 unsigned int 
	galloc
;

679 unsigned int 
	goffset
;

681 
	tgl_carray_waitqueue_t
;

684 
gl_spinlock_t
 
	gguard
;

685 
CRITICAL_SECTION
 
	glock
;

686 
gl_carray_waitqueue_t
 
	gwaiting_readers
;

687 
gl_carray_waitqueue_t
 
	gwaiting_writers
;

688 int 
	gruncount
;

690 
	tgl_rwlock_t
;

691 #define 
	#gl_rwlock_define
(
STORAGECLASS
, 
NAME
) \

692 
STORAGECLASS
 
gl_rwlock_t
 
NAME
;

	)

693 #define 
	#gl_rwlock_define_initialized
(
STORAGECLASS
, 
NAME
) \

694 
STORAGECLASS
 
gl_rwlock_t
 
NAME
 = 
gl_rwlock_initializer
;

	)

695 #define 
	#gl_rwlock_initializer
 \

696 { { 0, -1 } }

	)

697 #define 
	#glthread_rwlock_init
(
LOCK
) \

698 (
	`glthread_rwlock_init_func
 (
LOCK
), 0)

	)

699 #define 
	#glthread_rwlock_rdlock
(
LOCK
) \

700 
	`glthread_rwlock_rdlock_func
 (
LOCK
)

	)

701 #define 
	#glthread_rwlock_wrlock
(
LOCK
) \

702 
	`glthread_rwlock_wrlock_func
 (
LOCK
)

	)

703 #define 
	#glthread_rwlock_unlock
(
LOCK
) \

704 
	`glthread_rwlock_unlock_func
 (
LOCK
)

	)

705 #define 
	#glthread_rwlock_destroy
(
LOCK
) \

706 
	`glthread_rwlock_destroy_func
 (
LOCK
)

	)

707 extern void 
glthread_rwlock_init_func
 (
gl_rwlock_t
 *
lock
);

708 extern int 
glthread_rwlock_rdlock_func
 (
gl_rwlock_t
 *
lock
);

709 extern int 
glthread_rwlock_wrlock_func
 (
gl_rwlock_t
 *
lock
);

710 extern int 
glthread_rwlock_unlock_func
 (
gl_rwlock_t
 *
lock
);

711 extern int 
glthread_rwlock_destroy_func
 (
gl_rwlock_t
 *
lock
);

721 
gl_spinlock_t
 
	gguard
;

722 
DWORD
 
	gowner
;

723 unsigned long 
	gdepth
;

724 
CRITICAL_SECTION
 
	glock
;

726 
	tgl_recursive_lock_t
;

727 #define 
	#gl_recursive_lock_define
(
STORAGECLASS
, 
NAME
) \

728 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
;

	)

729 #define 
	#gl_recursive_lock_define_initialized
(
STORAGECLASS
, 
NAME
) \

730 
STORAGECLASS
 
gl_recursive_lock_t
 
NAME
 = 
gl_recursive_lock_initializer
;

	)

731 #define 
	#gl_recursive_lock_initializer
 \

732 { { 0, -1 }, 0, 0 }

	)

733 #define 
	#glthread_recursive_lock_init
(
LOCK
) \

734 (
	`glthread_recursive_lock_init_func
 (
LOCK
), 0)

	)

735 #define 
	#glthread_recursive_lock_lock
(
LOCK
) \

736 
	`glthread_recursive_lock_lock_func
 (
LOCK
)

	)

737 #define 
	#glthread_recursive_lock_unlock
(
LOCK
) \

738 
	`glthread_recursive_lock_unlock_func
 (
LOCK
)

	)

739 #define 
	#glthread_recursive_lock_destroy
(
LOCK
) \

740 
	`glthread_recursive_lock_destroy_func
 (
LOCK
)

	)

741 extern void 
glthread_recursive_lock_init_func
 (
gl_recursive_lock_t
 *
lock
);

742 extern int 
glthread_recursive_lock_lock_func
 (
gl_recursive_lock_t
 *
lock
);

743 extern int 
glthread_recursive_lock_unlock_func
 (
gl_recursive_lock_t
 *
lock
);

744 extern int 
glthread_recursive_lock_destroy_func
 (
gl_recursive_lock_t
 *
lock
);

750 volatile int 
	ginited
;

751 volatile long 
	gstarted
;

752 
CRITICAL_SECTION
 
	glock
;

754 
	tgl_once_t
;

755 #define 
	#gl_once_define
(
STORAGECLASS
, 
NAME
) \

756 
STORAGECLASS
 
gl_once_t
 
NAME
 = { -1, -1 };

	)

757 #define 
	#glthread_once
(
ONCE_CONTROL
, 
INITFUNCTION
) \

758 (
	`glthread_once_func
 (
ONCE_CONTROL
, 
INITFUNCTION
), 0)

	)

759 extern void 
glthread_once_func
 (
gl_once_t
 *
once_control
, void (*
initfunction
) (void));

761 #ifdef 
__cplusplus


769 #if !(
USE_POSIX_THREADS
 || 
USE_PTH_THREADS
 || 
USE_SOLARIS_THREADS
 || 
USE_WIN32_THREADS
)

775 typedef int 
	tgl_lock_t
;

776 #define 
	#gl_lock_define
(
STORAGECLASS
, 
NAME
)

	)

777 #define 
	#gl_lock_define_initialized
(
STORAGECLASS
, 
NAME
)

	)

778 #define 
	#glthread_lock_init
(
NAME
) 0

	)

779 #define 
	#glthread_lock_lock
(
NAME
) 0

	)

780 #define 
	#glthread_lock_unlock
(
NAME
) 0

	)

781 #define 
	#glthread_lock_destroy
(
NAME
) 0

	)

785 typedef int 
	tgl_rwlock_t
;

786 #define 
	#gl_rwlock_define
(
STORAGECLASS
, 
NAME
)

	)

787 #define 
	#gl_rwlock_define_initialized
(
STORAGECLASS
, 
NAME
)

	)

788 #define 
	#glthread_rwlock_init
(
NAME
) 0

	)

789 #define 
	#glthread_rwlock_rdlock
(
NAME
) 0

	)

790 #define 
	#glthread_rwlock_wrlock
(
NAME
) 0

	)

791 #define 
	#glthread_rwlock_unlock
(
NAME
) 0

	)

792 #define 
	#glthread_rwlock_destroy
(
NAME
) 0

	)

796 typedef int 
	tgl_recursive_lock_t
;

797 #define 
	#gl_recursive_lock_define
(
STORAGECLASS
, 
NAME
)

	)

798 #define 
	#gl_recursive_lock_define_initialized
(
STORAGECLASS
, 
NAME
)

	)

799 #define 
	#glthread_recursive_lock_init
(
NAME
) 0

	)

800 #define 
	#glthread_recursive_lock_lock
(
NAME
) 0

	)

801 #define 
	#glthread_recursive_lock_unlock
(
NAME
) 0

	)

802 #define 
	#glthread_recursive_lock_destroy
(
NAME
) 0

	)

806 typedef int 
	tgl_once_t
;

807 #define 
	#gl_once_define
(
STORAGECLASS
, 
NAME
) \

808 
STORAGECLASS
 
gl_once_t
 
NAME
 = 0;

	)

809 #define 
	#glthread_once
(
ONCE_CONTROL
, 
INITFUNCTION
) \

810 (*(
ONCE_CONTROL
) == 0 ? (*(ONCE_CONTROL) = ~ 0, 
	`INITFUNCTION
 (), 0) : 0)

	)

820 #define 
	#gl_lock_init
(
NAME
) \

823 if (
	`glthread_lock_init
 (&
NAME
)) \

824 
	`abort
 (); \

826 while (0)

	)

827 #define 
	#gl_lock_lock
(
NAME
) \

830 if (
	`glthread_lock_lock
 (&
NAME
)) \

831 
	`abort
 (); \

833 while (0)

	)

834 #define 
	#gl_lock_unlock
(
NAME
) \

837 if (
	`glthread_lock_unlock
 (&
NAME
)) \

838 
	`abort
 (); \

840 while (0)

	)

841 #define 
	#gl_lock_destroy
(
NAME
) \

844 if (
	`glthread_lock_destroy
 (&
NAME
)) \

845 
	`abort
 (); \

847 while (0)

	)

851 #define 
	#gl_rwlock_init
(
NAME
) \

854 if (
	`glthread_rwlock_init
 (&
NAME
)) \

855 
	`abort
 (); \

857 while (0)

	)

858 #define 
	#gl_rwlock_rdlock
(
NAME
) \

861 if (
	`glthread_rwlock_rdlock
 (&
NAME
)) \

862 
	`abort
 (); \

864 while (0)

	)

865 #define 
	#gl_rwlock_wrlock
(
NAME
) \

868 if (
	`glthread_rwlock_wrlock
 (&
NAME
)) \

869 
	`abort
 (); \

871 while (0)

	)

872 #define 
	#gl_rwlock_unlock
(
NAME
) \

875 if (
	`glthread_rwlock_unlock
 (&
NAME
)) \

876 
	`abort
 (); \

878 while (0)

	)

879 #define 
	#gl_rwlock_destroy
(
NAME
) \

882 if (
	`glthread_rwlock_destroy
 (&
NAME
)) \

883 
	`abort
 (); \

885 while (0)

	)

889 #define 
	#gl_recursive_lock_init
(
NAME
) \

892 if (
	`glthread_recursive_lock_init
 (&
NAME
)) \

893 
	`abort
 (); \

895 while (0)

	)

896 #define 
	#gl_recursive_lock_lock
(
NAME
) \

899 if (
	`glthread_recursive_lock_lock
 (&
NAME
)) \

900 
	`abort
 (); \

902 while (0)

	)

903 #define 
	#gl_recursive_lock_unlock
(
NAME
) \

906 if (
	`glthread_recursive_lock_unlock
 (&
NAME
)) \

907 
	`abort
 (); \

909 while (0)

	)

910 #define 
	#gl_recursive_lock_destroy
(
NAME
) \

913 if (
	`glthread_recursive_lock_destroy
 (&
NAME
)) \

914 
	`abort
 (); \

916 while (0)

	)

920 #define 
	#gl_once
(
NAME
, 
INITFUNCTION
) \

923 if (
	`glthread_once
 (&
NAME
, 
INITFUNCTION
)) \

924 
	`abort
 (); \

926 while (0)

	)

	@gnulib-tests/glthread/thread.c

24 #include 
	~<config.h
>

27 #include 
	~"glthread/thread.h
"

29 #include 
	~<stdlib.h
>

30 #include 
	~"glthread/lock.h
"

34 #if 
USE_POSIX_THREADS


36 #include 
	~<pthread.h
>

38 #ifdef 
PTW32_VERSION


40 const 
gl_thread_t
 
	ggl_null_thread
 ;

48 #if 
USE_WIN32_THREADS


50 #include 
	~<process.h
>

56 static 
DWORD
 
	gself_key
 = (DWORD)-1;

60 
	$do_init_self_key
 (void)

62 
self_key
 = 
	`TlsAlloc
 ();

64 if (
self_key
 == (
DWORD
)-1)

65 
	`abort
 ();

66 
	}
}

70 
	$init_self_key
 (void)

72 
	`gl_once_define
(static, 
once
)

73 
	`gl_once
 (
once
, 
do_init_self_key
);

74 
	}
}

78 struct 
	sgl_thread_struct


81 
HANDLE
 volatile 
	mhandle
;

82 
CRITICAL_SECTION
 
	mhandle_lock
;

84 void * volatile 
	mresult
;

86 void * (*
	mfunc
) (void *);

87 void *
	marg
;

91 static 
inline
 
HANDLE


92 
	$get_current_thread_handle
 (void)

94 
HANDLE
 
this_handle
;

98 if (!
	`DuplicateHandle
 (
	`GetCurrentProcess
 (), 
	`GetCurrentThread
 (),

99 
	`GetCurrentProcess
 (), &
this_handle
,

100 0, 
FALSE
, 
DUPLICATE_SAME_ACCESS
))

101 
	`abort
 ();

102 return 
this_handle
;

103 
	}
}

105 
gl_thread_t


106 
	$gl_thread_self_func
 (void)

108 
gl_thread_t
 
thread
;

110 if (
self_key
 == (
DWORD
)-1)

111 
	`init_self_key
 ();

112 
thread
 = 
	`TlsGetValue
 (
self_key
);

113 if (
thread
 == 
NULL
)

119 
thread
 =

120 (struct 
gl_thread_struct
 *)

121 
	`malloc
 (sizeof (struct 
gl_thread_struct
));

122 if (
thread
 != 
NULL
)

126 
	`Sleep
 (1);

129 
thread
->
handle
 = 
	`get_current_thread_handle
 ();

130 
	`InitializeCriticalSection
 (&
thread
->
handle_lock
);

131 
thread
->
result
 = 
NULL
;

132 
	`TlsSetValue
 (
self_key
, 
thread
);

134 return 
thread
;

135 
	}
}

139 static unsigned int 
WINAPI


140 
	$wrapper_func
 (void *
varg
)

142 struct 
gl_thread_struct
 *
thread
 = (struct gl_thread_struct *)
varg
;

144 
	`EnterCriticalSection
 (&
thread
->
handle_lock
);

147 if (
thread
->
handle
 == 
NULL
)

148 
thread
->
handle
 = 
	`get_current_thread_handle
 ();

149 
	`LeaveCriticalSection
 (&
thread
->
handle_lock
);

151 if (
self_key
 == (
DWORD
)-1)

152 
	`init_self_key
 ();

153 
	`TlsSetValue
 (
self_key
, 
thread
);

157 
thread
->
result
 = thread->
	`func
 (thread->
arg
);

159 
	}
}

162 
glthread_create_func
 (
gl_thread_t
 *
threadp
, void * (*
func
) (void *), void *
arg
)

164 struct 
gl_thread_struct
 *
	gthread
 =

165 (struct 
gl_thread_struct
 *) 
malloc
 (sizeof (struct gl_thread_struct));

166 if (
	gthread
 == 
NULL
)

167 return 
ENOMEM
;

168 
	gthread
->
	ghandle
 = 
NULL
;

169 
InitializeCriticalSection
 (&
thread
->
handle_lock
);

170 
	gthread
->
	gresult
 = 
NULL
;

171 
	gthread
->
	gfunc
 = 
func
;

172 
	gthread
->
	garg
 = 
arg
;

175 unsigned int 
	gthread_id
;

176 
HANDLE
 
	gthread_handle
;

178 
	gthread_handle
 = (
HANDLE
)

179 
_beginthreadex
 (
NULL
, 100000, 
wrapper_func
, 
thread
, 0, &
thread_id
);

181 if (
	gthread_handle
 == 
NULL
)

183 
DeleteCriticalSection
 (&
thread
->
handle_lock
);

184 
free
 (
thread
);

185 return 
	gEAGAIN
;

188 
EnterCriticalSection
 (&
thread
->
handle_lock
);

189 if (
	gthread
->
	ghandle
 == 
NULL
)

190 
thread
->
handle
 = 
thread_handle
;

193 
CloseHandle
 (
thread_handle
);

194 
LeaveCriticalSection
 (&
thread
->
handle_lock
);

196 *
	gthreadp
 = 
thread
;

202 
	$glthread_join_func
 (
gl_thread_t
 
thread
, void **
retvalp
)

204 if (
thread
 == 
NULL
)

205 return 
EINVAL
;

207 if (
thread
 == 
	`gl_thread_self
 ())

208 return 
EDEADLK
;

210 if (
	`WaitForSingleObject
 (
thread
->
handle
, 
INFINITE
) == 
WAIT_FAILED
)

211 return 
EINVAL
;

213 if (
retvalp
 != 
NULL
)

214 *
retvalp
 = 
thread
->
result
;

216 
	`DeleteCriticalSection
 (&
thread
->
handle_lock
);

217 
	`CloseHandle
 (
thread
->
handle
);

218 
	`free
 (
thread
);

221 
	}
}

224 
	$gl_thread_exit_func
 (void *
retval
)

226 
gl_thread_t
 
thread
 = 
	`gl_thread_self
 ();

227 
thread
->
result
 = 
retval
;

228 
	`_endthreadex
 (0);

229 
	`abort
 ();

230 
	}
}

	@gnulib-tests/glthread/thread.h

74 #ifndef 
_GLTHREAD_THREAD_H


75 #define 
	#_GLTHREAD_THREAD_H


	)

77 #include 
	~<errno.h
>

78 #include 
	~<stdlib.h
>

82 #if 
USE_POSIX_THREADS


86 #include 
	~<pthread.h
>

88 #ifdef 
__cplusplus


92 #if 
PTHREAD_IN_USE_DETECTION_HARD


95 #define 
	#pthread_in_use
() \

96 
	`glthread_in_use
 ()

	)

97 extern int 
glthread_in_use
 (void);

101 #if 
USE_POSIX_THREADS_WEAK


120 #pragma 
weak
 
pthread_create


121 #pragma 
weak
 
pthread_sigmask


122 #pragma 
weak
 
pthread_join


123 #ifndef 
pthread_self


124 #pragma 
weak
 
pthread_self


126 #pragma 
weak
 
pthread_exit


127 #if 
HAVE_PTHREAD_ATFORK


128 #pragma 
weak
 
pthread_atfork


131 #if !
PTHREAD_IN_USE_DETECTION_HARD


132 #pragma 
weak
 
pthread_cancel


133 #define 
	#pthread_in_use
() (
pthread_cancel
 != 
NULL
)

	)

138 #if !
PTHREAD_IN_USE_DETECTION_HARD


139 #define 
	#pthread_in_use
() 1

	)

149 typedef 
pthread_t
 
	tgl_thread_t
;

150 #define 
	#glthread_create
(
THREADP
, 
FUNC
, 
ARG
) \

151 (
	`pthread_in_use
 () ? 
	`pthread_create
 (
THREADP
, 
NULL
, 
FUNC
, 
ARG
) : 
ENOSYS
)

	)

152 #define 
	#glthread_sigmask
(
HOW
, 
SET
, 
OSET
) \

153 (
	`pthread_in_use
 () ? 
	`pthread_sigmask
 (
HOW
, 
SET
, 
OSET
) : 0)

	)

154 #define 
	#glthread_join
(
THREAD
, 
RETVALP
) \

155 (
	`pthread_in_use
 () ? 
	`pthread_join
 (
THREAD
, 
RETVALP
) : 0)

	)

156 #ifdef 
PTW32_VERSION


159 #define 
	#gl_thread_self
() \

160 (
	`pthread_in_use
 () ? 
	`pthread_self
 () : 
gl_null_thread
)

	)

161 #define 
	#gl_thread_self_pointer
() \

162 (
	`pthread_in_use
 () ? 
	`pthread_self
 ().
p
 : 
NULL
)

	)

163 extern const 
gl_thread_t
 
gl_null_thread
;

165 #define 
	#gl_thread_self
() \

166 (
	`pthread_in_use
 () ? 
	`pthread_self
 () : (
pthread_t
) 
NULL
)

	)

167 #define 
	#gl_thread_self_pointer
() \

168 (
	`pthread_in_use
 () ? (void *) 
	`pthread_self
 () : 
NULL
)

	)

170 #define 
	#gl_thread_exit
(
RETVAL
) \

171 (
	`pthread_in_use
 () ? 
	`pthread_exit
 (
RETVAL
) : 0)

	)

173 #if 
HAVE_PTHREAD_ATFORK


174 #define 
	#glthread_atfork
(
PREPARE_FUNC
, 
PARENT_FUNC
, 
CHILD_FUNC
) \

175 (
	`pthread_in_use
 () ? 
	`pthread_atfork
 (
PREPARE_FUNC
, 
PARENT_FUNC
, 
CHILD_FUNC
) : 0)

	)

177 #define 
	#glthread_atfork
(
PREPARE_FUNC
, 
PARENT_FUNC
, 
CHILD_FUNC
) 0

	)

180 #ifdef 
__cplusplus


188 #if 
USE_PTH_THREADS


192 #include 
	~<pth.h
>

194 #ifdef 
__cplusplus


198 #if 
USE_PTH_THREADS_WEAK


202 #pragma 
weak
 
pth_spawn


203 #pragma 
weak
 
pth_sigmask


204 #pragma 
weak
 
pth_join


205 #pragma 
weak
 
pth_self


206 #pragma 
weak
 
pth_exit


208 #pragma 
weak
 
pth_cancel


209 #define 
	#pth_in_use
() (
pth_cancel
 != 
NULL
)

	)

213 #define 
	#pth_in_use
() 1

	)

218 typedef 
pth_t
 
	tgl_thread_t
;

219 #define 
	#glthread_create
(
THREADP
, 
FUNC
, 
ARG
) \

220 (
	`pth_in_use
 () ? ((*(
THREADP
) = 
	`pth_spawn
 (
NULL
, 
FUNC
, 
ARG
)) ? 0 : 
errno
) : 0)

	)

221 #define 
	#glthread_sigmask
(
HOW
, 
SET
, 
OSET
) \

222 (
	`pth_in_use
 () && !
	`pth_sigmask
 (
HOW
, 
SET
, 
OSET
) ? 
errno
 : 0)

	)

223 #define 
	#glthread_join
(
THREAD
, 
RETVALP
) \

224 (
	`pth_in_use
 () && !
	`pth_join
 (
THREAD
, 
RETVALP
) ? 
errno
 : 0)

	)

225 #define 
	#gl_thread_self
() \

226 (
	`pth_in_use
 () ? (void *) 
	`pth_self
 () : 
NULL
)

	)

227 #define 
	#gl_thread_self_pointer
() \

228 
	`gl_thread_self
 ()

	)

229 #define 
	#gl_thread_exit
(
RETVAL
) \

230 (
	`pth_in_use
 () ? 
	`pth_exit
 (
RETVAL
) : 0)

	)

231 #define 
	#glthread_atfork
(
PREPARE_FUNC
, 
PARENT_FUNC
, 
CHILD_FUNC
) 0

	)

233 #ifdef 
__cplusplus


241 #if 
USE_SOLARIS_THREADS


245 #include 
	~<thread.h
>

246 #include 
	~<synch.h
>

248 #ifdef 
__cplusplus


252 #if 
USE_SOLARIS_THREADS_WEAK


256 #pragma 
weak
 
thr_create


257 #pragma 
weak
 
thr_join


258 #pragma 
weak
 
thr_self


259 #pragma 
weak
 
thr_exit


261 #pragma 
weak
 
thr_suspend


262 #define 
	#thread_in_use
() (
thr_suspend
 != 
NULL
)

	)

266 #define 
	#thread_in_use
() 1

	)

272 typedef 
thread_t
 
	tgl_thread_t
;

273 #define 
	#glthread_create
(
THREADP
, 
FUNC
, 
ARG
) \

274 (
	`thread_in_use
 () ? 
	`thr_create
 (
NULL
, 0, 
FUNC
, 
ARG
, 0, 
THREADP
) : 0)

	)

275 #define 
	#glthread_sigmask
(
HOW
, 
SET
, 
OSET
) \

276 (
	`thread_in_use
 () ? 
	`sigprocmask
 (
HOW
, 
SET
, 
OSET
) : 0)

	)

277 #define 
	#glthread_join
(
THREAD
, 
RETVALP
) \

278 (
	`thread_in_use
 () ? 
	`thr_join
 (
THREAD
, 
NULL
, 
RETVALP
) : 0)

	)

279 #define 
	#gl_thread_self
() \

280 (
	`thread_in_use
 () ? (void *) 
	`thr_self
 () : 
NULL
)

	)

281 #define 
	#gl_thread_self_pointer
() \

282 
	`gl_thread_self
 ()

	)

283 #define 
	#gl_thread_exit
(
RETVAL
) \

284 (
	`thread_in_use
 () ? 
	`thr_exit
 (
RETVAL
) : 0)

	)

285 #define 
	#glthread_atfork
(
PREPARE_FUNC
, 
PARENT_FUNC
, 
CHILD_FUNC
) 0

	)

287 #ifdef 
__cplusplus


295 #if 
USE_WIN32_THREADS


297 #define 
	#WIN32_LEAN_AND_MEAN


	)

298 #include 
	~<windows.h
>

300 #ifdef 
__cplusplus


315 typedef struct 
gl_thread_struct
 *
	tgl_thread_t
;

316 #define 
	#glthread_create
(
THREADP
, 
FUNC
, 
ARG
) \

317 
	`glthread_create_func
 (
THREADP
, 
FUNC
, 
ARG
)

	)

318 #define 
	#glthread_sigmask
(
HOW
, 
SET
, 
OSET
) \

319  0

	)

320 #define 
	#glthread_join
(
THREAD
, 
RETVALP
) \

321 
	`glthread_join_func
 (
THREAD
, 
RETVALP
)

	)

322 #define 
	#gl_thread_self
() \

323 
	`gl_thread_self_func
 ()

	)

324 #define 
	#gl_thread_self_pointer
() \

325 
	`gl_thread_self
 ()

	)

326 #define 
	#gl_thread_exit
(
RETVAL
) \

327 
	`gl_thread_exit_func
 (
RETVAL
)

	)

328 #define 
	#glthread_atfork
(
PREPARE_FUNC
, 
PARENT_FUNC
, 
CHILD_FUNC
) 0

	)

329 extern int 
glthread_create_func
 (
gl_thread_t
 *
threadp
, void * (*
func
) (void *), void *
arg
);

330 extern int 
glthread_join_func
 (
gl_thread_t
 
thread
, void **
retvalp
);

331 extern 
gl_thread_t
 
gl_thread_self_func
 (void);

332 extern int 
gl_thread_exit_func
 (void *
retval
);

334 #ifdef 
__cplusplus


342 #if !(
USE_POSIX_THREADS
 || 
USE_PTH_THREADS
 || 
USE_SOLARIS_THREADS
 || 
USE_WIN32_THREADS
)

346 typedef int 
	tgl_thread_t
;

347 #define 
	#glthread_create
(
THREADP
, 
FUNC
, 
ARG
) 
ENOSYS


	)

348 #define 
	#glthread_sigmask
(
HOW
, 
SET
, 
OSET
) 0

	)

349 #define 
	#glthread_join
(
THREAD
, 
RETVALP
) 0

	)

350 #define 
	#gl_thread_self
() 0

	)

351 #define 
	#gl_thread_self_pointer
() \

352 ((void *) 
	`gl_thread_self
 ())

	)

353 #define 
	#gl_thread_exit
(
RETVAL
) 0

	)

354 #define 
	#glthread_atfork
(
PREPARE_FUNC
, 
PARENT_FUNC
, 
CHILD_FUNC
) 0

	)

362 #ifdef 
__cplusplus


366 static 
inline
 
gl_thread_t


367 
gl_thread_create
 (void *(*
func
) (void *
arg
), void *arg)

369 
gl_thread_t
 
thread
;

370 int 
ret
;

372 
ret
 = 
glthread_create
 (&
thread
, 
func
, 
arg
);

373 if (
ret
 != 0)

374 
abort
 ();

375 return 
thread
;

377 #define 
	#gl_thread_sigmask
(
HOW
, 
SET
, 
OSET
) \

380 if (
	`glthread_sigmask
 (
HOW
, 
SET
, 
OSET
)) \

381 
	`abort
 (); \

383 while (0)

	)

384 #define 
	#gl_thread_join
(
THREAD
, 
RETVAL
) \

387 if (
	`glthread_join
 (
THREAD
, 
RETVAL
)) \

388 
	`abort
 (); \

390 while (0)

	)

391 #define 
	#gl_thread_atfork
(
PREPARE
, 
PARENT
, 
CHILD
) \

394 if (
	`glthread_atfork
 (
PREPARE
, 
PARENT
, 
CHILD
)) \

395 
	`abort
 (); \

397 while (0)

	)

399 #ifdef 
__cplusplus


	@gnulib-tests/glthread/threadlib.c

22 #include 
	~<config.h
>

26 #if 
USE_POSIX_THREADS


30 #include 
	~<pthread.h
>

31 #include 
	~<stdlib.h
>

33 #if 
PTHREAD_IN_USE_DETECTION_HARD


37 
	$dummy_thread_func
 (void *
arg
)

39 return 
arg
;

40 
	}
}

43 
	$glthread_in_use
 (void)

45 static int 
tested
;

46 static int 
result
;

48 if (!
tested
)

50 
pthread_t
 
thread
;

52 if (
	`pthread_create
 (&
thread
, 
NULL
, 
dummy_thread_func
, NULL) != 0)

54 
result
 = 0;

58 void *
retval
;

59 if (
	`pthread_join
 (
thread
, &
retval
) != 0)

60 
	`abort
 ();

61 
result
 = 1;

63 
tested
 = 1;

65 return 
result
;

66 
	}
}

76 typedef int 
	tdummy
;

	@gnulib-tests/glthread/yield.h

24 #ifndef 
_GLTHREAD_YIELD_H


25 #define 
	#_GLTHREAD_YIELD_H


	)

27 #include 
	~<errno.h
>

31 #if 
USE_POSIX_THREADS


35 #include 
	~<sched.h
>

37 #ifdef 
__cplusplus


41 #define 
	#gl_thread_yield
() \

42 
	`sched_yield
 ()

	)

44 #ifdef 
__cplusplus


52 #if 
USE_PTH_THREADS


56 #include 
	~<pth.h
>

58 #ifdef 
__cplusplus


62 #define 
	#gl_thread_yield
() \

63 
	`pth_yield
 (
NULL
)

	)

65 #ifdef 
__cplusplus


73 #if 
USE_SOLARIS_THREADS


77 #include 
	~<thread.h
>

79 #ifdef 
__cplusplus


83 #define 
	#gl_thread_yield
() \

84 
	`thr_yield
 ()

	)

86 #ifdef 
__cplusplus


94 #if 
USE_WIN32_THREADS


96 #define 
	#WIN32_LEAN_AND_MEAN


	)

97 #include 
	~<windows.h
>

99 #ifdef 
__cplusplus


103 #define 
	#gl_thread_yield
() \

104 
	`Sleep
 (0)

	)

106 #ifdef 
__cplusplus


114 #if !(
USE_POSIX_THREADS
 || 
USE_PTH_THREADS
 || 
USE_SOLARIS_THREADS
 || 
USE_WIN32_THREADS
)

118 #define 
	#gl_thread_yield
() 0

	)

	@gnulib-tests/hash-pjw.c

20 #include 
	~<config.h
>

22 #include 
	~"hash-pjw.h
"

24 #include 
	~<limits.h
>

26 #define 
	#SIZE_BITS
 (sizeof (
size_t
) * 
CHAR_BIT
)

	)

32 
size_t


33 
	$hash_pjw
 (const void *
x
, 
size_t
 
tablesize
)

35 const char *
s
;

36 
size_t
 
h
 = 0;

38 for (
s
 = 
x
; *s; s++)

39 
h
 = *
s
 + ((h << 9) | (h >> (
SIZE_BITS
 - 9)));

41 return 
h
 % 
tablesize
;

42 
	}
}

	@gnulib-tests/hash-pjw.h

19 #include 
	~<stddef.h
>

25 extern 
size_t
 
hash_pjw
 (void const *
x
, size_t 
tablesize
);

	@gnulib-tests/imaxtostr.c

3 #define 
	#anytostr
 
imaxtostr


	)

4 #define 
	#inttype
 
intmax_t


	)

5 #include 
	~"anytostr.c
"

	@gnulib-tests/inttostr.c

3 #define 
	#anytostr
 
inttostr


	)

4 #define 
	#inttype
 int

	)

5 #include 
	~"anytostr.c
"

	@gnulib-tests/inttostr.h

22 #include 
	~<stdint.h
>

23 #include 
	~<sys/types.h
>

25 #include 
	~"intprops.h
"

27 #ifndef 
__GNUC_PREREQ


28 #if 
defined
 
__GNUC__
 && defined 
__GNUC_MINOR__


29 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) \

30 ((
__GNUC__
 << 16) + 
__GNUC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

32 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) 0

	)

36 #if 
__GNUC_PREREQ
 (3,4)

37 #undef 
__attribute_warn_unused_result__


38 #define 
	#__attribute_warn_unused_result__
 \

39 
	`__attribute__
 ((
__warn_unused_result__
))

	)

41 #define 
	#__attribute_warn_unused_result__


	)

44 char *
	$imaxtostr
 (
intmax_t
, char *) 
__attribute_warn_unused_result__
;

45 char *
	$inttostr
 (int, char *) 
__attribute_warn_unused_result__
;

46 char *
	$offtostr
 (
off_t
, char *) 
__attribute_warn_unused_result__
;

47 char *
	$uinttostr
 (unsigned int, char *) 
__attribute_warn_unused_result__
;

48 char *
	$umaxtostr
 (
uintmax_t
, char *) 
__attribute_warn_unused_result__
;

	@gnulib-tests/itold.c

20 #include 
	~<config.h
>

23 #include 
	~<float.h
>

26 
	$_Qp_itoq
 (long double *
result
, int 
a
)

29 *
result
 = (double) 
a
;

30 
	}
}

	@gnulib-tests/localename.c

23 #include 
	~<config.h
>

26 #ifdef 
IN_LIBINTL


27 #include 
	~"gettextP.h
"

29 #include 
	~"localename.h
"

32 #include 
	~<limits.h
>

33 #include 
	~<stddef.h
>

34 #include 
	~<stdlib.h
>

35 #include 
	~<locale.h
>

36 #include 
	~<string.h
>

38 #if 
HAVE_USELOCALE


40 #if 
defined
 
__APPLE__
 && defined 
__MACH__


41 #include 
	~<xlocale.h
>

43 #include 
	~<langinfo.h
>

44 #if !
defined
 
IN_LIBINTL


45 #include 
	~"glthread/lock.h
"

49 #if 
HAVE_CFLOCALECOPYCURRENT
 || 
HAVE_CFPREFERENCESCOPYAPPVALUE


50 #include 
	~<CoreFoundation/CFString.h
>

51 #if 
HAVE_CFLOCALECOPYCURRENT


52 #include 
	~<CoreFoundation/CFLocale.h
>

53 #elif 
HAVE_CFPREFERENCESCOPYAPPVALUE


54 #include 
	~<CoreFoundation/CFPreferences.h
>

58 #if 
defined
 
_WIN32
 || defined 
__WIN32__


59 #define 
	#WIN32_NATIVE


	)

62 #if 
defined
 
WIN32_NATIVE
 || defined 
__CYGWIN__


63 #define 
	#WIN32_LEAN_AND_MEAN


	)

64 #include 
	~<windows.h
>

199 #ifndef 
LANG_AFRIKAANS


200 #define 
	#LANG_AFRIKAANS
 0x36

	)

202 #ifndef 
LANG_ALBANIAN


203 #define 
	#LANG_ALBANIAN
 0x1c

	)

205 #ifndef 
LANG_ALSATIAN


206 #define 
	#LANG_ALSATIAN
 0x84

	)

208 #ifndef 
LANG_AMHARIC


209 #define 
	#LANG_AMHARIC
 0x5e

	)

211 #ifndef 
LANG_ARABIC


212 #define 
	#LANG_ARABIC
 0x01

	)

214 #ifndef 
LANG_ARMENIAN


215 #define 
	#LANG_ARMENIAN
 0x2b

	)

217 #ifndef 
LANG_ASSAMESE


218 #define 
	#LANG_ASSAMESE
 0x4d

	)

220 #ifndef 
LANG_AZERI


221 #define 
	#LANG_AZERI
 0x2c

	)

223 #ifndef 
LANG_BASHKIR


224 #define 
	#LANG_BASHKIR
 0x6d

	)

226 #ifndef 
LANG_BASQUE


227 #define 
	#LANG_BASQUE
 0x2d

	)

229 #ifndef 
LANG_BELARUSIAN


230 #define 
	#LANG_BELARUSIAN
 0x23

	)

232 #ifndef 
LANG_BENGALI


233 #define 
	#LANG_BENGALI
 0x45

	)

235 #ifndef 
LANG_BRETON


236 #define 
	#LANG_BRETON
 0x7e

	)

238 #ifndef 
LANG_BURMESE


239 #define 
	#LANG_BURMESE
 0x55

	)

241 #ifndef 
LANG_CAMBODIAN


242 #define 
	#LANG_CAMBODIAN
 0x53

	)

244 #ifndef 
LANG_CATALAN


245 #define 
	#LANG_CATALAN
 0x03

	)

247 #ifndef 
LANG_CHEROKEE


248 #define 
	#LANG_CHEROKEE
 0x5c

	)

250 #ifndef 
LANG_CORSICAN


251 #define 
	#LANG_CORSICAN
 0x83

	)

253 #ifndef 
LANG_DARI


254 #define 
	#LANG_DARI
 0x8c

	)

256 #ifndef 
LANG_DIVEHI


257 #define 
	#LANG_DIVEHI
 0x65

	)

259 #ifndef 
LANG_EDO


260 #define 
	#LANG_EDO
 0x66

	)

262 #ifndef 
LANG_ESTONIAN


263 #define 
	#LANG_ESTONIAN
 0x25

	)

265 #ifndef 
LANG_FAEROESE


266 #define 
	#LANG_FAEROESE
 0x38

	)

268 #ifndef 
LANG_FARSI


269 #define 
	#LANG_FARSI
 0x29

	)

271 #ifndef 
LANG_FRISIAN


272 #define 
	#LANG_FRISIAN
 0x62

	)

274 #ifndef 
LANG_FULFULDE


275 #define 
	#LANG_FULFULDE
 0x67

	)

277 #ifndef 
LANG_GAELIC


278 #define 
	#LANG_GAELIC
 0x3c

	)

280 #ifndef 
LANG_GALICIAN


281 #define 
	#LANG_GALICIAN
 0x56

	)

283 #ifndef 
LANG_GEORGIAN


284 #define 
	#LANG_GEORGIAN
 0x37

	)

286 #ifndef 
LANG_GREENLANDIC


287 #define 
	#LANG_GREENLANDIC
 0x6f

	)

289 #ifndef 
LANG_GUARANI


290 #define 
	#LANG_GUARANI
 0x74

	)

292 #ifndef 
LANG_GUJARATI


293 #define 
	#LANG_GUJARATI
 0x47

	)

295 #ifndef 
LANG_HAUSA


296 #define 
	#LANG_HAUSA
 0x68

	)

298 #ifndef 
LANG_HAWAIIAN


299 #define 
	#LANG_HAWAIIAN
 0x75

	)

301 #ifndef 
LANG_HEBREW


302 #define 
	#LANG_HEBREW
 0x0d

	)

304 #ifndef 
LANG_HINDI


305 #define 
	#LANG_HINDI
 0x39

	)

307 #ifndef 
LANG_IBIBIO


308 #define 
	#LANG_IBIBIO
 0x69

	)

310 #ifndef 
LANG_IGBO


311 #define 
	#LANG_IGBO
 0x70

	)

313 #ifndef 
LANG_INDONESIAN


314 #define 
	#LANG_INDONESIAN
 0x21

	)

316 #ifndef 
LANG_INUKTITUT


317 #define 
	#LANG_INUKTITUT
 0x5d

	)

319 #ifndef 
LANG_KANNADA


320 #define 
	#LANG_KANNADA
 0x4b

	)

322 #ifndef 
LANG_KANURI


323 #define 
	#LANG_KANURI
 0x71

	)

325 #ifndef 
LANG_KASHMIRI


326 #define 
	#LANG_KASHMIRI
 0x60

	)

328 #ifndef 
LANG_KAZAK


329 #define 
	#LANG_KAZAK
 0x3f

	)

331 #ifndef 
LANG_KICHE


332 #define 
	#LANG_KICHE
 0x86

	)

334 #ifndef 
LANG_KINYARWANDA


335 #define 
	#LANG_KINYARWANDA
 0x87

	)

337 #ifndef 
LANG_KONKANI


338 #define 
	#LANG_KONKANI
 0x57

	)

340 #ifndef 
LANG_KYRGYZ


341 #define 
	#LANG_KYRGYZ
 0x40

	)

343 #ifndef 
LANG_LAO


344 #define 
	#LANG_LAO
 0x54

	)

346 #ifndef 
LANG_LATIN


347 #define 
	#LANG_LATIN
 0x76

	)

349 #ifndef 
LANG_LATVIAN


350 #define 
	#LANG_LATVIAN
 0x26

	)

352 #ifndef 
LANG_LITHUANIAN


353 #define 
	#LANG_LITHUANIAN
 0x27

	)

355 #ifndef 
LANG_LUXEMBOURGISH


356 #define 
	#LANG_LUXEMBOURGISH
 0x6e

	)

358 #ifndef 
LANG_MACEDONIAN


359 #define 
	#LANG_MACEDONIAN
 0x2f

	)

361 #ifndef 
LANG_MALAY


362 #define 
	#LANG_MALAY
 0x3e

	)

364 #ifndef 
LANG_MALAYALAM


365 #define 
	#LANG_MALAYALAM
 0x4c

	)

367 #ifndef 
LANG_MALTESE


368 #define 
	#LANG_MALTESE
 0x3a

	)

370 #ifndef 
LANG_MANIPURI


371 #define 
	#LANG_MANIPURI
 0x58

	)

373 #ifndef 
LANG_MAORI


374 #define 
	#LANG_MAORI
 0x81

	)

376 #ifndef 
LANG_MAPUDUNGUN


377 #define 
	#LANG_MAPUDUNGUN
 0x7a

	)

379 #ifndef 
LANG_MARATHI


380 #define 
	#LANG_MARATHI
 0x4e

	)

382 #ifndef 
LANG_MOHAWK


383 #define 
	#LANG_MOHAWK
 0x7c

	)

385 #ifndef 
LANG_MONGOLIAN


386 #define 
	#LANG_MONGOLIAN
 0x50

	)

388 #ifndef 
LANG_NEPALI


389 #define 
	#LANG_NEPALI
 0x61

	)

391 #ifndef 
LANG_OCCITAN


392 #define 
	#LANG_OCCITAN
 0x82

	)

394 #ifndef 
LANG_ORIYA


395 #define 
	#LANG_ORIYA
 0x48

	)

397 #ifndef 
LANG_OROMO


398 #define 
	#LANG_OROMO
 0x72

	)

400 #ifndef 
LANG_PAPIAMENTU


401 #define 
	#LANG_PAPIAMENTU
 0x79

	)

403 #ifndef 
LANG_PASHTO


404 #define 
	#LANG_PASHTO
 0x63

	)

406 #ifndef 
LANG_PUNJABI


407 #define 
	#LANG_PUNJABI
 0x46

	)

409 #ifndef 
LANG_QUECHUA


410 #define 
	#LANG_QUECHUA
 0x6b

	)

412 #ifndef 
LANG_ROMANSH


413 #define 
	#LANG_ROMANSH
 0x17

	)

415 #ifndef 
LANG_SAMI


416 #define 
	#LANG_SAMI
 0x3b

	)

418 #ifndef 
LANG_SANSKRIT


419 #define 
	#LANG_SANSKRIT
 0x4f

	)

421 #ifndef 
LANG_SCOTTISH_GAELIC


422 #define 
	#LANG_SCOTTISH_GAELIC
 0x91

	)

424 #ifndef 
LANG_SERBIAN


425 #define 
	#LANG_SERBIAN
 0x1a

	)

427 #ifndef 
LANG_SINDHI


428 #define 
	#LANG_SINDHI
 0x59

	)

430 #ifndef 
LANG_SINHALESE


431 #define 
	#LANG_SINHALESE
 0x5b

	)

433 #ifndef 
LANG_SLOVAK


434 #define 
	#LANG_SLOVAK
 0x1b

	)

436 #ifndef 
LANG_SOMALI


437 #define 
	#LANG_SOMALI
 0x77

	)

439 #ifndef 
LANG_SORBIAN


440 #define 
	#LANG_SORBIAN
 0x2e

	)

442 #ifndef 
LANG_SOTHO


443 #define 
	#LANG_SOTHO
 0x6c

	)

445 #ifndef 
LANG_SUTU


446 #define 
	#LANG_SUTU
 0x30

	)

448 #ifndef 
LANG_SWAHILI


449 #define 
	#LANG_SWAHILI
 0x41

	)

451 #ifndef 
LANG_SYRIAC


452 #define 
	#LANG_SYRIAC
 0x5a

	)

454 #ifndef 
LANG_TAGALOG


455 #define 
	#LANG_TAGALOG
 0x64

	)

457 #ifndef 
LANG_TAJIK


458 #define 
	#LANG_TAJIK
 0x28

	)

460 #ifndef 
LANG_TAMAZIGHT


461 #define 
	#LANG_TAMAZIGHT
 0x5f

	)

463 #ifndef 
LANG_TAMIL


464 #define 
	#LANG_TAMIL
 0x49

	)

466 #ifndef 
LANG_TATAR


467 #define 
	#LANG_TATAR
 0x44

	)

469 #ifndef 
LANG_TELUGU


470 #define 
	#LANG_TELUGU
 0x4a

	)

472 #ifndef 
LANG_THAI


473 #define 
	#LANG_THAI
 0x1e

	)

475 #ifndef 
LANG_TIBETAN


476 #define 
	#LANG_TIBETAN
 0x51

	)

478 #ifndef 
LANG_TIGRINYA


479 #define 
	#LANG_TIGRINYA
 0x73

	)

481 #ifndef 
LANG_TSONGA


482 #define 
	#LANG_TSONGA
 0x31

	)

484 #ifndef 
LANG_TSWANA


485 #define 
	#LANG_TSWANA
 0x32

	)

487 #ifndef 
LANG_TURKMEN


488 #define 
	#LANG_TURKMEN
 0x42

	)

490 #ifndef 
LANG_UIGHUR


491 #define 
	#LANG_UIGHUR
 0x80

	)

493 #ifndef 
LANG_UKRAINIAN


494 #define 
	#LANG_UKRAINIAN
 0x22

	)

496 #ifndef 
LANG_URDU


497 #define 
	#LANG_URDU
 0x20

	)

499 #ifndef 
LANG_UZBEK


500 #define 
	#LANG_UZBEK
 0x43

	)

502 #ifndef 
LANG_VENDA


503 #define 
	#LANG_VENDA
 0x33

	)

505 #ifndef 
LANG_VIETNAMESE


506 #define 
	#LANG_VIETNAMESE
 0x2a

	)

508 #ifndef 
LANG_WELSH


509 #define 
	#LANG_WELSH
 0x52

	)

511 #ifndef 
LANG_WOLOF


512 #define 
	#LANG_WOLOF
 0x88

	)

514 #ifndef 
LANG_XHOSA


515 #define 
	#LANG_XHOSA
 0x34

	)

517 #ifndef 
LANG_YAKUT


518 #define 
	#LANG_YAKUT
 0x85

	)

520 #ifndef 
LANG_YI


521 #define 
	#LANG_YI
 0x78

	)

523 #ifndef 
LANG_YIDDISH


524 #define 
	#LANG_YIDDISH
 0x3d

	)

526 #ifndef 
LANG_YORUBA


527 #define 
	#LANG_YORUBA
 0x6a

	)

529 #ifndef 
LANG_ZULU


530 #define 
	#LANG_ZULU
 0x35

	)

532 #ifndef 
SUBLANG_AFRIKAANS_SOUTH_AFRICA


533 #define 
	#SUBLANG_AFRIKAANS_SOUTH_AFRICA
 0x01

	)

535 #ifndef 
SUBLANG_ALBANIAN_ALBANIA


536 #define 
	#SUBLANG_ALBANIAN_ALBANIA
 0x01

	)

538 #ifndef 
SUBLANG_ALSATIAN_FRANCE


539 #define 
	#SUBLANG_ALSATIAN_FRANCE
 0x01

	)

541 #ifndef 
SUBLANG_AMHARIC_ETHIOPIA


542 #define 
	#SUBLANG_AMHARIC_ETHIOPIA
 0x01

	)

544 #ifndef 
SUBLANG_ARABIC_SAUDI_ARABIA


545 #define 
	#SUBLANG_ARABIC_SAUDI_ARABIA
 0x01

	)

547 #ifndef 
SUBLANG_ARABIC_IRAQ


548 #define 
	#SUBLANG_ARABIC_IRAQ
 0x02

	)

550 #ifndef 
SUBLANG_ARABIC_EGYPT


551 #define 
	#SUBLANG_ARABIC_EGYPT
 0x03

	)

553 #ifndef 
SUBLANG_ARABIC_LIBYA


554 #define 
	#SUBLANG_ARABIC_LIBYA
 0x04

	)

556 #ifndef 
SUBLANG_ARABIC_ALGERIA


557 #define 
	#SUBLANG_ARABIC_ALGERIA
 0x05

	)

559 #ifndef 
SUBLANG_ARABIC_MOROCCO


560 #define 
	#SUBLANG_ARABIC_MOROCCO
 0x06

	)

562 #ifndef 
SUBLANG_ARABIC_TUNISIA


563 #define 
	#SUBLANG_ARABIC_TUNISIA
 0x07

	)

565 #ifndef 
SUBLANG_ARABIC_OMAN


566 #define 
	#SUBLANG_ARABIC_OMAN
 0x08

	)

568 #ifndef 
SUBLANG_ARABIC_YEMEN


569 #define 
	#SUBLANG_ARABIC_YEMEN
 0x09

	)

571 #ifndef 
SUBLANG_ARABIC_SYRIA


572 #define 
	#SUBLANG_ARABIC_SYRIA
 0x0a

	)

574 #ifndef 
SUBLANG_ARABIC_JORDAN


575 #define 
	#SUBLANG_ARABIC_JORDAN
 0x0b

	)

577 #ifndef 
SUBLANG_ARABIC_LEBANON


578 #define 
	#SUBLANG_ARABIC_LEBANON
 0x0c

	)

580 #ifndef 
SUBLANG_ARABIC_KUWAIT


581 #define 
	#SUBLANG_ARABIC_KUWAIT
 0x0d

	)

583 #ifndef 
SUBLANG_ARABIC_UAE


584 #define 
	#SUBLANG_ARABIC_UAE
 0x0e

	)

586 #ifndef 
SUBLANG_ARABIC_BAHRAIN


587 #define 
	#SUBLANG_ARABIC_BAHRAIN
 0x0f

	)

589 #ifndef 
SUBLANG_ARABIC_QATAR


590 #define 
	#SUBLANG_ARABIC_QATAR
 0x10

	)

592 #ifndef 
SUBLANG_ARMENIAN_ARMENIA


593 #define 
	#SUBLANG_ARMENIAN_ARMENIA
 0x01

	)

595 #ifndef 
SUBLANG_ASSAMESE_INDIA


596 #define 
	#SUBLANG_ASSAMESE_INDIA
 0x01

	)

598 #ifndef 
SUBLANG_AZERI_LATIN


599 #define 
	#SUBLANG_AZERI_LATIN
 0x01

	)

601 #ifndef 
SUBLANG_AZERI_CYRILLIC


602 #define 
	#SUBLANG_AZERI_CYRILLIC
 0x02

	)

604 #ifndef 
SUBLANG_BASHKIR_RUSSIA


605 #define 
	#SUBLANG_BASHKIR_RUSSIA
 0x01

	)

607 #ifndef 
SUBLANG_BASQUE_BASQUE


608 #define 
	#SUBLANG_BASQUE_BASQUE
 0x01

	)

610 #ifndef 
SUBLANG_BELARUSIAN_BELARUS


611 #define 
	#SUBLANG_BELARUSIAN_BELARUS
 0x01

	)

613 #ifndef 
SUBLANG_BENGALI_INDIA


614 #define 
	#SUBLANG_BENGALI_INDIA
 0x01

	)

616 #ifndef 
SUBLANG_BENGALI_BANGLADESH


617 #define 
	#SUBLANG_BENGALI_BANGLADESH
 0x02

	)

619 #ifndef 
SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN


620 #define 
	#SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN
 0x05

	)

622 #ifndef 
SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC


623 #define 
	#SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC
 0x08

	)

625 #ifndef 
SUBLANG_BRETON_FRANCE


626 #define 
	#SUBLANG_BRETON_FRANCE
 0x01

	)

628 #ifndef 
SUBLANG_BULGARIAN_BULGARIA


629 #define 
	#SUBLANG_BULGARIAN_BULGARIA
 0x01

	)

631 #ifndef 
SUBLANG_CAMBODIAN_CAMBODIA


632 #define 
	#SUBLANG_CAMBODIAN_CAMBODIA
 0x01

	)

634 #ifndef 
SUBLANG_CATALAN_SPAIN


635 #define 
	#SUBLANG_CATALAN_SPAIN
 0x01

	)

637 #ifndef 
SUBLANG_CORSICAN_FRANCE


638 #define 
	#SUBLANG_CORSICAN_FRANCE
 0x01

	)

640 #ifndef 
SUBLANG_CROATIAN_CROATIA


641 #define 
	#SUBLANG_CROATIAN_CROATIA
 0x01

	)

643 #ifndef 
SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN


644 #define 
	#SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN
 0x04

	)

646 #ifndef 
SUBLANG_CHINESE_MACAU


647 #define 
	#SUBLANG_CHINESE_MACAU
 0x05

	)

649 #ifndef 
SUBLANG_CZECH_CZECH_REPUBLIC


650 #define 
	#SUBLANG_CZECH_CZECH_REPUBLIC
 0x01

	)

652 #ifndef 
SUBLANG_DANISH_DENMARK


653 #define 
	#SUBLANG_DANISH_DENMARK
 0x01

	)

655 #ifndef 
SUBLANG_DARI_AFGHANISTAN


656 #define 
	#SUBLANG_DARI_AFGHANISTAN
 0x01

	)

658 #ifndef 
SUBLANG_DIVEHI_MALDIVES


659 #define 
	#SUBLANG_DIVEHI_MALDIVES
 0x01

	)

661 #ifndef 
SUBLANG_DUTCH_SURINAM


662 #define 
	#SUBLANG_DUTCH_SURINAM
 0x03

	)

664 #ifndef 
SUBLANG_ENGLISH_SOUTH_AFRICA


665 #define 
	#SUBLANG_ENGLISH_SOUTH_AFRICA
 0x07

	)

667 #ifndef 
SUBLANG_ENGLISH_JAMAICA


668 #define 
	#SUBLANG_ENGLISH_JAMAICA
 0x08

	)

670 #ifndef 
SUBLANG_ENGLISH_CARIBBEAN


671 #define 
	#SUBLANG_ENGLISH_CARIBBEAN
 0x09

	)

673 #ifndef 
SUBLANG_ENGLISH_BELIZE


674 #define 
	#SUBLANG_ENGLISH_BELIZE
 0x0a

	)

676 #ifndef 
SUBLANG_ENGLISH_TRINIDAD


677 #define 
	#SUBLANG_ENGLISH_TRINIDAD
 0x0b

	)

679 #ifndef 
SUBLANG_ENGLISH_ZIMBABWE


680 #define 
	#SUBLANG_ENGLISH_ZIMBABWE
 0x0c

	)

682 #ifndef 
SUBLANG_ENGLISH_PHILIPPINES


683 #define 
	#SUBLANG_ENGLISH_PHILIPPINES
 0x0d

	)

685 #ifndef 
SUBLANG_ENGLISH_INDONESIA


686 #define 
	#SUBLANG_ENGLISH_INDONESIA
 0x0e

	)

688 #ifndef 
SUBLANG_ENGLISH_HONGKONG


689 #define 
	#SUBLANG_ENGLISH_HONGKONG
 0x0f

	)

691 #ifndef 
SUBLANG_ENGLISH_INDIA


692 #define 
	#SUBLANG_ENGLISH_INDIA
 0x10

	)

694 #ifndef 
SUBLANG_ENGLISH_MALAYSIA


695 #define 
	#SUBLANG_ENGLISH_MALAYSIA
 0x11

	)

697 #ifndef 
SUBLANG_ENGLISH_SINGAPORE


698 #define 
	#SUBLANG_ENGLISH_SINGAPORE
 0x12

	)

700 #ifndef 
SUBLANG_ESTONIAN_ESTONIA


701 #define 
	#SUBLANG_ESTONIAN_ESTONIA
 0x01

	)

703 #ifndef 
SUBLANG_FAEROESE_FAROE_ISLANDS


704 #define 
	#SUBLANG_FAEROESE_FAROE_ISLANDS
 0x01

	)

706 #ifndef 
SUBLANG_FARSI_IRAN


707 #define 
	#SUBLANG_FARSI_IRAN
 0x01

	)

709 #ifndef 
SUBLANG_FINNISH_FINLAND


710 #define 
	#SUBLANG_FINNISH_FINLAND
 0x01

	)

712 #ifndef 
SUBLANG_FRENCH_LUXEMBOURG


713 #define 
	#SUBLANG_FRENCH_LUXEMBOURG
 0x05

	)

715 #ifndef 
SUBLANG_FRENCH_MONACO


716 #define 
	#SUBLANG_FRENCH_MONACO
 0x06

	)

718 #ifndef 
SUBLANG_FRENCH_WESTINDIES


719 #define 
	#SUBLANG_FRENCH_WESTINDIES
 0x07

	)

721 #ifndef 
SUBLANG_FRENCH_REUNION


722 #define 
	#SUBLANG_FRENCH_REUNION
 0x08

	)

724 #ifndef 
SUBLANG_FRENCH_CONGO


725 #define 
	#SUBLANG_FRENCH_CONGO
 0x09

	)

727 #ifndef 
SUBLANG_FRENCH_SENEGAL


728 #define 
	#SUBLANG_FRENCH_SENEGAL
 0x0a

	)

730 #ifndef 
SUBLANG_FRENCH_CAMEROON


731 #define 
	#SUBLANG_FRENCH_CAMEROON
 0x0b

	)

733 #ifndef 
SUBLANG_FRENCH_COTEDIVOIRE


734 #define 
	#SUBLANG_FRENCH_COTEDIVOIRE
 0x0c

	)

736 #ifndef 
SUBLANG_FRENCH_MALI


737 #define 
	#SUBLANG_FRENCH_MALI
 0x0d

	)

739 #ifndef 
SUBLANG_FRENCH_MOROCCO


740 #define 
	#SUBLANG_FRENCH_MOROCCO
 0x0e

	)

742 #ifndef 
SUBLANG_FRENCH_HAITI


743 #define 
	#SUBLANG_FRENCH_HAITI
 0x0f

	)

745 #ifndef 
SUBLANG_FRISIAN_NETHERLANDS


746 #define 
	#SUBLANG_FRISIAN_NETHERLANDS
 0x01

	)

748 #ifndef 
SUBLANG_GALICIAN_SPAIN


749 #define 
	#SUBLANG_GALICIAN_SPAIN
 0x01

	)

751 #ifndef 
SUBLANG_GEORGIAN_GEORGIA


752 #define 
	#SUBLANG_GEORGIAN_GEORGIA
 0x01

	)

754 #ifndef 
SUBLANG_GERMAN_LUXEMBOURG


755 #define 
	#SUBLANG_GERMAN_LUXEMBOURG
 0x04

	)

757 #ifndef 
SUBLANG_GERMAN_LIECHTENSTEIN


758 #define 
	#SUBLANG_GERMAN_LIECHTENSTEIN
 0x05

	)

760 #ifndef 
SUBLANG_GREEK_GREECE


761 #define 
	#SUBLANG_GREEK_GREECE
 0x01

	)

763 #ifndef 
SUBLANG_GREENLANDIC_GREENLAND


764 #define 
	#SUBLANG_GREENLANDIC_GREENLAND
 0x01

	)

766 #ifndef 
SUBLANG_GUJARATI_INDIA


767 #define 
	#SUBLANG_GUJARATI_INDIA
 0x01

	)

769 #ifndef 
SUBLANG_HAUSA_NIGERIA_LATIN


770 #define 
	#SUBLANG_HAUSA_NIGERIA_LATIN
 0x01

	)

772 #ifndef 
SUBLANG_HEBREW_ISRAEL


773 #define 
	#SUBLANG_HEBREW_ISRAEL
 0x01

	)

775 #ifndef 
SUBLANG_HINDI_INDIA


776 #define 
	#SUBLANG_HINDI_INDIA
 0x01

	)

778 #ifndef 
SUBLANG_HUNGARIAN_HUNGARY


779 #define 
	#SUBLANG_HUNGARIAN_HUNGARY
 0x01

	)

781 #ifndef 
SUBLANG_ICELANDIC_ICELAND


782 #define 
	#SUBLANG_ICELANDIC_ICELAND
 0x01

	)

784 #ifndef 
SUBLANG_IGBO_NIGERIA


785 #define 
	#SUBLANG_IGBO_NIGERIA
 0x01

	)

787 #ifndef 
SUBLANG_INDONESIAN_INDONESIA


788 #define 
	#SUBLANG_INDONESIAN_INDONESIA
 0x01

	)

790 #ifndef 
SUBLANG_INUKTITUT_CANADA


791 #define 
	#SUBLANG_INUKTITUT_CANADA
 0x01

	)

793 #undef 
SUBLANG_INUKTITUT_CANADA_LATIN


794 #define 
	#SUBLANG_INUKTITUT_CANADA_LATIN
 0x02

	)

795 #undef 
SUBLANG_IRISH_IRELAND


796 #define 
	#SUBLANG_IRISH_IRELAND
 0x02

	)

797 #ifndef 
SUBLANG_JAPANESE_JAPAN


798 #define 
	#SUBLANG_JAPANESE_JAPAN
 0x01

	)

800 #ifndef 
SUBLANG_KANNADA_INDIA


801 #define 
	#SUBLANG_KANNADA_INDIA
 0x01

	)

803 #ifndef 
SUBLANG_KASHMIRI_INDIA


804 #define 
	#SUBLANG_KASHMIRI_INDIA
 0x02

	)

806 #ifndef 
SUBLANG_KAZAK_KAZAKHSTAN


807 #define 
	#SUBLANG_KAZAK_KAZAKHSTAN
 0x01

	)

809 #ifndef 
SUBLANG_KICHE_GUATEMALA


810 #define 
	#SUBLANG_KICHE_GUATEMALA
 0x01

	)

812 #ifndef 
SUBLANG_KINYARWANDA_RWANDA


813 #define 
	#SUBLANG_KINYARWANDA_RWANDA
 0x01

	)

815 #ifndef 
SUBLANG_KONKANI_INDIA


816 #define 
	#SUBLANG_KONKANI_INDIA
 0x01

	)

818 #ifndef 
SUBLANG_KYRGYZ_KYRGYZSTAN


819 #define 
	#SUBLANG_KYRGYZ_KYRGYZSTAN
 0x01

	)

821 #ifndef 
SUBLANG_LAO_LAOS


822 #define 
	#SUBLANG_LAO_LAOS
 0x01

	)

824 #ifndef 
SUBLANG_LATVIAN_LATVIA


825 #define 
	#SUBLANG_LATVIAN_LATVIA
 0x01

	)

827 #ifndef 
SUBLANG_LITHUANIAN_LITHUANIA


828 #define 
	#SUBLANG_LITHUANIAN_LITHUANIA
 0x01

	)

830 #undef 
SUBLANG_LOWER_SORBIAN_GERMANY


831 #define 
	#SUBLANG_LOWER_SORBIAN_GERMANY
 0x02

	)

832 #ifndef 
SUBLANG_LUXEMBOURGISH_LUXEMBOURG


833 #define 
	#SUBLANG_LUXEMBOURGISH_LUXEMBOURG
 0x01

	)

835 #ifndef 
SUBLANG_MACEDONIAN_MACEDONIA


836 #define 
	#SUBLANG_MACEDONIAN_MACEDONIA
 0x01

	)

838 #ifndef 
SUBLANG_MALAY_MALAYSIA


839 #define 
	#SUBLANG_MALAY_MALAYSIA
 0x01

	)

841 #ifndef 
SUBLANG_MALAY_BRUNEI_DARUSSALAM


842 #define 
	#SUBLANG_MALAY_BRUNEI_DARUSSALAM
 0x02

	)

844 #ifndef 
SUBLANG_MALAYALAM_INDIA


845 #define 
	#SUBLANG_MALAYALAM_INDIA
 0x01

	)

847 #ifndef 
SUBLANG_MALTESE_MALTA


848 #define 
	#SUBLANG_MALTESE_MALTA
 0x01

	)

850 #ifndef 
SUBLANG_MAORI_NEW_ZEALAND


851 #define 
	#SUBLANG_MAORI_NEW_ZEALAND
 0x01

	)

853 #ifndef 
SUBLANG_MAPUDUNGUN_CHILE


854 #define 
	#SUBLANG_MAPUDUNGUN_CHILE
 0x01

	)

856 #ifndef 
SUBLANG_MARATHI_INDIA


857 #define 
	#SUBLANG_MARATHI_INDIA
 0x01

	)

859 #ifndef 
SUBLANG_MOHAWK_CANADA


860 #define 
	#SUBLANG_MOHAWK_CANADA
 0x01

	)

862 #ifndef 
SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA


863 #define 
	#SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA
 0x01

	)

865 #ifndef 
SUBLANG_MONGOLIAN_PRC


866 #define 
	#SUBLANG_MONGOLIAN_PRC
 0x02

	)

868 #ifndef 
SUBLANG_NEPALI_NEPAL


869 #define 
	#SUBLANG_NEPALI_NEPAL
 0x01

	)

871 #ifndef 
SUBLANG_NEPALI_INDIA


872 #define 
	#SUBLANG_NEPALI_INDIA
 0x02

	)

874 #ifndef 
SUBLANG_OCCITAN_FRANCE


875 #define 
	#SUBLANG_OCCITAN_FRANCE
 0x01

	)

877 #ifndef 
SUBLANG_ORIYA_INDIA


878 #define 
	#SUBLANG_ORIYA_INDIA
 0x01

	)

880 #ifndef 
SUBLANG_PASHTO_AFGHANISTAN


881 #define 
	#SUBLANG_PASHTO_AFGHANISTAN
 0x01

	)

883 #ifndef 
SUBLANG_POLISH_POLAND


884 #define 
	#SUBLANG_POLISH_POLAND
 0x01

	)

886 #ifndef 
SUBLANG_PUNJABI_INDIA


887 #define 
	#SUBLANG_PUNJABI_INDIA
 0x01

	)

889 #ifndef 
SUBLANG_PUNJABI_PAKISTAN


890 #define 
	#SUBLANG_PUNJABI_PAKISTAN
 0x02

	)

892 #ifndef 
SUBLANG_QUECHUA_BOLIVIA


893 #define 
	#SUBLANG_QUECHUA_BOLIVIA
 0x01

	)

895 #ifndef 
SUBLANG_QUECHUA_ECUADOR


896 #define 
	#SUBLANG_QUECHUA_ECUADOR
 0x02

	)

898 #ifndef 
SUBLANG_QUECHUA_PERU


899 #define 
	#SUBLANG_QUECHUA_PERU
 0x03

	)

901 #ifndef 
SUBLANG_ROMANIAN_ROMANIA


902 #define 
	#SUBLANG_ROMANIAN_ROMANIA
 0x01

	)

904 #ifndef 
SUBLANG_ROMANIAN_MOLDOVA


905 #define 
	#SUBLANG_ROMANIAN_MOLDOVA
 0x02

	)

907 #ifndef 
SUBLANG_ROMANSH_SWITZERLAND


908 #define 
	#SUBLANG_ROMANSH_SWITZERLAND
 0x01

	)

910 #ifndef 
SUBLANG_RUSSIAN_RUSSIA


911 #define 
	#SUBLANG_RUSSIAN_RUSSIA
 0x01

	)

913 #ifndef 
SUBLANG_RUSSIAN_MOLDAVIA


914 #define 
	#SUBLANG_RUSSIAN_MOLDAVIA
 0x02

	)

916 #ifndef 
SUBLANG_SAMI_NORTHERN_NORWAY


917 #define 
	#SUBLANG_SAMI_NORTHERN_NORWAY
 0x01

	)

919 #ifndef 
SUBLANG_SAMI_NORTHERN_SWEDEN


920 #define 
	#SUBLANG_SAMI_NORTHERN_SWEDEN
 0x02

	)

922 #ifndef 
SUBLANG_SAMI_NORTHERN_FINLAND


923 #define 
	#SUBLANG_SAMI_NORTHERN_FINLAND
 0x03

	)

925 #ifndef 
SUBLANG_SAMI_LULE_NORWAY


926 #define 
	#SUBLANG_SAMI_LULE_NORWAY
 0x04

	)

928 #ifndef 
SUBLANG_SAMI_LULE_SWEDEN


929 #define 
	#SUBLANG_SAMI_LULE_SWEDEN
 0x05

	)

931 #ifndef 
SUBLANG_SAMI_SOUTHERN_NORWAY


932 #define 
	#SUBLANG_SAMI_SOUTHERN_NORWAY
 0x06

	)

934 #ifndef 
SUBLANG_SAMI_SOUTHERN_SWEDEN


935 #define 
	#SUBLANG_SAMI_SOUTHERN_SWEDEN
 0x07

	)

937 #undef 
SUBLANG_SAMI_SKOLT_FINLAND


938 #define 
	#SUBLANG_SAMI_SKOLT_FINLAND
 0x08

	)

939 #undef 
SUBLANG_SAMI_INARI_FINLAND


940 #define 
	#SUBLANG_SAMI_INARI_FINLAND
 0x09

	)

941 #ifndef 
SUBLANG_SANSKRIT_INDIA


942 #define 
	#SUBLANG_SANSKRIT_INDIA
 0x01

	)

944 #ifndef 
SUBLANG_SERBIAN_LATIN


945 #define 
	#SUBLANG_SERBIAN_LATIN
 0x02

	)

947 #ifndef 
SUBLANG_SERBIAN_CYRILLIC


948 #define 
	#SUBLANG_SERBIAN_CYRILLIC
 0x03

	)

950 #ifndef 
SUBLANG_SINDHI_INDIA


951 #define 
	#SUBLANG_SINDHI_INDIA
 0x01

	)

953 #undef 
SUBLANG_SINDHI_PAKISTAN


954 #define 
	#SUBLANG_SINDHI_PAKISTAN
 0x02

	)

955 #ifndef 
SUBLANG_SINDHI_AFGHANISTAN


956 #define 
	#SUBLANG_SINDHI_AFGHANISTAN
 0x02

	)

958 #ifndef 
SUBLANG_SINHALESE_SRI_LANKA


959 #define 
	#SUBLANG_SINHALESE_SRI_LANKA
 0x01

	)

961 #ifndef 
SUBLANG_SLOVAK_SLOVAKIA


962 #define 
	#SUBLANG_SLOVAK_SLOVAKIA
 0x01

	)

964 #ifndef 
SUBLANG_SLOVENIAN_SLOVENIA


965 #define 
	#SUBLANG_SLOVENIAN_SLOVENIA
 0x01

	)

967 #ifndef 
SUBLANG_SOTHO_SOUTH_AFRICA


968 #define 
	#SUBLANG_SOTHO_SOUTH_AFRICA
 0x01

	)

970 #ifndef 
SUBLANG_SPANISH_GUATEMALA


971 #define 
	#SUBLANG_SPANISH_GUATEMALA
 0x04

	)

973 #ifndef 
SUBLANG_SPANISH_COSTA_RICA


974 #define 
	#SUBLANG_SPANISH_COSTA_RICA
 0x05

	)

976 #ifndef 
SUBLANG_SPANISH_PANAMA


977 #define 
	#SUBLANG_SPANISH_PANAMA
 0x06

	)

979 #ifndef 
SUBLANG_SPANISH_DOMINICAN_REPUBLIC


980 #define 
	#SUBLANG_SPANISH_DOMINICAN_REPUBLIC
 0x07

	)

982 #ifndef 
SUBLANG_SPANISH_VENEZUELA


983 #define 
	#SUBLANG_SPANISH_VENEZUELA
 0x08

	)

985 #ifndef 
SUBLANG_SPANISH_COLOMBIA


986 #define 
	#SUBLANG_SPANISH_COLOMBIA
 0x09

	)

988 #ifndef 
SUBLANG_SPANISH_PERU


989 #define 
	#SUBLANG_SPANISH_PERU
 0x0a

	)

991 #ifndef 
SUBLANG_SPANISH_ARGENTINA


992 #define 
	#SUBLANG_SPANISH_ARGENTINA
 0x0b

	)

994 #ifndef 
SUBLANG_SPANISH_ECUADOR


995 #define 
	#SUBLANG_SPANISH_ECUADOR
 0x0c

	)

997 #ifndef 
SUBLANG_SPANISH_CHILE


998 #define 
	#SUBLANG_SPANISH_CHILE
 0x0d

	)

1000 #ifndef 
SUBLANG_SPANISH_URUGUAY


1001 #define 
	#SUBLANG_SPANISH_URUGUAY
 0x0e

	)

1003 #ifndef 
SUBLANG_SPANISH_PARAGUAY


1004 #define 
	#SUBLANG_SPANISH_PARAGUAY
 0x0f

	)

1006 #ifndef 
SUBLANG_SPANISH_BOLIVIA


1007 #define 
	#SUBLANG_SPANISH_BOLIVIA
 0x10

	)

1009 #ifndef 
SUBLANG_SPANISH_EL_SALVADOR


1010 #define 
	#SUBLANG_SPANISH_EL_SALVADOR
 0x11

	)

1012 #ifndef 
SUBLANG_SPANISH_HONDURAS


1013 #define 
	#SUBLANG_SPANISH_HONDURAS
 0x12

	)

1015 #ifndef 
SUBLANG_SPANISH_NICARAGUA


1016 #define 
	#SUBLANG_SPANISH_NICARAGUA
 0x13

	)

1018 #ifndef 
SUBLANG_SPANISH_PUERTO_RICO


1019 #define 
	#SUBLANG_SPANISH_PUERTO_RICO
 0x14

	)

1021 #ifndef 
SUBLANG_SPANISH_US


1022 #define 
	#SUBLANG_SPANISH_US
 0x15

	)

1024 #ifndef 
SUBLANG_SWAHILI_KENYA


1025 #define 
	#SUBLANG_SWAHILI_KENYA
 0x01

	)

1027 #ifndef 
SUBLANG_SWEDISH_SWEDEN


1028 #define 
	#SUBLANG_SWEDISH_SWEDEN
 0x01

	)

1030 #ifndef 
SUBLANG_SWEDISH_FINLAND


1031 #define 
	#SUBLANG_SWEDISH_FINLAND
 0x02

	)

1033 #ifndef 
SUBLANG_SYRIAC_SYRIA


1034 #define 
	#SUBLANG_SYRIAC_SYRIA
 0x01

	)

1036 #ifndef 
SUBLANG_TAGALOG_PHILIPPINES


1037 #define 
	#SUBLANG_TAGALOG_PHILIPPINES
 0x01

	)

1039 #ifndef 
SUBLANG_TAJIK_TAJIKISTAN


1040 #define 
	#SUBLANG_TAJIK_TAJIKISTAN
 0x01

	)

1042 #ifndef 
SUBLANG_TAMAZIGHT_ARABIC


1043 #define 
	#SUBLANG_TAMAZIGHT_ARABIC
 0x01

	)

1045 #ifndef 
SUBLANG_TAMAZIGHT_ALGERIA_LATIN


1046 #define 
	#SUBLANG_TAMAZIGHT_ALGERIA_LATIN
 0x02

	)

1048 #ifndef 
SUBLANG_TAMIL_INDIA


1049 #define 
	#SUBLANG_TAMIL_INDIA
 0x01

	)

1051 #ifndef 
SUBLANG_TATAR_RUSSIA


1052 #define 
	#SUBLANG_TATAR_RUSSIA
 0x01

	)

1054 #ifndef 
SUBLANG_TELUGU_INDIA


1055 #define 
	#SUBLANG_TELUGU_INDIA
 0x01

	)

1057 #ifndef 
SUBLANG_THAI_THAILAND


1058 #define 
	#SUBLANG_THAI_THAILAND
 0x01

	)

1060 #ifndef 
SUBLANG_TIBETAN_PRC


1061 #define 
	#SUBLANG_TIBETAN_PRC
 0x01

	)

1063 #undef 
SUBLANG_TIBETAN_BHUTAN


1064 #define 
	#SUBLANG_TIBETAN_BHUTAN
 0x02

	)

1065 #ifndef 
SUBLANG_TIGRINYA_ETHIOPIA


1066 #define 
	#SUBLANG_TIGRINYA_ETHIOPIA
 0x01

	)

1068 #ifndef 
SUBLANG_TIGRINYA_ERITREA


1069 #define 
	#SUBLANG_TIGRINYA_ERITREA
 0x02

	)

1071 #ifndef 
SUBLANG_TSWANA_SOUTH_AFRICA


1072 #define 
	#SUBLANG_TSWANA_SOUTH_AFRICA
 0x01

	)

1074 #ifndef 
SUBLANG_TURKISH_TURKEY


1075 #define 
	#SUBLANG_TURKISH_TURKEY
 0x01

	)

1077 #ifndef 
SUBLANG_TURKMEN_TURKMENISTAN


1078 #define 
	#SUBLANG_TURKMEN_TURKMENISTAN
 0x01

	)

1080 #ifndef 
SUBLANG_UIGHUR_PRC


1081 #define 
	#SUBLANG_UIGHUR_PRC
 0x01

	)

1083 #ifndef 
SUBLANG_UKRAINIAN_UKRAINE


1084 #define 
	#SUBLANG_UKRAINIAN_UKRAINE
 0x01

	)

1086 #ifndef 
SUBLANG_UPPER_SORBIAN_GERMANY


1087 #define 
	#SUBLANG_UPPER_SORBIAN_GERMANY
 0x01

	)

1089 #ifndef 
SUBLANG_URDU_PAKISTAN


1090 #define 
	#SUBLANG_URDU_PAKISTAN
 0x01

	)

1092 #ifndef 
SUBLANG_URDU_INDIA


1093 #define 
	#SUBLANG_URDU_INDIA
 0x02

	)

1095 #ifndef 
SUBLANG_UZBEK_LATIN


1096 #define 
	#SUBLANG_UZBEK_LATIN
 0x01

	)

1098 #ifndef 
SUBLANG_UZBEK_CYRILLIC


1099 #define 
	#SUBLANG_UZBEK_CYRILLIC
 0x02

	)

1101 #ifndef 
SUBLANG_VIETNAMESE_VIETNAM


1102 #define 
	#SUBLANG_VIETNAMESE_VIETNAM
 0x01

	)

1104 #ifndef 
SUBLANG_WELSH_UNITED_KINGDOM


1105 #define 
	#SUBLANG_WELSH_UNITED_KINGDOM
 0x01

	)

1107 #ifndef 
SUBLANG_WOLOF_SENEGAL


1108 #define 
	#SUBLANG_WOLOF_SENEGAL
 0x01

	)

1110 #ifndef 
SUBLANG_XHOSA_SOUTH_AFRICA


1111 #define 
	#SUBLANG_XHOSA_SOUTH_AFRICA
 0x01

	)

1113 #ifndef 
SUBLANG_YAKUT_RUSSIA


1114 #define 
	#SUBLANG_YAKUT_RUSSIA
 0x01

	)

1116 #ifndef 
SUBLANG_YI_PRC


1117 #define 
	#SUBLANG_YI_PRC
 0x01

	)

1119 #ifndef 
SUBLANG_YORUBA_NIGERIA


1120 #define 
	#SUBLANG_YORUBA_NIGERIA
 0x01

	)

1122 #ifndef 
SUBLANG_ZULU_SOUTH_AFRICA


1123 #define 
	#SUBLANG_ZULU_SOUTH_AFRICA
 0x01

	)

1126 #ifndef 
LOCALE_SNAME


1127 #define 
	#LOCALE_SNAME
 0x5c

	)

1132 #if 
HAVE_CFLOCALECOPYCURRENT
 || 
HAVE_CFPREFERENCESCOPYAPPVALUE


1139 #if !
defined
 
IN_LIBINTL


1143 
	$gl_locale_name_canonicalize
 (char *
name
)

1154 typedef struct { const char 
legacy
[21+1]; const char 
unixy
[5+1]; }

1155 
	tlegacy_entry
;

1156 static const 
legacy_entry
 
legacy_table
[] = {

1292 typedef struct { const char 
langtag
[7+1]; const char 
unixy
[12+1]; }

1293 
	tlangtag_entry
;

1294 static const 
langtag_entry
 
langtag_table
[] = {

1322 typedef struct { const char 
script
[4+1]; const char 
unixy
[9+1]; }

1323 
	tscript_entry
;

1324 static const 
script_entry
 
script_table
[] = {

1331 if (
name
[0] >= 'A' && name[0] <= 'Z')

1333 unsigned int 
i1
, 
i2
;

1334 
i1
 = 0;

1335 
i2
 = sizeof (
legacy_table
) / sizeof (
legacy_entry
);

1336 while (
i2
 - 
i1
 > 1)

1340 unsigned int 
i
 = (
i1
 + 
i2
) >> 1;

1341 const 
legacy_entry
 *
p
 = &
legacy_table
[
i
];

1342 if (
	`strcmp
 (
name
, 
p
->
legacy
) < 0)

1343 
i2
 = 
i
;

1345 
i1
 = 
i
;

1347 if (
	`strcmp
 (
name
, 
legacy_table
[
i1
].
legacy
) == 0)

1349 
	`strcpy
 (
name
, 
legacy_table
[
i1
].
unixy
);

1355 if (
	`strlen
 (
name
) == 7 && name[2] == '-')

1357 unsigned int 
i1
, 
i2
;

1358 
i1
 = 0;

1359 
i2
 = sizeof (
langtag_table
) / sizeof (
langtag_entry
);

1360 while (
i2
 - 
i1
 > 1)

1364 unsigned int 
i
 = (
i1
 + 
i2
) >> 1;

1365 const 
langtag_entry
 *
p
 = &
langtag_table
[
i
];

1366 if (
	`strcmp
 (
name
, 
p
->
langtag
) < 0)

1367 
i2
 = 
i
;

1369 
i1
 = 
i
;

1371 if (
	`strcmp
 (
name
, 
langtag_table
[
i1
].
langtag
) == 0)

1373 
	`strcpy
 (
name
, 
langtag_table
[
i1
].
unixy
);

1377 
i1
 = 0;

1378 
i2
 = sizeof (
script_table
) / sizeof (
script_entry
);

1379 while (
i2
 - 
i1
 > 1)

1383 unsigned int 
i
 = (
i1
 + 
i2
) >> 1;

1384 const 
script_entry
 *
p
 = &
script_table
[
i
];

1385 if (
	`strcmp
 (
name
 + 3, 
p
->
script
) < 0)

1386 
i2
 = 
i
;

1388 
i1
 = 
i
;

1390 if (
	`strcmp
 (
name
 + 3, 
script_table
[
i1
].
script
) == 0)

1392 
name
[2] = '@';

1393 
	`strcpy
 (
name
 + 3, 
script_table
[
i1
].
unixy
);

1400 char *
p
;

1401 for (
p
 = 
name
; *p != '\0'; p++)

1402 if (*
p
 == '-')

1403 *
p
 = '_';

1405 
	}
}

1410 #if 
defined
 
WIN32_NATIVE
 || defined 
__CYGWIN__


1416 #if !
defined
 
IN_LIBINTL


1420 
	$gl_locale_name_canonicalize
 (char *
name
)

1424 char *
p
;

1426 for (
p
 = 
name
; *p != '\0'; p++)

1427 if (*
p
 == '-')

1429 *
p
 = '_';

1430 
p
++;

1431 for (; *
p
 != '\0'; p++)

1433 if (*
p
 >= 'a' && *p <= 'z')

1434 *
p
 += 'A' - 'a';

1435 if (*
p
 == '-')

1437 *
p
 = '\0';

1443 
	}
}

1445 #if !
defined
 
IN_LIBINTL


1449 
	$gl_locale_name_from_win32_LANGID
 (
LANGID
 
langid
)

1453 if (
	`getenv
 ("GETTEXT_MUI") != 
NULL
)

1455 static char 
namebuf
[256];

1460 if (
	`GetLocaleInfoA
 (
	`MAKELCID
 (
langid
, 
SORT_DEFAULT
), 
LOCALE_SNAME
,

1461 
namebuf
, sizeof (namebuf) - 1))

1464 
	`gl_locale_name_canonicalize
 (
namebuf
);

1465 return 
namebuf
;

1475 int 
primary
, 
sub
;

1478 
primary
 = 
	`PRIMARYLANGID
 (
langid
);

1479 
sub
 = 
	`SUBLANGID
 (
langid
);

1484 switch (
primary
)

1486 case 
LANG_AFRIKAANS
:

1487 switch (
sub
)

1489 case 
SUBLANG_AFRIKAANS_SOUTH_AFRICA
: return "af_ZA";

1492 case 
LANG_ALBANIAN
:

1493 switch (
sub
)

1495 case 
SUBLANG_ALBANIAN_ALBANIA
: return "sq_AL";

1498 case 
LANG_ALSATIAN
:

1499 switch (
sub
)

1501 case 
SUBLANG_ALSATIAN_FRANCE
: return "gsw_FR";

1504 case 
LANG_AMHARIC
:

1505 switch (
sub
)

1507 case 
SUBLANG_AMHARIC_ETHIOPIA
: return "am_ET";

1510 case 
LANG_ARABIC
:

1511 switch (
sub
)

1513 case 
SUBLANG_ARABIC_SAUDI_ARABIA
: return "ar_SA";

1514 case 
SUBLANG_ARABIC_IRAQ
: return "ar_IQ";

1515 case 
SUBLANG_ARABIC_EGYPT
: return "ar_EG";

1516 case 
SUBLANG_ARABIC_LIBYA
: return "ar_LY";

1517 case 
SUBLANG_ARABIC_ALGERIA
: return "ar_DZ";

1518 case 
SUBLANG_ARABIC_MOROCCO
: return "ar_MA";

1519 case 
SUBLANG_ARABIC_TUNISIA
: return "ar_TN";

1520 case 
SUBLANG_ARABIC_OMAN
: return "ar_OM";

1521 case 
SUBLANG_ARABIC_YEMEN
: return "ar_YE";

1522 case 
SUBLANG_ARABIC_SYRIA
: return "ar_SY";

1523 case 
SUBLANG_ARABIC_JORDAN
: return "ar_JO";

1524 case 
SUBLANG_ARABIC_LEBANON
: return "ar_LB";

1525 case 
SUBLANG_ARABIC_KUWAIT
: return "ar_KW";

1526 case 
SUBLANG_ARABIC_UAE
: return "ar_AE";

1527 case 
SUBLANG_ARABIC_BAHRAIN
: return "ar_BH";

1528 case 
SUBLANG_ARABIC_QATAR
: return "ar_QA";

1531 case 
LANG_ARMENIAN
:

1532 switch (
sub
)

1534 case 
SUBLANG_ARMENIAN_ARMENIA
: return "hy_AM";

1537 case 
LANG_ASSAMESE
:

1538 switch (
sub
)

1540 case 
SUBLANG_ASSAMESE_INDIA
: return "as_IN";

1543 case 
LANG_AZERI
:

1544 switch (
sub
)

1548 case 
SUBLANG_AZERI_LATIN
: return "az_AZ@latin";

1550 case 
SUBLANG_AZERI_CYRILLIC
: return "az_AZ@cyrillic";

1553 case 
LANG_BASHKIR
:

1554 switch (
sub
)

1556 case 
SUBLANG_BASHKIR_RUSSIA
: return "ba_RU";

1559 case 
LANG_BASQUE
:

1560 switch (
sub
)

1562 case 
SUBLANG_BASQUE_BASQUE
: return "eu_ES";

1565 case 
LANG_BELARUSIAN
:

1566 switch (
sub
)

1568 case 
SUBLANG_BELARUSIAN_BELARUS
: return "be_BY";

1571 case 
LANG_BENGALI
:

1572 switch (
sub
)

1574 case 
SUBLANG_BENGALI_INDIA
: return "bn_IN";

1575 case 
SUBLANG_BENGALI_BANGLADESH
: return "bn_BD";

1578 case 
LANG_BRETON
:

1579 switch (
sub
)

1581 case 
SUBLANG_BRETON_FRANCE
: return "br_FR";

1584 case 
LANG_BULGARIAN
:

1585 switch (
sub
)

1587 case 
SUBLANG_BULGARIAN_BULGARIA
: return "bg_BG";

1590 case 
LANG_BURMESE
:

1591 switch (
sub
)

1593 case 
SUBLANG_DEFAULT
: return "my_MM";

1596 case 
LANG_CAMBODIAN
:

1597 switch (
sub
)

1599 case 
SUBLANG_CAMBODIAN_CAMBODIA
: return "km_KH";

1602 case 
LANG_CATALAN
:

1603 switch (
sub
)

1605 case 
SUBLANG_CATALAN_SPAIN
: return "ca_ES";

1608 case 
LANG_CHEROKEE
:

1609 switch (
sub
)

1611 case 
SUBLANG_DEFAULT
: return "chr_US";

1614 case 
LANG_CHINESE
:

1615 switch (
sub
)

1617 case 
SUBLANG_CHINESE_TRADITIONAL
: case 0x1f: return "zh_TW";

1618 case 
SUBLANG_CHINESE_SIMPLIFIED
: case 0x00: return "zh_CN";

1619 case 
SUBLANG_CHINESE_HONGKONG
: return "zh_HK";

1620 case 
SUBLANG_CHINESE_SINGAPORE
: return "zh_SG";

1621 case 
SUBLANG_CHINESE_MACAU
: return "zh_MO";

1624 case 
LANG_CORSICAN
:

1625 switch (
sub
)

1627 case 
SUBLANG_CORSICAN_FRANCE
: return "co_FR";

1630 case 
LANG_CROATIAN
:

1638 switch (
sub
)

1642 case 
SUBLANG_CROATIAN_CROATIA
: return "hr_HR";

1643 case 
SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN
: return "hr_BA";

1647 case 
SUBLANG_SERBIAN_LATIN
: return "sr_CS";

1652 case 
SUBLANG_SERBIAN_CYRILLIC
: return "sr_CS@cyrillic";

1659 case 
SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN
: return "bs_BA";

1661 case 
SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC
: return "bs_BA@cyrillic";

1664 case 
LANG_CZECH
:

1665 switch (
sub
)

1667 case 
SUBLANG_CZECH_CZECH_REPUBLIC
: return "cs_CZ";

1670 case 
LANG_DANISH
:

1671 switch (
sub
)

1673 case 
SUBLANG_DANISH_DENMARK
: return "da_DK";

1676 case 
LANG_DARI
:

1678 switch (
sub
)

1680 case 
SUBLANG_DARI_AFGHANISTAN
: return "prs_AF";

1683 case 
LANG_DIVEHI
:

1684 switch (
sub
)

1686 case 
SUBLANG_DIVEHI_MALDIVES
: return "dv_MV";

1689 case 
LANG_DUTCH
:

1690 switch (
sub
)

1692 case 
SUBLANG_DUTCH
: return "nl_NL";

1693 case 
SUBLANG_DUTCH_BELGIAN
: return "nl_BE";

1694 case 
SUBLANG_DUTCH_SURINAM
: return "nl_SR";

1697 case 
LANG_EDO
:

1698 switch (
sub
)

1700 case 
SUBLANG_DEFAULT
: return "bin_NG";

1703 case 
LANG_ENGLISH
:

1704 switch (
sub
)

1710 case 
SUBLANG_ENGLISH_US
: return "en_US";

1711 case 
SUBLANG_ENGLISH_UK
: return "en_GB";

1712 case 
SUBLANG_ENGLISH_AUS
: return "en_AU";

1713 case 
SUBLANG_ENGLISH_CAN
: return "en_CA";

1714 case 
SUBLANG_ENGLISH_NZ
: return "en_NZ";

1715 case 
SUBLANG_ENGLISH_EIRE
: return "en_IE";

1716 case 
SUBLANG_ENGLISH_SOUTH_AFRICA
: return "en_ZA";

1717 case 
SUBLANG_ENGLISH_JAMAICA
: return "en_JM";

1718 case 
SUBLANG_ENGLISH_CARIBBEAN
: return "en_GD";

1719 case 
SUBLANG_ENGLISH_BELIZE
: return "en_BZ";

1720 case 
SUBLANG_ENGLISH_TRINIDAD
: return "en_TT";

1721 case 
SUBLANG_ENGLISH_ZIMBABWE
: return "en_ZW";

1722 case 
SUBLANG_ENGLISH_PHILIPPINES
: return "en_PH";

1723 case 
SUBLANG_ENGLISH_INDONESIA
: return "en_ID";

1724 case 
SUBLANG_ENGLISH_HONGKONG
: return "en_HK";

1725 case 
SUBLANG_ENGLISH_INDIA
: return "en_IN";

1726 case 
SUBLANG_ENGLISH_MALAYSIA
: return "en_MY";

1727 case 
SUBLANG_ENGLISH_SINGAPORE
: return "en_SG";

1730 case 
LANG_ESTONIAN
:

1731 switch (
sub
)

1733 case 
SUBLANG_ESTONIAN_ESTONIA
: return "et_EE";

1736 case 
LANG_FAEROESE
:

1737 switch (
sub
)

1739 case 
SUBLANG_FAEROESE_FAROE_ISLANDS
: return "fo_FO";

1742 case 
LANG_FARSI
:

1743 switch (
sub
)

1745 case 
SUBLANG_FARSI_IRAN
: return "fa_IR";

1748 case 
LANG_FINNISH
:

1749 switch (
sub
)

1751 case 
SUBLANG_FINNISH_FINLAND
: return "fi_FI";

1754 case 
LANG_FRENCH
:

1755 switch (
sub
)

1757 case 
SUBLANG_FRENCH
: return "fr_FR";

1758 case 
SUBLANG_FRENCH_BELGIAN
: return "fr_BE";

1759 case 
SUBLANG_FRENCH_CANADIAN
: return "fr_CA";

1760 case 
SUBLANG_FRENCH_SWISS
: return "fr_CH";

1761 case 
SUBLANG_FRENCH_LUXEMBOURG
: return "fr_LU";

1762 case 
SUBLANG_FRENCH_MONACO
: return "fr_MC";

1763 case 
SUBLANG_FRENCH_WESTINDIES
: return "fr";

1764 case 
SUBLANG_FRENCH_REUNION
: return "fr_RE";

1765 case 
SUBLANG_FRENCH_CONGO
: return "fr_CG";

1766 case 
SUBLANG_FRENCH_SENEGAL
: return "fr_SN";

1767 case 
SUBLANG_FRENCH_CAMEROON
: return "fr_CM";

1768 case 
SUBLANG_FRENCH_COTEDIVOIRE
: return "fr_CI";

1769 case 
SUBLANG_FRENCH_MALI
: return "fr_ML";

1770 case 
SUBLANG_FRENCH_MOROCCO
: return "fr_MA";

1771 case 
SUBLANG_FRENCH_HAITI
: return "fr_HT";

1774 case 
LANG_FRISIAN
:

1775 switch (
sub
)

1777 case 
SUBLANG_FRISIAN_NETHERLANDS
: return "fy_NL";

1780 case 
LANG_FULFULDE
:

1782 switch (
sub
)

1784 case 
SUBLANG_DEFAULT
: return "ff_NG";

1787 case 
LANG_GAELIC
:

1788 switch (
sub
)

1793 case 
SUBLANG_IRISH_IRELAND
: return "ga_IE";

1796 case 
LANG_GALICIAN
:

1797 switch (
sub
)

1799 case 
SUBLANG_GALICIAN_SPAIN
: return "gl_ES";

1802 case 
LANG_GEORGIAN
:

1803 switch (
sub
)

1805 case 
SUBLANG_GEORGIAN_GEORGIA
: return "ka_GE";

1808 case 
LANG_GERMAN
:

1809 switch (
sub
)

1811 case 
SUBLANG_GERMAN
: return "de_DE";

1812 case 
SUBLANG_GERMAN_SWISS
: return "de_CH";

1813 case 
SUBLANG_GERMAN_AUSTRIAN
: return "de_AT";

1814 case 
SUBLANG_GERMAN_LUXEMBOURG
: return "de_LU";

1815 case 
SUBLANG_GERMAN_LIECHTENSTEIN
: return "de_LI";

1818 case 
LANG_GREEK
:

1819 switch (
sub
)

1821 case 
SUBLANG_GREEK_GREECE
: return "el_GR";

1824 case 
LANG_GREENLANDIC
:

1825 switch (
sub
)

1827 case 
SUBLANG_GREENLANDIC_GREENLAND
: return "kl_GL";

1830 case 
LANG_GUARANI
:

1831 switch (
sub
)

1833 case 
SUBLANG_DEFAULT
: return "gn_PY";

1836 case 
LANG_GUJARATI
:

1837 switch (
sub
)

1839 case 
SUBLANG_GUJARATI_INDIA
: return "gu_IN";

1842 case 
LANG_HAUSA
:

1843 switch (
sub
)

1846 case 
SUBLANG_HAUSA_NIGERIA_LATIN
: return "ha_NG";

1849 case 
LANG_HAWAIIAN
:

1852 switch (
sub
)

1854 case 
SUBLANG_DEFAULT
: return "cpe_US";

1857 case 
LANG_HEBREW
:

1858 switch (
sub
)

1860 case 
SUBLANG_HEBREW_ISRAEL
: return "he_IL";

1863 case 
LANG_HINDI
:

1864 switch (
sub
)

1866 case 
SUBLANG_HINDI_INDIA
: return "hi_IN";

1869 case 
LANG_HUNGARIAN
:

1870 switch (
sub
)

1872 case 
SUBLANG_HUNGARIAN_HUNGARY
: return "hu_HU";

1875 case 
LANG_IBIBIO
:

1876 switch (
sub
)

1878 case 
SUBLANG_DEFAULT
: return "nic_NG";

1881 case 
LANG_ICELANDIC
:

1882 switch (
sub
)

1884 case 
SUBLANG_ICELANDIC_ICELAND
: return "is_IS";

1887 case 
LANG_IGBO
:

1888 switch (
sub
)

1890 case 
SUBLANG_IGBO_NIGERIA
: return "ig_NG";

1893 case 
LANG_INDONESIAN
:

1894 switch (
sub
)

1896 case 
SUBLANG_INDONESIAN_INDONESIA
: return "id_ID";

1899 case 
LANG_INUKTITUT
:

1900 switch (
sub
)

1903 case 
SUBLANG_INUKTITUT_CANADA
: return "iu_CA";

1905 case 
SUBLANG_INUKTITUT_CANADA_LATIN
: return "iu_CA@latin";

1908 case 
LANG_ITALIAN
:

1909 switch (
sub
)

1911 case 
SUBLANG_ITALIAN
: return "it_IT";

1912 case 
SUBLANG_ITALIAN_SWISS
: return "it_CH";

1915 case 
LANG_JAPANESE
:

1916 switch (
sub
)

1918 case 
SUBLANG_JAPANESE_JAPAN
: return "ja_JP";

1921 case 
LANG_KANNADA
:

1922 switch (
sub
)

1924 case 
SUBLANG_KANNADA_INDIA
: return "kn_IN";

1927 case 
LANG_KANURI
:

1928 switch (
sub
)

1930 case 
SUBLANG_DEFAULT
: return "kr_NG";

1933 case 
LANG_KASHMIRI
:

1934 switch (
sub
)

1936 case 
SUBLANG_DEFAULT
: return "ks_PK";

1937 case 
SUBLANG_KASHMIRI_INDIA
: return "ks_IN";

1940 case 
LANG_KAZAK
:

1941 switch (
sub
)

1943 case 
SUBLANG_KAZAK_KAZAKHSTAN
: return "kk_KZ";

1946 case 
LANG_KICHE
:

1948 switch (
sub
)

1950 case 
SUBLANG_KICHE_GUATEMALA
: return "qut_GT";

1953 case 
LANG_KINYARWANDA
:

1954 switch (
sub
)

1956 case 
SUBLANG_KINYARWANDA_RWANDA
: return "rw_RW";

1959 case 
LANG_KONKANI
:

1961 switch (
sub
)

1963 case 
SUBLANG_KONKANI_INDIA
: return "kok_IN";

1966 case 
LANG_KOREAN
:

1967 switch (
sub
)

1969 case 
SUBLANG_DEFAULT
: return "ko_KR";

1972 case 
LANG_KYRGYZ
:

1973 switch (
sub
)

1975 case 
SUBLANG_KYRGYZ_KYRGYZSTAN
: return "ky_KG";

1978 case 
LANG_LAO
:

1979 switch (
sub
)

1981 case 
SUBLANG_LAO_LAOS
: return "lo_LA";

1984 case 
LANG_LATIN
:

1985 switch (
sub
)

1987 case 
SUBLANG_DEFAULT
: return "la_VA";

1990 case 
LANG_LATVIAN
:

1991 switch (
sub
)

1993 case 
SUBLANG_LATVIAN_LATVIA
: return "lv_LV";

1996 case 
LANG_LITHUANIAN
:

1997 switch (
sub
)

1999 case 
SUBLANG_LITHUANIAN_LITHUANIA
: return "lt_LT";

2002 case 
LANG_LUXEMBOURGISH
:

2003 switch (
sub
)

2005 case 
SUBLANG_LUXEMBOURGISH_LUXEMBOURG
: return "lb_LU";

2008 case 
LANG_MACEDONIAN
:

2009 switch (
sub
)

2011 case 
SUBLANG_MACEDONIAN_MACEDONIA
: return "mk_MK";

2014 case 
LANG_MALAY
:

2015 switch (
sub
)

2017 case 
SUBLANG_MALAY_MALAYSIA
: return "ms_MY";

2018 case 
SUBLANG_MALAY_BRUNEI_DARUSSALAM
: return "ms_BN";

2021 case 
LANG_MALAYALAM
:

2022 switch (
sub
)

2024 case 
SUBLANG_MALAYALAM_INDIA
: return "ml_IN";

2027 case 
LANG_MALTESE
:

2028 switch (
sub
)

2030 case 
SUBLANG_MALTESE_MALTA
: return "mt_MT";

2033 case 
LANG_MANIPURI
:

2035 switch (
sub
)

2037 case 
SUBLANG_DEFAULT
: return "mni_IN";

2040 case 
LANG_MAORI
:

2041 switch (
sub
)

2043 case 
SUBLANG_MAORI_NEW_ZEALAND
: return "mi_NZ";

2046 case 
LANG_MAPUDUNGUN
:

2047 switch (
sub
)

2049 case 
SUBLANG_MAPUDUNGUN_CHILE
: return "arn_CL";

2052 case 
LANG_MARATHI
:

2053 switch (
sub
)

2055 case 
SUBLANG_MARATHI_INDIA
: return "mr_IN";

2058 case 
LANG_MOHAWK
:

2059 switch (
sub
)

2061 case 
SUBLANG_MOHAWK_CANADA
: return "moh_CA";

2064 case 
LANG_MONGOLIAN
:

2065 switch (
sub
)

2067 case 
SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA
: case 0x1e: return "mn_MN";

2068 case 
SUBLANG_MONGOLIAN_PRC
: case 0x1f: return "mn_CN";

2071 case 
LANG_NEPALI
:

2072 switch (
sub
)

2074 case 
SUBLANG_NEPALI_NEPAL
: return "ne_NP";

2075 case 
SUBLANG_NEPALI_INDIA
: return "ne_IN";

2078 case 
LANG_NORWEGIAN
:

2079 switch (
sub
)

2082 case 
SUBLANG_NORWEGIAN_BOKMAL
: return "nb_NO";

2084 case 
SUBLANG_NORWEGIAN_NYNORSK
: return "nn_NO";

2087 case 
LANG_OCCITAN
:

2088 switch (
sub
)

2090 case 
SUBLANG_OCCITAN_FRANCE
: return "oc_FR";

2093 case 
LANG_ORIYA
:

2094 switch (
sub
)

2096 case 
SUBLANG_ORIYA_INDIA
: return "or_IN";

2099 case 
LANG_OROMO
:

2100 switch (
sub
)

2102 case 
SUBLANG_DEFAULT
: return "om_ET";

2105 case 
LANG_PAPIAMENTU
:

2106 switch (
sub
)

2108 case 
SUBLANG_DEFAULT
: return "pap_AN";

2111 case 
LANG_PASHTO
:

2112 switch (
sub
)

2114 case 
SUBLANG_PASHTO_AFGHANISTAN
: return "ps_AF";

2117 case 
LANG_POLISH
:

2118 switch (
sub
)

2120 case 
SUBLANG_POLISH_POLAND
: return "pl_PL";

2123 case 
LANG_PORTUGUESE
:

2124 switch (
sub
)

2128 case 
SUBLANG_PORTUGUESE_BRAZILIAN
: return "pt_BR";

2129 case 
SUBLANG_PORTUGUESE
: return "pt_PT";

2132 case 
LANG_PUNJABI
:

2133 switch (
sub
)

2135 case 
SUBLANG_PUNJABI_INDIA
: return "pa_IN";

2136 case 
SUBLANG_PUNJABI_PAKISTAN
: return "pa_PK";

2139 case 
LANG_QUECHUA
:

2141 switch (
sub
)

2143 case 
SUBLANG_QUECHUA_BOLIVIA
: return "qu_BO";

2144 case 
SUBLANG_QUECHUA_ECUADOR
: return "qu_EC";

2145 case 
SUBLANG_QUECHUA_PERU
: return "qu_PE";

2148 case 
LANG_ROMANIAN
:

2149 switch (
sub
)

2151 case 
SUBLANG_ROMANIAN_ROMANIA
: return "ro_RO";

2152 case 
SUBLANG_ROMANIAN_MOLDOVA
: return "ro_MD";

2155 case 
LANG_ROMANSH
:

2156 switch (
sub
)

2158 case 
SUBLANG_ROMANSH_SWITZERLAND
: return "rm_CH";

2161 case 
LANG_RUSSIAN
:

2162 switch (
sub
)

2164 case 
SUBLANG_RUSSIAN_RUSSIA
: return "ru_RU";

2165 case 
SUBLANG_RUSSIAN_MOLDAVIA
: return "ru_MD";

2168 case 
LANG_SAMI
:

2169 switch (
sub
)

2173 case 
SUBLANG_SAMI_NORTHERN_NORWAY
: return "se_NO";

2174 case 
SUBLANG_SAMI_NORTHERN_SWEDEN
: return "se_SE";

2175 case 
SUBLANG_SAMI_NORTHERN_FINLAND
: return "se_FI";

2178 case 
SUBLANG_SAMI_LULE_NORWAY
: return "smj_NO";

2179 case 
SUBLANG_SAMI_LULE_SWEDEN
: return "smj_SE";

2182 case 
SUBLANG_SAMI_SOUTHERN_NORWAY
: return "sma_NO";

2183 case 
SUBLANG_SAMI_SOUTHERN_SWEDEN
: return "sma_SE";

2186 case 
SUBLANG_SAMI_SKOLT_FINLAND
: return "sms_FI";

2189 case 
SUBLANG_SAMI_INARI_FINLAND
: return "smn_FI";

2192 case 
LANG_SANSKRIT
:

2193 switch (
sub
)

2195 case 
SUBLANG_SANSKRIT_INDIA
: return "sa_IN";

2198 case 
LANG_SCOTTISH_GAELIC
:

2199 switch (
sub
)

2201 case 
SUBLANG_DEFAULT
: return "gd_GB";

2204 case 
LANG_SINDHI
:

2205 switch (
sub
)

2207 case 
SUBLANG_SINDHI_INDIA
: return "sd_IN";

2208 case 
SUBLANG_SINDHI_PAKISTAN
: return "sd_PK";

2212 case 
LANG_SINHALESE
:

2213 switch (
sub
)

2215 case 
SUBLANG_SINHALESE_SRI_LANKA
: return "si_LK";

2218 case 
LANG_SLOVAK
:

2219 switch (
sub
)

2221 case 
SUBLANG_SLOVAK_SLOVAKIA
: return "sk_SK";

2224 case 
LANG_SLOVENIAN
:

2225 switch (
sub
)

2227 case 
SUBLANG_SLOVENIAN_SLOVENIA
: return "sl_SI";

2230 case 
LANG_SOMALI
:

2231 switch (
sub
)

2233 case 
SUBLANG_DEFAULT
: return "so_SO";

2236 case 
LANG_SORBIAN
:

2238 switch (
sub
)

2242 case 
SUBLANG_UPPER_SORBIAN_GERMANY
: return "hsb_DE";

2245 case 
SUBLANG_LOWER_SORBIAN_GERMANY
: return "dsb_DE";

2248 case 
LANG_SOTHO
:

2254 switch (
sub
)

2256 case 
SUBLANG_SOTHO_SOUTH_AFRICA
: return "nso_ZA";

2259 case 
LANG_SPANISH
:

2260 switch (
sub
)

2262 case 
SUBLANG_SPANISH
: return "es_ES";

2263 case 
SUBLANG_SPANISH_MEXICAN
: return "es_MX";

2264 case 
SUBLANG_SPANISH_MODERN
:

2266 case 
SUBLANG_SPANISH_GUATEMALA
: return "es_GT";

2267 case 
SUBLANG_SPANISH_COSTA_RICA
: return "es_CR";

2268 case 
SUBLANG_SPANISH_PANAMA
: return "es_PA";

2269 case 
SUBLANG_SPANISH_DOMINICAN_REPUBLIC
: return "es_DO";

2270 case 
SUBLANG_SPANISH_VENEZUELA
: return "es_VE";

2271 case 
SUBLANG_SPANISH_COLOMBIA
: return "es_CO";

2272 case 
SUBLANG_SPANISH_PERU
: return "es_PE";

2273 case 
SUBLANG_SPANISH_ARGENTINA
: return "es_AR";

2274 case 
SUBLANG_SPANISH_ECUADOR
: return "es_EC";

2275 case 
SUBLANG_SPANISH_CHILE
: return "es_CL";

2276 case 
SUBLANG_SPANISH_URUGUAY
: return "es_UY";

2277 case 
SUBLANG_SPANISH_PARAGUAY
: return "es_PY";

2278 case 
SUBLANG_SPANISH_BOLIVIA
: return "es_BO";

2279 case 
SUBLANG_SPANISH_EL_SALVADOR
: return "es_SV";

2280 case 
SUBLANG_SPANISH_HONDURAS
: return "es_HN";

2281 case 
SUBLANG_SPANISH_NICARAGUA
: return "es_NI";

2282 case 
SUBLANG_SPANISH_PUERTO_RICO
: return "es_PR";

2283 case 
SUBLANG_SPANISH_US
: return "es_US";

2286 case 
LANG_SUTU
:

2287 switch (
sub
)

2289 case 
SUBLANG_DEFAULT
: return "bnt_TZ";

2292 case 
LANG_SWAHILI
:

2293 switch (
sub
)

2295 case 
SUBLANG_SWAHILI_KENYA
: return "sw_KE";

2298 case 
LANG_SWEDISH
:

2299 switch (
sub
)

2301 case 
SUBLANG_SWEDISH_SWEDEN
: return "sv_SE";

2302 case 
SUBLANG_SWEDISH_FINLAND
: return "sv_FI";

2305 case 
LANG_SYRIAC
:

2306 switch (
sub
)

2308 case 
SUBLANG_SYRIAC_SYRIA
: return "syr_SY";

2311 case 
LANG_TAGALOG
:

2312 switch (
sub
)

2314 case 
SUBLANG_TAGALOG_PHILIPPINES
: return "tl_PH";

2317 case 
LANG_TAJIK
:

2318 switch (
sub
)

2321 case 
SUBLANG_TAJIK_TAJIKISTAN
: return "tg_TJ";

2324 case 
LANG_TAMAZIGHT
:

2326 switch (
sub
)

2329 case 
SUBLANG_TAMAZIGHT_ARABIC
: return "ber_MA@arabic";

2331 case 
SUBLANG_TAMAZIGHT_ALGERIA_LATIN
: return "ber_DZ@latin";

2334 case 
LANG_TAMIL
:

2335 switch (
sub
)

2337 case 
SUBLANG_TAMIL_INDIA
: return "ta_IN";

2340 case 
LANG_TATAR
:

2341 switch (
sub
)

2343 case 
SUBLANG_TATAR_RUSSIA
: return "tt_RU";

2346 case 
LANG_TELUGU
:

2347 switch (
sub
)

2349 case 
SUBLANG_TELUGU_INDIA
: return "te_IN";

2352 case 
LANG_THAI
:

2353 switch (
sub
)

2355 case 
SUBLANG_THAI_THAILAND
: return "th_TH";

2358 case 
LANG_TIBETAN
:

2359 switch (
sub
)

2361 case 
SUBLANG_TIBETAN_PRC
:

2365 case 
SUBLANG_TIBETAN_BHUTAN
: return "bo_BT";

2368 case 
LANG_TIGRINYA
:

2369 switch (
sub
)

2371 case 
SUBLANG_TIGRINYA_ETHIOPIA
: return "ti_ET";

2372 case 
SUBLANG_TIGRINYA_ERITREA
: return "ti_ER";

2375 case 
LANG_TSONGA
:

2376 switch (
sub
)

2378 case 
SUBLANG_DEFAULT
: return "ts_ZA";

2381 case 
LANG_TSWANA
:

2383 switch (
sub
)

2385 case 
SUBLANG_TSWANA_SOUTH_AFRICA
: return "tn_ZA";

2388 case 
LANG_TURKISH
:

2389 switch (
sub
)

2391 case 
SUBLANG_TURKISH_TURKEY
: return "tr_TR";

2394 case 
LANG_TURKMEN
:

2395 switch (
sub
)

2397 case 
SUBLANG_TURKMEN_TURKMENISTAN
: return "tk_TM";

2400 case 
LANG_UIGHUR
:

2401 switch (
sub
)

2403 case 
SUBLANG_UIGHUR_PRC
: return "ug_CN";

2406 case 
LANG_UKRAINIAN
:

2407 switch (
sub
)

2409 case 
SUBLANG_UKRAINIAN_UKRAINE
: return "uk_UA";

2412 case 
LANG_URDU
:

2413 switch (
sub
)

2415 case 
SUBLANG_URDU_PAKISTAN
: return "ur_PK";

2416 case 
SUBLANG_URDU_INDIA
: return "ur_IN";

2419 case 
LANG_UZBEK
:

2420 switch (
sub
)

2423 case 
SUBLANG_UZBEK_LATIN
: return "uz_UZ";

2425 case 
SUBLANG_UZBEK_CYRILLIC
: return "uz_UZ@cyrillic";

2428 case 
LANG_VENDA
:

2429 switch (
sub
)

2431 case 
SUBLANG_DEFAULT
: return "ve_ZA";

2434 case 
LANG_VIETNAMESE
:

2435 switch (
sub
)

2437 case 
SUBLANG_VIETNAMESE_VIETNAM
: return "vi_VN";

2440 case 
LANG_WELSH
:

2441 switch (
sub
)

2443 case 
SUBLANG_WELSH_UNITED_KINGDOM
: return "cy_GB";

2446 case 
LANG_WOLOF
:

2447 switch (
sub
)

2449 case 
SUBLANG_WOLOF_SENEGAL
: return "wo_SN";

2452 case 
LANG_XHOSA
:

2453 switch (
sub
)

2455 case 
SUBLANG_XHOSA_SOUTH_AFRICA
: return "xh_ZA";

2458 case 
LANG_YAKUT
:

2459 switch (
sub
)

2461 case 
SUBLANG_YAKUT_RUSSIA
: return "sah_RU";

2464 case 
LANG_YI
:

2465 switch (
sub
)

2467 case 
SUBLANG_YI_PRC
: return "ii_CN";

2470 case 
LANG_YIDDISH
:

2471 switch (
sub
)

2473 case 
SUBLANG_DEFAULT
: return "yi_IL";

2476 case 
LANG_YORUBA
:

2477 switch (
sub
)

2479 case 
SUBLANG_YORUBA_NIGERIA
: return "yo_NG";

2482 case 
LANG_ZULU
:

2483 switch (
sub
)

2485 case 
SUBLANG_ZULU_SOUTH_AFRICA
: return "zu_ZA";

2491 
	}
}

2493 #if !
defined
 
IN_LIBINTL


2497 
	$gl_locale_name_from_win32_LCID
 (
LCID
 
lcid
)

2499 
LANGID
 
langid
;

2502 
langid
 = 
	`LANGIDFROMLCID
 (
lcid
);

2504 return 
	`gl_locale_name_from_win32_LANGID
 (
langid
);

2505 
	}
}

2510 #if 
HAVE_USELOCALE


2515 #define 
	#SIZE_BITS
 (sizeof (
size_t
) * 
CHAR_BIT
)

	)

2520 static 
size_t


2521 
	$string_hash
 (const void *
x
)

2523 const char *
s
 = (const char *) 
x
;

2524 
size_t
 
h
 = 0;

2526 for (; *
s
; s++)

2527 
h
 = *
s
 + ((h << 9) | (h >> (
SIZE_BITS
 - 9)));

2529 return 
h
;

2530 
	}
}

2536 struct 
	shash_node


2538 struct 
hash_node
 * volatile 
	mnext
;

2539 char 
	mcontents
[100];

2542 #define 
	#HASH_TABLE_SIZE
 257

	)

2543 static struct 
hash_node
 * volatile 
	gstruniq_hash_table
[
HASH_TABLE_SIZE
]

2548 
	$gl_lock_define_initialized
(static, 
struniq_lock
)

2553 
	$struniq
 (const char *
string
)

2555 
size_t
 
hashcode
 = 
	`string_hash
 (
string
);

2556 
size_t
 
slot
 = 
hashcode
 % 
HASH_TABLE_SIZE
;

2557 
size_t
 
size
;

2558 struct 
hash_node
 *
new_node
;

2559 struct 
hash_node
 *
p
;

2560 for (
p
 = 
struniq_hash_table
[
slot
]; p != 
NULL
; p = p->
next
)

2561 if (
	`strcmp
 (
p
->
contents
, 
string
) == 0)

2562 return 
p
->
contents
;

2563 
size
 = 
	`strlen
 (
string
) + 1;

2564 
new_node
 =

2565 (struct 
hash_node
 *)

2566 
	`malloc
 (
	`offsetof
 (struct 
hash_node
, 
contents
[0]) + 
size
);

2567 if (
new_node
 == 
NULL
)

2570 
	`memcpy
 (
new_node
->
contents
, 
string
, 
size
);

2572 
	`gl_lock_lock
 (
struniq_lock
);

2575 for (
p
 = 
struniq_hash_table
[
slot
]; p != 
NULL
; p = p->
next
)

2576 if (
	`strcmp
 (
p
->
contents
, 
string
) == 0)

2578 
	`free
 (
new_node
);

2579 
new_node
 = 
p
;

2580 goto 
done
;

2584 
new_node
->
next
 = 
struniq_hash_table
[
slot
];

2585 
struniq_hash_table
[
slot
] = 
new_node
;

2586 
done
:

2588 
	`gl_lock_unlock
 (
struniq_lock
);

2589 return 
new_node
->
contents
;

2590 
	}
}

2595 #if 
defined
 
IN_LIBINTL
 || 
HAVE_USELOCALE


2599 #if !
defined
 
IN_LIBINTL


2603 
	$gl_locale_name_thread_unsafe
 (int 
category
, const char *
categoryname
)

2605 #if 
HAVE_USELOCALE


2607 
locale_t
 
thread_locale
 = 
	`uselocale
 (
NULL
);

2608 if (
thread_locale
 != 
LC_GLOBAL_LOCALE
)

2610 #if 
__GLIBC__
 >= 2 && !
defined
 
__UCLIBC__


2614 const char *
name
 =

2615 
	`nl_langinfo
 (
	`_NL_ITEM
 ((
category
), 
	`_NL_ITEM_INDEX
 (-1)));

2616 if (
name
[0] == '\0')

2619 
name
 = 
thread_locale
->
__names
[
category
];

2620 return 
name
;

2622 #if 
defined
 
__APPLE__
 && defined 
__MACH__


2628 struct 
	s_xlocale_part1_v0


2630 
int32_t
 
__refcount
;

2631 void (*
__free_extra
)(void *);

2632 
__darwin_mbstate_t
 
__mbs
[10];

2633 
int64_t
 
__magic
;

2635 struct 
	s_xlocale_part1_v1


2637 
int32_t
 
__refcount
;

2638 void (*
__free_extra
)(void *);

2639 
__darwin_mbstate_t
 
__mbs
[10];

2640  int 
__lock
;

2641 
int64_t
 
__magic
;

2643 struct 
	s_xlocale_part2


2645 
int64_t
 
__magic
;

2646 unsigned char 
__collate_load_error
;

2647 unsigned char 
__collate_substitute_nontrivial
;

2648 unsigned char 
_messages_using_locale
;

2649 unsigned char 
_monetary_using_locale
;

2650 unsigned char 
_numeric_using_locale
;

2651 unsigned char 
_time_using_locale
;

2652 unsigned char 
__mlocale_changed
;

2653 unsigned char 
__nlocale_changed
;

2654 unsigned char 
__numeric_fp_cvt
;

2655 struct 
__xlocale_st_collate
 *
__lc_collate
;

2656 struct 
__xlocale_st_runelocale
 *
__lc_ctype
;

2657 struct 
__xlocale_st_messages
 *
__lc_messages
;

2658 struct 
__xlocale_st_monetary
 *
__lc_monetary
;

2659 struct 
__xlocale_st_numeric
 *
__lc_numeric
;

2660 struct 
_xlocale
 *
__lc_numeric_loc
;

2661 struct 
__xlocale_st_time
 *
__lc_time
;

2664 struct 
	s__xlocale_st_collate


2666 
int32_t
 
__refcount
;

2667 void (*
__free_extra
)(void *);

2668 char 
__encoding
[32];

2671 struct 
	s__xlocale_st_runelocale


2673 
int32_t
 
__refcount
;

2674 void (*
__free_extra
)(void *);

2675 char 
__ctype_encoding
[32];

2678 struct 
	s__xlocale_st_messages


2680 
int32_t
 
__refcount
;

2681 void (*
__free_extra
)(void *);

2682 char *
_messages_locale_buf
;

2685 struct 
	s__xlocale_st_monetary


2687 
int32_t
 
__refcount
;

2688 void (*
__free_extra
)(void *);

2689 char *
_monetary_locale_buf
;

2692 struct 
	s__xlocale_st_numeric
 {

2693 
int32_t
 
__refcount
;

2694 void (*
__free_extra
)(void *);

2695 char *
_numeric_locale_buf
;

2698 struct 
	s__xlocale_st_time
 {

2699 
int32_t
 
__refcount
;

2700 void (*
__free_extra
)(void *);

2701 char *
_time_locale_buf
;

2704 struct 
_xlocale_part2
 *
tlp
;

2705 if (((struct 
_xlocale_part1_v0
 *) 
thread_locale
)->
__magic


2708 
tlp
 =

2709 (struct 
_xlocale_part2
 *)

2710 &((struct 
_xlocale_part1_v0
 *) 
thread_locale
)->
__magic
;

2711 else if (((struct 
_xlocale_part1_v1
 *) 
thread_locale
)->
__magic


2714 
tlp
 =

2715 (struct 
_xlocale_part2
 *)

2716 &((struct 
_xlocale_part1_v1
 *) 
thread_locale
)->
__magic
;

2721 switch (
category
)

2723 case 
LC_CTYPE
:

2724 return 
tlp
->
__lc_ctype
->
__ctype_encoding
;

2725 case 
LC_NUMERIC
:

2726 return 
tlp
->
_numeric_using_locale


2727 ? 
tlp
->
__lc_numeric
->
_numeric_locale_buf


2729 case 
LC_TIME
:

2730 return 
tlp
->
_time_using_locale


2731 ? 
tlp
->
__lc_time
->
_time_locale_buf


2733 case 
LC_COLLATE
:

2734 return !
tlp
->
__collate_load_error


2735 ? 
tlp
->
__lc_collate
->
__encoding


2737 case 
LC_MONETARY
:

2738 return 
tlp
->
_monetary_using_locale


2739 ? 
tlp
->
__lc_monetary
->
_monetary_locale_buf


2741 case 
LC_MESSAGES
:

2742 return 
tlp
->
_messages_using_locale


2743 ? 
tlp
->
__lc_messages
->
_messages_locale_buf


2752 return 
NULL
;

2753 
	}
}

2758 
	$gl_locale_name_thread
 (int 
category
, const char *
categoryname
)

2760 #if 
HAVE_USELOCALE


2761 const char *
name
 = 
	`gl_locale_name_thread_unsafe
 (
category
, 
categoryname
);

2762 if (
name
 != 
NULL
)

2763 return 
	`struniq
 (
name
);

2765 return 
NULL
;

2766 
	}
}

2774 #if 
defined
 
_LIBC
 || ((defined 
__GLIBC__
 && __GLIBC__ >= 2) && !defined 
__UCLIBC__
)

2775 #define 
	#HAVE_LOCALE_NULL


	)

2779 
	$gl_locale_name_posix
 (int 
category
, const char *
categoryname
)

2783 #if 
defined
 
HAVE_SETLOCALE
 && defined 
HAVE_LC_MESSAGES
 && defined 
HAVE_LOCALE_NULL


2784 return 
	`setlocale
 (
category
, 
NULL
);

2803 return 
	`gl_locale_name_environ
 (
category
, 
categoryname
);

2805 
	}
}

2808 
	$gl_locale_name_environ
 (int 
category
, const char *
categoryname
)

2810 const char *
retval
;

2813 
retval
 = 
	`getenv
 ("LC_ALL");

2814 if (
retval
 != 
NULL
 && retval[0] != '\0')

2815 return 
retval
;

2817 
retval
 = 
	`getenv
 (
categoryname
);

2818 if (
retval
 != 
NULL
 && retval[0] != '\0')

2819 return 
retval
;

2821 
retval
 = 
	`getenv
 ("LANG");

2822 if (
retval
 != 
NULL
 && retval[0] != '\0')

2824 #if 
HAVE_CFLOCALECOPYCURRENT
 || 
HAVE_CFPREFERENCESCOPYAPPVALUE


2827 if (
	`strcmp
 (
retval
, "UTF-8") != 0)

2829 #if 
defined
 
__CYGWIN__


2832 if (
	`strcmp
 (
retval
, "C.UTF-8") != 0)

2834 return 
retval
;

2837 return 
NULL
;

2838 
	}
}

2841 
	$gl_locale_name_default
 (void)

2871 #if !(
HAVE_CFLOCALECOPYCURRENT
 || 
HAVE_CFPREFERENCESCOPYAPPVALUE
 || 
defined
 
WIN32_NATIVE
 || defined 
__CYGWIN__
)

2884 #if 
HAVE_CFLOCALECOPYCURRENT
 || 
HAVE_CFPREFERENCESCOPYAPPVALUE


2888 static const char *
cached_localename
;

2890 if (
cached_localename
 == 
NULL
)

2892 char 
namebuf
[256];

2893 #if 
HAVE_CFLOCALECOPYCURRENT


2894 
CFLocaleRef
 
locale
 = 
	`CFLocaleCopyCurrent
 ();

2895 
CFStringRef
 
name
 = 
	`CFLocaleGetIdentifier
 (
locale
);

2897 if (
	`CFStringGetCString
 (
name
, 
namebuf
, sizeof (namebuf),

2898 
kCFStringEncodingASCII
))

2900 
	`gl_locale_name_canonicalize
 (
namebuf
);

2901 
cached_localename
 = 
	`strdup
 (
namebuf
);

2903 
	`CFRelease
 (
locale
);

2904 #elif 
HAVE_CFPREFERENCESCOPYAPPVALUE


2905 
CFTypeRef
 
value
 =

2906 
	`CFPreferencesCopyAppValue
 (
	`CFSTR
 ("AppleLocale"),

2907 
kCFPreferencesCurrentApplication
);

2908 if (
value
 != 
NULL


2909 && 
	`CFGetTypeID
 (
value
) == 
	`CFStringGetTypeID
 ()

2910 && 
	`CFStringGetCString
 ((
CFStringRef
)
value
,

2911 
namebuf
, sizeof (namebuf),

2912 
kCFStringEncodingASCII
))

2914 
	`gl_locale_name_canonicalize
 (
namebuf
);

2915 
cached_localename
 = 
	`strdup
 (
namebuf
);

2918 if (
cached_localename
 == 
NULL
)

2919 
cached_localename
 = "C";

2921 return 
cached_localename
;

2926 #if 
defined
 
WIN32_NATIVE
 || defined 
__CYGWIN__


2928 
LCID
 
lcid
;

2931 
lcid
 = 
	`GetThreadLocale
 ();

2933 return 
	`gl_locale_name_from_win32_LCID
 (
lcid
);

2937 
	}
}

2946 
	$gl_locale_name
 (int 
category
, const char *
categoryname
)

2948 const char *
retval
;

2950 
retval
 = 
	`gl_locale_name_thread
 (
category
, 
categoryname
);

2951 if (
retval
 != 
NULL
)

2952 return 
retval
;

2954 
retval
 = 
	`gl_locale_name_posix
 (
category
, 
categoryname
);

2955 if (
retval
 != 
NULL
)

2956 return 
retval
;

2958 return 
	`gl_locale_name_default
 ();

2959 
	}
}

	@gnulib-tests/localename.h

19 #ifndef 
_GL_LOCALENAME_H


20 #define 
	#_GL_LOCALENAME_H


	)

22 #ifdef 
__cplusplus


39 extern const char * 
gl_locale_name
 (int 
category
, const char *
categoryname
);

52 extern const char * 
gl_locale_name_thread
 (int 
category
, const char *
categoryname
);

66 extern const char * 
gl_locale_name_posix
 (int 
category
, const char *
categoryname
);

73 extern const char * 
gl_locale_name_environ
 (int 
category
, const char *
categoryname
);

90 extern const char * 
gl_locale_name_default
 (void);

93 #ifdef 
__cplusplus


	@gnulib-tests/lstat.c

25 #define 
	#__need_system_sys_stat_h


	)

26 #include 
	~<config.h
>

28 #if !
HAVE_LSTAT


32 typedef int 
	tdummy
;

36 #include 
	~<sys/types.h
>

37 #include 
	~<sys/stat.h
>

38 #undef 
__need_system_sys_stat_h


40 static 
inline
 int

41 
	$orig_lstat
 (const char *
filename
, struct 
stat
 *
buf
)

43 return 
	`lstat
 (
filename
, 
buf
);

44 
	}
}

50 #include 
	~"sys/stat.h
"

52 #include 
	~<string.h
>

53 #include 
	~<errno.h
>

69 
	$rpl_lstat
 (const char *
file
, struct 
stat
 *
sbuf
)

71 
size_t
 
len
;

72 int 
lstat_result
 = 
	`orig_lstat
 (
file
, 
sbuf
);

74 if (
lstat_result
 != 0)

75 return 
lstat_result
;

82 
len
 = 
	`strlen
 (
file
);

83 if (
file
[
len
 - 1] != '/' || 
	`S_ISDIR
 (
sbuf
->
st_mode
))

91 if (!
	`S_ISLNK
 (
sbuf
->
st_mode
))

93 
errno
 = 
ENOTDIR
;

96 return 
	`stat
 (
file
, 
sbuf
);

97 
	}
}

	@gnulib-tests/macros.h

23 #include 
	~<stdio.h
>

24 #include 
	~<stdlib.h
>

28 #ifndef 
ASSERT_STREAM


29 #define 
	#ASSERT_STREAM
 
stderr


	)

48 #define 
	#ASSERT
(
expr
) \

51 if (!(
expr
)) \

53 
	`fprintf
 (
ASSERT_STREAM
, "%s:%d: assertion failed\n", \

54 
__FILE__
, 
__LINE__
); \

55 
	`fflush
 (
ASSERT_STREAM
); \

56 
	`abort
 (); \

59 while (0)

	)

66 #define 
	#SIZEOF
(
array
) (sizeof (array) / sizeof (array[0]))

	)

70 #define 
	#STREQ
(
a
, 
b
) (
	`strcmp
 (a, b) == 0)

	)

	@gnulib-tests/offtostr.c

3 #define 
	#anytostr
 
offtostr


	)

4 #define 
	#inttype
 
off_t


	)

5 #include 
	~"anytostr.c
"

	@gnulib-tests/printf-args.c

26 #ifndef 
PRINTF_FETCHARGS


27 #include 
	~<config.h
>

31 #ifndef 
PRINTF_FETCHARGS


32 #include 
	~"printf-args.h
"

35 #ifdef 
STATIC


36 
	gSTATIC


39 
	$PRINTF_FETCHARGS
 (
va_list
 
args
, 
arguments
 *
a
)

41 
size_t
 
i
;

42 
argument
 *
ap
;

44 for (
i
 = 0, 
ap
 = &
a
->
arg
[0]; i < a->
count
; i++, ap++)

45 switch (
ap
->
type
)

47 case 
TYPE_SCHAR
:

48 
ap
->
a
.
a_schar
 = 
	`va_arg
 (
args
, int);

50 case 
TYPE_UCHAR
:

51 
ap
->
a
.
a_uchar
 = 
	`va_arg
 (
args
, int);

53 case 
TYPE_SHORT
:

54 
ap
->
a
.
a_short
 = 
	`va_arg
 (
args
, int);

56 case 
TYPE_USHORT
:

57 
ap
->
a
.
a_ushort
 = 
	`va_arg
 (
args
, int);

59 case 
TYPE_INT
:

60 
ap
->
a
.
a_int
 = 
	`va_arg
 (
args
, int);

62 case 
TYPE_UINT
:

63 
ap
->
a
.
a_uint
 = 
	`va_arg
 (
args
, unsigned int);

65 case 
TYPE_LONGINT
:

66 
ap
->
a
.
a_longint
 = 
	`va_arg
 (
args
, long int);

68 case 
TYPE_ULONGINT
:

69 
ap
->
a
.
a_ulongint
 = 
	`va_arg
 (
args
, unsigned long int);

71 #if 
HAVE_LONG_LONG_INT


72 case 
TYPE_LONGLONGINT
:

73 
ap
->
a
.
a_longlongint
 = 
	`va_arg
 (
args
, long long int);

75 case 
TYPE_ULONGLONGINT
:

76 
ap
->
a
.
a_ulonglongint
 = 
	`va_arg
 (
args
, unsigned long long int);

79 case 
TYPE_DOUBLE
:

80 
ap
->
a
.
a_double
 = 
	`va_arg
 (
args
, double);

82 case 
TYPE_LONGDOUBLE
:

83 
ap
->
a
.
a_longdouble
 = 
	`va_arg
 (
args
, long double);

85 case 
TYPE_CHAR
:

86 
ap
->
a
.
a_char
 = 
	`va_arg
 (
args
, int);

88 #if 
HAVE_WINT_T


89 case 
TYPE_WIDE_CHAR
:

93 
ap
->
a
.
a_wide_char
 =

94 (sizeof (
wint_t
) < sizeof (int)

95 ? (
wint_t
) 
	`va_arg
 (
args
, int)

96 : 
	`va_arg
 (
args
, 
wint_t
));

99 case 
TYPE_STRING
:

100 
ap
->
a
.
a_string
 = 
	`va_arg
 (
args
, const char *);

104 if (
ap
->
a
.
a_string
 == 
NULL
)

105 
ap
->
a
.
a_string
 = "(NULL)";

107 #if 
HAVE_WCHAR_T


108 case 
TYPE_WIDE_STRING
:

109 
ap
->
a
.
a_wide_string
 = 
	`va_arg
 (
args
, const 
wchar_t
 *);

113 if (
ap
->
a
.
a_wide_string
 == 
NULL
)

115 static const 
wchar_t
 
wide_null_string
[] =

117 (
wchar_t
)'(',

118 (
wchar_t
)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',

119 (
wchar_t
)')',

120 (
wchar_t
)0

122 
ap
->
a
.
a_wide_string
 = 
wide_null_string
;

126 case 
TYPE_POINTER
:

127 
ap
->
a
.
a_pointer
 = 
	`va_arg
 (
args
, void *);

129 case 
TYPE_COUNT_SCHAR_POINTER
:

130 
ap
->
a
.
a_count_schar_pointer
 = 
	`va_arg
 (
args
, signed char *);

132 case 
TYPE_COUNT_SHORT_POINTER
:

133 
ap
->
a
.
a_count_short_pointer
 = 
	`va_arg
 (
args
, short *);

135 case 
TYPE_COUNT_INT_POINTER
:

136 
ap
->
a
.
a_count_int_pointer
 = 
	`va_arg
 (
args
, int *);

138 case 
TYPE_COUNT_LONGINT_POINTER
:

139 
ap
->
a
.
a_count_longint_pointer
 = 
	`va_arg
 (
args
, long int *);

141 #if 
HAVE_LONG_LONG_INT


142 case 
TYPE_COUNT_LONGLONGINT_POINTER
:

143 
ap
->
a
.
a_count_longlongint_pointer
 = 
	`va_arg
 (
args
, long long int *);

146 #if 
ENABLE_UNISTDIO


148 case 
TYPE_U8_STRING
:

149 
ap
->
a
.
a_u8_string
 = 
	`va_arg
 (
args
, const 
uint8_t
 *);

153 if (
ap
->
a
.
a_u8_string
 == 
NULL
)

155 static const 
uint8_t
 
u8_null_string
[] =

157 
ap
->
a
.
a_u8_string
 = 
u8_null_string
;

160 case 
TYPE_U16_STRING
:

161 
ap
->
a
.
a_u16_string
 = 
	`va_arg
 (
args
, const 
uint16_t
 *);

165 if (
ap
->
a
.
a_u16_string
 == 
NULL
)

167 static const 
uint16_t
 
u16_null_string
[] =

169 
ap
->
a
.
a_u16_string
 = 
u16_null_string
;

172 case 
TYPE_U32_STRING
:

173 
ap
->
a
.
a_u32_string
 = 
	`va_arg
 (
args
, const 
uint32_t
 *);

177 if (
ap
->
a
.
a_u32_string
 == 
NULL
)

179 static const 
uint32_t
 
u32_null_string
[] =

181 
ap
->
a
.
a_u32_string
 = 
u32_null_string
;

190 
	}
}

	@gnulib-tests/printf-args.h

21 #ifndef 
_PRINTF_ARGS_H


22 #define 
	#_PRINTF_ARGS_H


	)

30 #ifndef 
PRINTF_FETCHARGS


31 #define 
	#PRINTF_FETCHARGS
 
printf_fetchargs


	)

35 #include 
	~<stddef.h
>

38 #if 
HAVE_WCHAR_T


39 #include 
	~<stddef.h
>

43 #if 
HAVE_WINT_T


44 #include 
	~<wchar.h
>

48 #include 
	~<stdarg.h
>

54 
	mTYPE_NONE
,

55 
	mTYPE_SCHAR
,

56 
	mTYPE_UCHAR
,

57 
	mTYPE_SHORT
,

58 
	mTYPE_USHORT
,

59 
	mTYPE_INT
,

60 
	mTYPE_UINT
,

61 
	mTYPE_LONGINT
,

62 
	mTYPE_ULONGINT
,

63 #if 
HAVE_LONG_LONG_INT


64 
	mTYPE_LONGLONGINT
,

65 
	mTYPE_ULONGLONGINT
,

67 
	mTYPE_DOUBLE
,

68 
	mTYPE_LONGDOUBLE
,

69 
	mTYPE_CHAR
,

70 #if 
HAVE_WINT_T


71 
	mTYPE_WIDE_CHAR
,

73 
	mTYPE_STRING
,

74 #if 
HAVE_WCHAR_T


75 
	mTYPE_WIDE_STRING
,

77 
	mTYPE_POINTER
,

78 
	mTYPE_COUNT_SCHAR_POINTER
,

79 
	mTYPE_COUNT_SHORT_POINTER
,

80 
	mTYPE_COUNT_INT_POINTER
,

81 
	mTYPE_COUNT_LONGINT_POINTER


82 #if 
HAVE_LONG_LONG_INT


83 , 
	mTYPE_COUNT_LONGLONGINT_POINTER


85 #if 
ENABLE_UNISTDIO


87 , 
	mTYPE_U8_STRING


88 , 
	mTYPE_U16_STRING


89 , 
	mTYPE_U32_STRING


91 } 
	targ_type
;

96 
arg_type
 
	mtype
;

99 signed char 
	ma_schar
;

100 unsigned char 
	ma_uchar
;

101 short 
	ma_short
;

102 unsigned short 
	ma_ushort
;

103 int 
	ma_int
;

104 unsigned int 
	ma_uint
;

105 long int 
	ma_longint
;

106 unsigned long int 
	ma_ulongint
;

107 #if 
HAVE_LONG_LONG_INT


108 long long int 
	ma_longlongint
;

109 unsigned long long int 
	ma_ulonglongint
;

111 float 
	ma_float
;

112 double 
	ma_double
;

113 long double 
	ma_longdouble
;

114 int 
	ma_char
;

115 #if 
HAVE_WINT_T


116 
wint_t
 
	ma_wide_char
;

118 const char* 
	ma_string
;

119 #if 
HAVE_WCHAR_T


120 const 
wchar_t
* 
	ma_wide_string
;

122 void* 
	ma_pointer
;

123 signed char * 
	ma_count_schar_pointer
;

124 short * 
	ma_count_short_pointer
;

125 int * 
	ma_count_int_pointer
;

126 long int * 
	ma_count_longint_pointer
;

127 #if 
HAVE_LONG_LONG_INT


128 long long int * 
	ma_count_longlongint_pointer
;

130 #if 
ENABLE_UNISTDIO


132 const 
uint8_t
 * 
	ma_u8_string
;

133 const 
uint16_t
 * 
	ma_u16_string
;

134 const 
uint32_t
 * 
	ma_u32_string
;

137 
	ma
;

139 
	targument
;

142 #define 
	#N_DIRECT_ALLOC_ARGUMENTS
 7

	)

146 
size_t
 
	mcount
;

147 
argument
 *
	marg
;

148 
argument
 
	mdirect_alloc_arg
[
N_DIRECT_ALLOC_ARGUMENTS
];

150 
	targuments
;

154 #ifdef 
STATIC


155 
	gSTATIC


159 int 
PRINTF_FETCHARGS
 (
va_list
 
args
, 
arguments
 *
a
);

	@gnulib-tests/printf-parse.c

33 #ifndef 
PRINTF_PARSE


34 #include 
	~<config.h
>

38 #ifndef 
PRINTF_PARSE


39 #include 
	~"printf-parse.h
"

43 #ifndef 
PRINTF_PARSE


44 #define 
	#PRINTF_PARSE
 
printf_parse


	)

45 #define 
	#CHAR_T
 char

	)

46 #define 
	#DIRECTIVE
 
char_directive


	)

47 #define 
	#DIRECTIVES
 
char_directives


	)

51 #include 
	~<stddef.h
>

54 #if 
defined
 
IN_LIBINTL
 || defined 
IN_LIBASPRINTF


55 #if 
HAVE_STDINT_H_WITH_UINTMAX


56 #include 
	~<stdint.h
>

58 #if 
HAVE_INTTYPES_H_WITH_UINTMAX


59 #include 
	~<inttypes.h
>

62 #include 
	~<stdint.h
>

66 #include 
	~<stdlib.h
>

69 #include 
	~<string.h
>

72 #include 
	~<errno.h
>

75 #include 
	~"xsize.h
"

77 #if 
CHAR_T_ONLY_ASCII


79 #include 
	~"c-ctype.h
"

82 #ifdef 
STATIC


83 
	gSTATIC


86 
	$PRINTF_PARSE
 (const 
CHAR_T
 *
format
, 
DIRECTIVES
 *
d
, 
arguments
 *
a
)

88 const 
CHAR_T
 *
cp
 = 
format
;

89 
size_t
 
arg_posn
 = 0;

90 
size_t
 
d_allocated
;

91 
size_t
 
a_allocated
;

92 
size_t
 
max_width_length
 = 0;

93 
size_t
 
max_precision_length
 = 0;

95 
d
->
count
 = 0;

96 
d_allocated
 = 
N_DIRECT_ALLOC_DIRECTIVES
;

97 
d
->
dir
 = d->
direct_alloc_dir
;

99 
a
->
count
 = 0;

100 
a_allocated
 = 
N_DIRECT_ALLOC_ARGUMENTS
;

101 
a
->
arg
 = a->
direct_alloc_arg
;

103 #define 
	#REGISTER_ARG
(
_index_
,
_type_
) \

105 
size_t
 
n
 = (
_index_
); \

106 if (
n
 >= 
a_allocated
) \

108 
size_t
 
memory_size
; \

109 
argument
 *
memory
; \

111 
a_allocated
 = 
	`xtimes
 (a_allocated, 2); \

112 if (
a_allocated
 <= 
n
) \

113 
a_allocated
 = 
	`xsum
 (
n
, 1); \

114 
memory_size
 = 
	`xtimes
 (
a_allocated
, sizeof (
argument
)); \

115 if (
	`size_overflow_p
 (
memory_size
)) \

117 goto 
out_of_memory
; \

118 
memory
 = (
argument
 *) (
a
->
arg
 != a->
direct_alloc_arg
 \

119 ? 
	`realloc
 (
a
->
arg
, 
memory_size
) \

120 : 
	`malloc
 (
memory_size
)); \

121 if (
memory
 == 
NULL
) \

123 goto 
out_of_memory
; \

124 if (
a
->
arg
 == a->
direct_alloc_arg
) \

125 
	`memcpy
 (
memory
, 
a
->
arg
, a->
count
 * sizeof (
argument
)); \

126 
a
->
arg
 = 
memory
; \

128 while (
a
->
count
 <= 
n
) \

129 
a
->
arg
[a->
count
++].
type
 = 
TYPE_NONE
; \

130 if (
a
->
arg
[
n
].
type
 == 
TYPE_NONE
) \

131 
a
->
arg
[
n
].
type
 = (
_type_
); \

132 else if (
a
->
arg
[
n
].
type
 != (
_type_
)) \

134 goto 
error
; \

135 }

	)

137 while (*
cp
 != '\0')

139 
CHAR_T
 
c
 = *
cp
++;

140 if (
c
 == '%')

142 
size_t
 
arg_index
 = 
ARG_NONE
;

143 
DIRECTIVE
 *
dp
 = &
d
->
dir
[d->
count
];

146 
dp
->
dir_start
 = 
cp
 - 1;

147 
dp
->
flags
 = 0;

148 
dp
->
width_start
 = 
NULL
;

149 
dp
->
width_end
 = 
NULL
;

150 
dp
->
width_arg_index
 = 
ARG_NONE
;

151 
dp
->
precision_start
 = 
NULL
;

152 
dp
->
precision_end
 = 
NULL
;

153 
dp
->
precision_arg_index
 = 
ARG_NONE
;

154 
dp
->
arg_index
 = 
ARG_NONE
;

157 if (*
cp
 >= '0' && *cp <= '9')

159 const 
CHAR_T
 *
np
;

161 for (
np
 = 
cp
; *np >= '0' && *np <= '9'; np++)

163 if (*
np
 == '$')

165 
size_t
 
n
 = 0;

167 for (
np
 = 
cp
; *np >= '0' && *np <= '9'; np++)

168 
n
 = 
	`xsum
 (
	`xtimes
 (n, 10), *
np
 - '0');

169 if (
n
 == 0)

171 goto 
error
;

172 if (
	`size_overflow_p
 (
n
))

174 goto 
error
;

175 
arg_index
 = 
n
 - 1;

176 
cp
 = 
np
 + 1;

183 if (*
cp
 == '\'')

185 
dp
->
flags
 |= 
FLAG_GROUP
;

186 
cp
++;

188 else if (*
cp
 == '-')

190 
dp
->
flags
 |= 
FLAG_LEFT
;

191 
cp
++;

193 else if (*
cp
 == '+')

195 
dp
->
flags
 |= 
FLAG_SHOWSIGN
;

196 
cp
++;

198 else if (*
cp
 == ' ')

200 
dp
->
flags
 |= 
FLAG_SPACE
;

201 
cp
++;

203 else if (*
cp
 == '#')

205 
dp
->
flags
 |= 
FLAG_ALT
;

206 
cp
++;

208 else if (*
cp
 == '0')

210 
dp
->
flags
 |= 
FLAG_ZERO
;

211 
cp
++;

213 #if 
__GLIBC__
 >= 2 && !
defined
 
__UCLIBC__


214 else if (*
cp
 == 'I')

216 
dp
->
flags
 |= 
FLAG_LOCALIZED
;

217 
cp
++;

225 if (*
cp
 == '*')

227 
dp
->
width_start
 = 
cp
;

228 
cp
++;

229 
dp
->
width_end
 = 
cp
;

230 if (
max_width_length
 < 1)

231 
max_width_length
 = 1;

234 if (*
cp
 >= '0' && *cp <= '9')

236 const 
CHAR_T
 *
np
;

238 for (
np
 = 
cp
; *np >= '0' && *np <= '9'; np++)

240 if (*
np
 == '$')

242 
size_t
 
n
 = 0;

244 for (
np
 = 
cp
; *np >= '0' && *np <= '9'; np++)

245 
n
 = 
	`xsum
 (
	`xtimes
 (n, 10), *
np
 - '0');

246 if (
n
 == 0)

248 goto 
error
;

249 if (
	`size_overflow_p
 (
n
))

251 goto 
error
;

252 
dp
->
width_arg_index
 = 
n
 - 1;

253 
cp
 = 
np
 + 1;

256 if (
dp
->
width_arg_index
 == 
ARG_NONE
)

258 
dp
->
width_arg_index
 = 
arg_posn
++;

259 if (
dp
->
width_arg_index
 == 
ARG_NONE
)

261 goto 
error
;

263 
	`REGISTER_ARG
 (
dp
->
width_arg_index
, 
TYPE_INT
);

265 else if (*
cp
 >= '0' && *cp <= '9')

267 
size_t
 
width_length
;

269 
dp
->
width_start
 = 
cp
;

270 for (; *
cp
 >= '0' && *cp <= '9'; cp++)

272 
dp
->
width_end
 = 
cp
;

273 
width_length
 = 
dp
->
width_end
 - dp->
width_start
;

274 if (
max_width_length
 < 
width_length
)

275 
max_width_length
 = 
width_length
;

279 if (*
cp
 == '.')

281 
cp
++;

282 if (*
cp
 == '*')

284 
dp
->
precision_start
 = 
cp
 - 1;

285 
cp
++;

286 
dp
->
precision_end
 = 
cp
;

287 if (
max_precision_length
 < 2)

288 
max_precision_length
 = 2;

291 if (*
cp
 >= '0' && *cp <= '9')

293 const 
CHAR_T
 *
np
;

295 for (
np
 = 
cp
; *np >= '0' && *np <= '9'; np++)

297 if (*
np
 == '$')

299 
size_t
 
n
 = 0;

301 for (
np
 = 
cp
; *np >= '0' && *np <= '9'; np++)

302 
n
 = 
	`xsum
 (
	`xtimes
 (n, 10), *
np
 - '0');

303 if (
n
 == 0)

305 goto 
error
;

306 if (
	`size_overflow_p
 (
n
))

309 goto 
error
;

310 
dp
->
precision_arg_index
 = 
n
 - 1;

311 
cp
 = 
np
 + 1;

314 if (
dp
->
precision_arg_index
 == 
ARG_NONE
)

316 
dp
->
precision_arg_index
 = 
arg_posn
++;

317 if (
dp
->
precision_arg_index
 == 
ARG_NONE
)

319 goto 
error
;

321 
	`REGISTER_ARG
 (
dp
->
precision_arg_index
, 
TYPE_INT
);

325 
size_t
 
precision_length
;

327 
dp
->
precision_start
 = 
cp
 - 1;

328 for (; *
cp
 >= '0' && *cp <= '9'; cp++)

330 
dp
->
precision_end
 = 
cp
;

331 
precision_length
 = 
dp
->
precision_end
 - dp->
precision_start
;

332 if (
max_precision_length
 < 
precision_length
)

333 
max_precision_length
 = 
precision_length
;

338 
arg_type
 
type
;

342 int 
flags
 = 0;

346 if (*
cp
 == 'h')

348 
flags
 |= (1 << (flags & 1));

349 
cp
++;

351 else if (*
cp
 == 'L')

353 
flags
 |= 4;

354 
cp
++;

356 else if (*
cp
 == 'l')

358 
flags
 += 8;

359 
cp
++;

361 else if (*
cp
 == 'j')

363 if (sizeof (
intmax_t
) > sizeof (long))

366 
flags
 += 16;

368 else if (sizeof (
intmax_t
) > sizeof (int))

371 
flags
 += 8;

373 
cp
++;

375 else if (*
cp
 == 'z' || *cp == 'Z')

380 if (sizeof (
size_t
) > sizeof (long))

383 
flags
 += 16;

385 else if (sizeof (
size_t
) > sizeof (int))

388 
flags
 += 8;

390 
cp
++;

392 else if (*
cp
 == 't')

394 if (sizeof (
ptrdiff_t
) > sizeof (long))

397 
flags
 += 16;

399 else if (sizeof (
ptrdiff_t
) > sizeof (int))

402 
flags
 += 8;

404 
cp
++;

406 #if 
defined
 
__APPLE__
 && defined 
__MACH__


410 else if (*
cp
 == 'q')

415 
flags
 += 16;

420 
flags
 += 8;

422 
cp
++;

425 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


429 else if (*
cp
 == 'I' && cp[1] == '6' && cp[2] == '4')

434 
flags
 += 16;

439 
flags
 += 8;

441 
cp
 += 3;

449 
c
 = *
cp
++;

450 switch (
c
)

453 #if 
HAVE_LONG_LONG_INT


455 if (
flags
 >= 16 || (flags & 4))

456 
type
 = 
TYPE_LONGLONGINT
;

461 if (
flags
 >= 8)

462 
type
 = 
TYPE_LONGINT
;

463 else if (
flags
 & 2)

464 
type
 = 
TYPE_SCHAR
;

465 else if (
flags
 & 1)

466 
type
 = 
TYPE_SHORT
;

468 
type
 = 
TYPE_INT
;

471 #if 
HAVE_LONG_LONG_INT


473 if (
flags
 >= 16 || (flags & 4))

474 
type
 = 
TYPE_ULONGLONGINT
;

479 if (
flags
 >= 8)

480 
type
 = 
TYPE_ULONGINT
;

481 else if (
flags
 & 2)

482 
type
 = 
TYPE_UCHAR
;

483 else if (
flags
 & 1)

484 
type
 = 
TYPE_USHORT
;

486 
type
 = 
TYPE_UINT
;

490 if (
flags
 >= 16 || (flags & 4))

491 
type
 = 
TYPE_LONGDOUBLE
;

493 
type
 = 
TYPE_DOUBLE
;

496 if (
flags
 >= 8)

497 #if 
HAVE_WINT_T


498 
type
 = 
TYPE_WIDE_CHAR
;

500 goto 
error
;

503 
type
 = 
TYPE_CHAR
;

505 #if 
HAVE_WINT_T


507 
type
 = 
TYPE_WIDE_CHAR
;

508 
c
 = 'c';

512 if (
flags
 >= 8)

513 #if 
HAVE_WCHAR_T


514 
type
 = 
TYPE_WIDE_STRING
;

516 goto 
error
;

519 
type
 = 
TYPE_STRING
;

521 #if 
HAVE_WCHAR_T


523 
type
 = 
TYPE_WIDE_STRING
;

524 
c
 = 's';

528 
type
 = 
TYPE_POINTER
;

531 #if 
HAVE_LONG_LONG_INT


533 if (
flags
 >= 16 || (flags & 4))

534 
type
 = 
TYPE_COUNT_LONGLONGINT_POINTER
;

539 if (
flags
 >= 8)

540 
type
 = 
TYPE_COUNT_LONGINT_POINTER
;

541 else if (
flags
 & 2)

542 
type
 = 
TYPE_COUNT_SCHAR_POINTER
;

543 else if (
flags
 & 1)

544 
type
 = 
TYPE_COUNT_SHORT_POINTER
;

546 
type
 = 
TYPE_COUNT_INT_POINTER
;

548 #if 
ENABLE_UNISTDIO


551 if (
flags
 >= 16)

552 
type
 = 
TYPE_U32_STRING
;

553 else if (
flags
 >= 8)

554 
type
 = 
TYPE_U16_STRING
;

556 
type
 = 
TYPE_U8_STRING
;

560 
type
 = 
TYPE_NONE
;

564 goto 
error
;

568 if (
type
 != 
TYPE_NONE
)

570 
dp
->
arg_index
 = arg_index;

571 if (
dp
->
arg_index
 == 
ARG_NONE
)

573 
dp
->
arg_index
 = 
arg_posn
++;

574 if (
dp
->
arg_index
 == 
ARG_NONE
)

576 goto 
error
;

578 
	`REGISTER_ARG
 (
dp
->
arg_index
, 
type
);

580 
dp
->
conversion
 = 
c
;

581 
dp
->
dir_end
 = 
cp
;

584 
d
->
count
++;

585 if (
d
->
count
 >= 
d_allocated
)

587 
size_t
 
memory_size
;

588 
DIRECTIVE
 *
memory
;

590 
d_allocated
 = 
	`xtimes
 (d_allocated, 2);

591 
memory_size
 = 
	`xtimes
 (
d_allocated
, sizeof (
DIRECTIVE
));

592 if (
	`size_overflow_p
 (
memory_size
))

594 goto 
out_of_memory
;

595 
memory
 = (
DIRECTIVE
 *) (
d
->
dir
 != d->
direct_alloc_dir


596 ? 
	`realloc
 (
d
->
dir
, 
memory_size
)

597 : 
	`malloc
 (
memory_size
));

598 if (
memory
 == 
NULL
)

600 goto 
out_of_memory
;

601 if (
d
->
dir
 == d->
direct_alloc_dir
)

602 
	`memcpy
 (
memory
, 
d
->
dir
, d->
count
 * sizeof (
DIRECTIVE
));

603 
d
->
dir
 = 
memory
;

606 #if 
CHAR_T_ONLY_ASCII


607 else if (!
	`c_isascii
 (
c
))

610 goto 
error
;

614 
d
->
dir
[d->
count
].
dir_start
 = 
cp
;

616 
d
->
max_width_length
 = max_width_length;

617 
d
->
max_precision_length
 = max_precision_length;

620 
error
:

621 if (
a
->
arg
 != a->
direct_alloc_arg
)

622 
	`free
 (
a
->
arg
);

623 if (
d
->
dir
 != d->
direct_alloc_dir
)

624 
	`free
 (
d
->
dir
);

625 
errno
 = 
EINVAL
;

628 
out_of_memory
:

629 if (
a
->
arg
 != a->
direct_alloc_arg
)

630 
	`free
 (
a
->
arg
);

631 if (
d
->
dir
 != d->
direct_alloc_dir
)

632 
	`free
 (
d
->
dir
);

633 
errno
 = 
ENOMEM
;

635 
	}
}

637 #undef 
PRINTF_PARSE


638 #undef 
DIRECTIVES


639 #undef 
DIRECTIVE


640 #undef 
CHAR_T_ONLY_ASCII


641 #undef 
CHAR_T


	@gnulib-tests/printf-parse.h

21 #ifndef 
_PRINTF_PARSE_H


22 #define 
	#_PRINTF_PARSE_H


	)

28 #if 
HAVE_FEATURES_H


29 #include 
	~<features.h
>

32 #include 
	~"printf-args.h
"

36 #define 
	#FLAG_GROUP
 1

	)

37 #define 
	#FLAG_LEFT
 2

	)

38 #define 
	#FLAG_SHOWSIGN
 4

	)

39 #define 
	#FLAG_SPACE
 8

	)

40 #define 
	#FLAG_ALT
 16

	)

41 #define 
	#FLAG_ZERO
 32

	)

42 #if 
__GLIBC__
 >= 2 && !
defined
 
__UCLIBC__


43 #define 
	#FLAG_LOCALIZED
 64

	)

47 #define 
	#ARG_NONE
 (~(
size_t
)0)

	)

53 #define 
	#N_DIRECT_ALLOC_DIRECTIVES
 7

	)

58 const char* 
	mdir_start
;

59 const char* 
	mdir_end
;

60 int 
	mflags
;

61 const char* 
	mwidth_start
;

62 const char* 
	mwidth_end
;

63 
size_t
 
	mwidth_arg_index
;

64 const char* 
	mprecision_start
;

65 const char* 
	mprecision_end
;

66 
size_t
 
	mprecision_arg_index
;

67 char 
	mconversion
;

68 
size_t
 
	marg_index
;

70 
	tchar_directive
;

75 
size_t
 
	mcount
;

76 
char_directive
 *
	mdir
;

77 
size_t
 
	mmax_width_length
;

78 
size_t
 
	mmax_precision_length
;

79 
char_directive
 
	mdirect_alloc_dir
[
N_DIRECT_ALLOC_DIRECTIVES
];

81 
	tchar_directives
;

83 #if 
ENABLE_UNISTDIO


88 const 
uint8_t
* 
	mdir_start
;

89 const 
uint8_t
* 
	mdir_end
;

90 int 
	mflags
;

91 const 
uint8_t
* 
	mwidth_start
;

92 const 
uint8_t
* 
	mwidth_end
;

93 
size_t
 
	mwidth_arg_index
;

94 const 
uint8_t
* 
	mprecision_start
;

95 const 
uint8_t
* 
	mprecision_end
;

96 
size_t
 
	mprecision_arg_index
;

97 
uint8_t
 
	mconversion
;

98 
size_t
 
	marg_index
;

100 
	tu8_directive
;

105 
size_t
 
	mcount
;

106 
u8_directive
 *
	mdir
;

107 
size_t
 
	mmax_width_length
;

108 
size_t
 
	mmax_precision_length
;

109 
u8_directive
 
	mdirect_alloc_dir
[
N_DIRECT_ALLOC_DIRECTIVES
];

111 
	tu8_directives
;

116 const 
uint16_t
* 
	mdir_start
;

117 const 
uint16_t
* 
	mdir_end
;

118 int 
	mflags
;

119 const 
uint16_t
* 
	mwidth_start
;

120 const 
uint16_t
* 
	mwidth_end
;

121 
size_t
 
	mwidth_arg_index
;

122 const 
uint16_t
* 
	mprecision_start
;

123 const 
uint16_t
* 
	mprecision_end
;

124 
size_t
 
	mprecision_arg_index
;

125 
uint16_t
 
	mconversion
;

126 
size_t
 
	marg_index
;

128 
	tu16_directive
;

133 
size_t
 
	mcount
;

134 
u16_directive
 *
	mdir
;

135 
size_t
 
	mmax_width_length
;

136 
size_t
 
	mmax_precision_length
;

137 
u16_directive
 
	mdirect_alloc_dir
[
N_DIRECT_ALLOC_DIRECTIVES
];

139 
	tu16_directives
;

144 const 
uint32_t
* 
	mdir_start
;

145 const 
uint32_t
* 
	mdir_end
;

146 int 
	mflags
;

147 const 
uint32_t
* 
	mwidth_start
;

148 const 
uint32_t
* 
	mwidth_end
;

149 
size_t
 
	mwidth_arg_index
;

150 const 
uint32_t
* 
	mprecision_start
;

151 const 
uint32_t
* 
	mprecision_end
;

152 
size_t
 
	mprecision_arg_index
;

153 
uint32_t
 
	mconversion
;

154 
size_t
 
	marg_index
;

156 
	tu32_directive
;

161 
size_t
 
	mcount
;

162 
u32_directive
 *
	mdir
;

163 
size_t
 
	mmax_width_length
;

164 
size_t
 
	mmax_precision_length
;

165 
u32_directive
 
	mdirect_alloc_dir
[
N_DIRECT_ALLOC_DIRECTIVES
];

167 
	tu32_directives
;

176 #if 
ENABLE_UNISTDIO


178 
ulc_printf_parse
 (const char *
format
, 
char_directives
 *
d
, 
arguments
 *
a
);

180 
u8_printf_parse
 (const 
uint8_t
 *
format
, 
u8_directives
 *
d
, 
arguments
 *
a
);

182 
u16_printf_parse
 (const 
uint16_t
 *
format
, 
u16_directives
 *
d
,

183 
arguments
 *
a
);

185 
u32_printf_parse
 (const 
uint32_t
 *
format
, 
u32_directives
 *
d
,

186 
arguments
 *
a
);

188 #ifdef 
STATIC


189 
	gSTATIC


193 int 
printf_parse
 (const char *
format
, 
char_directives
 *
d
, 
arguments
 *
a
);

	@gnulib-tests/putenv.c

22 #include 
	~<config.h
>

25 #include 
	~<stdlib.h
>

27 #include 
	~<stddef.h
>

31 #include 
	~<errno.h
>

32 #ifndef 
__set_errno


33 #define 
	#__set_errno
(
ev
) ((
errno
) = (ev))

	)

36 #include 
	~<string.h
>

37 #include 
	~<unistd.h
>

39 #if 
_LIBC


40 #if 
HAVE_GNU_LD


41 #define 
	#environ
 
__environ


	)

43 extern char **
environ
;

47 #if 
_LIBC


49 #include 
	~<bits/libc-lock.h
>

50 
	$__libc_lock_define_initialized
 (static, 
envlock
)

51 #define 
	#LOCK
 
	`__libc_lock_lock
 (
envlock
)

	)

52 #define 
	#UNLOCK
 
	`__libc_lock_unlock
 (
envlock
)

	)

54 #define 
	#LOCK


	)

55 #define 
	#UNLOCK


	)

59 
	$_unsetenv
 (const char *
name
)

61 
size_t
 
len
;

62 char **
ep
;

64 if (
name
 == 
NULL
 || *name == '\0' || 
	`strchr
 (name, '=') != NULL)

66 
	`__set_errno
 (
EINVAL
);

70 
len
 = 
	`strlen
 (
name
);

72 
LOCK
;

74 
ep
 = 
environ
;

75 while (*
ep
 != 
NULL
)

76 if (!
	`strncmp
 (*
ep
, 
name
, 
len
) && (*ep)[len] == '=')

79 char **
dp
 = 
ep
;

82 
dp
[0] = dp[1];

83 while (*
dp
++);

87 ++
ep
;

89 
UNLOCK
;

92 
	}
}

98 
	$putenv
 (char *
string
)

100 const char *const 
name_end
 = 
	`strchr
 (
string
, '=');

101 register 
size_t
 
size
;

102 register char **
ep
;

104 if (
name_end
 == 
NULL
)

107 return 
	`_unsetenv
 (
string
);

110 
size
 = 0;

111 for (
ep
 = 
environ
; *ep != 
NULL
; ++ep)

112 if (!
	`strncmp
 (*
ep
, 
string
, 
name_end
 - string) &&

113 (*
ep
)[
name_end
 - 
string
] == '=')

116 ++
size
;

118 if (*
ep
 == 
NULL
)

120 static char **
last_environ
 = 
NULL
;

121 char **
new_environ
 = (char **) 
	`malloc
 ((
size
 + 2) * sizeof (char *));

122 if (
new_environ
 == 
NULL
)

124 (void) 
	`memcpy
 ((void *) 
new_environ
, (void *) 
environ
,

125 
size
 * sizeof (char *));

126 
new_environ
[
size
] = (char *) 
string
;

127 
new_environ
[
size
 + 1] = 
NULL
;

128 
	`free
 (
last_environ
);

129 
last_environ
 = 
new_environ
;

130 
environ
 = 
new_environ
;

133 *
ep
 = 
string
;

136 
	}
}

	@gnulib-tests/setenv.c

19 #if !
_LIBC


20 #define 
	#_GL_USE_STDLIB_ALLOC
 1

	)

21 #include 
	~<config.h
>

26 #define 
	#_GL_ARG_NONNULL
(
params
)

	)

28 #include 
	~<alloca.h
>

31 #include 
	~<stdlib.h
>

33 #include 
	~<errno.h
>

34 #ifndef 
__set_errno


35 #define 
	#__set_errno
(
ev
) ((
errno
) = (ev))

	)

38 #include 
	~<string.h
>

39 #if 
_LIBC
 || 
HAVE_UNISTD_H


40 #include 
	~<unistd.h
>

43 #if !
_LIBC


44 #include 
	~"malloca.h
"

47 #if 
_LIBC
 || !
HAVE_SETENV


49 #if !
_LIBC


50 #define 
	#__environ
 
environ


	)

53 #if 
_LIBC


55 #include 
	~<bits/libc-lock.h
>

56 
	$__libc_lock_define_initialized
 (static, 
envlock
)

57 #define 
	#LOCK
 
	`__libc_lock_lock
 (
envlock
)

	)

58 #define 
	#UNLOCK
 
	`__libc_lock_unlock
 (
envlock
)

	)

60 #define 
	#LOCK


	)

61 #define 
	#UNLOCK


	)

65 #ifdef 
_LIBC


66 #define 
	#setenv
 
__setenv


	)

67 #define 
	#clearenv
 
__clearenv


	)

68 #define 
	#tfind
 
__tfind


	)

69 #define 
	#tsearch
 
__tsearch


	)

76 #if 
defined
 
_LIBC
 || (defined 
HAVE_SEARCH_H
 && defined 
HAVE_TSEARCH
 \

77 && 
defined
 
__GNUC__
)

78 #define 
	#USE_TSEARCH
 1

	)

79 #include 
	~<search.h
>

80 typedef int (*
	tcompar_fn_t
) (const void *, const void *);

84 static void *
known_values
;

86 #define 
	#KNOWN_VALUE
(
Str
) \

88 void *
value
 = 
	`tfind
 (
Str
, &
known_values
, (
compar_fn_t
) 
strcmp
); \

89 
value
 != 
NULL
 ? *(char **) value : NULL; \

90 
	}
})

	)

91 #define 
	#STORE_VALUE
(
Str
) \

92 
	`tsearch
 (
Str
, &
known_values
, (
compar_fn_t
) 
strcmp
)

	)

95 #undef 
USE_TSEARCH


97 #define 
	#KNOWN_VALUE
(
Str
) 
NULL


	)

98 #define 
	#STORE_VALUE
(
Str
) do { } while (0)

	)

105 static char **
	glast_environ
;

115 
	$__add_to_environ
 (const char *
name
, const char *
value
, const char *
combined
,

116 int 
replace
)

118 char **
ep
;

119 
size_t
 
size
;

120 const 
size_t
 
namelen
 = 
	`strlen
 (
name
);

121 const 
size_t
 
vallen
 = 
value
 != 
NULL
 ? 
	`strlen
 (value) + 1 : 0;

123 
LOCK
;

127 
ep
 = 
__environ
;

129 
size
 = 0;

130 if (
ep
 != 
NULL
)

132 for (; *
ep
 != 
NULL
; ++ep)

133 if (!
	`strncmp
 (*
ep
, 
name
, 
namelen
) && (*ep)[namelen] == '=')

136 ++
size
;

139 if (
ep
 == 
NULL
 || *ep == NULL)

141 char **
new_environ
;

142 #ifdef 
USE_TSEARCH


143 char *
new_value
;

147 
new_environ
 =

148 (char **) (
last_environ
 == 
NULL


149 ? 
	`malloc
 ((
size
 + 2) * sizeof (char *))

150 : 
	`realloc
 (
last_environ
, (
size
 + 2) * sizeof (char *)));

151 if (
new_environ
 == 
NULL
)

155 
	`__set_errno
 (
ENOMEM
);

156 
UNLOCK
;

161 if (
combined
 != 
NULL
)

164 
new_environ
[
size
] = (char *) 
combined
;

168 #ifdef 
USE_TSEARCH


169 #ifdef 
_LIBC


170 
new_value
 = (char *) 
	`alloca
 (
namelen
 + 1 + 
vallen
);

171 
	`__mempcpy
 (__mempcpy (__mempcpy (
new_value
, 
name
, 
namelen
), "=", 1),

172 
value
, 
vallen
);

174 
new_value
 = (char *) 
	`malloca
 (
namelen
 + 1 + 
vallen
);

175 if (
new_value
 == 
NULL
)

177 
	`__set_errno
 (
ENOMEM
);

178 
UNLOCK
;

181 
	`memcpy
 (
new_value
, 
name
, 
namelen
);

182 
new_value
[
namelen
] = '=';

183 
	`memcpy
 (&
new_value
[
namelen
 + 1], 
value
, 
vallen
);

186 
new_environ
[
size
] = 
	`KNOWN_VALUE
 (
new_value
);

187 if (
new_environ
[
size
] == 
NULL
)

190 
new_environ
[
size
] = (char *) 
	`malloc
 (
namelen
 + 1 + 
vallen
);

191 if (
new_environ
[
size
] == 
NULL
)

193 #if 
defined
 
USE_TSEARCH
 && !defined 
_LIBC


194 
	`freea
 (
new_value
);

196 
	`__set_errno
 (
ENOMEM
);

197 
UNLOCK
;

201 #ifdef 
USE_TSEARCH


202 
	`memcpy
 (
new_environ
[
size
], 
new_value
, 
namelen
 + 1 + 
vallen
);

204 
	`memcpy
 (
new_environ
[
size
], 
name
, 
namelen
);

205 
new_environ
[
size
][
namelen
] = '=';

206 
	`memcpy
 (&
new_environ
[
size
][
namelen
 + 1], 
value
, 
vallen
);

211 
	`STORE_VALUE
 (
new_environ
[
size
]);

213 #if 
defined
 
USE_TSEARCH
 && !defined 
_LIBC


214 
	`freea
 (
new_value
);

218 if (
__environ
 != 
last_environ
)

219 
	`memcpy
 ((char *) 
new_environ
, (char *) 
__environ
,

220 
size
 * sizeof (char *));

222 
new_environ
[
size
 + 1] = 
NULL
;

224 
last_environ
 = 
__environ
 = 
new_environ
;

226 else if (
replace
)

228 char *
np
;

231 if (
combined
 != 
NULL
)

232 
np
 = (char *) 
combined
;

235 #ifdef 
USE_TSEARCH


236 char *
new_value
;

237 #ifdef 
_LIBC


238 
new_value
 = 
	`alloca
 (
namelen
 + 1 + 
vallen
);

239 
	`__mempcpy
 (__mempcpy (__mempcpy (
new_value
, 
name
, 
namelen
), "=", 1),

240 
value
, 
vallen
);

242 
new_value
 = 
	`malloca
 (
namelen
 + 1 + 
vallen
);

243 if (
new_value
 == 
NULL
)

245 
	`__set_errno
 (
ENOMEM
);

246 
UNLOCK
;

249 
	`memcpy
 (
new_value
, 
name
, 
namelen
);

250 
new_value
[
namelen
] = '=';

251 
	`memcpy
 (&
new_value
[
namelen
 + 1], 
value
, 
vallen
);

254 
np
 = 
	`KNOWN_VALUE
 (
new_value
);

255 if (
np
 == 
NULL
)

258 
np
 = (char *) 
	`malloc
 (
namelen
 + 1 + 
vallen
);

259 if (
np
 == 
NULL
)

261 #if 
defined
 
USE_TSEARCH
 && !defined 
_LIBC


262 
	`freea
 (
new_value
);

264 
	`__set_errno
 (
ENOMEM
);

265 
UNLOCK
;

269 #ifdef 
USE_TSEARCH


270 
	`memcpy
 (
np
, 
new_value
, 
namelen
 + 1 + 
vallen
);

272 
	`memcpy
 (
np
, 
name
, 
namelen
);

273 
np
[
namelen
] = '=';

274 
	`memcpy
 (&
np
[
namelen
 + 1], 
value
, 
vallen
);

277 
	`STORE_VALUE
 (
np
);

279 #if 
defined
 
USE_TSEARCH
 && !defined 
_LIBC


280 
	`freea
 (
new_value
);

284 *
ep
 = 
np
;

287 
UNLOCK
;

290 
	}
}

293 
	$setenv
 (const char *
name
, const char *
value
, int 
replace
)

295 if (
name
 == 
NULL
 || *name == '\0' || 
	`strchr
 (name, '=') != NULL)

297 
	`__set_errno
 (
EINVAL
);

301 return 
	`__add_to_environ
 (
name
, 
value
, 
NULL
, 
replace
);

302 
	}
}

308 
	$clearenv
 (void)

310 
LOCK
;

312 if (
__environ
 == 
last_environ
 && __environ != 
NULL
)

315 
	`free
 (
__environ
);

316 
last_environ
 = 
NULL
;

320 
__environ
 = 
NULL
;

322 
UNLOCK
;

325 
	}
}

327 #ifdef 
_LIBC


329 
	$free_mem
 (void)

332 
	`clearenv
 ();

335 
	`__tdestroy
 (
known_values
, 
free
);

336 
known_values
 = 
NULL
;

337 
	}
}

338 
text_set_element
 (
__libc_subfreeres
, 
free_mem
);

341 #undef 
setenv


342 #undef 
clearenv


343 
	$weak_alias
 (
__setenv
, 
setenv
)

344 
	$weak_alias
 (
__clearenv
, 
clearenv
)

352 #if 
HAVE_SETENV


354 #undef 
setenv


355 #if !
HAVE_DECL_SETENV


356 extern int 
	`setenv
 (const char *, const char *, int);

358 #define 
	#STREQ
(
a
, 
b
) (
	`strcmp
 (a, b) == 0)

	)

361 
	$rpl_setenv
 (const char *
name
, const char *
value
, int 
replace
)

363 int 
result
;

364 if (!
name
 || !*name || 
	`strchr
 (name, '='))

366 
errno
 = 
EINVAL
;

371 
result
 = 
	`setenv
 (
name
, 
value
, 
replace
);

372 if (
result
 == 0 && 
replace
 && *
value
 == '=')

374 char *
tmp
 = 
	`getenv
 (
name
);

375 if (!
	`STREQ
 (
tmp
, 
value
))

377 int 
saved_errno
;

378 
size_t
 
len
 = 
	`strlen
 (
value
);

379 
tmp
 = 
	`malloca
 (
len
 + 2);

381 *
tmp
 = '=';

382 
	`memcpy
 (
tmp
 + 1, 
value
, 
len
 + 1);

383 
result
 = 
	`setenv
 (
name
, 
tmp
, 
replace
);

384 
saved_errno
 = 
errno
;

385 
	`freea
 (
tmp
);

386 
errno
 = 
saved_errno
;

389 return 
result
;

390 
	}
}

	@gnulib-tests/setlocale.c

21 #include 
	~<config.h
>

32 #include 
	~<locale.h
>

34 #include 
	~<stdlib.h
>

35 #include 
	~<string.h
>

37 #include 
	~"localename.h
"

41 #undef 
setlocale


45 
	$category_to_name
 (int 
category
)

47 const char *
retval
;

49 switch (
category
)

51 case 
LC_COLLATE
:

52 
retval
 = "LC_COLLATE";

54 case 
LC_CTYPE
:

55 
retval
 = "LC_CTYPE";

57 case 
LC_MONETARY
:

58 
retval
 = "LC_MONETARY";

60 case 
LC_NUMERIC
:

61 
retval
 = "LC_NUMERIC";

63 case 
LC_TIME
:

64 
retval
 = "LC_TIME";

66 case 
LC_MESSAGES
:

67 
retval
 = "LC_MESSAGES";

71 
retval
 = "LC_XXX";

74 return 
retval
;

75 
	}
}

77 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


243 struct 
	stable_entry


245 const char *
	mcode
;

246 const char *
	menglish
;

248 static const struct 
table_entry
 
	glanguage_table
[] =

419 static const struct 
table_entry
 
	gcountry_table
[] =

568 typedef struct { 
size_t
 
	mlo
; size_t 
	mhi
; } 
	trange_t
;

570 
	$search
 (const struct 
table_entry
 *
table
, 
size_t
 
table_size
, const char *
string
,

571 
range_t
 *
result
)

574 
size_t
 
hi
 = 
table_size
;

575 
size_t
 
lo
 = 0;

576 while (
lo
 < 
hi
)

581 
size_t
 
mid
 = (
hi
 + 
lo
) >> 1;

582 int 
cmp
 = 
	`strcmp
 (
table
[
mid
].
code
, 
string
);

583 if (
cmp
 < 0)

584 
lo
 = 
mid
 + 1;

585 else if (
cmp
 > 0)

586 
hi
 = 
mid
;

593 
size_t
 
i
;

595 for (
i
 = 
mid
; i > 
lo
; )

597 
i
--;

598 if (
	`strcmp
 (
table
[
i
].
code
, 
string
) < 0)

600 
lo
 = 
i
 + 1;

606 
size_t
 
i
;

608 for (
i
 = 
mid
; i < 
hi
; i++)

610 if (
	`strcmp
 (
table
[
i
].
code
, 
string
) > 0)

612 
hi
 = 
i
;

623 
result
->
lo
 = lo;

624 
result
->
hi
 = hi;

625 
	}
}

630 
	$setlocale_unixlike
 (int 
category
, const char *
locale
)

632 char *
result
;

633 char 
llCC_buf
[64];

634 char 
ll_buf
[64];

635 char 
CC_buf
[64];

638 
result
 = 
	`setlocale
 (
category
, 
locale
);

639 if (
result
 != 
NULL
)

640 return 
result
;

645 if (
	`strlen
 (
locale
) < sizeof (
llCC_buf
))

649 const char *
p
 = 
locale
;

650 char *
q
 = 
llCC_buf
;

653 for (; *
p
 != '\0' && *p != '.'; p++, 
q
++)

654 *
q
 = *
p
;

655 if (*
p
 == '.')

657 for (; *
p
 != '\0' && *p != '@'; p++)

660 for (; *
p
 != '\0'; p++, 
q
++)

661 *
q
 = *
p
;

662 *
q
 = '\0';

667 if (
	`strcmp
 (
llCC_buf
, 
locale
) != 0)

669 
result
 = 
	`setlocale
 (
category
, 
llCC_buf
);

670 if (
result
 != 
NULL
)

671 return 
result
;

675 
range_t
 
range
;

676 
size_t
 
i
;

678 
	`search
 (
language_table
,

679 sizeof (
language_table
) / sizeof (language_table[0]),

680 
llCC_buf
,

681 &
range
);

683 for (
i
 = 
range
.
lo
; i < range.
hi
; i++)

686 
result
 = 
	`setlocale
 (
category
, 
language_table
[
i
].
english
);

687 if (
result
 != 
NULL
)

688 return 
result
;

696 const char *
underscore
 = 
	`strchr
 (
llCC_buf
, '_');

697 if (
underscore
 != 
NULL
)

699 const char *
territory_start
 = 
underscore
 + 1;

700 const char *
territory_end
 = 
	`strchr
 (
territory_start
, '@');

701 if (
territory_end
 == 
NULL
)

702 
territory_end
 = 
territory_start
 + 
	`strlen
 (territory_start);

704 
	`memcpy
 (
ll_buf
, 
llCC_buf
, 
underscore
 - llCC_buf);

705 
	`strcpy
 (
ll_buf
 + (
underscore
 - 
llCC_buf
), 
territory_end
);

707 
	`memcpy
 (
CC_buf
, 
territory_start
, 
territory_end
 - territory_start);

708 
CC_buf
[
territory_end
 - 
territory_start
] = '\0';

713 
range_t
 
language_range
;

715 
	`search
 (
language_table
,

716 sizeof (
language_table
) / sizeof (language_table[0]),

717 
ll_buf
,

718 &
language_range
);

719 if (
language_range
.
lo
 < language_range.
hi
)

721 
range_t
 
country_range
;

723 
	`search
 (
country_table
,

724 sizeof (
country_table
) / sizeof (country_table[0]),

725 
CC_buf
,

726 &
country_range
);

727 if (
country_range
.
lo
 < country_range.
hi
)

729 
size_t
 
i
;

730 
size_t
 
j
;

732 for (
i
 = 
language_range
.
lo
; i < language_range.
hi
; i++)

733 for (
j
 = 
country_range
.
lo
; j < country_range.
hi
; j++)

736 const char *
part1
 = 
language_table
[
i
].
english
;

737 
size_t
 
part1_len
 = 
	`strlen
 (
part1
);

738 const char *
part2
 = 
country_table
[
j
].
english
;

739 
size_t
 
part2_len
 = 
	`strlen
 (
part2
) + 1;

740 char 
buf
[64+64];

742 if (!(
part1_len
 + 1 + 
part2_len
 <= sizeof (
buf
)))

743 
	`abort
 ();

744 
	`memcpy
 (
buf
, 
part1
, 
part1_len
);

745 
buf
[
part1_len
] = '_';

746 
	`memcpy
 (
buf
 + 
part1_len
 + 1, 
part2
, 
part2_len
);

749 
result
 = 
	`setlocale
 (
category
, 
buf
);

750 if (
result
 != 
NULL
)

751 return 
result
;

759 
size_t
 
i
;

761 for (
i
 = 
language_range
.
lo
; i < language_range.
hi
; i++)

764 
result
 =

765 
	`setlocale
 (
category
, 
language_table
[
i
].
english
);

766 if (
result
 != 
NULL
)

767 return 
result
;

777 return 
NULL
;

778 
	}
}

781 #define 
	#setlocale_unixlike
 
setlocale


	)

784 #if 
LC_MESSAGES
 == 1729

787 static char 
	glc_messages_name
[64] = "C";

791 
	$setlocale_single
 (int 
category
, const char *
locale
)

793 if (
category
 == 
LC_MESSAGES
)

795 if (
locale
 != 
NULL
)

797 
lc_messages_name
[sizeof (lc_messages_name) - 1] = '\0';

798 
	`strncpy
 (
lc_messages_name
, 
locale
, sizeof (lc_messages_name) - 1);

800 return 
lc_messages_name
;

803 return 
	`setlocale_unixlike
 (
category
, 
locale
);

804 
	}
}

807 #define 
	#setlocale_single
 
setlocale_unixlike


	)

811 
	$rpl_setlocale
 (int 
category
, const char *
locale
)

813 if (
locale
 != 
NULL
 && locale[0] == '\0')

816 if (
category
 == 
LC_ALL
)

819 static int const 
categories
[] =

821 
LC_NUMERIC
,

822 
LC_TIME
,

823 
LC_COLLATE
,

824 
LC_MONETARY
,

825 
LC_MESSAGES


827 char *
saved_locale
;

828 const char *
base_name
;

829 unsigned int 
i
;

832 
saved_locale
 = 
	`setlocale
 (
LC_ALL
, 
NULL
);

833 if (
saved_locale
 == 
NULL
)

834 return 
NULL
;

835 
saved_locale
 = 
	`strdup
 (saved_locale);

836 if (
saved_locale
 == 
NULL
)

837 return 
NULL
;

842 
base_name
 =

843 
	`gl_locale_name_environ
 (
LC_CTYPE
, 
	`category_to_name
 (LC_CTYPE));

844 if (
base_name
 == 
NULL
)

845 
base_name
 = 
	`gl_locale_name_default
 ();

847 if (
	`setlocale_unixlike
 (
LC_ALL
, 
base_name
) == 
NULL
)

848 goto 
fail
;

849 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


853 if (
	`strchr
 (
base_name
, '.') != 
NULL


854 && 
	`strcmp
 (
	`setlocale
 (
LC_CTYPE
, 
NULL
), "C") == 0)

855 goto 
fail
;

858 for (
i
 = 0; i < sizeof (
categories
) / sizeof (categories[0]); i++)

860 int 
cat
 = 
categories
[
i
];

861 const char *
name
;

863 
name
 = 
	`gl_locale_name_environ
 (
cat
, 
	`category_to_name
 (cat));

864 if (
name
 == 
NULL
)

865 
name
 = 
	`gl_locale_name_default
 ();

869 if (
	`strcmp
 (
name
, 
base_name
) != 0

870 #if 
LC_MESSAGES
 == 1729

871 || 
cat
 == 
LC_MESSAGES


874 if (
	`setlocale_single
 (
cat
, 
name
) == 
NULL
)

875 goto 
fail
;

879 
	`free
 (
saved_locale
);

880 return 
	`setlocale
 (
LC_ALL
, 
NULL
);

882 
fail
:

883 if (
saved_locale
[0] != '\0')

884 
	`setlocale
 (
LC_ALL
, 
saved_locale
);

885 
	`free
 (
saved_locale
);

886 return 
NULL
;

890 const char *
name
 =

891 
	`gl_locale_name_environ
 (
category
, 
	`category_to_name
 (category));

892 if (
name
 == 
NULL
)

893 
name
 = 
	`gl_locale_name_default
 ();

895 return 
	`setlocale_single
 (
category
, 
name
);

900 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


901 if (
category
 == 
LC_ALL
 && 
locale
 != 
NULL
 && 
	`strchr
 (locale, '.') != NULL)

903 char *
saved_locale
;

906 
saved_locale
 = 
	`setlocale
 (
LC_ALL
, 
NULL
);

907 if (
saved_locale
 == 
NULL
)

908 return 
NULL
;

909 
saved_locale
 = 
	`strdup
 (saved_locale);

910 if (
saved_locale
 == 
NULL
)

911 return 
NULL
;

913 if (
	`setlocale_unixlike
 (
LC_ALL
, 
locale
) == 
NULL
)

915 
	`free
 (
saved_locale
);

916 return 
NULL
;

922 if (
	`strcmp
 (
	`setlocale
 (
LC_CTYPE
, 
NULL
), "C") == 0)

924 if (
saved_locale
[0] != '\0')

925 
	`setlocale
 (
LC_ALL
, 
saved_locale
);

926 
	`free
 (
saved_locale
);

927 return 
NULL
;

931 
	`free
 (
saved_locale
);

932 return 
	`setlocale
 (
LC_ALL
, 
NULL
);

936 return 
	`setlocale_single
 (
category
, 
locale
);

938 
	}
}

	@gnulib-tests/signature.h

19 #ifndef 
SIGNATURE_CHECK


40 #define 
	#SIGNATURE_CHECK
(
fn
, 
ret
, 
args
) \

41 
	`SIGNATURE_CHECK1
 (
fn
, 
ret
, 
args
, 
__LINE__
)

	)

45 #define 
	#SIGNATURE_CHECK1
(
fn
, 
ret
, 
args
, 
id
) \

46 
	`SIGNATURE_CHECK2
 (
fn
, 
ret
, 
args
, 
id
)

	)

47 #define 
	#SIGNATURE_CHECK2
(
fn
, 
ret
, 
args
, 
id
) \

48 static 
	`ret
 (* 
_GL_UNUSED
 
signature_check
 ## 
id
) 
args
 = 
fn


	)

	@gnulib-tests/size_max.h

21 #ifndef 
GNULIB_SIZE_MAX_H


22 #define 
	#GNULIB_SIZE_MAX_H


	)

25 #include 
	~<limits.h
>

27 #if 
HAVE_STDINT_H


28 #include 
	~<stdint.h
>

	@gnulib-tests/snprintf.c

21 #include 
	~<config.h
>

24 #include 
	~<stdio.h
>

26 #include 
	~<errno.h
>

27 #include 
	~<limits.h
>

28 #include 
	~<stdarg.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

32 #include 
	~"vasnprintf.h
"

40 
	$snprintf
 (char *
str
, 
size_t
 
size
, const char *
format
, ...)

42 char *
output
;

43 
size_t
 
len
;

44 
size_t
 
lenbuf
 = 
size
;

45 
va_list
 
args
;

47 
	`va_start
 (
args
, 
format
);

48 
output
 = 
	`vasnprintf
 (
str
, &
lenbuf
, 
format
, 
args
);

49 
len
 = 
lenbuf
;

50 
	`va_end
 (
args
);

52 if (!
output
)

55 if (
output
 != 
str
)

57 if (
size
)

59 
size_t
 
pruned_len
 = (
len
 < 
size
 ? len : size - 1);

60 
	`memcpy
 (
str
, 
output
, 
pruned_len
);

61 
str
[
pruned_len
] = '\0';

64 
	`free
 (
output
);

67 if (
INT_MAX
 < 
len
)

69 
errno
 = 
EOVERFLOW
;

73 return 
len
;

74 
	}
}

	@gnulib-tests/stdio.in.h

21 #if 
__GNUC__
 >= 3

22 @
	gPRAGMA_SYSTEM_HEADER
@

24 @
	gPRAGMA_COLUMNS
@

26 #if 
defined
 
__need_FILE
 || defined 
__need___FILE
 || defined 
_GL_ALREADY_INCLUDING_STDIO_H


35 #@
INCLUDE_NEXT
@ @
NEXT_STDIO_H
@

40 #ifndef 
_
@
GUARD_PREFIX
@
_STDIO_H


42 #define 
	#_GL_ALREADY_INCLUDING_STDIO_H


	)

45 #@
INCLUDE_NEXT
@ @
NEXT_STDIO_H
@

47 #undef 
_GL_ALREADY_INCLUDING_STDIO_H


49 #ifndef 
_
@
GUARD_PREFIX
@
_STDIO_H


50 #define 
	#_
@
GUARD_PREFIX
@
_STDIO_H


	)

53 #include 
	~<stdarg.h
>

55 #include 
	~<stddef.h
>

59 #include 
	~<sys/types.h
>

67 #if 
__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 7)

68 #define 
	#_GL_ATTRIBUTE_FORMAT
(
spec
) 
	`__attribute__
 ((
__format__
 spec))

	)

70 #define 
	#_GL_ATTRIBUTE_FORMAT
(
spec
)

	)

77 #if 
__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4)

78 #define 
	#_GL_ATTRIBUTE_FORMAT_PRINTF
(
formatstring_parameter
, 
first_argument
) \

79 
	`_GL_ATTRIBUTE_FORMAT
 ((
__gnu_printf__
, 
formatstring_parameter
, 
first_argument
))

	)

81 #define 
	#_GL_ATTRIBUTE_FORMAT_PRINTF
(
formatstring_parameter
, 
first_argument
) \

82 
	`_GL_ATTRIBUTE_FORMAT
 ((
__printf__
, 
formatstring_parameter
, 
first_argument
))

	)

89 #define 
	#_GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM
(
formatstring_parameter
, 
first_argument
) \

90 
	`_GL_ATTRIBUTE_FORMAT
 ((
__printf__
, 
formatstring_parameter
, 
first_argument
))

	)

96 #if 
__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4)

97 #define 
	#_GL_ATTRIBUTE_FORMAT_SCANF
(
formatstring_parameter
, 
first_argument
) \

98 
	`_GL_ATTRIBUTE_FORMAT
 ((
__gnu_scanf__
, 
formatstring_parameter
, 
first_argument
))

	)

100 #define 
	#_GL_ATTRIBUTE_FORMAT_SCANF
(
formatstring_parameter
, 
first_argument
) \

101 
	`_GL_ATTRIBUTE_FORMAT
 ((
__scanf__
, 
formatstring_parameter
, 
first_argument
))

	)

108 #define 
	#_GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM
(
formatstring_parameter
, 
first_argument
) \

109 
	`_GL_ATTRIBUTE_FORMAT
 ((
__scanf__
, 
formatstring_parameter
, 
first_argument
))

	)

113 #if (@
GNULIB_RENAMEAT
@ || 
defined
 
GNULIB_POSIXCHECK
) && defined 
__sun
 \

114 && ! 
defined
 
	g__GLIBC__


115 #include 
	~<unistd.h
>

126 #define 
	#_GL_STDIO_STRINGIZE
(
token
) #token

	)

127 #define 
	#_GL_STDIO_MACROEXPAND_AND_STRINGIZE
(
token
) 
	`_GL_STDIO_STRINGIZE
(token)

	)

130 #if @
GNULIB_DPRINTF
@

131 #if @
REPLACE_DPRINTF
@

132 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

133 #define 
	#dprintf
 
rpl_dprintf


	)

135 
_GL_FUNCDECL_RPL
 (
dprintf
, int, (int 
fd
, const char *
format
, ...)

136 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

137 
	`_GL_ARG_NONNULL
 ((2)));

138 
	`_GL_CXXALIAS_RPL
 (
dprintf
, int, (int 
fd
, const char *
format
, ...));

140 #if !@
HAVE_DPRINTF
@

141 
	`_GL_FUNCDECL_SYS
 (
dprintf
, int, (int 
fd
, const char *
format
, ...)

142 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

143 
	`_GL_ARG_NONNULL
 ((2)));

145 
	`_GL_CXXALIAS_SYS
 (
dprintf
, int, (int 
fd
, const char *
format
, ...));

147 
	`_GL_CXXALIASWARN
 (
dprintf
);

148 #elif 
defined
 
GNULIB_POSIXCHECK


149 #undef 
dprintf


150 #if 
HAVE_RAW_DECL_DPRINTF


151 
	`_GL_WARN_ON_USE
 (
dprintf
, "dprintf is unportable - "

156 #if @
GNULIB_FCLOSE
@

158 #if @
REPLACE_FCLOSE
@

159 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

160 #define 
	#fclose
 
rpl_fclose


	)

162 
	`_GL_FUNCDECL_RPL
 (
fclose
, int, (
FILE
 *
stream
) 
	`_GL_ARG_NONNULL
 ((1)));

163 
	`_GL_CXXALIAS_RPL
 (
fclose
, int, (
FILE
 *
stream
));

165 
	`_GL_CXXALIAS_SYS
 (
fclose
, int, (
FILE
 *
stream
));

167 
	`_GL_CXXALIASWARN
 (
fclose
);

168 #elif 
defined
 
GNULIB_POSIXCHECK


169 #undef 
fclose


171 
	`_GL_WARN_ON_USE
 (
fclose
, "fclose is not always POSIX compliant - "

175 #if @
GNULIB_FDOPEN
@

176 #if @
REPLACE_FDOPEN
@

177 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

178 #undef 
fdopen


179 #define 
	#fdopen
 
rpl_fdopen


	)

181 
	`_GL_FUNCDECL_RPL
 (
fdopen
, 
FILE
 *, (int 
fd
, const char *
mode
)

182 
	`_GL_ARG_NONNULL
 ((2)));

183 
	`_GL_CXXALIAS_RPL
 (
fdopen
, 
FILE
 *, (int 
fd
, const char *
mode
));

185 
	`_GL_CXXALIAS_SYS
 (
fdopen
, 
FILE
 *, (int 
fd
, const char *
mode
));

187 
	`_GL_CXXALIASWARN
 (
fdopen
);

188 #elif 
defined
 
GNULIB_POSIXCHECK


189 #undef 
fdopen


191 
	`_GL_WARN_ON_USE
 (
fdopen
, "fdopen on Win32 platforms is not POSIX compatible - "

195 #if @
GNULIB_FFLUSH
@

202 #if @
REPLACE_FFLUSH
@

203 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

204 #define 
	#fflush
 
rpl_fflush


	)

206 
	`_GL_FUNCDECL_RPL
 (
fflush
, int, (
FILE
 *
gl_stream
));

207 
	`_GL_CXXALIAS_RPL
 (
fflush
, int, (
FILE
 *
gl_stream
));

209 
	`_GL_CXXALIAS_SYS
 (
fflush
, int, (
FILE
 *
gl_stream
));

211 
	`_GL_CXXALIASWARN
 (
fflush
);

212 #elif 
defined
 
GNULIB_POSIXCHECK


213 #undef 
fflush


215 
	`_GL_WARN_ON_USE
 (
fflush
, "fflush is not always POSIX compliant - "

219 #if @
GNULIB_FGETC
@

220 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

221 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

222 #undef 
fgetc


223 #define 
	#fgetc
 
rpl_fgetc


	)

225 
	`_GL_FUNCDECL_RPL
 (
fgetc
, int, (
FILE
 *
stream
) 
	`_GL_ARG_NONNULL
 ((1)));

226 
	`_GL_CXXALIAS_RPL
 (
fgetc
, int, (
FILE
 *
stream
));

228 
	`_GL_CXXALIAS_SYS
 (
fgetc
, int, (
FILE
 *
stream
));

230 
	`_GL_CXXALIASWARN
 (
fgetc
);

233 #if @
GNULIB_FGETS
@

234 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

235 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

236 #undef 
fgets


237 #define 
	#fgets
 
rpl_fgets


	)

239 
	`_GL_FUNCDECL_RPL
 (
fgets
, char *, (char *
s
, int 
n
, 
FILE
 *
stream
)

240 
	`_GL_ARG_NONNULL
 ((1, 3)));

241 
	`_GL_CXXALIAS_RPL
 (
fgets
, char *, (char *
s
, int 
n
, 
FILE
 *
stream
));

243 
	`_GL_CXXALIAS_SYS
 (
fgets
, char *, (char *
s
, int 
n
, 
FILE
 *
stream
));

245 
	`_GL_CXXALIASWARN
 (
fgets
);

248 #if @
GNULIB_FOPEN
@

249 #if @
REPLACE_FOPEN
@

250 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

251 #undef 
fopen


252 #define 
	#fopen
 
rpl_fopen


	)

254 
	`_GL_FUNCDECL_RPL
 (
fopen
, 
FILE
 *, (const char *
filename
, const char *
mode
)

255 
	`_GL_ARG_NONNULL
 ((1, 2)));

256 
	`_GL_CXXALIAS_RPL
 (
fopen
, 
FILE
 *, (const char *
filename
, const char *
mode
));

258 
	`_GL_CXXALIAS_SYS
 (
fopen
, 
FILE
 *, (const char *
filename
, const char *
mode
));

260 
	`_GL_CXXALIASWARN
 (
fopen
);

261 #elif 
defined
 
GNULIB_POSIXCHECK


262 #undef 
fopen


264 
	`_GL_WARN_ON_USE
 (
fopen
, "fopen on Win32 platforms is not POSIX compatible - "

268 #if @
GNULIB_FPRINTF_POSIX
@ || @
GNULIB_FPRINTF
@

269 #if (@
GNULIB_FPRINTF_POSIX
@ && @
REPLACE_FPRINTF
@) \

270 || (@
GNULIB_FPRINTF
@ && @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@))

271 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

272 #define 
	#fprintf
 
rpl_fprintf


	)

274 #define 
	#GNULIB_overrides_fprintf
 1

	)

275 #if @
GNULIB_FPRINTF_POSIX
@ || @
GNULIB_VFPRINTF_POSIX
@

276 
	`_GL_FUNCDECL_RPL
 (
fprintf
, int, (
FILE
 *
fp
, const char *
format
, ...)

277 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

278 
	`_GL_ARG_NONNULL
 ((1, 2)));

280 
	`_GL_FUNCDECL_RPL
 (
fprintf
, int, (
FILE
 *
fp
, const char *
format
, ...)

281 
	$_GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM
 (2, 3)

282 
	`_GL_ARG_NONNULL
 ((1, 2)));

284 
	`_GL_CXXALIAS_RPL
 (
fprintf
, int, (
FILE
 *
fp
, const char *
format
, ...));

286 
	`_GL_CXXALIAS_SYS
 (
fprintf
, int, (
FILE
 *
fp
, const char *
format
, ...));

288 
	`_GL_CXXALIASWARN
 (
fprintf
);

290 #if !@
GNULIB_FPRINTF_POSIX
@ && 
defined
 
GNULIB_POSIXCHECK


291 #if !
GNULIB_overrides_fprintf


292 #undef 
fprintf


295 
	`_GL_WARN_ON_USE
 (
fprintf
, "fprintf is not always POSIX compliant - "

300 #if @
GNULIB_FPURGE
@

307 #if @
REPLACE_FPURGE
@

308 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

309 #define 
	#fpurge
 
rpl_fpurge


	)

311 
	`_GL_FUNCDECL_RPL
 (
fpurge
, int, (
FILE
 *
gl_stream
) 
	`_GL_ARG_NONNULL
 ((1)));

312 
	`_GL_CXXALIAS_RPL
 (
fpurge
, int, (
FILE
 *
gl_stream
));

314 #if !@
HAVE_DECL_FPURGE
@

315 
	`_GL_FUNCDECL_SYS
 (
fpurge
, int, (
FILE
 *
gl_stream
) 
	`_GL_ARG_NONNULL
 ((1)));

317 
	`_GL_CXXALIAS_SYS
 (
fpurge
, int, (
FILE
 *
gl_stream
));

319 
	`_GL_CXXALIASWARN
 (
fpurge
);

320 #elif 
defined
 
GNULIB_POSIXCHECK


321 #undef 
fpurge


322 #if 
HAVE_RAW_DECL_FPURGE


323 
	`_GL_WARN_ON_USE
 (
fpurge
, "fpurge is not always present - "

328 #if @
GNULIB_FPUTC
@

329 #if @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@)

330 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

331 #undef 
fputc


332 #define 
	#fputc
 
rpl_fputc


	)

334 
	`_GL_FUNCDECL_RPL
 (
fputc
, int, (int 
c
, 
FILE
 *
stream
) 
	`_GL_ARG_NONNULL
 ((2)));

335 
	`_GL_CXXALIAS_RPL
 (
fputc
, int, (int 
c
, 
FILE
 *
stream
));

337 
	`_GL_CXXALIAS_SYS
 (
fputc
, int, (int 
c
, 
FILE
 *
stream
));

339 
	`_GL_CXXALIASWARN
 (
fputc
);

342 #if @
GNULIB_FPUTS
@

343 #if @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@)

344 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

345 #undef 
fputs


346 #define 
	#fputs
 
rpl_fputs


	)

348 
	`_GL_FUNCDECL_RPL
 (
fputs
, int, (const char *
string
, 
FILE
 *
stream
)

349 
	`_GL_ARG_NONNULL
 ((1, 2)));

350 
	`_GL_CXXALIAS_RPL
 (
fputs
, int, (const char *
string
, 
FILE
 *
stream
));

352 
	`_GL_CXXALIAS_SYS
 (
fputs
, int, (const char *
string
, 
FILE
 *
stream
));

354 
	`_GL_CXXALIASWARN
 (
fputs
);

357 #if @
GNULIB_FREAD
@

358 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

359 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

360 #undef 
fread


361 #define 
	#fread
 
rpl_fread


	)

363 
	`_GL_FUNCDECL_RPL
 (
fread
, 
size_t
, (void *
ptr
, size_t 
s
, size_t 
n
, 
FILE
 *
stream
)

364 
	`_GL_ARG_NONNULL
 ((4)));

365 
	`_GL_CXXALIAS_RPL
 (
fread
, 
size_t
, (void *
ptr
, size_t 
s
, size_t 
n
, 
FILE
 *
stream
));

367 
	`_GL_CXXALIAS_SYS
 (
fread
, 
size_t
, (void *
ptr
, size_t 
s
, size_t 
n
, 
FILE
 *
stream
));

369 
	`_GL_CXXALIASWARN
 (
fread
);

372 #if @
GNULIB_FREOPEN
@

373 #if @
REPLACE_FREOPEN
@

374 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

375 #undef 
freopen


376 #define 
	#freopen
 
rpl_freopen


	)

378 
	`_GL_FUNCDECL_RPL
 (
freopen
, 
FILE
 *,

379 (const char *
filename
, const char *
mode
, 
FILE
 *
stream
)

380 
	`_GL_ARG_NONNULL
 ((2, 3)));

381 
	`_GL_CXXALIAS_RPL
 (
freopen
, 
FILE
 *,

382 (const char *
filename
, const char *
mode
, 
FILE
 *
stream
));

384 
	`_GL_CXXALIAS_SYS
 (
freopen
, 
FILE
 *,

385 (const char *
filename
, const char *
mode
, 
FILE
 *
stream
));

387 
	`_GL_CXXALIASWARN
 (
freopen
);

388 #elif 
defined
 
GNULIB_POSIXCHECK


389 #undef 
freopen


391 
	`_GL_WARN_ON_USE
 (
freopen
,

396 #if @
GNULIB_FSCANF
@

397 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

398 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

399 #undef 
fscanf


400 #define 
	#fscanf
 
rpl_fscanf


	)

402 
	`_GL_FUNCDECL_RPL
 (
fscanf
, int, (
FILE
 *
stream
, const char *
format
, ...)

403 
	$_GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM
 (2, 3)

404 
	`_GL_ARG_NONNULL
 ((1, 2)));

405 
	`_GL_CXXALIAS_RPL
 (
fscanf
, int, (
FILE
 *
stream
, const char *
format
, ...));

407 
	`_GL_CXXALIAS_SYS
 (
fscanf
, int, (
FILE
 *
stream
, const char *
format
, ...));

409 
	`_GL_CXXALIASWARN
 (
fscanf
);

444 #if @
GNULIB_FSEEK
@

445 #if 
defined
 
GNULIB_POSIXCHECK
 && !defined 
_GL_NO_LARGE_FILES


446 #define 
	#_GL_FSEEK_WARN


	)

447 #undef 
fseek


449 #if @
REPLACE_FSEEK
@

450 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

451 #undef 
fseek


452 #define 
	#fseek
 
rpl_fseek


	)

454 
	`_GL_FUNCDECL_RPL
 (
fseek
, int, (
FILE
 *
fp
, long 
offset
, int 
whence
)

455 
	`_GL_ARG_NONNULL
 ((1)));

456 
	`_GL_CXXALIAS_RPL
 (
fseek
, int, (
FILE
 *
fp
, long 
offset
, int 
whence
));

458 
	`_GL_CXXALIAS_SYS
 (
fseek
, int, (
FILE
 *
fp
, long 
offset
, int 
whence
));

460 
	`_GL_CXXALIASWARN
 (
fseek
);

463 #if @
GNULIB_FSEEKO
@

464 #if !@
GNULIB_FSEEK
@ && !
defined
 
_GL_NO_LARGE_FILES


465 #define 
	#_GL_FSEEK_WARN


	)

466 #undef 
fseek


468 #if @
REPLACE_FSEEKO
@

471 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

472 #undef 
fseeko


473 #define 
	#fseeko
 
rpl_fseeko


	)

475 
	`_GL_FUNCDECL_RPL
 (
fseeko
, int, (
FILE
 *
fp
, 
off_t
 
offset
, int 
whence
)

476 
	`_GL_ARG_NONNULL
 ((1)));

477 
	`_GL_CXXALIAS_RPL
 (
fseeko
, int, (
FILE
 *
fp
, 
off_t
 
offset
, int 
whence
));

479 #if ! @
HAVE_DECL_FSEEKO
@

480 
	`_GL_FUNCDECL_SYS
 (
fseeko
, int, (
FILE
 *
fp
, 
off_t
 
offset
, int 
whence
)

481 
	`_GL_ARG_NONNULL
 ((1)));

483 
	`_GL_CXXALIAS_SYS
 (
fseeko
, int, (
FILE
 *
fp
, 
off_t
 
offset
, int 
whence
));

485 
	`_GL_CXXALIASWARN
 (
fseeko
);

486 #elif 
defined
 
GNULIB_POSIXCHECK


487 #define 
	#_GL_FSEEK_WARN


	)

488 #undef 
fseek


489 #undef 
fseeko


490 #if 
HAVE_RAW_DECL_FSEEKO


491 
	`_GL_WARN_ON_USE
 (
fseeko
, "fseeko is unportable - "

496 #ifdef 
_GL_FSEEK_WARN


497 #undef 
_GL_FSEEK_WARN


500 
	`_GL_WARN_ON_USE
 (
fseek
, "fseek cannot handle files larger than 4 GB "

508 #if @
GNULIB_FTELL
@

509 #if 
defined
 
GNULIB_POSIXCHECK
 && !defined 
_GL_NO_LARGE_FILES


510 #define 
	#_GL_FTELL_WARN


	)

511 #undef 
ftell


513 #if @
REPLACE_FTELL
@

514 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

515 #undef 
ftell


516 #define 
	#ftell
 
rpl_ftell


	)

518 
	`_GL_FUNCDECL_RPL
 (
ftell
, long, (
FILE
 *
fp
) 
	`_GL_ARG_NONNULL
 ((1)));

519 
	`_GL_CXXALIAS_RPL
 (
ftell
, long, (
FILE
 *
fp
));

521 
	`_GL_CXXALIAS_SYS
 (
ftell
, long, (
FILE
 *
fp
));

523 
	`_GL_CXXALIASWARN
 (
ftell
);

526 #if @
GNULIB_FTELLO
@

527 #if !@
GNULIB_FTELL
@ && !
defined
 
_GL_NO_LARGE_FILES


528 #define 
	#_GL_FTELL_WARN


	)

529 #undef 
ftell


531 #if @
REPLACE_FTELLO
@

532 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

533 #undef 
ftello


534 #define 
	#ftello
 
rpl_ftello


	)

536 
	`_GL_FUNCDECL_RPL
 (
ftello
, 
off_t
, (
FILE
 *
fp
) 
	`_GL_ARG_NONNULL
 ((1)));

537 
	`_GL_CXXALIAS_RPL
 (
ftello
, 
off_t
, (
FILE
 *
fp
));

539 #if ! @
HAVE_DECL_FTELLO
@

540 
	`_GL_FUNCDECL_SYS
 (
ftello
, 
off_t
, (
FILE
 *
fp
) 
	`_GL_ARG_NONNULL
 ((1)));

542 
	`_GL_CXXALIAS_SYS
 (
ftello
, 
off_t
, (
FILE
 *
fp
));

544 
	`_GL_CXXALIASWARN
 (
ftello
);

545 #elif 
defined
 
GNULIB_POSIXCHECK


546 #define 
	#_GL_FTELL_WARN


	)

547 #undef 
ftell


548 #undef 
ftello


549 #if 
HAVE_RAW_DECL_FTELLO


550 
	`_GL_WARN_ON_USE
 (
ftello
, "ftello is unportable - "

555 #ifdef 
_GL_FTELL_WARN


556 #undef 
_GL_FTELL_WARN


559 
	`_GL_WARN_ON_USE
 (
ftell
, "ftell cannot handle files larger than 4 GB "

565 #if @
GNULIB_FWRITE
@

566 #if @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@)

567 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

568 #undef 
fwrite


569 #define 
	#fwrite
 
rpl_fwrite


	)

571 
	`_GL_FUNCDECL_RPL
 (
fwrite
, 
size_t
,

572 (const void *
ptr
, 
size_t
 
s
, size_t 
n
, 
FILE
 *
stream
)

573 
	`_GL_ARG_NONNULL
 ((1, 4)));

574 
	`_GL_CXXALIAS_RPL
 (
fwrite
, 
size_t
,

575 (const void *
ptr
, 
size_t
 
s
, size_t 
n
, 
FILE
 *
stream
));

577 
	`_GL_CXXALIAS_SYS
 (
fwrite
, 
size_t
,

578 (const void *
ptr
, 
size_t
 
s
, size_t 
n
, 
FILE
 *
stream
));

585 #if !
defined
 
__cplusplus
 && 0 < 
__USE_FORTIFY_LEVEL


586 static 
inline
 
size_t
 
	`_GL_ARG_NONNULL
 ((1, 4))

587 
	$rpl_fwrite
 (const void *
ptr
, 
size_t
 
s
, size_t 
n
, 
FILE
 *
stream
)

589 
size_t
 
r
 = 
	`fwrite
 (
ptr
, 
s
, 
n
, 
stream
);

590 (void) 
r
;

591 return 
r
;

592 
	}
}

593 #undef 
fwrite


594 #define 
	#fwrite
 
rpl_fwrite


	)

597 
_GL_CXXALIASWARN
 (
fwrite
);

600 #if @
GNULIB_GETC
@

601 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

602 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

603 #undef 
getc


604 #define 
	#getc
 
rpl_fgetc


	)

606 
_GL_FUNCDECL_RPL
 (
fgetc
, int, (
FILE
 *
stream
) 
_GL_ARG_NONNULL
 ((1)));

607 
_GL_CXXALIAS_RPL_1
 (
getc
, 
rpl_fgetc
, int, (
FILE
 *
stream
));

609 
_GL_CXXALIAS_SYS
 (
getc
, int, (
FILE
 *
stream
));

611 
_GL_CXXALIASWARN
 (
getc
);

614 #if @
GNULIB_GETCHAR
@

615 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

616 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

617 #undef 
getchar


618 #define 
	#getchar
 
rpl_getchar


	)

620 
_GL_FUNCDECL_RPL
 (
getchar
, int, (void));

621 
_GL_CXXALIAS_RPL
 (
getchar
, int, (void));

623 
_GL_CXXALIAS_SYS
 (
getchar
, int, (void));

625 
_GL_CXXALIASWARN
 (
getchar
);

628 #if @
GNULIB_GETDELIM
@

635 #if @
REPLACE_GETDELIM
@

636 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

637 #undef 
getdelim


638 #define 
	#getdelim
 
rpl_getdelim


	)

640 
_GL_FUNCDECL_RPL
 (
getdelim
, 
ssize_t
,

641 (char **
lineptr
, 
size_t
 *
linesize
, int 
delimiter
,

642 
FILE
 *
stream
)

643 
_GL_ARG_NONNULL
 ((1, 2, 4)));

644 
_GL_CXXALIAS_RPL
 (
getdelim
, 
ssize_t
,

645 (char **
lineptr
, 
size_t
 *
linesize
, int 
delimiter
,

646 
FILE
 *
stream
));

648 #if !@
HAVE_DECL_GETDELIM
@

649 
_GL_FUNCDECL_SYS
 (
getdelim
, 
ssize_t
,

650 (char **
lineptr
, 
size_t
 *
linesize
, int 
delimiter
,

651 
FILE
 *
stream
)

652 
_GL_ARG_NONNULL
 ((1, 2, 4)));

654 
_GL_CXXALIAS_SYS
 (
getdelim
, 
ssize_t
,

655 (char **
lineptr
, 
size_t
 *
linesize
, int 
delimiter
,

656 
FILE
 *
stream
));

658 
_GL_CXXALIASWARN
 (
getdelim
);

659 #elif 
defined
 
GNULIB_POSIXCHECK


660 #undef 
getdelim


661 #if 
HAVE_RAW_DECL_GETDELIM


662 
_GL_WARN_ON_USE
 (
getdelim
, "getdelim is unportable - "

667 #if @
GNULIB_GETLINE
@

674 #if @
REPLACE_GETLINE
@

675 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

676 #undef 
getline


677 #define 
	#getline
 
rpl_getline


	)

679 
_GL_FUNCDECL_RPL
 (
getline
, 
ssize_t
,

680 (char **
lineptr
, 
size_t
 *
linesize
, 
FILE
 *
stream
)

681 
_GL_ARG_NONNULL
 ((1, 2, 3)));

682 
_GL_CXXALIAS_RPL
 (
getline
, 
ssize_t
,

683 (char **
lineptr
, 
size_t
 *
linesize
, 
FILE
 *
stream
));

685 #if !@
HAVE_DECL_GETLINE
@

686 
_GL_FUNCDECL_SYS
 (
getline
, 
ssize_t
,

687 (char **
lineptr
, 
size_t
 *
linesize
, 
FILE
 *
stream
)

688 
_GL_ARG_NONNULL
 ((1, 2, 3)));

690 
_GL_CXXALIAS_SYS
 (
getline
, 
ssize_t
,

691 (char **
lineptr
, 
size_t
 *
linesize
, 
FILE
 *
stream
));

693 #if @
HAVE_DECL_GETLINE
@

694 
_GL_CXXALIASWARN
 (
getline
);

696 #elif 
defined
 
GNULIB_POSIXCHECK


697 #undef 
getline


698 #if 
HAVE_RAW_DECL_GETLINE


699 
_GL_WARN_ON_USE
 (
getline
, "getline is unportable - "

704 #if @
GNULIB_GETS
@

705 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

706 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

707 #undef 
gets


708 #define 
	#gets
 
rpl_gets


	)

710 
_GL_FUNCDECL_RPL
 (
gets
, char *, (char *
s
) 
_GL_ARG_NONNULL
 ((1)));

711 
_GL_CXXALIAS_RPL
 (
gets
, char *, (char *
s
));

713 
_GL_CXXALIAS_SYS
 (
gets
, char *, (char *
s
));

714 #undef 
gets


716 
_GL_CXXALIASWARN
 (
gets
);

720 
_GL_WARN_ON_USE
 (
gets
, "gets is a security hole - use fgets instead");

724 #if @
GNULIB_OBSTACK_PRINTF
@ || @
GNULIB_OBSTACK_PRINTF_POSIX
@

725 struct 
	gobstack
;

731 #if @
REPLACE_OBSTACK_PRINTF
@

732 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

733 #define 
	#obstack_printf
 
rpl_obstack_printf


	)

735 
_GL_FUNCDECL_RPL
 (
obstack_printf
, int,

736 (struct 
obstack
 *
obs
, const char *
format
, ...)

737 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

738 
	`_GL_ARG_NONNULL
 ((1, 2)));

739 
	`_GL_CXXALIAS_RPL
 (
obstack_printf
, int,

740 (struct 
obstack
 *
obs
, const char *
format
, ...));

742 #if !@
HAVE_DECL_OBSTACK_PRINTF
@

743 
	`_GL_FUNCDECL_SYS
 (
obstack_printf
, int,

744 (struct 
obstack
 *
obs
, const char *
format
, ...)

745 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

746 
	`_GL_ARG_NONNULL
 ((1, 2)));

748 
	`_GL_CXXALIAS_SYS
 (
obstack_printf
, int,

749 (struct 
obstack
 *
obs
, const char *
format
, ...));

751 
	`_GL_CXXALIASWARN
 (
obstack_printf
);

752 #if @
REPLACE_OBSTACK_PRINTF
@

753 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

754 #define 
	#obstack_vprintf
 
rpl_obstack_vprintf


	)

756 
	`_GL_FUNCDECL_RPL
 (
obstack_vprintf
, int,

757 (struct 
obstack
 *
obs
, const char *
format
, 
va_list
 
args
)

758 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

759 
	`_GL_ARG_NONNULL
 ((1, 2)));

760 
	`_GL_CXXALIAS_RPL
 (
obstack_vprintf
, int,

761 (struct 
obstack
 *
obs
, const char *
format
, 
va_list
 
args
));

763 #if !@
HAVE_DECL_OBSTACK_PRINTF
@

764 
	`_GL_FUNCDECL_SYS
 (
obstack_vprintf
, int,

765 (struct 
obstack
 *
obs
, const char *
format
, 
va_list
 
args
)

766 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

767 
	`_GL_ARG_NONNULL
 ((1, 2)));

769 
	`_GL_CXXALIAS_SYS
 (
obstack_vprintf
, int,

770 (struct 
obstack
 *
obs
, const char *
format
, 
va_list
 
args
));

772 
	`_GL_CXXALIASWARN
 (
obstack_vprintf
);

775 #if @
GNULIB_PCLOSE
@

776 #if !@
HAVE_PCLOSE
@

777 
	`_GL_FUNCDECL_SYS
 (
pclose
, int, (
FILE
 *
stream
) 
	`_GL_ARG_NONNULL
 ((1)));

779 
	`_GL_CXXALIAS_SYS
 (
pclose
, int, (
FILE
 *
stream
));

780 
	`_GL_CXXALIASWARN
 (
pclose
);

781 #elif 
defined
 
GNULIB_POSIXCHECK


782 #undef 
pclose


783 #if 
HAVE_RAW_DECL_PCLOSE


784 
	`_GL_WARN_ON_USE
 (
pclose
, "popen is unportable - "

789 #if @
GNULIB_PERROR
@

793 #if @
REPLACE_PERROR
@

794 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

795 #define 
	#perror
 
rpl_perror


	)

797 
	`_GL_FUNCDECL_RPL
 (
perror
, void, (const char *
string
));

798 
	`_GL_CXXALIAS_RPL
 (
perror
, void, (const char *
string
));

800 
	`_GL_CXXALIAS_SYS
 (
perror
, void, (const char *
string
));

802 
	`_GL_CXXALIASWARN
 (
perror
);

803 #elif 
defined
 
GNULIB_POSIXCHECK


804 #undef 
perror


806 
	`_GL_WARN_ON_USE
 (
perror
, "perror is not always POSIX compliant - "

810 #if @
GNULIB_POPEN
@

811 #if @
REPLACE_POPEN
@

812 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

813 #undef 
popen


814 #define 
	#popen
 
rpl_popen


	)

816 
	`_GL_FUNCDECL_RPL
 (
popen
, 
FILE
 *, (const char *
cmd
, const char *
mode
)

817 
	`_GL_ARG_NONNULL
 ((1, 2)));

818 
	`_GL_CXXALIAS_RPL
 (
popen
, 
FILE
 *, (const char *
cmd
, const char *
mode
));

820 #if !@
HAVE_POPEN
@

821 
	`_GL_FUNCDECL_SYS
 (
popen
, 
FILE
 *, (const char *
cmd
, const char *
mode
)

822 
	`_GL_ARG_NONNULL
 ((1, 2)));

824 
	`_GL_CXXALIAS_SYS
 (
popen
, 
FILE
 *, (const char *
cmd
, const char *
mode
));

826 
	`_GL_CXXALIASWARN
 (
popen
);

827 #elif 
defined
 
GNULIB_POSIXCHECK


828 #undef 
popen


829 #if 
HAVE_RAW_DECL_POPEN


830 
	`_GL_WARN_ON_USE
 (
popen
, "popen is buggy on some platforms - "

835 #if @
GNULIB_PRINTF_POSIX
@ || @
GNULIB_PRINTF
@

836 #if (@
GNULIB_PRINTF_POSIX
@ && @
REPLACE_PRINTF
@) \

837 || (@
GNULIB_PRINTF
@ && @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@))

838 #if 
defined
 
__GNUC__


839 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

841 #define 
	#printf
 
__printf__


	)

843 #if @
GNULIB_PRINTF_POSIX
@ || @
GNULIB_VFPRINTF_POSIX
@

844 
	`_GL_FUNCDECL_RPL_1
 (
__printf__
, int,

845 (const char *
format
, ...)

846 
	`__asm__
 (@
ASM_SYMBOL_PREFIX
@

847 
	$_GL_STDIO_MACROEXPAND_AND_STRINGIZE
(
rpl_printf
))

848 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (1, 2)

849 
	`_GL_ARG_NONNULL
 ((1)));

851 
	`_GL_FUNCDECL_RPL_1
 (
__printf__
, int,

852 (const char *
format
, ...)

853 
	`__asm__
 (@
ASM_SYMBOL_PREFIX
@

854 
	$_GL_STDIO_MACROEXPAND_AND_STRINGIZE
(
rpl_printf
))

855 
	$_GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM
 (1, 2)

856 
	`_GL_ARG_NONNULL
 ((1)));

858 
	`_GL_CXXALIAS_RPL_1
 (
printf
, 
__printf__
, int, (const char *
format
, ...));

860 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

861 #define 
	#printf
 
rpl_printf


	)

863 
	`_GL_FUNCDECL_RPL
 (
printf
, int,

864 (const char *
format
, ...)

865 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (1, 2)

866 
	`_GL_ARG_NONNULL
 ((1)));

867 
	`_GL_CXXALIAS_RPL
 (
printf
, int, (const char *
format
, ...));

869 #define 
	#GNULIB_overrides_printf
 1

	)

871 
	`_GL_CXXALIAS_SYS
 (
printf
, int, (const char *
format
, ...));

873 
	`_GL_CXXALIASWARN
 (
printf
);

875 #if !@
GNULIB_PRINTF_POSIX
@ && 
defined
 
GNULIB_POSIXCHECK


876 #if !
GNULIB_overrides_printf


877 #undef 
printf


880 
	`_GL_WARN_ON_USE
 (
printf
, "printf is not always POSIX compliant - "

885 #if @
GNULIB_PUTC
@

886 #if @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@)

887 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

888 #undef 
putc


889 #define 
	#putc
 
rpl_fputc


	)

891 
	`_GL_FUNCDECL_RPL
 (
fputc
, int, (int 
c
, 
FILE
 *
stream
) 
	`_GL_ARG_NONNULL
 ((2)));

892 
	`_GL_CXXALIAS_RPL_1
 (
putc
, 
rpl_fputc
, int, (int 
c
, 
FILE
 *
stream
));

894 
	`_GL_CXXALIAS_SYS
 (
putc
, int, (int 
c
, 
FILE
 *
stream
));

896 
	`_GL_CXXALIASWARN
 (
putc
);

899 #if @
GNULIB_PUTCHAR
@

900 #if @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@)

901 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

902 #undef 
putchar


903 #define 
	#putchar
 
rpl_putchar


	)

905 
	`_GL_FUNCDECL_RPL
 (
putchar
, int, (int 
c
));

906 
	`_GL_CXXALIAS_RPL
 (
putchar
, int, (int 
c
));

908 
	`_GL_CXXALIAS_SYS
 (
putchar
, int, (int 
c
));

910 
	`_GL_CXXALIASWARN
 (
putchar
);

913 #if @
GNULIB_PUTS
@

914 #if @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@)

915 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

916 #undef 
puts


917 #define 
	#puts
 
rpl_puts


	)

919 
	`_GL_FUNCDECL_RPL
 (
puts
, int, (const char *
string
) 
	`_GL_ARG_NONNULL
 ((1)));

920 
	`_GL_CXXALIAS_RPL
 (
puts
, int, (const char *
string
));

922 
	`_GL_CXXALIAS_SYS
 (
puts
, int, (const char *
string
));

924 
	`_GL_CXXALIASWARN
 (
puts
);

927 #if @
GNULIB_REMOVE
@

928 #if @
REPLACE_REMOVE
@

929 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

930 #undef 
remove


931 #define 
	#remove
 
rpl_remove


	)

933 
	`_GL_FUNCDECL_RPL
 (
remove
, int, (const char *
name
) 
	`_GL_ARG_NONNULL
 ((1)));

934 
	`_GL_CXXALIAS_RPL
 (
remove
, int, (const char *
name
));

936 
	`_GL_CXXALIAS_SYS
 (
remove
, int, (const char *
name
));

938 
	`_GL_CXXALIASWARN
 (
remove
);

939 #elif 
defined
 
GNULIB_POSIXCHECK


940 #undef 
remove


942 
	`_GL_WARN_ON_USE
 (
remove
, "remove cannot handle directories on some platforms - "

946 #if @
GNULIB_RENAME
@

947 #if @
REPLACE_RENAME
@

948 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

949 #undef 
rename


950 #define 
	#rename
 
rpl_rename


	)

952 
	`_GL_FUNCDECL_RPL
 (
rename
, int,

953 (const char *
old_filename
, const char *
new_filename
)

954 
	`_GL_ARG_NONNULL
 ((1, 2)));

955 
	`_GL_CXXALIAS_RPL
 (
rename
, int,

956 (const char *
old_filename
, const char *
new_filename
));

958 
	`_GL_CXXALIAS_SYS
 (
rename
, int,

959 (const char *
old_filename
, const char *
new_filename
));

961 
	`_GL_CXXALIASWARN
 (
rename
);

962 #elif 
defined
 
GNULIB_POSIXCHECK


963 #undef 
rename


965 
	`_GL_WARN_ON_USE
 (
rename
, "rename is buggy on some platforms - "

969 #if @
GNULIB_RENAMEAT
@

970 #if @
REPLACE_RENAMEAT
@

971 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

972 #undef 
renameat


973 #define 
	#renameat
 
rpl_renameat


	)

975 
	`_GL_FUNCDECL_RPL
 (
renameat
, int,

976 (int 
fd1
, char const *
file1
, int 
fd2
, char const *
file2
)

977 
	`_GL_ARG_NONNULL
 ((2, 4)));

978 
	`_GL_CXXALIAS_RPL
 (
renameat
, int,

979 (int 
fd1
, char const *
file1
, int 
fd2
, char const *
file2
));

981 #if !@
HAVE_RENAMEAT
@

982 
	`_GL_FUNCDECL_SYS
 (
renameat
, int,

983 (int 
fd1
, char const *
file1
, int 
fd2
, char const *
file2
)

984 
	`_GL_ARG_NONNULL
 ((2, 4)));

986 
	`_GL_CXXALIAS_SYS
 (
renameat
, int,

987 (int 
fd1
, char const *
file1
, int 
fd2
, char const *
file2
));

989 
	`_GL_CXXALIASWARN
 (
renameat
);

990 #elif 
defined
 
GNULIB_POSIXCHECK


991 #undef 
renameat


992 #if 
HAVE_RAW_DECL_RENAMEAT


993 
	`_GL_WARN_ON_USE
 (
renameat
, "renameat is not portable - "

998 #if @
GNULIB_SCANF
@

999 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

1000 #if 
defined
 
__GNUC__


1001 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1002 #undef 
scanf


1004 #define 
	#scanf
 
__scanf__


	)

1006 
	`_GL_FUNCDECL_RPL_1
 (
__scanf__
, int,

1007 (const char *
format
, ...)

1008 
	`__asm__
 (@
ASM_SYMBOL_PREFIX
@

1009 
	$_GL_STDIO_MACROEXPAND_AND_STRINGIZE
(
rpl_scanf
))

1010 
	$_GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM
 (1, 2)

1011 
	`_GL_ARG_NONNULL
 ((1)));

1012 
	`_GL_CXXALIAS_RPL_1
 (
scanf
, 
__scanf__
, int, (const char *
format
, ...));

1014 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1015 #undef 
scanf


1016 #define 
	#scanf
 
rpl_scanf


	)

1018 
	`_GL_FUNCDECL_RPL
 (
scanf
, int, (const char *
format
, ...)

1019 
	$_GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM
 (1, 2)

1020 
	`_GL_ARG_NONNULL
 ((1)));

1021 
	`_GL_CXXALIAS_RPL
 (
scanf
, int, (const char *
format
, ...));

1024 
	`_GL_CXXALIAS_SYS
 (
scanf
, int, (const char *
format
, ...));

1026 
	`_GL_CXXALIASWARN
 (
scanf
);

1029 #if @
GNULIB_SNPRINTF
@

1030 #if @
REPLACE_SNPRINTF
@

1031 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1032 #define 
	#snprintf
 
rpl_snprintf


	)

1034 
	`_GL_FUNCDECL_RPL
 (
snprintf
, int,

1035 (char *
str
, 
size_t
 
size
, const char *
format
, ...)

1036 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (3, 4)

1037 
	`_GL_ARG_NONNULL
 ((3)));

1038 
	`_GL_CXXALIAS_RPL
 (
snprintf
, int,

1039 (char *
str
, 
size_t
 
size
, const char *
format
, ...));

1041 #if !@
HAVE_DECL_SNPRINTF
@

1042 
	`_GL_FUNCDECL_SYS
 (
snprintf
, int,

1043 (char *
str
, 
size_t
 
size
, const char *
format
, ...)

1044 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (3, 4)

1045 
	`_GL_ARG_NONNULL
 ((3)));

1047 
	`_GL_CXXALIAS_SYS
 (
snprintf
, int,

1048 (char *
str
, 
size_t
 
size
, const char *
format
, ...));

1050 
	`_GL_CXXALIASWARN
 (
snprintf
);

1051 #elif 
defined
 
GNULIB_POSIXCHECK


1052 #undef 
snprintf


1053 #if 
HAVE_RAW_DECL_SNPRINTF


1054 
	`_GL_WARN_ON_USE
 (
snprintf
, "snprintf is unportable - "

1068 #if @
GNULIB_SPRINTF_POSIX
@

1069 #if @
REPLACE_SPRINTF
@

1070 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1071 #define 
	#sprintf
 
rpl_sprintf


	)

1073 
	`_GL_FUNCDECL_RPL
 (
sprintf
, int, (char *
str
, const char *
format
, ...)

1074 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

1075 
	`_GL_ARG_NONNULL
 ((1, 2)));

1076 
	`_GL_CXXALIAS_RPL
 (
sprintf
, int, (char *
str
, const char *
format
, ...));

1078 
	`_GL_CXXALIAS_SYS
 (
sprintf
, int, (char *
str
, const char *
format
, ...));

1080 
	`_GL_CXXALIASWARN
 (
sprintf
);

1081 #elif 
defined
 
GNULIB_POSIXCHECK


1082 #undef 
sprintf


1084 
	`_GL_WARN_ON_USE
 (
sprintf
, "sprintf is not always POSIX compliant - "

1089 #if @
GNULIB_TMPFILE
@

1090 #if @
REPLACE_TMPFILE
@

1091 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1092 #define 
	#tmpfile
 
rpl_tmpfile


	)

1094 
	`_GL_FUNCDECL_RPL
 (
tmpfile
, 
FILE
 *, (void));

1095 
	`_GL_CXXALIAS_RPL
 (
tmpfile
, 
FILE
 *, (void));

1097 
	`_GL_CXXALIAS_SYS
 (
tmpfile
, 
FILE
 *, (void));

1099 
	`_GL_CXXALIASWARN
 (
tmpfile
);

1100 #elif 
defined
 
GNULIB_POSIXCHECK


1101 #undef 
tmpfile


1102 #if 
HAVE_RAW_DECL_TMPFILE


1103 
	`_GL_WARN_ON_USE
 (
tmpfile
, "tmpfile is not usable on mingw - "

1108 #if @
GNULIB_VASPRINTF
@

1113 #if @
REPLACE_VASPRINTF
@

1114 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1115 #define 
	#asprintf
 
rpl_asprintf


	)

1117 
	`_GL_FUNCDECL_RPL
 (
asprintf
, int,

1118 (char **
result
, const char *
format
, ...)

1119 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

1120 
	`_GL_ARG_NONNULL
 ((1, 2)));

1121 
	`_GL_CXXALIAS_RPL
 (
asprintf
, int,

1122 (char **
result
, const char *
format
, ...));

1124 #if !@
HAVE_VASPRINTF
@

1125 
	`_GL_FUNCDECL_SYS
 (
asprintf
, int,

1126 (char **
result
, const char *
format
, ...)

1127 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 3)

1128 
	`_GL_ARG_NONNULL
 ((1, 2)));

1130 
	`_GL_CXXALIAS_SYS
 (
asprintf
, int,

1131 (char **
result
, const char *
format
, ...));

1133 
	`_GL_CXXALIASWARN
 (
asprintf
);

1134 #if @
REPLACE_VASPRINTF
@

1135 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1136 #define 
	#vasprintf
 
rpl_vasprintf


	)

1138 
	`_GL_FUNCDECL_RPL
 (
vasprintf
, int,

1139 (char **
result
, const char *
format
, 
va_list
 
args
)

1140 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

1141 
	`_GL_ARG_NONNULL
 ((1, 2)));

1142 
	`_GL_CXXALIAS_RPL
 (
vasprintf
, int,

1143 (char **
result
, const char *
format
, 
va_list
 
args
));

1145 #if !@
HAVE_VASPRINTF
@

1146 
	`_GL_FUNCDECL_SYS
 (
vasprintf
, int,

1147 (char **
result
, const char *
format
, 
va_list
 
args
)

1148 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

1149 
	`_GL_ARG_NONNULL
 ((1, 2)));

1151 
	`_GL_CXXALIAS_SYS
 (
vasprintf
, int,

1152 (char **
result
, const char *
format
, 
va_list
 
args
));

1154 
	`_GL_CXXALIASWARN
 (
vasprintf
);

1157 #if @
GNULIB_VDPRINTF
@

1158 #if @
REPLACE_VDPRINTF
@

1159 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1160 #define 
	#vdprintf
 
rpl_vdprintf


	)

1162 
	`_GL_FUNCDECL_RPL
 (
vdprintf
, int, (int 
fd
, const char *
format
, 
va_list
 
args
)

1163 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

1164 
	`_GL_ARG_NONNULL
 ((2)));

1165 
	`_GL_CXXALIAS_RPL
 (
vdprintf
, int, (int 
fd
, const char *
format
, 
va_list
 
args
));

1167 #if !@
HAVE_VDPRINTF
@

1168 
	`_GL_FUNCDECL_SYS
 (
vdprintf
, int, (int 
fd
, const char *
format
, 
va_list
 
args
)

1169 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

1170 
	`_GL_ARG_NONNULL
 ((2)));

1174 
	`_GL_CXXALIAS_SYS_CAST
 (
vdprintf
, int,

1175 (int 
fd
, const char *
format
, 
va_list
 
args
));

1177 
	`_GL_CXXALIASWARN
 (
vdprintf
);

1178 #elif 
defined
 
GNULIB_POSIXCHECK


1179 #undef 
vdprintf


1180 #if 
HAVE_RAW_DECL_VDPRINTF


1181 
	`_GL_WARN_ON_USE
 (
vdprintf
, "vdprintf is unportable - "

1186 #if @
GNULIB_VFPRINTF_POSIX
@ || @
GNULIB_VFPRINTF
@

1187 #if (@
GNULIB_VFPRINTF_POSIX
@ && @
REPLACE_VFPRINTF
@) \

1188 || (@
GNULIB_VFPRINTF
@ && @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@))

1189 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1190 #define 
	#vfprintf
 
rpl_vfprintf


	)

1192 #define 
	#GNULIB_overrides_vfprintf
 1

	)

1193 #if @
GNULIB_VFPRINTF_POSIX
@

1194 
	`_GL_FUNCDECL_RPL
 (
vfprintf
, int, (
FILE
 *
fp
, const char *
format
, 
va_list
 
args
)

1195 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

1196 
	`_GL_ARG_NONNULL
 ((1, 2)));

1198 
	`_GL_FUNCDECL_RPL
 (
vfprintf
, int, (
FILE
 *
fp
, const char *
format
, 
va_list
 
args
)

1199 
	$_GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM
 (2, 0)

1200 
	`_GL_ARG_NONNULL
 ((1, 2)));

1202 
	`_GL_CXXALIAS_RPL
 (
vfprintf
, int, (
FILE
 *
fp
, const char *
format
, 
va_list
 
args
));

1207 
	`_GL_CXXALIAS_SYS_CAST
 (
vfprintf
, int,

1208 (
FILE
 *
fp
, const char *
format
, 
va_list
 
args
));

1210 
	`_GL_CXXALIASWARN
 (
vfprintf
);

1212 #if !@
GNULIB_VFPRINTF_POSIX
@ && 
defined
 
GNULIB_POSIXCHECK


1213 #if !
GNULIB_overrides_vfprintf


1214 #undef 
vfprintf


1217 
	`_GL_WARN_ON_USE
 (
vfprintf
, "vfprintf is not always POSIX compliant - "

1222 #if @
GNULIB_VFSCANF
@

1223 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

1224 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1225 #undef 
vfscanf


1226 #define 
	#vfscanf
 
rpl_vfscanf


	)

1228 
	`_GL_FUNCDECL_RPL
 (
vfscanf
, int,

1229 (
FILE
 *
stream
, const char *
format
, 
va_list
 
args
)

1230 
	$_GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM
 (2, 0)

1231 
	`_GL_ARG_NONNULL
 ((1, 2)));

1232 
	`_GL_CXXALIAS_RPL
 (
vfscanf
, int,

1233 (
FILE
 *
stream
, const char *
format
, 
va_list
 
args
));

1235 
	`_GL_CXXALIAS_SYS
 (
vfscanf
, int,

1236 (
FILE
 *
stream
, const char *
format
, 
va_list
 
args
));

1238 
	`_GL_CXXALIASWARN
 (
vfscanf
);

1241 #if @
GNULIB_VPRINTF_POSIX
@ || @
GNULIB_VPRINTF
@

1242 #if (@
GNULIB_VPRINTF_POSIX
@ && @
REPLACE_VPRINTF
@) \

1243 || (@
GNULIB_VPRINTF
@ && @
REPLACE_STDIO_WRITE_FUNCS
@ && (@
GNULIB_STDIO_H_NONBLOCKING
@ || @
GNULIB_STDIO_H_SIGPIPE
@))

1244 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1245 #define 
	#vprintf
 
rpl_vprintf


	)

1247 #define 
	#GNULIB_overrides_vprintf
 1

	)

1248 #if @
GNULIB_VPRINTF_POSIX
@ || @
GNULIB_VFPRINTF_POSIX
@

1249 
	`_GL_FUNCDECL_RPL
 (
vprintf
, int, (const char *
format
, 
va_list
 
args
)

1250 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (1, 0)

1251 
	`_GL_ARG_NONNULL
 ((1)));

1253 
	`_GL_FUNCDECL_RPL
 (
vprintf
, int, (const char *
format
, 
va_list
 
args
)

1254 
	$_GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM
 (1, 0)

1255 
	`_GL_ARG_NONNULL
 ((1)));

1257 
	`_GL_CXXALIAS_RPL
 (
vprintf
, int, (const char *
format
, 
va_list
 
args
));

1262 
	`_GL_CXXALIAS_SYS_CAST
 (
vprintf
, int, (const char *
format
, 
va_list
 
args
));

1264 
	`_GL_CXXALIASWARN
 (
vprintf
);

1266 #if !@
GNULIB_VPRINTF_POSIX
@ && 
defined
 
GNULIB_POSIXCHECK


1267 #if !
GNULIB_overrides_vprintf


1268 #undef 
vprintf


1271 
	`_GL_WARN_ON_USE
 (
vprintf
, "vprintf is not always POSIX compliant - "

1276 #if @
GNULIB_VSCANF
@

1277 #if @
REPLACE_STDIO_READ_FUNCS
@ && @
GNULIB_STDIO_H_NONBLOCKING
@

1278 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1279 #undef 
vscanf


1280 #define 
	#vscanf
 
rpl_vscanf


	)

1282 
	`_GL_FUNCDECL_RPL
 (
vscanf
, int, (const char *
format
, 
va_list
 
args
)

1283 
	$_GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM
 (1, 0)

1284 
	`_GL_ARG_NONNULL
 ((1)));

1285 
	`_GL_CXXALIAS_RPL
 (
vscanf
, int, (const char *
format
, 
va_list
 
args
));

1287 
	`_GL_CXXALIAS_SYS
 (
vscanf
, int, (const char *
format
, 
va_list
 
args
));

1289 
	`_GL_CXXALIASWARN
 (
vscanf
);

1292 #if @
GNULIB_VSNPRINTF
@

1293 #if @
REPLACE_VSNPRINTF
@

1294 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1295 #define 
	#vsnprintf
 
rpl_vsnprintf


	)

1297 
	`_GL_FUNCDECL_RPL
 (
vsnprintf
, int,

1298 (char *
str
, 
size_t
 
size
, const char *
format
, 
va_list
 
args
)

1299 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (3, 0)

1300 
	`_GL_ARG_NONNULL
 ((3)));

1301 
	`_GL_CXXALIAS_RPL
 (
vsnprintf
, int,

1302 (char *
str
, 
size_t
 
size
, const char *
format
, 
va_list
 
args
));

1304 #if !@
HAVE_DECL_VSNPRINTF
@

1305 
	`_GL_FUNCDECL_SYS
 (
vsnprintf
, int,

1306 (char *
str
, 
size_t
 
size
, const char *
format
, 
va_list
 
args
)

1307 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (3, 0)

1308 
	`_GL_ARG_NONNULL
 ((3)));

1310 
	`_GL_CXXALIAS_SYS
 (
vsnprintf
, int,

1311 (char *
str
, 
size_t
 
size
, const char *
format
, 
va_list
 
args
));

1313 
	`_GL_CXXALIASWARN
 (
vsnprintf
);

1314 #elif 
defined
 
GNULIB_POSIXCHECK


1315 #undef 
vsnprintf


1316 #if 
HAVE_RAW_DECL_VSNPRINTF


1317 
	`_GL_WARN_ON_USE
 (
vsnprintf
, "vsnprintf is unportable - "

1322 #if @
GNULIB_VSPRINTF_POSIX
@

1323 #if @
REPLACE_VSPRINTF
@

1324 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1325 #define 
	#vsprintf
 
rpl_vsprintf


	)

1327 
	`_GL_FUNCDECL_RPL
 (
vsprintf
, int,

1328 (char *
str
, const char *
format
, 
va_list
 
args
)

1329 
	$_GL_ATTRIBUTE_FORMAT_PRINTF
 (2, 0)

1330 
	`_GL_ARG_NONNULL
 ((1, 2)));

1331 
	`_GL_CXXALIAS_RPL
 (
vsprintf
, int,

1332 (char *
str
, const char *
format
, 
va_list
 
args
));

1337 
	`_GL_CXXALIAS_SYS_CAST
 (
vsprintf
, int,

1338 (char *
str
, const char *
format
, 
va_list
 
args
));

1340 
	`_GL_CXXALIASWARN
 (
vsprintf
);

1341 #elif 
defined
 
GNULIB_POSIXCHECK


1342 #undef 
vsprintf


1344 
	`_GL_WARN_ON_USE
 (
vsprintf
, "vsprintf is not always POSIX compliant - "

	@gnulib-tests/symlink.c

19 #include 
	~<config.h
>

22 #include 
	~<unistd.h
>

24 #include 
	~<errno.h
>

25 #include 
	~<string.h
>

26 #include 
	~<sys/stat.h
>

29 #if 
HAVE_SYMLINK


31 #undef 
symlink


35 
	$rpl_symlink
 (char const *
contents
, char const *
name
)

37 
size_t
 
len
 = 
	`strlen
 (
name
);

38 if (
len
 && 
name
[len - 1] == '/')

40 struct 
stat
 
st
;

41 if (
	`lstat
 (
name
, &
st
) == 0)

42 
errno
 = 
EEXIST
;

45 return 
	`symlink
 (
contents
, 
name
);

46 
	}
}

52 
	$symlink
 (char const *
contents
 
_GL_UNUSED
,

53 char const *
name
 
_GL_UNUSED
)

55 
errno
 = 
ENOSYS
;

57 
	}
}

	@gnulib-tests/test-alloca-opt.c

21 #include 
	~<config.h
>

23 #include 
	~<alloca.h
>

25 #if 
HAVE_ALLOCA


28 
	$do_allocation
 (int 
n
)

30 void *
ptr
 = 
	`alloca
 (
n
);

31 (void) 
ptr
;

32 
	}
}

34 void (*
func
) (int) = 
do_allocation
;

39 
	$main
 ()

41 #if 
HAVE_ALLOCA


42 int 
i
;

45 for (
i
 = 0; i < 100000; i++)

50 
	`func
 (34);

51 
	`func
 (134);

52 
	`func
 (399);

53 
	`func
 (510823);

54 
	`func
 (129321);

55 
	`func
 (0);

56 
	`func
 (4070);

57 
	`func
 (4095);

58 
	`func
 (1);

59 
	`func
 (16582);

64 
	}
}

	@gnulib-tests/test-argmatch.c

22 #include 
	~<config.h
>

24 #include 
	~"argmatch.h
"

26 #include 
	~<stdlib.h
>

28 #include 
	~"progname.h
"

29 #include 
	~"macros.h
"

33 #ifdef 
ARGMATCH_DIE_DECL


35 
_Noreturn
 
	gARGMATCH_DIE_DECL
;

36 
	gARGMATCH_DIE_DECL
 { 
exit
 (1); }

40 enum 
	ebackup_type


42 
	mno_backups
,

43 
	msimple_backups
,

44 
	mnumbered_existing_backups
,

45 
	mnumbered_backups


48 static const char *const 
	gbackup_args
[] =

54 
NULL


57 static const enum 
backup_type
 
	gbackup_vals
[] =

59 
no_backups
, no_backups, no_backups,

60 
simple_backups
, simple_backups, simple_backups,

61 
numbered_existing_backups
, numbered_existing_backups, numbered_existing_backups,

62 
numbered_backups
, numbered_backups, numbered_backups

66 
	$main
 (int 
argc
, char *
argv
[])

68 
	`set_program_name
 (
argv
[0]);

71 
	`ASSERT
 (
	`ARGMATCH
 ("klingon", 
backup_args
, 
backup_vals
) == -1);

74 
	`ASSERT
 (
	`ARGMATCH
 ("none", 
backup_args
, 
backup_vals
) == 1);

75 
	`ASSERT
 (
	`ARGMATCH
 ("nil", 
backup_args
, 
backup_vals
) == 7);

78 
	`ASSERT
 (
	`ARGMATCH
 ("nilpotent", 
backup_args
, 
backup_vals
) == -1);

81 
	`ASSERT
 (
	`ARGMATCH
 ("simpl", 
backup_args
, 
backup_vals
) == 3);

82 
	`ASSERT
 (
	`ARGMATCH
 ("simp", 
backup_args
, 
backup_vals
) == 3);

83 
	`ASSERT
 (
	`ARGMATCH
 ("sim", 
backup_args
, 
backup_vals
) == 3);

86 
	`ASSERT
 (
	`ARGMATCH
 ("numbered", 
backup_args
, 
backup_vals
) == 9);

87 
	`ASSERT
 (
	`ARGMATCH
 ("numbere", 
backup_args
, 
backup_vals
) == -2);

88 
	`ASSERT
 (
	`ARGMATCH
 ("number", 
backup_args
, 
backup_vals
) == -2);

89 
	`ASSERT
 (
	`ARGMATCH
 ("numbe", 
backup_args
, 
backup_vals
) == -2);

90 
	`ASSERT
 (
	`ARGMATCH
 ("numb", 
backup_args
, 
backup_vals
) == -2);

91 
	`ASSERT
 (
	`ARGMATCH
 ("num", 
backup_args
, 
backup_vals
) == -2);

92 
	`ASSERT
 (
	`ARGMATCH
 ("nu", 
backup_args
, 
backup_vals
) == -2);

93 
	`ASSERT
 (
	`ARGMATCH
 ("n", 
backup_args
, 
backup_vals
) == -2);

96 
	`ASSERT
 (
	`ARGMATCH
 ("ne", 
backup_args
, 
backup_vals
) == -2);

99 
	`ASSERT
 (
	`ARGMATCH
 ("si", 
backup_args
, 
backup_vals
) == 3);

100 
	`ASSERT
 (
	`ARGMATCH
 ("s", 
backup_args
, 
backup_vals
) == 3);

103 
	}
}

	@gnulib-tests/test-binary-io.c

21 #include 
	~<config.h
>

23 #include 
	~"binary-io.h
"

25 #include 
	~<sys/types.h
>

26 #include 
	~<sys/stat.h
>

27 #include 
	~<fcntl.h
>

28 #include 
	~<stdio.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<unistd.h
>

32 #include 
	~"macros.h
"

35 
	$main
 ()

39 int 
fd
 =

40 
	`open
 ("t-bin-out2.tmp", 
O_CREAT
 | 
O_TRUNC
 | 
O_RDWR
 | 
O_BINARY
, 0600);

41 if (
	`write
 (
fd
, "Hello\n", 6) < 0)

42 
	`exit
 (1);

43 
	`close
 (
fd
);

46 struct 
stat
 
statbuf
;

47 if (
	`stat
 ("t-bin-out2.tmp", &
statbuf
) < 0)

48 
	`exit
 (1);

49 
	`ASSERT
 (
statbuf
.
st_size
 == 6);

51 
	`unlink
 ("t-bin-out2.tmp");

54 
	`SET_BINARY
 (1);

55 
	`fputs
 ("Hello\n", 
stdout
);

56 
	`fclose
 (
stdout
);

57 
	`fclose
 (
stderr
);

59 struct 
stat
 
statbuf
;

60 if (
	`stat
 ("t-bin-out1.tmp", &
statbuf
) < 0)

61 
	`exit
 (1);

62 
	`ASSERT
 (
statbuf
.
st_size
 == 6);

66 
	}
}

	@gnulib-tests/test-bitrotate.c

21 #include 
	~<config.h
>

23 #include 
	~"bitrotate.h
"

25 #include 
	~"macros.h
"

28 
	$main
 (void)

30 
	`ASSERT
 (
	`rotl8
 (42, 0) == 42);

31 
	`ASSERT
 (
	`rotl8
 (42, 1) == 84);

32 
	`ASSERT
 (
	`rotl8
 (42, 2) == 168);

33 
	`ASSERT
 (
	`rotl8
 (42, 3) == 81);

34 
	`ASSERT
 (
	`rotl8
 (42, 4) == 162);

35 
	`ASSERT
 (
	`rotl8
 (42, 5) == 69);

36 
	`ASSERT
 (
	`rotl8
 (42, 6) == 138);

37 
	`ASSERT
 (
	`rotl8
 (42, 7) == 21);

38 
	`ASSERT
 (
	`rotl8
 (42, 8) == 42);

40 
	`ASSERT
 (
	`rotr8
 (42, 0) == 42);

41 
	`ASSERT
 (
	`rotr8
 (42, 1) == 21);

42 
	`ASSERT
 (
	`rotr8
 (42, 2) == 138);

43 
	`ASSERT
 (
	`rotr8
 (42, 3) == 69);

44 
	`ASSERT
 (
	`rotr8
 (42, 4) == 162);

45 
	`ASSERT
 (
	`rotr8
 (42, 5) == 81);

46 
	`ASSERT
 (
	`rotr8
 (42, 6) == 168);

47 
	`ASSERT
 (
	`rotr8
 (42, 7) == 84);

48 
	`ASSERT
 (
	`rotr8
 (42, 8) == 42);

50 
	`ASSERT
 (
	`rotl16
 (43981, 0) == 43981);

51 
	`ASSERT
 (
	`rotl16
 (43981, 1) == 22427);

52 
	`ASSERT
 (
	`rotl16
 (43981, 2) == 44854);

53 
	`ASSERT
 (
	`rotl16
 (43981, 3) == 24173);

54 
	`ASSERT
 (
	`rotl16
 (43981, 4) == 48346);

55 
	`ASSERT
 (
	`rotl16
 (43981, 5) == 31157);

56 
	`ASSERT
 (
	`rotl16
 (43981, 6) == 62314);

57 
	`ASSERT
 (
	`rotl16
 (43981, 7) == 59093);

58 
	`ASSERT
 (
	`rotl16
 (43981, 8) == 52651);

59 
	`ASSERT
 (
	`rotl16
 (43981, 9) == 39767);

60 
	`ASSERT
 (
	`rotl16
 (43981, 10) == 13999);

61 
	`ASSERT
 (
	`rotl16
 (43981, 11) == 27998);

62 
	`ASSERT
 (
	`rotl16
 (43981, 12) == 55996);

63 
	`ASSERT
 (
	`rotl16
 (43981, 13) == 46457);

64 
	`ASSERT
 (
	`rotl16
 (43981, 14) == 27379);

65 
	`ASSERT
 (
	`rotl16
 (43981, 15) == 54758);

66 
	`ASSERT
 (
	`rotl16
 (43981, 16) == 43981);

68 
	`ASSERT
 (
	`rotr16
 (43981, 0) == 43981);

69 
	`ASSERT
 (
	`rotr16
 (43981, 1) == 54758);

70 
	`ASSERT
 (
	`rotr16
 (43981, 2) == 27379);

71 
	`ASSERT
 (
	`rotr16
 (43981, 3) == 46457);

72 
	`ASSERT
 (
	`rotr16
 (43981, 4) == 55996);

73 
	`ASSERT
 (
	`rotr16
 (43981, 5) == 27998);

74 
	`ASSERT
 (
	`rotr16
 (43981, 6) == 13999);

75 
	`ASSERT
 (
	`rotr16
 (43981, 7) == 39767);

76 
	`ASSERT
 (
	`rotr16
 (43981, 8) == 52651);

77 
	`ASSERT
 (
	`rotr16
 (43981, 9) == 59093);

78 
	`ASSERT
 (
	`rotr16
 (43981, 10) == 62314);

79 
	`ASSERT
 (
	`rotr16
 (43981, 11) == 31157);

80 
	`ASSERT
 (
	`rotr16
 (43981, 12) == 48346);

81 
	`ASSERT
 (
	`rotr16
 (43981, 13) == 24173);

82 
	`ASSERT
 (
	`rotr16
 (43981, 14) == 44854);

83 
	`ASSERT
 (
	`rotr16
 (43981, 15) == 22427);

84 
	`ASSERT
 (
	`rotr16
 (43981, 16) == 43981);

86 
	`ASSERT
 (
	`rotl32
 (2309737967U, 1) == 324508639U);

87 
	`ASSERT
 (
	`rotl32
 (2309737967U, 2) == 649017278U);

88 
	`ASSERT
 (
	`rotl32
 (2309737967U, 3) == 1298034556U);

89 
	`ASSERT
 (
	`rotl32
 (2309737967U, 4) == 2596069112U);

90 
	`ASSERT
 (
	`rotl32
 (2309737967U, 5) == 897170929U);

91 
	`ASSERT
 (
	`rotl32
 (2309737967U, 6) == 1794341858U);

92 
	`ASSERT
 (
	`rotl32
 (2309737967U, 7) == 3588683716U);

93 
	`ASSERT
 (
	`rotl32
 (2309737967U, 8) == 2882400137U);

94 
	`ASSERT
 (
	`rotl32
 (2309737967U, 9) == 1469832979U);

95 
	`ASSERT
 (
	`rotl32
 (2309737967U, 10) == 2939665958U);

96 
	`ASSERT
 (
	`rotl32
 (2309737967U, 11) == 1584364621U);

97 
	`ASSERT
 (
	`rotl32
 (2309737967U, 12) == 3168729242U);

98 
	`ASSERT
 (
	`rotl32
 (2309737967U, 13) == 2042491189U);

99 
	`ASSERT
 (
	`rotl32
 (2309737967U, 14) == 4084982378U);

100 
	`ASSERT
 (
	`rotl32
 (2309737967U, 15) == 3874997461U);

101 
	`ASSERT
 (
	`rotl32
 (2309737967U, 16) == 3455027627U);

102 
	`ASSERT
 (
	`rotl32
 (2309737967U, 17) == 2615087959U);

103 
	`ASSERT
 (
	`rotl32
 (2309737967U, 18) == 935208623U);

104 
	`ASSERT
 (
	`rotl32
 (2309737967U, 19) == 1870417246U);

105 
	`ASSERT
 (
	`rotl32
 (2309737967U, 20) == 3740834492U);

106 
	`ASSERT
 (
	`rotl32
 (2309737967U, 21) == 3186701689U);

107 
	`ASSERT
 (
	`rotl32
 (2309737967U, 22) == 2078436083U);

108 
	`ASSERT
 (
	`rotl32
 (2309737967U, 23) == 4156872166U);

109 
	`ASSERT
 (
	`rotl32
 (2309737967U, 24) == 4018777037U);

110 
	`ASSERT
 (
	`rotl32
 (2309737967U, 25) == 3742586779U);

111 
	`ASSERT
 (
	`rotl32
 (2309737967U, 26) == 3190206263U);

112 
	`ASSERT
 (
	`rotl32
 (2309737967U, 27) == 2085445231U);

113 
	`ASSERT
 (
	`rotl32
 (2309737967U, 28) == 4170890462U);

114 
	`ASSERT
 (
	`rotl32
 (2309737967U, 29) == 4046813629U);

115 
	`ASSERT
 (
	`rotl32
 (2309737967U, 30) == 3798659963U);

116 
	`ASSERT
 (
	`rotl32
 (2309737967U, 31) == 3302352631U);

118 
	`ASSERT
 (
	`rotr32
 (2309737967U, 1) == 3302352631lU);

119 
	`ASSERT
 (
	`rotr32
 (2309737967U, 2) == 3798659963lU);

120 
	`ASSERT
 (
	`rotr32
 (2309737967U, 3) == 4046813629lU);

121 
	`ASSERT
 (
	`rotr32
 (2309737967U, 4) == 4170890462lU);

122 
	`ASSERT
 (
	`rotr32
 (2309737967U, 5) == 2085445231lU);

123 
	`ASSERT
 (
	`rotr32
 (2309737967U, 6) == 3190206263lU);

124 
	`ASSERT
 (
	`rotr32
 (2309737967U, 7) == 3742586779lU);

125 
	`ASSERT
 (
	`rotr32
 (2309737967U, 8) == 4018777037lU);

126 
	`ASSERT
 (
	`rotr32
 (2309737967U, 9) == 4156872166lU);

127 
	`ASSERT
 (
	`rotr32
 (2309737967U, 10) == 2078436083lU);

128 
	`ASSERT
 (
	`rotr32
 (2309737967U, 11) == 3186701689lU);

129 
	`ASSERT
 (
	`rotr32
 (2309737967U, 12) == 3740834492lU);

130 
	`ASSERT
 (
	`rotr32
 (2309737967U, 13) == 1870417246lU);

131 
	`ASSERT
 (
	`rotr32
 (2309737967U, 14) == 935208623lU);

132 
	`ASSERT
 (
	`rotr32
 (2309737967U, 15) == 2615087959lU);

133 
	`ASSERT
 (
	`rotr32
 (2309737967U, 16) == 3455027627lU);

134 
	`ASSERT
 (
	`rotr32
 (2309737967U, 17) == 3874997461lU);

135 
	`ASSERT
 (
	`rotr32
 (2309737967U, 18) == 4084982378lU);

136 
	`ASSERT
 (
	`rotr32
 (2309737967U, 19) == 2042491189lU);

137 
	`ASSERT
 (
	`rotr32
 (2309737967U, 20) == 3168729242lU);

138 
	`ASSERT
 (
	`rotr32
 (2309737967U, 21) == 1584364621lU);

139 
	`ASSERT
 (
	`rotr32
 (2309737967U, 22) == 2939665958lU);

140 
	`ASSERT
 (
	`rotr32
 (2309737967U, 23) == 1469832979lU);

141 
	`ASSERT
 (
	`rotr32
 (2309737967U, 24) == 2882400137lU);

142 
	`ASSERT
 (
	`rotr32
 (2309737967U, 25) == 3588683716lU);

143 
	`ASSERT
 (
	`rotr32
 (2309737967U, 26) == 1794341858lU);

144 
	`ASSERT
 (
	`rotr32
 (2309737967U, 27) == 897170929lU);

145 
	`ASSERT
 (
	`rotr32
 (2309737967U, 28) == 2596069112lU);

146 
	`ASSERT
 (
	`rotr32
 (2309737967U, 29) == 1298034556lU);

147 
	`ASSERT
 (
	`rotr32
 (2309737967U, 30) == 649017278lU);

148 
	`ASSERT
 (
	`rotr32
 (2309737967U, 31) == 324508639lU);

150 #ifdef 
UINT64_MAX


151 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 1) == 13644637895296644477ULL);

152 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 2) == 8842531716883737339ULL);

153 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 3) == 17685063433767474678ULL);

154 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 4) == 16923382793825397741ULL);

155 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 5) == 15400021513941243867ULL);

156 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 6) == 12353298954172936119ULL);

157 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 7) == 6259853834636320623ULL);

158 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 8) == 12519707669272641246ULL);

159 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 9) == 6592671264835730877ULL);

160 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 10) == 13185342529671461754ULL);

161 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 11) == 7923940985633371893ULL);

162 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 12) == 15847881971266743786ULL);

163 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 13) == 13249019868823935957ULL);

164 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 14) == 8051295663938320299ULL);

165 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 15) == 16102591327876640598ULL);

166 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 16) == 13758438582043729581ULL);

167 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 17) == 9070133090377907547ULL);

168 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 18) == 18140266180755815094ULL);

169 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 19) == 17833788287802078573ULL);

170 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 20) == 17220832501894605531ULL);

171 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 21) == 15994920930079659447ULL);

172 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 22) == 13543097786449767279ULL);

173 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 23) == 8639451499189982943ULL);

174 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 24) == 17278902998379965886ULL);

175 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 25) == 16111061923050380157ULL);

176 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 26) == 13775379772391208699ULL);

177 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 27) == 9104015471072865783ULL);

178 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 28) == 18208030942145731566ULL);

179 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 29) == 17969317810581911517ULL);

180 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 30) == 17491891547454271419ULL);

181 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 31) == 16537039021198991223ULL);

182 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 32) == 14627333968688430831ULL);

183 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 33) == 10807923863667310047ULL);

184 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 34) == 3169103653625068479ULL);

185 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 35) == 6338207307250136958ULL);

186 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 36) == 12676414614500273916ULL);

187 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 37) == 6906085155290996217ULL);

188 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 38) == 13812170310581992434ULL);

189 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 39) == 9177596547454433253ULL);

190 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 40) == 18355193094908866506ULL);

191 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 41) == 18263642116108181397ULL);

192 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 42) == 18080540158506811179ULL);

193 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 43) == 17714336243304070743ULL);

194 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 44) == 16981928412898589871ULL);

195 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 45) == 15517112752087628127ULL);

196 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 46) == 12587481430465704639ULL);

197 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 47) == 6728218787221857663ULL);

198 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 48) == 13456437574443715326ULL);

199 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 49) == 8466131075177879037ULL);

200 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 50) == 16932262150355758074ULL);

201 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 51) == 15417780227001964533ULL);

202 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 52) == 12388816380294377451ULL);

203 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 53) == 6330888686879203287ULL);

204 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 54) == 12661777373758406574ULL);

205 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 55) == 6876810673807261533ULL);

206 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 56) == 13753621347614523066ULL);

207 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 57) == 9060498621519494517ULL);

208 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 58) == 18120997243038989034ULL);

209 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 59) == 17795250412368426453ULL);

210 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 60) == 17143756751027301291ULL);

211 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 61) == 15840769428345050967ULL);

212 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 62) == 13234794782980550319ULL);

213 
	`ASSERT
 (
	`rotl64
 (16045690984503098046ULL, 63) == 8022845492251549023ULL);

215 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 1) == 8022845492251549023ULL);

216 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 2) == 13234794782980550319ULL);

217 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 3) == 15840769428345050967ULL);

218 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 4) == 17143756751027301291ULL);

219 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 5) == 17795250412368426453ULL);

220 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 6) == 18120997243038989034ULL);

221 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 7) == 9060498621519494517ULL);

222 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 8) == 13753621347614523066ULL);

223 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 9) == 6876810673807261533ULL);

224 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 10) == 12661777373758406574ULL);

225 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 11) == 6330888686879203287ULL);

226 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 12) == 12388816380294377451ULL);

227 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 13) == 15417780227001964533ULL);

228 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 14) == 16932262150355758074ULL);

229 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 15) == 8466131075177879037ULL);

230 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 16) == 13456437574443715326ULL);

231 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 17) == 6728218787221857663ULL);

232 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 18) == 12587481430465704639ULL);

233 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 19) == 15517112752087628127ULL);

234 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 20) == 16981928412898589871ULL);

235 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 21) == 17714336243304070743ULL);

236 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 22) == 18080540158506811179ULL);

237 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 23) == 18263642116108181397ULL);

238 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 24) == 18355193094908866506ULL);

239 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 25) == 9177596547454433253ULL);

240 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 26) == 13812170310581992434ULL);

241 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 27) == 6906085155290996217ULL);

242 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 28) == 12676414614500273916ULL);

243 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 29) == 6338207307250136958ULL);

244 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 30) == 3169103653625068479ULL);

245 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 31) == 10807923863667310047ULL);

246 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 32) == 14627333968688430831ULL);

247 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 33) == 16537039021198991223ULL);

248 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 34) == 17491891547454271419ULL);

249 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 35) == 17969317810581911517ULL);

250 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 36) == 18208030942145731566ULL);

251 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 37) == 9104015471072865783ULL);

252 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 38) == 13775379772391208699ULL);

253 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 39) == 16111061923050380157ULL);

254 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 40) == 17278902998379965886ULL);

255 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 41) == 8639451499189982943ULL);

256 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 42) == 13543097786449767279ULL);

257 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 43) == 15994920930079659447ULL);

258 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 44) == 17220832501894605531ULL);

259 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 45) == 17833788287802078573ULL);

260 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 46) == 18140266180755815094ULL);

261 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 47) == 9070133090377907547ULL);

262 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 48) == 13758438582043729581ULL);

263 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 49) == 16102591327876640598ULL);

264 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 50) == 8051295663938320299ULL);

265 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 51) == 13249019868823935957ULL);

266 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 52) == 15847881971266743786ULL);

267 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 53) == 7923940985633371893ULL);

268 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 54) == 13185342529671461754ULL);

269 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 55) == 6592671264835730877ULL);

270 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 56) == 12519707669272641246ULL);

271 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 57) == 6259853834636320623ULL);

272 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 58) == 12353298954172936119ULL);

273 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 59) == 15400021513941243867ULL);

274 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 60) == 16923382793825397741ULL);

275 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 61) == 17685063433767474678ULL);

276 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 62) == 8842531716883737339ULL);

277 
	`ASSERT
 (
	`rotr64
 (16045690984503098046ULL, 63) == 13644637895296644477ULL);

281 
	}
}

	@gnulib-tests/test-btowc.c

21 #include 
	~<config.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
btowc
, 
wint_t
, (int));

28 #include 
	~<locale.h
>

29 #include 
	~<stdio.h
>

31 #include 
	~"macros.h
"

34 
	$main
 (int 
argc
, char *
argv
[])

36 int 
c
;

39 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

42 
	`ASSERT
 (
	`btowc
 (
EOF
) == 
WEOF
);

44 if (
argc
 > 1)

45 switch (
argv
[1][0])

49 for (
c
 = 0; c < 0x80; c++)

50 
	`ASSERT
 (
	`btowc
 (
c
) == c);

51 for (
c
 = 0xA0; c < 0x100; c++)

52 
	`ASSERT
 (
	`btowc
 (
c
) != 
WEOF
);

57 for (
c
 = 0; c < 0x80; c++)

58 
	`ASSERT
 (
	`btowc
 (
c
) == c);

59 for (
c
 = 0x80; c < 0x100; c++)

60 
	`ASSERT
 (
	`btowc
 (
c
) == 
WEOF
);

65 
	}
}

	@gnulib-tests/test-c-ctype.c

21 #include 
	~<config.h
>

23 #include 
	~"c-ctype.h
"

25 #include 
	~<locale.h
>

27 #include 
	~"macros.h
"

30 
	$test_all
 (void)

32 int 
c
;

34 for (
c
 = -0x80; c < 0x100; c++)

36 
	`ASSERT
 (
	`c_isascii
 (
c
) == (c >= 0 && c < 0x80));

38 switch (
c
)

52 
	`ASSERT
 (
	`c_isalnum
 (
c
) == 1);

55 
	`ASSERT
 (
	`c_isalnum
 (
c
) == 0);

59 switch (
c
)

71 
	`ASSERT
 (
	`c_isalpha
 (
c
) == 1);

74 
	`ASSERT
 (
	`c_isalpha
 (
c
) == 0);

78 switch (
c
)

81 
	`ASSERT
 (
	`c_isblank
 (
c
) == 1);

84 
	`ASSERT
 (
	`c_isblank
 (
c
) == 0);

88 
	`ASSERT
 (
	`c_iscntrl
 (
c
) == ((c >= 0 && c < 0x20) || c == 0x7f));

90 switch (
c
)

94 
	`ASSERT
 (
	`c_isdigit
 (
c
) == 1);

97 
	`ASSERT
 (
	`c_isdigit
 (
c
) == 0);

101 switch (
c
)

108 
	`ASSERT
 (
	`c_islower
 (
c
) == 1);

111 
	`ASSERT
 (
	`c_islower
 (
c
) == 0);

115 
	`ASSERT
 (
	`c_isgraph
 (
c
) == ((c >= 0x20 && c < 0x7f) && c != ' '));

117 
	`ASSERT
 (
	`c_isprint
 (
c
) == (c >= 0x20 && c < 0x7f));

119 
	`ASSERT
 (
	`c_ispunct
 (
c
) == (
	`c_isgraph
 (c) && !
	`c_isalnum
 (c)));

121 switch (
c
)

124 
	`ASSERT
 (
	`c_isspace
 (
c
) == 1);

127 
	`ASSERT
 (
	`c_isspace
 (
c
) == 0);

131 switch (
c
)

138 
	`ASSERT
 (
	`c_isupper
 (
c
) == 1);

141 
	`ASSERT
 (
	`c_isupper
 (
c
) == 0);

145 switch (
c
)

151 
	`ASSERT
 (
	`c_isxdigit
 (
c
) == 1);

154 
	`ASSERT
 (
	`c_isxdigit
 (
c
) == 0);

158 switch (
c
)

161 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'a');

162 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

165 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'b');

166 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

169 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'c');

170 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

173 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'd');

174 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

177 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'e');

178 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

181 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'f');

182 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

185 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'g');

186 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

189 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'h');

190 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

193 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'i');

194 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

197 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'j');

198 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

201 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'k');

202 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

205 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'l');

206 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

209 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'm');

210 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

213 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'n');

214 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

217 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'o');

218 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

221 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'p');

222 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

225 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'q');

226 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

229 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'r');

230 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

233 
	`ASSERT
 (
	`c_tolower
 (
c
) == 's');

234 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

237 
	`ASSERT
 (
	`c_tolower
 (
c
) == 't');

238 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

241 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'u');

242 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

245 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'v');

246 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

249 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'w');

250 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

253 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'x');

254 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

257 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'y');

258 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

261 
	`ASSERT
 (
	`c_tolower
 (
c
) == 'z');

262 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

265 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

266 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'A');

269 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

270 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'B');

273 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

274 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'C');

277 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

278 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'D');

281 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

282 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'E');

285 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

286 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'F');

289 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

290 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'G');

293 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

294 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'H');

297 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

298 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'I');

301 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

302 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'J');

305 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

306 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'K');

309 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

310 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'L');

313 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

314 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'M');

317 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

318 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'N');

321 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

322 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'O');

325 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

326 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'P');

329 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

330 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'Q');

333 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

334 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'R');

337 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

338 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'S');

341 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

342 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'T');

345 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

346 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'U');

349 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

350 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'V');

353 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

354 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'W');

357 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

358 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'X');

361 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

362 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'Y');

365 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

366 
	`ASSERT
 (
	`c_toupper
 (
c
) == 'Z');

369 
	`ASSERT
 (
	`c_tolower
 (
c
) == c);

370 
	`ASSERT
 (
	`c_toupper
 (
c
) == c);

374 
	}
}

377 
	$main
 ()

379 
	`test_all
 ();

381 
	`setlocale
 (
LC_ALL
, "de_DE");

382 
	`test_all
 ();

384 
	`setlocale
 (
LC_ALL
, "ja_JP.EUC-JP");

385 
	`test_all
 ();

388 
	}
}

	@gnulib-tests/test-c-strcasecmp.c

21 #include 
	~<config.h
>

23 #include 
	~"c-strcase.h
"

25 #include 
	~<locale.h
>

26 #include 
	~<string.h
>

28 #include 
	~"macros.h
"

31 
	$main
 (int 
argc
, char *
argv
[])

33 if (
argc
 > 1)

36 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

40 
	`ASSERT
 (
	`c_strcasecmp
 ("paragraph", "Paragraph") == 0);

42 
	`ASSERT
 (
	`c_strcasecmp
 ("paragrapH", "parAgRaph") == 0);

44 
	`ASSERT
 (
	`c_strcasecmp
 ("paragraph", "paraLyzed") < 0);

45 
	`ASSERT
 (
	`c_strcasecmp
 ("paraLyzed", "paragraph") > 0);

47 
	`ASSERT
 (
	`c_strcasecmp
 ("para", "paragraph") < 0);

48 
	`ASSERT
 (
	`c_strcasecmp
 ("paragraph", "para") > 0);

53 
	`ASSERT
 (
	`c_strcasecmp
 ("\311mile", "\351mile") < 0);

54 
	`ASSERT
 (
	`c_strcasecmp
 ("\351mile", "\311mile") > 0);

59 
	`ASSERT
 (
	`c_strcasecmp
 ("\303\266zg\303\274r", "\303\226ZG\303\234R") > 0);

60 
	`ASSERT
 (
	`c_strcasecmp
 ("\303\226ZG\303\234R", "\303\266zg\303\274r") < 0);

63 
	`ASSERT
 (
	`c_strcasecmp
 ("turkish", "TURK\304\260SH") < 0);

64 
	`ASSERT
 (
	`c_strcasecmp
 ("TURK\304\260SH", "turkish") > 0);

67 
	}
}

	@gnulib-tests/test-c-strncasecmp.c

21 #include 
	~<config.h
>

23 #include 
	~"c-strcase.h
"

25 #include 
	~<locale.h
>

26 #include 
	~<string.h
>

28 #include 
	~"macros.h
"

31 
	$main
 (int 
argc
, char *
argv
[])

33 if (
argc
 > 1)

36 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

40 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "Paragraph", 1000000) == 0);

41 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "Paragraph", 9) == 0);

43 
	`ASSERT
 (
	`c_strncasecmp
 ("paragrapH", "parAgRaph", 1000000) == 0);

44 
	`ASSERT
 (
	`c_strncasecmp
 ("paragrapH", "parAgRaph", 9) == 0);

46 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "paraLyzed", 10) < 0);

47 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "paraLyzed", 9) < 0);

48 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "paraLyzed", 5) < 0);

49 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "paraLyzed", 4) == 0);

50 
	`ASSERT
 (
	`c_strncasecmp
 ("paraLyzed", "paragraph", 10) > 0);

51 
	`ASSERT
 (
	`c_strncasecmp
 ("paraLyzed", "paragraph", 9) > 0);

52 
	`ASSERT
 (
	`c_strncasecmp
 ("paraLyzed", "paragraph", 5) > 0);

53 
	`ASSERT
 (
	`c_strncasecmp
 ("paraLyzed", "paragraph", 4) == 0);

55 
	`ASSERT
 (
	`c_strncasecmp
 ("para", "paragraph", 10) < 0);

56 
	`ASSERT
 (
	`c_strncasecmp
 ("para", "paragraph", 9) < 0);

57 
	`ASSERT
 (
	`c_strncasecmp
 ("para", "paragraph", 5) < 0);

58 
	`ASSERT
 (
	`c_strncasecmp
 ("para", "paragraph", 4) == 0);

59 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "para", 10) > 0);

60 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "para", 9) > 0);

61 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "para", 5) > 0);

62 
	`ASSERT
 (
	`c_strncasecmp
 ("paragraph", "para", 4) == 0);

67 
	`ASSERT
 (
	`c_strncasecmp
 ("\311mily", "\351mile", 4) < 0);

68 
	`ASSERT
 (
	`c_strncasecmp
 ("\351mile", "\311mily", 4) > 0);

73 
	`ASSERT
 (
	`c_strncasecmp
 ("\303\266zg\303\274r", "\303\226ZG\303\234R", 99) > 0);

74 
	`ASSERT
 (
	`c_strncasecmp
 ("\303\226ZG\303\234R", "\303\266zg\303\274r", 99) < 0);

77 
	`ASSERT
 (
	`c_strncasecmp
 ("turkish", "TURK\304\260SH", 7) < 0);

78 
	`ASSERT
 (
	`c_strncasecmp
 ("TURK\304\260SH", "turkish", 7) > 0);

81 
	}
}

	@gnulib-tests/test-close.c

19 #include 
	~<config.h
>

21 #include 
	~<unistd.h
>

23 #include 
	~"signature.h
"

24 
SIGNATURE_CHECK
 (
close
, int, (int));

26 #include 
	~<errno.h
>

28 #include 
	~"macros.h
"

31 
	$main
 (void)

35 
errno
 = 0;

36 
	`ASSERT
 (
	`close
 (-1) == -1);

37 
	`ASSERT
 (
errno
 == 
EBADF
);

40 
errno
 = 0;

41 
	`ASSERT
 (
	`close
 (99) == -1);

42 
	`ASSERT
 (
errno
 == 
EBADF
);

46 
	}
}

	@gnulib-tests/test-ctype.c

21 #include 
	~<config.h
>

23 #include 
	~<ctype.h
>

26 
	$main
 (void)

29 
	}
}

	@gnulib-tests/test-dirent.c

21 #include 
	~<config.h
>

23 #include 
	~<dirent.h
>

26 static 
DIR
 *
dir
 
	g_GL_UNUSED
;

27 static struct 
dirent
 
	gd
;

28 static 
ino_t
 
	gi
;

31 
	$main
 (void)

33 return 
d
.
d_name
[0] + 
i
;

34 
	}
}

	@gnulib-tests/test-dirname.c

19 #include 
	~<config.h
>

21 #include 
	~"dirname.h
"

23 #include 
	~<stdbool.h
>

24 #include 
	~<stdio.h
>

25 #include 
	~<stdlib.h
>

26 #include 
	~<string.h
>

28 struct 
	stest
 {

29 const char *
	mname
;

30 const char *
	mdir
;

31 const char *
	mlast
;

32 const char *
	mbase
;

33 const char *
	mstripped
;

34 
bool
 
	mmodified
;

35 
bool
 
	mabsolute
;

38 static struct 
test
 
	gtests
[] = {

39 {"d/f", "d", "f", "f", "d/f", 
false
, false},

40 {"/d/f", "/d", "f", "f", "/d/f", 
false
, 
true
},

41 {"d/f/", "d", "f/", "f/", "d/f", 
true
, 
false
},

42 {"d/f//", "d", "f//", "f/", "d/f", 
true
, 
false
},

43 {"f", ".", "f", "f", "f", 
false
, false},

44 {"/", "/", "", "/", "/", 
false
, 
true
},

45 #if 
DOUBLE_SLASH_IS_DISTINCT_ROOT


46 {"//", "//", "", "//", "//", 
false
, 
true
},

47 {"//d", "//", "d", "d", "//d", 
false
, 
true
},

49 {"//", "/", "", "/", "/", 
true
, true},

50 {"//d", "/", "d", "d", "//d", 
false
, 
true
},

52 {"///", "/", "", "/", "/", 
true
, true},

53 {"///a///", "/", "a///", "a/", "///a", 
true
, true},

56 {"", ".", "", "", "", 
false
, false},

57 {".", ".", ".", ".", ".", 
false
, false},

58 {"..", ".", "..", "..", "..", 
false
, false},

59 #if 
ISSLASH
 ('\\')

60 {"a\\", ".", "a\\", "a\\", "a", 
true
, 
false
},

61 {"a\\b", "a", "b", "b", "a\\b", 
false
, false},

62 {"\\", "\\", "", "\\", "\\", 
false
, 
true
},

63 {"\\/\\", "\\", "", "\\", "\\", 
true
, true},

64 {"\\\\/", "\\", "", "\\", "\\", 
true
, true},

65 {"\\//", "\\", "", "\\", "\\", 
true
, true},

66 {"//\\", "/", "", "/", "/", 
true
, true},

68 {"a\\", ".", "a\\", "a\\", "a\\", 
false
, false},

69 {"a\\b", ".", "a\\b", "a\\b", "a\\b", 
false
, false},

70 {"\\", ".", "\\", "\\", "\\", 
false
, false},

71 {"\\/\\", "\\", "\\", "\\", "\\/\\",
false
, false},

72 {"\\\\/", ".", "\\\\/","\\\\/","\\\\", 
true
, 
false
},

73 {"\\//", ".", "\\//", "\\/", "\\", 
true
, 
false
},

74 #if 
DOUBLE_SLASH_IS_DISTINCT_ROOT


75 {"//\\", "//", "\\", "\\", "//\\", 
false
, 
true
},

77 {"//\\", "/", "\\", "\\", "//\\", 
false
, 
true
},

80 #if 
ISSLASH
 ('\\')

81 #if 
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE


82 {"c:", "c:", "", "c:", "c:", 
false
, false},

83 {"c:/", "c:/", "", "c:/", "c:/", 
false
, 
true
},

84 {"c://", "c:/", "", "c:/", "c:/", 
true
, true},

85 {"c:/d", "c:/", "d", "d", "c:/d", 
false
, 
true
},

86 {"c://d", "c:/", "d", "d", "c://d",
false
, 
true
},

87 {"c:/d/", "c:/", "d/", "d/", "c:/d", 
true
, true},

88 {"c:/d/f", "c:/d", "f", "f", "c:/d/f",
false
, 
true
},

89 {"c:d", "c:.", "d", "d", "c:d", 
false
, false},

90 {"c:d/", "c:.", "d/", "d/", "c:d", 
true
, 
false
},

91 {"c:d/f", "c:d", "f", "f", "c:d/f",
false
, false},

92 {"a:b:c", "a:.", "b:c", "./b:c","a:b:c",
false
, false},

93 {"a/b:c", "a", "b:c", "./b:c","a/b:c",
false
, false},

94 {"a/b:c/", "a", "b:c/", "./b:c/","a/b:c",
true
, 
false
},

96 {"c:", "c:", "", "c:", "c:", 
false
, 
true
},

97 {"c:/", "c:", "", "c:", "c:", 
true
, true},

98 {"c://", "c:", "", "c:", "c:", 
true
, true},

99 {"c:/d", "c:", "d", "d", "c:/d", 
false
, 
true
},

100 {"c://d", "c:", "d", "d", "c://d",
false
, 
true
},

101 {"c:/d/", "c:", "d/", "d/", "c:/d", 
true
, true},

102 {"c:/d/f", "c:/d", "f", "f", "c:/d/f",
false
, 
true
},

103 {"c:d", "c:", "d", "d", "c:d", 
false
, 
true
},

104 {"c:d/", "c:", "d/", "d/", "c:d", 
true
, true},

105 {"c:d/f", "c:d", "f", "f", "c:d/f",
false
, 
true
},

106 {"a:b:c", "a:", "b:c", "./b:c","a:b:c",
false
, 
true
},

107 {"a/b:c", "a", "b:c", "./b:c","a/b:c",
false
, false},

108 {"a/b:c/", "a", "b:c/", "./b:c/","a/b:c",
true
, 
false
},

111 {"c:", ".", "c:", "c:", "c:", 
false
, false},

112 {"c:/", ".", "c:/", "c:/", "c:", 
true
, 
false
},

113 {"c://", ".", "c://", "c:/", "c:", 
true
, 
false
},

114 {"c:/d", "c:", "d", "d", "c:/d", 
false
, false},

115 {"c://d", "c:", "d", "d", "c://d",
false
, false},

116 {"c:/d/", "c:", "d/", "d/", "c:/d", 
true
, 
false
},

117 {"c:/d/f", "c:/d", "f", "f", "c:/d/f",
false
, false},

118 {"c:d", ".", "c:d", "c:d", "c:d", 
false
, false},

119 {"c:d/", ".", "c:d/", "c:d/", "c:d", 
true
, 
false
},

120 {"c:d/f", "c:d", "f", "f", "c:d/f",
false
, false},

121 {"a:b:c", ".", "a:b:c","a:b:c","a:b:c",
false
, false},

122 {"a/b:c", "a", "b:c", "b:c", "a/b:c",
false
, false},

123 {"a/b:c/", "a", "b:c/", "b:c/", "a/b:c",
true
, 
false
},

125 {"1:", ".", "1:", "1:", "1:", 
false
, false},

126 {"1:/", ".", "1:/", "1:/", "1:", 
true
, 
false
},

127 {"/:", "/", ":", ":", "/:", 
false
, 
true
},

128 {"/:/", "/", ":/", ":/", "/:", 
true
, true},

130 {
NULL
, NULL, NULL, NULL, NULL, 
false
, false}

134 
	$main
 (void)

136 struct 
test
 *
t
;

137 
bool
 
ok
 = 
true
;

139 for (
t
 = 
tests
; t->
name
; t++)

141 char *
dir
 = 
	`dir_name
 (
t
->
name
);

142 int 
dirlen
 = 
	`dir_len
 (
t
->
name
);

143 char *
last
 = 
	`last_component
 (
t
->
name
);

144 char *
base
 = 
	`base_name
 (
t
->
name
);

145 int 
baselen
 = 
	`base_len
 (
base
);

146 char *
stripped
 = 
	`strdup
 (
t
->
name
);

147 
bool
 
modified
 = 
	`strip_trailing_slashes
 (
stripped
);

148 
bool
 
absolute
 = 
	`IS_ABSOLUTE_FILE_NAME
 (
t
->
name
);

149 if (! (
	`strcmp
 (
dir
, 
t
->dir) == 0

150 && (
dirlen
 == 
	`strlen
 (
dir
)

151 || (
dirlen
 + 1 == 
	`strlen
 (
dir
) && dir[dirlen] == '.'))))

153 
ok
 = 
false
;

154 
	`printf
 ("dir_name `%s': got `%s' len %d, expected `%s' len %ld\n",

155 
t
->
name
, 
dir
, 
dirlen
,

156 
t
->
dir
, (unsigned long) 
	`strlen
 (t->dir));

158 if (
	`strcmp
 (
last
, 
t
->last))

160 
ok
 = 
false
;

161 
	`printf
 ("last_component `%s': got `%s', expected `%s'\n",

162 
t
->
name
, 
last
, t->last);

164 if (! (
	`strcmp
 (
base
, 
t
->base) == 0

165 && (
baselen
 == 
	`strlen
 (
base
)

166 || (
baselen
 + 1 == 
	`strlen
 (
base
)

167 && 
	`ISSLASH
 (
base
[
baselen
])))))

169 
ok
 = 
false
;

170 
	`printf
 ("base_name `%s': got `%s' len %d, expected `%s' len %ld\n",

171 
t
->
name
, 
base
, 
baselen
,

172 
t
->
base
, (unsigned long) 
	`strlen
 (t->base));

174 if (
	`strcmp
 (
stripped
, 
t
->stripped) || 
modified
 != t->modified)

176 
ok
 = 
false
;

177 
	`printf
 ("strip_trailing_slashes `%s': got %s %s, expected %s %s\n",

178 
t
->
name
, 
stripped
, 
modified
 ? "changed" : "unchanged",

179 
t
->
stripped
, t->
modified
 ? "changed" : "unchanged");

181 if (
t
->
absolute
 != absolute)

183 
ok
 = 
false
;

184 
	`printf
 ("`%s': got %s, expected %s\n", 
t
->
name
,

185 
absolute
 ? "absolute" : "relative",

186 
t
->
absolute
 ? "absolute" : "relative");

188 
	`free
 (
dir
);

189 
	`free
 (
base
);

190 
	`free
 (
stripped
);

192 return 
ok
 ? 0 : 1;

193 
	}
}

	@gnulib-tests/test-dup2.c

21 #include 
	~<config.h
>

23 #include 
	~<unistd.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
dup2
, int, (int, int));

28 #include 
	~<errno.h
>

29 #include 
	~<fcntl.h
>

31 #include 
	~"binary-io.h
"

33 #if 
GNULIB_TEST_CLOEXEC


34 #include 
	~"cloexec.h
"

37 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


39 #define 
	#WIN32_LEAN_AND_MEAN


	)

40 #include 
	~<windows.h
>

42 #include 
	~"msvc-nothrow.h
"

45 #include 
	~"macros.h
"

49 
	$is_open
 (int 
fd
)

51 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


55 return (
HANDLE
) 
	`_get_osfhandle
 (
fd
) != 
INVALID_HANDLE_VALUE
;

57 #ifndef 
F_GETFL


58 #error 
Please
 
port
 
fcntl
 
to
 
your
 
platform


60 return 0 <= 
	`fcntl
 (
fd
, 
F_GETFL
);

62 
	}
}

64 #if 
GNULIB_TEST_CLOEXEC


67 
	$is_inheritable
 (int 
fd
)

69 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


73 
HANDLE
 
h
 = (HANDLE) 
	`_get_osfhandle
 (
fd
);

74 
DWORD
 
flags
;

75 if (
h
 == 
INVALID_HANDLE_VALUE
 || 
	`GetHandleInformation
 (h, &
flags
) == 0)

77 return (
flags
 & 
HANDLE_FLAG_INHERIT
) != 0;

79 #ifndef 
F_GETFD


80 #error 
Please
 
port
 
fcntl
 
to
 
your
 
platform


82 int 
i
 = 
	`fcntl
 (
fd
, 
F_GETFD
);

83 return 0 <= 
i
 && (i & 
FD_CLOEXEC
) == 0;

85 
	}
}

88 #if !
O_BINARY


89 #define 
	#setmode
(
f
,
m
) 
	`zero
 ()

	)

90 static int 
	$zero
 (void) { return 0; 
	}
}

96 
	$is_mode
 (int 
fd
, int 
mode
)

98 int 
value
 = 
	`setmode
 (
fd
, 
O_BINARY
);

99 
	`setmode
 (
fd
, 
value
);

100 return 
mode
 == 
value
;

101 
	}
}

104 
	$main
 (void)

106 const char *
file
 = "test-dup2.tmp";

107 char 
buffer
[1];

108 int 
fd
 = 
	`open
 (
file
, 
O_CREAT
 | 
O_TRUNC
 | 
O_RDWR
, 0600);

111 
	`ASSERT
 (
STDERR_FILENO
 < 
fd
);

112 
	`ASSERT
 (
	`is_open
 (
fd
));

114 
	`close
 (
fd
 + 1);

115 
	`close
 (
fd
 + 2);

116 
	`ASSERT
 (!
	`is_open
 (
fd
 + 1));

117 
	`ASSERT
 (!
	`is_open
 (
fd
 + 2));

120 
	`ASSERT
 (
	`dup2
 (
fd
, fd) == fd);

121 
	`ASSERT
 (
	`is_open
 (
fd
));

124 
errno
 = 0;

125 
	`ASSERT
 (
	`dup2
 (-1, 
fd
) == -1);

126 
	`ASSERT
 (
errno
 == 
EBADF
);

127 
errno
 = 0;

128 
	`ASSERT
 (
	`dup2
 (99, 
fd
) == -1);

129 
	`ASSERT
 (
errno
 == 
EBADF
);

130 
errno
 = 0;

131 
	`ASSERT
 (
	`dup2
 (
AT_FDCWD
, 
fd
) == -1);

132 
	`ASSERT
 (
errno
 == 
EBADF
);

133 
	`ASSERT
 (
	`is_open
 (
fd
));

136 
errno
 = 0;

137 
	`ASSERT
 (
	`dup2
 (
fd
 + 1, fd + 1) == -1);

138 
	`ASSERT
 (
errno
 == 
EBADF
);

139 
	`ASSERT
 (!
	`is_open
 (
fd
 + 1));

140 
errno
 = 0;

141 
	`ASSERT
 (
	`dup2
 (
fd
 + 1, fd) == -1);

142 
	`ASSERT
 (
errno
 == 
EBADF
);

143 
	`ASSERT
 (
	`is_open
 (
fd
));

146 
errno
 = 0;

147 
	`ASSERT
 (
	`dup2
 (
fd
, -2) == -1);

148 
	`ASSERT
 (
errno
 == 
EBADF
);

149 
errno
 = 0;

150 
	`ASSERT
 (
	`dup2
 (
fd
, 10000000) == -1);

151 
	`ASSERT
 (
errno
 == 
EBADF
);

154 
	`ASSERT
 (
	`dup2
 (
fd
, fd + 2) == fd + 2);

155 
	`ASSERT
 (
	`is_open
 (
fd
));

156 
	`ASSERT
 (!
	`is_open
 (
fd
 + 1));

157 
	`ASSERT
 (
	`is_open
 (
fd
 + 2));

160 
	`ASSERT
 (
	`open
 ("/dev/null", 
O_WRONLY
, 0600) == 
fd
 + 1);

161 
	`ASSERT
 (
	`dup2
 (
fd
 + 1, fd) == fd);

162 
	`ASSERT
 (
	`close
 (
fd
 + 1) == 0);

163 
	`ASSERT
 (
	`write
 (
fd
, "1", 1) == 1);

164 
	`ASSERT
 (
	`dup2
 (
fd
 + 2, fd) == fd);

165 
	`ASSERT
 (
	`lseek
 (
fd
, 0, 
SEEK_END
) == 0);

166 
	`ASSERT
 (
	`write
 (
fd
 + 2, "2", 1) == 1);

167 
	`ASSERT
 (
	`lseek
 (
fd
, 0, 
SEEK_SET
) == 0);

168 
	`ASSERT
 (
	`read
 (
fd
, 
buffer
, 1) == 1);

169 
	`ASSERT
 (*
buffer
 == '2');

171 #if 
GNULIB_TEST_CLOEXEC


173 
	`ASSERT
 (
	`close
 (
fd
 + 2) == 0);

174 
	`ASSERT
 (
	`dup_cloexec
 (
fd
) == fd + 1);

175 
	`ASSERT
 (!
	`is_inheritable
 (
fd
 + 1));

176 
	`ASSERT
 (
	`dup2
 (
fd
 + 1, fd + 1) == fd + 1);

177 
	`ASSERT
 (!
	`is_inheritable
 (
fd
 + 1));

178 
	`ASSERT
 (
	`dup2
 (
fd
 + 1, fd + 2) == fd + 2);

179 
	`ASSERT
 (!
	`is_inheritable
 (
fd
 + 1));

180 
	`ASSERT
 (
	`is_inheritable
 (
fd
 + 2));

181 
errno
 = 0;

182 
	`ASSERT
 (
	`dup2
 (
fd
 + 1, -1) == -1);

183 
	`ASSERT
 (
errno
 == 
EBADF
);

184 
	`ASSERT
 (!
	`is_inheritable
 (
fd
 + 1));

189 
	`setmode
 (
fd
, 
O_BINARY
);

190 
	`ASSERT
 (
	`is_mode
 (
fd
, 
O_BINARY
));

191 
	`ASSERT
 (
	`dup2
 (
fd
, fd + 1) == fd + 1);

192 
	`ASSERT
 (
	`is_mode
 (
fd
 + 1, 
O_BINARY
));

193 
	`setmode
 (
fd
, 
O_TEXT
);

194 
	`ASSERT
 (
	`is_mode
 (
fd
, 
O_TEXT
));

195 
	`ASSERT
 (
	`dup2
 (
fd
, fd + 1) == fd + 1);

196 
	`ASSERT
 (
	`is_mode
 (
fd
 + 1, 
O_TEXT
));

199 
	`ASSERT
 (
	`close
 (
fd
 + 2) == 0);

200 
	`ASSERT
 (
	`close
 (
fd
 + 1) == 0);

201 
	`ASSERT
 (
	`close
 (
fd
) == 0);

202 
	`ASSERT
 (
	`unlink
 (
file
) == 0);

205 
	}
}

	@gnulib-tests/test-environ.c

21 #include 
	~<config.h
>

23 #include 
	~<unistd.h
>

25 #include 
	~<string.h
>

28 
	$main
 ()

35 char **
remaining_variables
 = 
environ
;

36 char *
string
;

38 for (; (
string
 = *
remaining_variables
) != 
NULL
; remaining_variables++)

40 if (
	`strncmp
 (
string
, "PATH=", 5) == 0)

46 
	}
}

	@gnulib-tests/test-errno.c

21 #include 
	~<config.h
>

23 #include 
	~<errno.h
>

28 int 
	ge1
 = 
EPERM
;

29 int 
	ge2
 = 
ENOENT
;

30 int 
	ge3
 = 
ESRCH
;

31 int 
	ge4
 = 
EINTR
;

32 int 
	ge5
 = 
EIO
;

33 int 
	ge6
 = 
ENXIO
;

34 int 
	ge7
 = 
E2BIG
;

35 int 
	ge8
 = 
ENOEXEC
;

36 int 
	ge9
 = 
EBADF
;

37 int 
	ge10
 = 
ECHILD
;

38 int 
	ge11
 = 
EAGAIN
;

39 int 
	ge11a
 = 
EWOULDBLOCK
;

40 int 
	ge12
 = 
ENOMEM
;

41 int 
	ge13
 = 
EACCES
;

42 int 
	ge14
 = 
EFAULT
;

43 int 
	ge16
 = 
EBUSY
;

44 int 
	ge17
 = 
EEXIST
;

45 int 
	ge18
 = 
EXDEV
;

46 int 
	ge19
 = 
ENODEV
;

47 int 
	ge20
 = 
ENOTDIR
;

48 int 
	ge21
 = 
EISDIR
;

49 int 
	ge22
 = 
EINVAL
;

50 int 
	ge23
 = 
ENFILE
;

51 int 
	ge24
 = 
EMFILE
;

52 int 
	ge25
 = 
ENOTTY
;

53 int 
	ge26
 = 
ETXTBSY
;

54 int 
	ge27
 = 
EFBIG
;

55 int 
	ge28
 = 
ENOSPC
;

56 int 
	ge29
 = 
ESPIPE
;

57 int 
	ge30
 = 
EROFS
;

58 int 
	ge31
 = 
EMLINK
;

59 int 
	ge32
 = 
EPIPE
;

60 int 
	ge33
 = 
EDOM
;

61 int 
	ge34
 = 
ERANGE
;

62 int 
	ge35
 = 
EDEADLK
;

63 int 
	ge36
 = 
ENAMETOOLONG
;

64 int 
	ge37
 = 
ENOLCK
;

65 int 
	ge38
 = 
ENOSYS
;

66 int 
	ge39
 = 
ENOTEMPTY
;

67 int 
	ge40
 = 
ELOOP
;

68 int 
	ge42
 = 
ENOMSG
;

69 int 
	ge43
 = 
EIDRM
;

70 int 
	ge67
 = 
ENOLINK
;

71 int 
	ge71
 = 
EPROTO
;

72 int 
	ge72
 = 
EMULTIHOP
;

73 int 
	ge74
 = 
EBADMSG
;

74 int 
	ge75
 = 
EOVERFLOW
;

75 int 
	ge84
 = 
EILSEQ
;

76 int 
	ge88
 = 
ENOTSOCK
;

77 int 
	ge89
 = 
EDESTADDRREQ
;

78 int 
	ge90
 = 
EMSGSIZE
;

79 int 
	ge91
 = 
EPROTOTYPE
;

80 int 
	ge92
 = 
ENOPROTOOPT
;

81 int 
	ge93
 = 
EPROTONOSUPPORT
;

82 int 
	ge95
 = 
EOPNOTSUPP
;

83 int 
	ge95a
 = 
ENOTSUP
;

84 int 
	ge97
 = 
EAFNOSUPPORT
;

85 int 
	ge98
 = 
EADDRINUSE
;

86 int 
	ge99
 = 
EADDRNOTAVAIL
;

87 int 
	ge100
 = 
ENETDOWN
;

88 int 
	ge101
 = 
ENETUNREACH
;

89 int 
	ge102
 = 
ENETRESET
;

90 int 
	ge103
 = 
ECONNABORTED
;

91 int 
	ge104
 = 
ECONNRESET
;

92 int 
	ge105
 = 
ENOBUFS
;

93 int 
	ge106
 = 
EISCONN
;

94 int 
	ge107
 = 
ENOTCONN
;

95 int 
	ge110
 = 
ETIMEDOUT
;

96 int 
	ge111
 = 
ECONNREFUSED
;

97 int 
	ge113
 = 
EHOSTUNREACH
;

98 int 
	ge114
 = 
EALREADY
;

99 int 
	ge115
 = 
EINPROGRESS
;

100 int 
	ge116
 = 
ESTALE
;

101 int 
	ge122
 = 
EDQUOT
;

102 int 
	ge125
 = 
ECANCELED
;

109 
	$main
 ()

112 
errno
 = 
EOVERFLOW
;

115 if (
errno
 == 
EINVAL
)

119 
	}
}

	@gnulib-tests/test-exclude.c

20 #include 
	~<config.h
>

21 #include 
	~<stdio.h
>

22 #include 
	~<stdlib.h
>

23 #include 
	~<errno.h
>

24 #include 
	~<string.h
>

25 #include 
	~<stdbool.h
>

26 #include 
	~<fnmatch.h
>

28 #include 
	~"exclude.h
"

29 #include 
	~"progname.h
"

30 #include 
	~"error.h
"

31 #include 
	~"argmatch.h
"

33 #ifndef 
FNM_CASEFOLD


34 #define 
	#FNM_CASEFOLD
 0

	)

36 #ifndef 
FNM_LEADING_DIR


37 #define 
	#FNM_LEADING_DIR
 0

	)

40 char const * const 
	gexclude_keywords
[] = {

49 
NULL


52 int 
	gexclude_flags
[] = {

53 
FNM_NOESCAPE
,

54 
FNM_PATHNAME
,

55 
FNM_PERIOD
,

56 
FNM_LEADING_DIR
,

57 
FNM_CASEFOLD
,

58 
EXCLUDE_ANCHORED
,

59 
EXCLUDE_INCLUDE
,

60 
EXCLUDE_WILDCARDS


63 
ARGMATCH_VERIFY
 (
exclude_keywords
, 
exclude_flags
);

67 #ifdef 
ARGMATCH_DIE_DECL


69 
_Noreturn
 
	gARGMATCH_DIE_DECL
;

70 
	gARGMATCH_DIE_DECL
 { 
exit
 (1); }

75 
	$main
 (int 
argc
, char **
argv
)

77 int 
exclude_options
 = 0;

78 struct 
exclude
 *exclude = 
	`new_exclude
 ();

80 
	`set_program_name
 (
argv
[0]);

82 if (
argc
 == 1)

83 
	`error
 (1, 0, "usage: %s file -- words...", 
argv
[0]);

85 while (--
argc
)

87 char *
opt
 = *++
argv
;

88 if (
opt
[0] == '-')

90 int 
neg
 = 0;

91 int 
flag
;

92 char *
s
 = 
opt
 + 1;

94 if (
opt
[1] == '-' && opt[2] == 0)

96 
argc
--;

99 if (
	`strlen
 (
s
) > 3 && 
	`memcmp
 (s, "no-", 3) == 0)

101 
neg
 = 1;

102 
s
 += 3;

104 
flag
 = 
	`XARGMATCH
 (
opt
, 
s
, 
exclude_keywords
, 
exclude_flags
);

105 if (
neg
)

106 
exclude_options
 &= ~
flag
;

108 
exclude_options
 |= 
flag
;

112 if (
	`strcmp
 (
s
, "leading_dir") == 0 && 
FNM_LEADING_DIR
 == 0)

113 
	`exit
 (77);

116 if (
	`strcmp
 (
s
, "casefold") == 0 && 
FNM_CASEFOLD
 == 0)

117 
	`exit
 (77);

119 else if (
	`add_exclude_file
 (
add_exclude
, 
exclude
, 
opt
,

120 
exclude_options
, '\n') != 0)

121 
	`error
 (1, 
errno
, "error loading %s", 
opt
);

124 for (; 
argc
; --argc)

126 char *
word
 = *++
argv
;

128 
	`printf
 ("%s: %d\n", 
word
, 
	`excluded_file_name
 (
exclude
, word));

131 
	}
}

	@gnulib-tests/test-fcntl-h.c

21 #include 
	~<config.h
>

23 #include 
	~<fcntl.h
>

26 int 
	go
 = 
O_DIRECT
 | 
O_DIRECTORY
 | 
O_DSYNC
 | 
O_NDELAY
 | 
O_NOATIME
 | 
O_NONBLOCK


27 | 
O_NOCTTY
 | 
O_NOFOLLOW
 | 
O_NOLINKS
 | 
O_RSYNC
 | 
O_SYNC
 | 
O_TTY_INIT


28 | 
O_BINARY
 | 
O_TEXT
;

31 int 
	gsk
[] = { 
SEEK_CUR
, 
SEEK_END
, 
SEEK_SET
 };

34 int 
	gi
 = 
FD_CLOEXEC
;

37 
pid_t
 
	gt1
;

38 
off_t
 
	gt2
;

39 
mode_t
 
	gt3
;

42 
	$main
 (void)

47 case 
SEEK_CUR
:

48 case 
SEEK_END
:

49 case 
SEEK_SET
:

54 switch (
O_RDONLY
)

57 case 
O_RDONLY
:

58 case 
O_WRONLY
:

59 case 
O_RDWR
:

60 #if 
O_EXEC
 && O_EXEC != 
O_RDONLY


61 case 
O_EXEC
:

63 #if 
O_SEARCH
 && 
O_EXEC
 != O_SEARCH && O_SEARCH != 
O_RDONLY


64 case 
O_SEARCH
:

66 
i
 = 
O_ACCMODE
 == (
O_RDONLY
 | 
O_WRONLY
 | 
O_RDWR
 | 
O_EXEC
 | 
O_SEARCH
);

70 case 
O_CREAT
:

71 case 
O_EXCL
:

72 case 
O_TRUNC
:

73 case 
O_APPEND
:

77 #if 
O_CLOEXEC


78 case 
O_CLOEXEC
:

80 #if 
O_DIRECT


81 case 
O_DIRECT
:

83 #if 
O_DIRECTORY


84 case 
O_DIRECTORY
:

86 #if 
O_DSYNC


87 case 
O_DSYNC
:

89 #if 
O_NOATIME


90 case 
O_NOATIME
:

92 #if 
O_NONBLOCK


93 case 
O_NONBLOCK
:

95 #if 
O_NOCTTY


96 case 
O_NOCTTY
:

98 #if 
O_NOFOLLOW


99 case 
O_NOFOLLOW
:

101 #if 
O_NOLINKS


102 case 
O_NOLINKS
:

104 #if 
O_RSYNC
 && O_RSYNC != 
O_DSYNC


105 case 
O_RSYNC
:

107 #if 
O_SYNC
 && O_SYNC != 
O_RSYNC


108 case 
O_SYNC
:

110 #if 
O_TTY_INIT


111 case 
O_TTY_INIT
:

113 #if 
O_BINARY


114 case 
O_BINARY
:

116 #if 
O_TEXT


117 case 
O_TEXT
:

122 return !
i
;

123 
	}
}

	@gnulib-tests/test-fdopen.c

19 #include 
	~<config.h
>

21 #include 
	~<stdio.h
>

23 #include 
	~"signature.h
"

24 
SIGNATURE_CHECK
 (
fdopen
, 
FILE
 *, (int, const char *));

26 #include 
	~<errno.h
>

28 #include 
	~"macros.h
"

31 
	$main
 (void)

35 
FILE
 *
fp
;

37 
errno
 = 0;

38 
fp
 = 
	`fdopen
 (-1, "r");

39 if (
fp
 == 
NULL
)

40 
	`ASSERT
 (
errno
 == 
EBADF
);

42 
	`fclose
 (
fp
);

45 
FILE
 *
fp
;

47 
errno
 = 0;

48 
fp
 = 
	`fdopen
 (99, "r");

49 if (
fp
 == 
NULL
)

50 
	`ASSERT
 (
errno
 == 
EBADF
);

52 
	`fclose
 (
fp
);

56 
	}
}

	@gnulib-tests/test-fgetc.c

20 #include 
	~<config.h
>

22 #include 
	~<stdio.h
>

24 #include 
	~"signature.h
"

25 
SIGNATURE_CHECK
 (
fgetc
, int, (
FILE
 *));

27 #include 
	~<errno.h
>

28 #include 
	~<fcntl.h
>

29 #include 
	~<unistd.h
>

31 #include 
	~"msvc-inval.h
"

33 #include 
	~"macros.h
"

36 
	$main
 (int 
argc
, char **
argv
)

38 const char *
filename
 = "test-fgetc.txt";

42 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER
 \

43 && 
MSVC_INVALID_PARAMETER_HANDLING
 == 
DEFAULT_HANDLING


44 
	`gl_msvc_inval_ensure_handler
 ();

49 const char 
text
[] = "hello world";

50 int 
fd
 = 
	`open
 (
filename
, 
O_RDWR
 | 
O_CREAT
 | 
O_TRUNC
, 0600);

51 
	`ASSERT
 (
fd
 >= 0);

52 
	`ASSERT
 (
	`write
 (
fd
, 
text
, sizeof (text)) == sizeof (text));

53 
	`ASSERT
 (
	`close
 (
fd
) == 0);

59 
FILE
 *
fp
 = 
	`fopen
 (
filename
, "r");

60 
	`ASSERT
 (
fp
 != 
NULL
);

61 
	`ASSERT
 (
	`close
 (
	`fileno
 (
fp
)) == 0);

62 
errno
 = 0;

63 
	`ASSERT
 (
	`fgetc
 (
fp
) == 
EOF
);

64 
	`ASSERT
 (
errno
 == 
EBADF
);

65 
	`ASSERT
 (
	`ferror
 (
fp
));

66 
	`fclose
 (
fp
);

72 
FILE
 *
fp
 = 
	`fdopen
 (-1, "r");

73 if (
fp
 != 
NULL
)

75 
errno
 = 0;

76 
	`ASSERT
 (
	`fgetc
 (
fp
) == 
EOF
);

77 
	`ASSERT
 (
errno
 == 
EBADF
);

78 
	`ASSERT
 (
	`ferror
 (
fp
));

79 
	`fclose
 (
fp
);

83 
FILE
 *
fp
 = 
	`fdopen
 (99, "r");

84 if (
fp
 != 
NULL
)

86 
errno
 = 0;

87 
	`ASSERT
 (
	`fgetc
 (
fp
) == 
EOF
);

88 
	`ASSERT
 (
errno
 == 
EBADF
);

89 
	`ASSERT
 (
	`ferror
 (
fp
));

90 
	`fclose
 (
fp
);

95 
	`unlink
 (
filename
);

98 
	}
}

	@gnulib-tests/test-float.c

21 #include 
	~<config.h
>

23 #include 
	~<float.h
>

25 #include 
	~"fpucw.h
"

26 #include 
	~"macros.h
"

29 int 
	ga
[] = { 
FLT_RADIX
 };

31 #if 
FLT_RADIX
 == 2

35 
	$pow2f
 (int 
n
)

37 int 
k
 = 
n
;

38 volatile float 
x
 = 1;

39 volatile float 
y
 = 2;

41 if (
k
 < 0)

43 
y
 = 0.5f;

44 
k
 = - k;

46 while (
k
 > 0)

48 if (
k
 != 2 * (k / 2))

50 
x
 = x * 
y
;

51 
k
 = k - 1;

53 if (
k
 == 0)

55 
y
 = y * y;

56 
k
 = k / 2;

59 return 
x
;

60 
	}
}

64 
	$pow2d
 (int 
n
)

66 int 
k
 = 
n
;

67 volatile double 
x
 = 1;

68 volatile double 
y
 = 2;

70 if (
k
 < 0)

72 
y
 = 0.5;

73 
k
 = - k;

75 while (
k
 > 0)

77 if (
k
 != 2 * (k / 2))

79 
x
 = x * 
y
;

80 
k
 = k - 1;

82 if (
k
 == 0)

84 
y
 = y * y;

85 
k
 = k / 2;

88 return 
x
;

89 
	}
}

93 
	$pow2l
 (int 
n
)

95 int 
k
 = 
n
;

96 volatile long double 
x
 = 1;

97 volatile long double 
y
 = 2;

99 if (
k
 < 0)

101 
y
 = 0.5L;

102 
k
 = - k;

104 while (
k
 > 0)

106 if (
k
 != 2 * (k / 2))

108 
x
 = x * 
y
;

109 
k
 = k - 1;

111 if (
k
 == 0)

113 
y
 = y * y;

114 
k
 = k / 2;

117 return 
x
;

118 
	}
}

123 int 
	gfb
[] =

125 
FLT_MANT_DIG
, 
FLT_MIN_EXP
, 
FLT_MAX_EXP
,

126 
FLT_DIG
, 
FLT_MIN_10_EXP
, 
FLT_MAX_10_EXP


128 float 
	gfc
[] = { 
FLT_EPSILON
, 
FLT_MIN
, 
FLT_MAX
 };

131 
	$test_float
 (void)

134 
	`ASSERT
 ((
FLT_MIN_EXP
 % 101111) == (FLT_MIN_EXP) % 101111);

137 
	`ASSERT
 ((
FLT_MIN_10_EXP
 % 101111) == (FLT_MIN_10_EXP) % 101111);

140 
	`ASSERT
 (
FLT_MANT_DIG
 == 24);

141 
	`ASSERT
 (
FLT_MIN_EXP
 == -125);

142 
	`ASSERT
 (
FLT_MAX_EXP
 == 128);

145 
	`ASSERT
 (
FLT_MIN_10_EXP
 == - (int) (- (
FLT_MIN_EXP
 - 1) * 0.30103));

148 
	`ASSERT
 (
FLT_DIG
 == (int) ((
FLT_MANT_DIG
 - 1) * 0.30103));

151 
	`ASSERT
 (
FLT_MIN_10_EXP
 == - (int) (- (
FLT_MIN_EXP
 - 1) * 0.30103));

154 
	`ASSERT
 (
FLT_MAX_10_EXP
 == (int) (
FLT_MAX_EXP
 * 0.30103));

158 volatile float 
m
 = 
FLT_MAX
;

159 int 
n
;

161 
	`ASSERT
 (
m
 + m > m);

162 for (
n
 = 0; n <= 2 * 
FLT_MANT_DIG
; n++)

164 volatile float 
pow2_n
 = 
	`pow2f
 (
n
);

165 volatile float 
x
 = 
m
 + (m / 
pow2_n
);

166 if (
x
 > 
m
)

167 
	`ASSERT
 (
x
 + x == x);

169 
	`ASSERT
 (!(
x
 + x == x));

175 volatile float 
m
 = 
FLT_MIN
;

176 volatile float 
x
 = 
	`pow2f
 (
FLT_MIN_EXP
 - 1);

177 
	`ASSERT
 (
m
 == 
x
);

182 volatile float 
e
 = 
FLT_EPSILON
;

183 volatile float 
me
;

184 int 
n
;

186 
me
 = 1.0f + 
e
;

187 
	`ASSERT
 (
me
 > 1.0f);

188 
	`ASSERT
 (
me
 - 1.0f == 
e
);

189 for (
n
 = 0; n <= 2 * 
FLT_MANT_DIG
; n++)

191 volatile float 
half_n
 = 
	`pow2f
 (- 
n
);

192 volatile float 
x
 = 
me
 - 
half_n
;

193 if (
x
 < 
me
)

194 
	`ASSERT
 (
x
 <= 1.0f);

197 
	}
}

202 int 
	gdb
[] =

204 
DBL_MANT_DIG
, 
DBL_MIN_EXP
, 
DBL_MAX_EXP
,

205 
DBL_DIG
, 
DBL_MIN_10_EXP
, 
DBL_MAX_10_EXP


207 double 
	gdc
[] = { 
DBL_EPSILON
, 
DBL_MIN
, 
DBL_MAX
 };

210 
	$test_double
 (void)

213 
	`ASSERT
 ((
DBL_MIN_EXP
 % 101111) == (DBL_MIN_EXP) % 101111);

216 
	`ASSERT
 ((
DBL_MIN_10_EXP
 % 101111) == (DBL_MIN_10_EXP) % 101111);

219 
	`ASSERT
 (
DBL_MANT_DIG
 == 53);

220 
	`ASSERT
 (
DBL_MIN_EXP
 == -1021);

221 
	`ASSERT
 (
DBL_MAX_EXP
 == 1024);

224 
	`ASSERT
 (
DBL_MIN_10_EXP
 == - (int) (- (
DBL_MIN_EXP
 - 1) * 0.30103));

227 
	`ASSERT
 (
DBL_DIG
 == (int) ((
DBL_MANT_DIG
 - 1) * 0.30103));

230 
	`ASSERT
 (
DBL_MIN_10_EXP
 == - (int) (- (
DBL_MIN_EXP
 - 1) * 0.30103));

233 
	`ASSERT
 (
DBL_MAX_10_EXP
 == (int) (
DBL_MAX_EXP
 * 0.30103));

237 volatile double 
m
 = 
DBL_MAX
;

238 int 
n
;

240 
	`ASSERT
 (
m
 + m > m);

241 for (
n
 = 0; n <= 2 * 
DBL_MANT_DIG
; n++)

243 volatile double 
pow2_n
 = 
	`pow2d
 (
n
);

244 volatile double 
x
 = 
m
 + (m / 
pow2_n
);

245 if (
x
 > 
m
)

246 
	`ASSERT
 (
x
 + x == x);

248 
	`ASSERT
 (!(
x
 + x == x));

254 volatile double 
m
 = 
DBL_MIN
;

255 volatile double 
x
 = 
	`pow2d
 (
DBL_MIN_EXP
 - 1);

256 
	`ASSERT
 (
m
 == 
x
);

261 volatile double 
e
 = 
DBL_EPSILON
;

262 volatile double 
me
;

263 int 
n
;

265 
me
 = 1.0 + 
e
;

266 
	`ASSERT
 (
me
 > 1.0);

267 
	`ASSERT
 (
me
 - 1.0 == 
e
);

268 for (
n
 = 0; n <= 2 * 
DBL_MANT_DIG
; n++)

270 volatile double 
half_n
 = 
	`pow2d
 (- 
n
);

271 volatile double 
x
 = 
me
 - 
half_n
;

272 if (
x
 < 
me
)

273 
	`ASSERT
 (
x
 <= 1.0);

276 
	}
}

281 int 
	glb
[] =

283 
LDBL_MANT_DIG
, 
LDBL_MIN_EXP
, 
LDBL_MAX_EXP
,

284 
LDBL_DIG
, 
LDBL_MIN_10_EXP
, 
LDBL_MAX_10_EXP


286 long double 
	glc1
 = 
LDBL_EPSILON
;

287 long double 
	glc2
 = 
LDBL_MIN
;

289 long double 
	glc3
 = 
LDBL_MAX
;

293 
	$test_long_double
 (void)

296 
	`ASSERT
 ((
LDBL_MIN_EXP
 % 101111) == (LDBL_MIN_EXP) % 101111);

299 
	`ASSERT
 ((
LDBL_MIN_10_EXP
 % 101111) == (LDBL_MIN_10_EXP) % 101111);

302 
	`ASSERT
 (
LDBL_MANT_DIG
 >= 
DBL_MANT_DIG
);

311 
	`ASSERT
 (
LDBL_MAX_EXP
 >= 
DBL_MAX_EXP
);

314 
	`ASSERT
 (
LDBL_DIG
 == (int)((
LDBL_MANT_DIG
 - 1) * 0.30103));

317 
	`ASSERT
 (
LDBL_MIN_10_EXP
 == - (int) (- (
LDBL_MIN_EXP
 - 1) * 0.30103));

320 
	`ASSERT
 (
LDBL_MAX_10_EXP
 == (int) (
LDBL_MAX_EXP
 * 0.30103));

324 volatile long double 
m
 = 
LDBL_MAX
;

325 int 
n
;

327 
	`ASSERT
 (
m
 + m > m);

328 for (
n
 = 0; n <= 2 * 
LDBL_MANT_DIG
; n++)

330 volatile long double 
pow2_n
 = 
	`pow2l
 (
n
);

331 volatile long double 
x
 = 
m
 + (m / 
pow2_n
);

332 if (
x
 > 
m
)

333 
	`ASSERT
 (
x
 + x == x);

335 
	`ASSERT
 (!(
x
 + x == x));

341 volatile long double 
m
 = 
LDBL_MIN
;

342 volatile long double 
x
 = 
	`pow2l
 (
LDBL_MIN_EXP
 - 1);

343 
	`ASSERT
 (
m
 == 
x
);

348 volatile long double 
e
 = 
LDBL_EPSILON
;

349 volatile long double 
me
;

350 int 
n
;

352 
me
 = 1.0L + 
e
;

353 
	`ASSERT
 (
me
 > 1.0L);

354 
	`ASSERT
 (
me
 - 1.0L == 
e
);

355 for (
n
 = 0; n <= 2 * 
LDBL_MANT_DIG
; n++)

357 volatile long double 
half_n
 = 
	`pow2l
 (- 
n
);

358 volatile long double 
x
 = 
me
 - 
half_n
;

359 if (
x
 < 
me
)

360 
	`ASSERT
 (
x
 <= 1.0L);

363 
	}
}

366 
	$main
 ()

368 
	`test_float
 ();

369 
	`test_double
 ();

372 
DECL_LONG_DOUBLE_ROUNDING


374 
	`BEGIN_LONG_DOUBLE_ROUNDING
 ();

376 
	`test_long_double
 ();

378 
	`END_LONG_DOUBLE_ROUNDING
 ();

382 
	}
}

387 
	$main
 ()

389 
	`fprintf
 (
stderr
, "Skipping test: FLT_RADIX is not 2.\n");

391 
	}
}

	@gnulib-tests/test-fnmatch.c

21 #include 
	~<config.h
>

23 #include 
	~<fnmatch.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
fnmatch
, int, (char const *, char const *, int));

28 #include 
	~"macros.h
"

31 
	$main
 ()

33 int 
res
;

35 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("", "", 0) == 0);

37 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("*", "", 0) == 0);

38 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("*", "foo", 0) == 0);

39 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("*", "bar", 0) == 0);

40 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("*", "*", 0) == 0);

41 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("**", "f", 0) == 0);

42 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("**", "foo.txt", 0) == 0);

43 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("*.*", "foo.txt", 0) == 0);

45 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("foo*.txt", "foobar.txt", 0) == 0);

47 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("foo.txt", "foo.txt", 0) == 0);

48 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("foo\\.txt", "foo.txt", 0) == 0);

49 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("foo\\.txt", "foo.txt", 
FNM_NOESCAPE
) == 
FNM_NOMATCH
);

55 
	`ASSERT
 (
res
 = 
	`fnmatch
 ("[/b", "[/b", 0) == 0);

58 
	}
}

	@gnulib-tests/test-fpending.c

22 #include 
	~<config.h
>

24 #include 
	~"fpending.h
"

26 #include 
	~<stdio.h
>

27 #include 
	~<stdlib.h
>

29 #include 
	~"macros.h
"

32 
	$main
 (void)

34 
	`ASSERT
 (
	`__fpending
 (
stdout
) == 0);

36 
	`fputs
 ("foo", 
stdout
);

37 
	`ASSERT
 (
	`__fpending
 (
stdout
) == 3);

39 
	`fflush
 (
stdout
);

40 
	`ASSERT
 (
	`__fpending
 (
stdout
) == 0);

42 
	`exit
 (0);

43 
	}
}

	@gnulib-tests/test-fputc.c

20 #include 
	~<config.h
>

22 #include 
	~<stdio.h
>

24 #include 
	~"signature.h
"

25 
SIGNATURE_CHECK
 (
fputc
, int, (int, 
FILE
 *));

27 #include 
	~<errno.h
>

28 #include 
	~<fcntl.h
>

29 #include 
	~<unistd.h
>

31 #include 
	~"msvc-inval.h
"

33 #include 
	~"macros.h
"

36 
	$main
 (int 
argc
, char **
argv
)

38 const char *
filename
 = "test-fputc.txt";

42 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER
 \

43 && 
MSVC_INVALID_PARAMETER_HANDLING
 == 
DEFAULT_HANDLING


44 
	`gl_msvc_inval_ensure_handler
 ();

50 
FILE
 *
fp
 = 
	`fopen
 (
filename
, "w");

51 
	`ASSERT
 (
fp
 != 
NULL
);

52 
	`setvbuf
 (
fp
, 
NULL
, 
_IONBF
, 0);

53 
	`ASSERT
 (
	`close
 (
	`fileno
 (
fp
)) == 0);

54 
errno
 = 0;

55 
	`ASSERT
 (
	`fputc
 ('x', 
fp
) == 
EOF
);

56 
	`ASSERT
 (
errno
 == 
EBADF
);

57 
	`ASSERT
 (
	`ferror
 (
fp
));

58 
	`fclose
 (
fp
);

64 
FILE
 *
fp
 = 
	`fdopen
 (-1, "w");

65 if (
fp
 != 
NULL
)

67 
	`setvbuf
 (
fp
, 
NULL
, 
_IONBF
, 0);

68 
errno
 = 0;

69 
	`ASSERT
 (
	`fputc
 ('x', 
fp
) == 
EOF
);

70 
	`ASSERT
 (
errno
 == 
EBADF
);

71 
	`ASSERT
 (
	`ferror
 (
fp
));

72 
	`fclose
 (
fp
);

76 
FILE
 *
fp
 = 
	`fdopen
 (99, "w");

77 if (
fp
 != 
NULL
)

79 
	`setvbuf
 (
fp
, 
NULL
, 
_IONBF
, 0);

80 
errno
 = 0;

81 
	`ASSERT
 (
	`fputc
 ('x', 
fp
) == 
EOF
);

82 
	`ASSERT
 (
errno
 == 
EBADF
);

83 
	`ASSERT
 (
	`ferror
 (
fp
));

84 
	`fclose
 (
fp
);

89 
	`unlink
 (
filename
);

92 
	}
}

	@gnulib-tests/test-fread.c

20 #include 
	~<config.h
>

22 #include 
	~<stdio.h
>

24 #include 
	~"signature.h
"

25 
SIGNATURE_CHECK
 (
fread
, 
size_t
, (void *, size_t, size_t, 
FILE
 *));

27 #include 
	~<errno.h
>

28 #include 
	~<fcntl.h
>

29 #include 
	~<unistd.h
>

31 #include 
	~"msvc-inval.h
"

33 #include 
	~"macros.h
"

36 
	$main
 (int 
argc
, char **
argv
)

38 const char *
filename
 = "test-fread.txt";

42 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER
 \

43 && 
MSVC_INVALID_PARAMETER_HANDLING
 == 
DEFAULT_HANDLING


44 
	`gl_msvc_inval_ensure_handler
 ();

49 const char 
text
[] = "hello world";

50 int 
fd
 = 
	`open
 (
filename
, 
O_RDWR
 | 
O_CREAT
 | 
O_TRUNC
, 0600);

51 
	`ASSERT
 (
fd
 >= 0);

52 
	`ASSERT
 (
	`write
 (
fd
, 
text
, sizeof (text)) == sizeof (text));

53 
	`ASSERT
 (
	`close
 (
fd
) == 0);

59 
FILE
 *
fp
 = 
	`fopen
 (
filename
, "r");

60 char 
buf
[5];

61 
	`ASSERT
 (
fp
 != 
NULL
);

62 
	`ASSERT
 (
	`close
 (
	`fileno
 (
fp
)) == 0);

63 
errno
 = 0;

64 
	`ASSERT
 (
	`fread
 (
buf
, 1, sizeof (buf), 
fp
) == 0);

65 
	`ASSERT
 (
errno
 == 
EBADF
);

66 
	`ASSERT
 (
	`ferror
 (
fp
));

67 
	`fclose
 (
fp
);

73 
FILE
 *
fp
 = 
	`fdopen
 (-1, "r");

74 if (
fp
 != 
NULL
)

76 char 
buf
[1];

77 
errno
 = 0;

78 
	`ASSERT
 (
	`fread
 (
buf
, 1, 1, 
fp
) == 0);

79 
	`ASSERT
 (
errno
 == 
EBADF
);

80 
	`ASSERT
 (
	`ferror
 (
fp
));

81 
	`fclose
 (
fp
);

85 
FILE
 *
fp
 = 
	`fdopen
 (99, "r");

86 if (
fp
 != 
NULL
)

88 char 
buf
[1];

89 
errno
 = 0;

90 
	`ASSERT
 (
	`fread
 (
buf
, 1, 1, 
fp
) == 0);

91 
	`ASSERT
 (
errno
 == 
EBADF
);

92 
	`ASSERT
 (
	`ferror
 (
fp
));

93 
	`fclose
 (
fp
);

98 
	`unlink
 (
filename
);

101 
	}
}

	@gnulib-tests/test-fstat.c

19 #include 
	~<config.h
>

21 #include 
	~<sys/stat.h
>

23 #include 
	~"signature.h
"

24 
SIGNATURE_CHECK
 (
fstat
, int, (int, struct 
stat
 *));

26 #include 
	~<errno.h
>

28 #include 
	~"macros.h
"

31 
	$main
 (int 
argc
, char *
argv
[])

35 struct 
stat
 
statbuf
;

37 
errno
 = 0;

38 
	`ASSERT
 (
	`fstat
 (-1, &
statbuf
) == -1);

39 
	`ASSERT
 (
errno
 == 
EBADF
);

42 struct 
stat
 
statbuf
;

44 
errno
 = 0;

45 
	`ASSERT
 (
	`fstat
 (99, &
statbuf
) == -1);

46 
	`ASSERT
 (
errno
 == 
EBADF
);

50 
	}
}

	@gnulib-tests/test-fwrite.c

20 #include 
	~<config.h
>

22 #include 
	~<stdio.h
>

24 #include 
	~"signature.h
"

25 
SIGNATURE_CHECK
 (
fwrite
, 
size_t
, (const void *, size_t, size_t, 
FILE
 *));

27 #include 
	~<errno.h
>

28 #include 
	~<fcntl.h
>

29 #include 
	~<unistd.h
>

31 #include 
	~"msvc-inval.h
"

33 #include 
	~"macros.h
"

36 
	$main
 (int 
argc
, char **
argv
)

38 const char *
filename
 = "test-fwrite.txt";

42 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER
 \

43 && 
MSVC_INVALID_PARAMETER_HANDLING
 == 
DEFAULT_HANDLING


44 
	`gl_msvc_inval_ensure_handler
 ();

50 
FILE
 *
fp
 = 
	`fopen
 (
filename
, "w");

51 char 
buf
[5] = "world";

52 
	`ASSERT
 (
fp
 != 
NULL
);

53 
	`setvbuf
 (
fp
, 
NULL
, 
_IONBF
, 0);

54 
	`ASSERT
 (
	`close
 (
	`fileno
 (
fp
)) == 0);

55 
errno
 = 0;

56 
	`ASSERT
 (
	`fwrite
 (
buf
, 1, sizeof (buf), 
fp
) == 0);

57 
	`ASSERT
 (
errno
 == 
EBADF
);

58 
	`ASSERT
 (
	`ferror
 (
fp
));

59 
	`fclose
 (
fp
);

65 
FILE
 *
fp
 = 
	`fdopen
 (-1, "w");

66 if (
fp
 != 
NULL
)

68 char 
buf
[5] = "world";

69 
	`setvbuf
 (
fp
, 
NULL
, 
_IONBF
, 0);

70 
errno
 = 0;

71 
	`ASSERT
 (
	`fwrite
 (
buf
, 1, sizeof (buf), 
fp
) == 0);

72 
	`ASSERT
 (
errno
 == 
EBADF
);

73 
	`ASSERT
 (
	`ferror
 (
fp
));

74 
	`fclose
 (
fp
);

78 
FILE
 *
fp
 = 
	`fdopen
 (99, "w");

79 if (
fp
 != 
NULL
)

81 char 
buf
[5] = "world";

82 
	`setvbuf
 (
fp
, 
NULL
, 
_IONBF
, 0);

83 
errno
 = 0;

84 
	`ASSERT
 (
	`fwrite
 (
buf
, 1, sizeof (buf), 
fp
) == 0);

85 
	`ASSERT
 (
errno
 == 
EBADF
);

86 
	`ASSERT
 (
	`ferror
 (
fp
));

87 
	`fclose
 (
fp
);

92 
	`unlink
 (
filename
);

95 
	}
}

	@gnulib-tests/test-getcwd-lgpl.c

19 #include 
	~<config.h
>

21 #include 
	~<unistd.h
>

23 #include 
	~"signature.h
"

24 
SIGNATURE_CHECK
 (
getcwd
, char *, (char *, 
size_t
));

26 #include 
	~<errno.h
>

27 #include 
	~<stdio.h
>

28 #include 
	~<stdlib.h
>

29 #include 
	~<string.h
>

31 #include 
	~"macros.h
"

34 
	$main
 (int 
argc
, char **
argv
)

36 char *
pwd1
;

37 char *
pwd2
;

39 if (1 < 
argc
)

41 if (
	`chdir
 (
argv
[1]) == 0)

42 
	`printf
 ("changed to directory %s\n", 
argv
[1]);

45 
pwd1
 = 
	`getcwd
 (
NULL
, 0);

46 
	`ASSERT
 (
pwd1
 && *pwd1);

47 if (1 < 
argc
)

48 
	`printf
 ("cwd=%s\n", 
pwd1
);

51 
	`ASSERT
 (
	`chdir
 (
pwd1
) == 0);

52 
	`ASSERT
 (
	`chdir
 (".//./.") == 0);

55 
pwd2
 = 
	`getcwd
 (
NULL
, 0);

56 
	`ASSERT
 (
pwd2
);

57 
	`ASSERT
 (
	`strcmp
 (
pwd1
, 
pwd2
) == 0);

58 
	`free
 (
pwd2
);

60 
size_t
 
len
 = 
	`strlen
 (
pwd1
);

61 
ssize_t
 
i
 = 
len
 - 10;

62 if (
i
 < 1)

63 
i
 = 1;

64 
pwd2
 = 
	`getcwd
 (
NULL
, 
len
 + 1);

65 
	`ASSERT
 (
pwd2
);

66 
	`free
 (
pwd2
);

67 
pwd2
 = 
	`malloc
 (
len
 + 2);

68 for ( ; 
i
 <= 
len
; i++)

70 char *
tmp
;

71 
errno
 = 0;

72 
	`ASSERT
 (
	`getcwd
 (
pwd2
, 
i
) == 
NULL
);

73 
	`ASSERT
 (
errno
 == 
ERANGE
);

75 
errno
 = 0;

76 
tmp
 = 
	`getcwd
 (
NULL
, 
i
);

77 if (
tmp
)

79 
	`ASSERT
 (
	`strcmp
 (
pwd1
, 
tmp
) == 0);

80 
	`free
 (
tmp
);

84 
	`ASSERT
 (
errno
 == 
ERANGE
);

87 
	`ASSERT
 (
	`getcwd
 (
pwd2
, 
len
 + 1) == pwd2);

88 
pwd2
[
len
] = '/';

89 
pwd2
[
len
 + 1] = '\0';

91 
	`ASSERT
 (
	`strstr
 (
pwd2
, "/./") == 
NULL
);

92 
	`ASSERT
 (
	`strstr
 (
pwd2
, "/../") == 
NULL
);

93 
	`ASSERT
 (
	`strstr
 (
pwd2
 + 1 + (pwd2[1] == '/'), "//") == 
NULL
);

96 
errno
 = 0;

97 
	`ASSERT
 (
	`getcwd
(
pwd2
, 0) == 
NULL
);

98 
	`ASSERT
 (
errno
 == 
EINVAL
);

100 
	`free
 (
pwd1
);

101 
	`free
 (
pwd2
);

104 
	}
}

	@gnulib-tests/test-getopt.c

21 #include 
	~<config.h
>

25 #define 
	#_GL_NO_LARGE_FILES


	)

27 #if 
GNULIB_TEST_GETOPT_GNU


28 #include 
	~<getopt.h
>

30 #ifndef 
__getopt_argv_const


31 #define 
	#__getopt_argv_const
 const

	)

33 #include 
	~"signature.h
"

34 
SIGNATURE_CHECK
 (
getopt_long
, int, (int, char *
__getopt_argv_const
 *,

35 char const *, struct 
option
 const *,

37 
SIGNATURE_CHECK
 (
getopt_long_only
, int, (int, char *
__getopt_argv_const
 *,

38 char const *, struct 
option
 const *,

43 #include 
	~<unistd.h
>

45 #include 
	~"signature.h
"

46 
SIGNATURE_CHECK
 (
getopt
, int, (int, char * const[], char const *));

48 #include 
	~<stdio.h
>

49 #include 
	~<stdlib.h
>

50 #include 
	~<string.h
>

56 #define 
	#BACKUP_STDERR_FILENO
 10

	)

57 #define 
	#ASSERT_STREAM
 
myerr


	)

58 #include 
	~"macros.h
"

60 static 
FILE
 *
	gmyerr
;

62 #include 
	~"test-getopt.h
"

63 #if 
GNULIB_TEST_GETOPT_GNU


64 #include 
	~"test-getopt_long.h
"

68 
	$main
 (void)

72 if (
	`dup2
 (
STDERR_FILENO
, 
BACKUP_STDERR_FILENO
) != BACKUP_STDERR_FILENO

73 || (
myerr
 = 
	`fdopen
 (
BACKUP_STDERR_FILENO
, "w")) == 
NULL
)

76 
	`ASSERT
 (
	`freopen
 ("test-getopt.tmp", "w", 
stderr
) == stderr);

79 
	`ASSERT
 (
optind
 == 1);

80 
	`ASSERT
 (
opterr
 != 0);

82 
	`setenv
 ("POSIXLY_CORRECT", "1", 1);

83 
	`test_getopt
 ();

85 #if 
GNULIB_TEST_GETOPT_GNU


86 
	`test_getopt_long_posix
 ();

89 
	`unsetenv
 ("POSIXLY_CORRECT");

90 
	`test_getopt
 ();

92 #if 
GNULIB_TEST_GETOPT_GNU


93 
	`test_getopt_long
 ();

94 
	`test_getopt_long_only
 ();

97 
	`ASSERT
 (
	`fclose
 (
stderr
) == 0);

98 
	`ASSERT
 (
	`remove
 ("test-getopt.tmp") == 0);

101 
	}
}

	@gnulib-tests/test-getopt.h

21 #include 
	~<stdbool.h
>

26 #if 
defined
 
__GETOPT_PREFIX
 || (
__GLIBC__
 >= 2 && !defined 
__UCLIBC__
)

27 #define 
	#OPTIND_MIN
 0

	)

28 #elif 
HAVE_DECL_OPTRESET


29 #define 
	#OPTIND_MIN
 (
optreset
 = 1)

	)

31 #define 
	#OPTIND_MIN
 1

	)

35 
	$getopt_loop
 (int 
argc
, const char **
argv
,

36 const char *
options
,

37 int *
a_seen
, int *
b_seen
,

38 const char **
p_value
, const char **
q_value
,

39 int *
non_options_count
, const char **
non_options
,

40 int *
unrecognized
, 
bool
 *
message_issued
)

42 int 
c
;

43 int 
pos
 = 
	`ftell
 (
stderr
);

45 while ((
c
 = 
	`getopt
 (
argc
, (char **) 
argv
, 
options
)) != -1)

47 switch (
c
)

50 (*
a_seen
)++;

53 (*
b_seen
)++;

56 *
p_value
 = 
optarg
;

59 *
q_value
 = 
optarg
;

63 
	`ASSERT
 (
options
[0] == '-');

64 
non_options
[(*
non_options_count
)++] = 
optarg
;

68 
	`ASSERT
 (
options
[0] == ':'

69 || ((
options
[0] == '-' || options[0] == '+')

70 && 
options
[1] == ':'));

73 *
unrecognized
 = 
optopt
;

76 *
unrecognized
 = 
c
;

81 *
message_issued
 = 
pos
 < 
	`ftell
 (
stderr
);

82 
	}
}

85 
	$test_getopt
 (void)

87 int 
start
;

88 
bool
 
posixly
 = !!
	`getenv
 ("POSIXLY_CORRECT");

92 #if 
defined
 
__GETOPT_PREFIX
 || !(
__GLIBC__
 >= 2 || defined 
__MINGW32__
)

94 
posixly
 = 
true
;

98 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

100 int 
a_seen
 = 0;

101 int 
b_seen
 = 0;

102 const char *
p_value
 = 
NULL
;

103 const char *
q_value
 = 
NULL
;

104 int 
non_options_count
 = 0;

105 const char *
non_options
[10];

106 int 
unrecognized
 = 0;

107 
bool
 
output
;

108 int 
argc
 = 0;

109 const char *
argv
[10];

111 
argv
[
argc
++] = "program";

112 
argv
[
argc
++] = "-a";

113 
argv
[
argc
++] = "foo";

114 
argv
[
argc
++] = "bar";

115 
argv
[
argc
] = 
NULL
;

116 
optind
 = 
start
;

117 
opterr
 = 1;

118 
	`getopt_loop
 (
argc
, 
argv
, "ab",

119 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

120 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

121 
	`ASSERT
 (
a_seen
 == 1);

122 
	`ASSERT
 (
b_seen
 == 0);

123 
	`ASSERT
 (
p_value
 == 
NULL
);

124 
	`ASSERT
 (
q_value
 == 
NULL
);

125 
	`ASSERT
 (
non_options_count
 == 0);

126 
	`ASSERT
 (
unrecognized
 == 0);

127 
	`ASSERT
 (
optind
 == 2);

128 
	`ASSERT
 (!
output
);

130 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

132 int 
a_seen
 = 0;

133 int 
b_seen
 = 0;

134 const char *
p_value
 = 
NULL
;

135 const char *
q_value
 = 
NULL
;

136 int 
non_options_count
 = 0;

137 const char *
non_options
[10];

138 int 
unrecognized
 = 0;

139 
bool
 
output
;

140 int 
argc
 = 0;

141 const char *
argv
[10];

143 
argv
[
argc
++] = "program";

144 
argv
[
argc
++] = "-b";

145 
argv
[
argc
++] = "-a";

146 
argv
[
argc
++] = "foo";

147 
argv
[
argc
++] = "bar";

148 
argv
[
argc
] = 
NULL
;

149 
optind
 = 
start
;

150 
opterr
 = 1;

151 
	`getopt_loop
 (
argc
, 
argv
, "ab",

152 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

153 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

154 
	`ASSERT
 (
a_seen
 == 1);

155 
	`ASSERT
 (
b_seen
 == 1);

156 
	`ASSERT
 (
p_value
 == 
NULL
);

157 
	`ASSERT
 (
q_value
 == 
NULL
);

158 
	`ASSERT
 (
non_options_count
 == 0);

159 
	`ASSERT
 (
unrecognized
 == 0);

160 
	`ASSERT
 (
optind
 == 3);

161 
	`ASSERT
 (!
output
);

163 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

165 int 
a_seen
 = 0;

166 int 
b_seen
 = 0;

167 const char *
p_value
 = 
NULL
;

168 const char *
q_value
 = 
NULL
;

169 int 
non_options_count
 = 0;

170 const char *
non_options
[10];

171 int 
unrecognized
 = 0;

172 
bool
 
output
;

173 int 
argc
 = 0;

174 const char *
argv
[10];

176 
argv
[
argc
++] = "program";

177 
argv
[
argc
++] = "-ba";

178 
argv
[
argc
++] = "foo";

179 
argv
[
argc
++] = "bar";

180 
argv
[
argc
] = 
NULL
;

181 
optind
 = 
start
;

182 
opterr
 = 1;

183 
	`getopt_loop
 (
argc
, 
argv
, "ab",

184 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

185 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

186 
	`ASSERT
 (
a_seen
 == 1);

187 
	`ASSERT
 (
b_seen
 == 1);

188 
	`ASSERT
 (
p_value
 == 
NULL
);

189 
	`ASSERT
 (
q_value
 == 
NULL
);

190 
	`ASSERT
 (
non_options_count
 == 0);

191 
	`ASSERT
 (
unrecognized
 == 0);

192 
	`ASSERT
 (
optind
 == 2);

193 
	`ASSERT
 (!
output
);

195 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

197 int 
a_seen
 = 0;

198 int 
b_seen
 = 0;

199 const char *
p_value
 = 
NULL
;

200 const char *
q_value
 = 
NULL
;

201 int 
non_options_count
 = 0;

202 const char *
non_options
[10];

203 int 
unrecognized
 = 0;

204 
bool
 
output
;

205 int 
argc
 = 0;

206 const char *
argv
[10];

208 
argv
[
argc
++] = "program";

209 
argv
[
argc
++] = "-ab";

210 
argv
[
argc
++] = "-a";

211 
argv
[
argc
++] = "foo";

212 
argv
[
argc
++] = "bar";

213 
argv
[
argc
] = 
NULL
;

214 
optind
 = 
start
;

215 
opterr
 = 1;

216 
	`getopt_loop
 (
argc
, 
argv
, "ab",

217 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

218 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

219 
	`ASSERT
 (
a_seen
 == 2);

220 
	`ASSERT
 (
b_seen
 == 1);

221 
	`ASSERT
 (
p_value
 == 
NULL
);

222 
	`ASSERT
 (
q_value
 == 
NULL
);

223 
	`ASSERT
 (
non_options_count
 == 0);

224 
	`ASSERT
 (
unrecognized
 == 0);

225 
	`ASSERT
 (
optind
 == 3);

226 
	`ASSERT
 (!
output
);

230 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

232 int 
a_seen
 = 0;

233 int 
b_seen
 = 0;

234 const char *
p_value
 = 
NULL
;

235 const char *
q_value
 = 
NULL
;

236 int 
non_options_count
 = 0;

237 const char *
non_options
[10];

238 int 
unrecognized
 = 0;

239 
bool
 
output
;

240 int 
argc
 = 0;

241 const char *
argv
[10];

243 
argv
[
argc
++] = "program";

244 
argv
[
argc
++] = "-pfoo";

245 
argv
[
argc
++] = "bar";

246 
argv
[
argc
] = 
NULL
;

247 
optind
 = 
start
;

248 
opterr
 = 1;

249 
	`getopt_loop
 (
argc
, 
argv
, "p:q:",

250 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

251 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

252 
	`ASSERT
 (
a_seen
 == 0);

253 
	`ASSERT
 (
b_seen
 == 0);

254 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

255 
	`ASSERT
 (
q_value
 == 
NULL
);

256 
	`ASSERT
 (
non_options_count
 == 0);

257 
	`ASSERT
 (
unrecognized
 == 0);

258 
	`ASSERT
 (
optind
 == 2);

259 
	`ASSERT
 (!
output
);

261 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

263 int 
a_seen
 = 0;

264 int 
b_seen
 = 0;

265 const char *
p_value
 = 
NULL
;

266 const char *
q_value
 = 
NULL
;

267 int 
non_options_count
 = 0;

268 const char *
non_options
[10];

269 int 
unrecognized
 = 0;

270 
bool
 
output
;

271 int 
argc
 = 0;

272 const char *
argv
[10];

274 
argv
[
argc
++] = "program";

275 
argv
[
argc
++] = "-p";

276 
argv
[
argc
++] = "foo";

277 
argv
[
argc
++] = "bar";

278 
argv
[
argc
] = 
NULL
;

279 
optind
 = 
start
;

280 
opterr
 = 1;

281 
	`getopt_loop
 (
argc
, 
argv
, "p:q:",

282 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

283 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

284 
	`ASSERT
 (
a_seen
 == 0);

285 
	`ASSERT
 (
b_seen
 == 0);

286 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

287 
	`ASSERT
 (
q_value
 == 
NULL
);

288 
	`ASSERT
 (
non_options_count
 == 0);

289 
	`ASSERT
 (
unrecognized
 == 0);

290 
	`ASSERT
 (
optind
 == 3);

291 
	`ASSERT
 (!
output
);

293 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

295 int 
a_seen
 = 0;

296 int 
b_seen
 = 0;

297 const char *
p_value
 = 
NULL
;

298 const char *
q_value
 = 
NULL
;

299 int 
non_options_count
 = 0;

300 const char *
non_options
[10];

301 int 
unrecognized
 = 0;

302 
bool
 
output
;

303 int 
argc
 = 0;

304 const char *
argv
[10];

306 
argv
[
argc
++] = "program";

307 
argv
[
argc
++] = "-ab";

308 
argv
[
argc
++] = "-q";

309 
argv
[
argc
++] = "baz";

310 
argv
[
argc
++] = "-pfoo";

311 
argv
[
argc
++] = "bar";

312 
argv
[
argc
] = 
NULL
;

313 
optind
 = 
start
;

314 
opterr
 = 1;

315 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

316 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

317 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

318 
	`ASSERT
 (
a_seen
 == 1);

319 
	`ASSERT
 (
b_seen
 == 1);

320 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

321 
	`ASSERT
 (
q_value
 != 
NULL
 && 
	`strcmp
 (q_value, "baz") == 0);

322 
	`ASSERT
 (
non_options_count
 == 0);

323 
	`ASSERT
 (
unrecognized
 == 0);

324 
	`ASSERT
 (
optind
 == 5);

325 
	`ASSERT
 (!
output
);

328 #if 
GNULIB_TEST_GETOPT_GNU


330 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

332 int 
a_seen
 = 0;

333 int 
b_seen
 = 0;

334 const char *
p_value
 = 
NULL
;

335 const char *
q_value
 = 
NULL
;

336 int 
non_options_count
 = 0;

337 const char *
non_options
[10];

338 int 
unrecognized
 = 0;

339 
bool
 
output
;

340 int 
argc
 = 0;

341 const char *
argv
[10];

343 
argv
[
argc
++] = "program";

344 
argv
[
argc
++] = "-pfoo";

345 
argv
[
argc
++] = "bar";

346 
argv
[
argc
] = 
NULL
;

347 
optind
 = 
start
;

348 
opterr
 = 1;

349 
	`getopt_loop
 (
argc
, 
argv
, "p::q::",

350 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

351 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

352 
	`ASSERT
 (
a_seen
 == 0);

353 
	`ASSERT
 (
b_seen
 == 0);

354 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

355 
	`ASSERT
 (
q_value
 == 
NULL
);

356 
	`ASSERT
 (
non_options_count
 == 0);

357 
	`ASSERT
 (
unrecognized
 == 0);

358 
	`ASSERT
 (
optind
 == 2);

359 
	`ASSERT
 (!
output
);

361 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

363 int 
a_seen
 = 0;

364 int 
b_seen
 = 0;

365 const char *
p_value
 = 
NULL
;

366 const char *
q_value
 = 
NULL
;

367 int 
non_options_count
 = 0;

368 const char *
non_options
[10];

369 int 
unrecognized
 = 0;

370 
bool
 
output
;

371 int 
argc
 = 0;

372 const char *
argv
[10];

374 
argv
[
argc
++] = "program";

375 
argv
[
argc
++] = "-p";

376 
argv
[
argc
++] = "foo";

377 
argv
[
argc
++] = "bar";

378 
argv
[
argc
] = 
NULL
;

379 
optind
 = 
start
;

380 
opterr
 = 1;

381 
	`getopt_loop
 (
argc
, 
argv
, "p::q::",

382 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

383 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

384 
	`ASSERT
 (
a_seen
 == 0);

385 
	`ASSERT
 (
b_seen
 == 0);

386 
	`ASSERT
 (
p_value
 == 
NULL
);

387 
	`ASSERT
 (
q_value
 == 
NULL
);

388 
	`ASSERT
 (
non_options_count
 == 0);

389 
	`ASSERT
 (
unrecognized
 == 0);

390 
	`ASSERT
 (
optind
 == 2);

391 
	`ASSERT
 (!
output
);

393 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

395 int 
a_seen
 = 0;

396 int 
b_seen
 = 0;

397 const char *
p_value
 = 
NULL
;

398 const char *
q_value
 = 
NULL
;

399 int 
non_options_count
 = 0;

400 const char *
non_options
[10];

401 int 
unrecognized
 = 0;

402 
bool
 
output
;

403 int 
argc
 = 0;

404 const char *
argv
[10];

406 
argv
[
argc
++] = "program";

407 
argv
[
argc
++] = "-p";

408 
argv
[
argc
++] = "-a";

409 
argv
[
argc
++] = "bar";

410 
argv
[
argc
] = 
NULL
;

411 
optind
 = 
start
;

412 
opterr
 = 1;

413 
	`getopt_loop
 (
argc
, 
argv
, "abp::q::",

414 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

415 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

416 
	`ASSERT
 (
a_seen
 == 1);

417 
	`ASSERT
 (
b_seen
 == 0);

418 
	`ASSERT
 (
p_value
 == 
NULL
);

419 
	`ASSERT
 (
q_value
 == 
NULL
);

420 
	`ASSERT
 (
non_options_count
 == 0);

421 
	`ASSERT
 (
unrecognized
 == 0);

422 
	`ASSERT
 (
optind
 == 3);

423 
	`ASSERT
 (!
output
);

429 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

431 int 
a_seen
 = 0;

432 int 
b_seen
 = 0;

433 const char *
p_value
 = 
NULL
;

434 const char *
q_value
 = 
NULL
;

435 int 
non_options_count
 = 0;

436 const char *
non_options
[10];

437 int 
unrecognized
 = 0;

438 
bool
 
output
;

439 int 
argc
 = 0;

440 const char *
argv
[10];

442 
argv
[
argc
++] = "program";

443 
argv
[
argc
++] = "-p";

444 
argv
[
argc
++] = "foo";

445 
argv
[
argc
++] = "-x";

446 
argv
[
argc
++] = "-a";

447 
argv
[
argc
++] = "bar";

448 
argv
[
argc
] = 
NULL
;

449 
optind
 = 
start
;

450 
opterr
 = 42;

451 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

452 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

453 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

454 
	`ASSERT
 (
a_seen
 == 1);

455 
	`ASSERT
 (
b_seen
 == 0);

456 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

457 
	`ASSERT
 (
q_value
 == 
NULL
);

458 
	`ASSERT
 (
non_options_count
 == 0);

459 
	`ASSERT
 (
unrecognized
 == 'x');

460 
	`ASSERT
 (
optind
 == 5);

461 
	`ASSERT
 (
output
);

463 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

465 int 
a_seen
 = 0;

466 int 
b_seen
 = 0;

467 const char *
p_value
 = 
NULL
;

468 const char *
q_value
 = 
NULL
;

469 int 
non_options_count
 = 0;

470 const char *
non_options
[10];

471 int 
unrecognized
 = 0;

472 
bool
 
output
;

473 int 
argc
 = 0;

474 const char *
argv
[10];

476 
argv
[
argc
++] = "program";

477 
argv
[
argc
++] = "-p";

478 
argv
[
argc
++] = "foo";

479 
argv
[
argc
++] = "-x";

480 
argv
[
argc
++] = "-a";

481 
argv
[
argc
++] = "bar";

482 
argv
[
argc
] = 
NULL
;

483 
optind
 = 
start
;

484 
opterr
 = 0;

485 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

486 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

487 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

488 
	`ASSERT
 (
a_seen
 == 1);

489 
	`ASSERT
 (
b_seen
 == 0);

490 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

491 
	`ASSERT
 (
q_value
 == 
NULL
);

492 
	`ASSERT
 (
non_options_count
 == 0);

493 
	`ASSERT
 (
unrecognized
 == 'x');

494 
	`ASSERT
 (
optind
 == 5);

495 
	`ASSERT
 (!
output
);

497 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

499 int 
a_seen
 = 0;

500 int 
b_seen
 = 0;

501 const char *
p_value
 = 
NULL
;

502 const char *
q_value
 = 
NULL
;

503 int 
non_options_count
 = 0;

504 const char *
non_options
[10];

505 int 
unrecognized
 = 0;

506 
bool
 
output
;

507 int 
argc
 = 0;

508 const char *
argv
[10];

510 
argv
[
argc
++] = "program";

511 
argv
[
argc
++] = "-p";

512 
argv
[
argc
++] = "foo";

513 
argv
[
argc
++] = "-x";

514 
argv
[
argc
++] = "-a";

515 
argv
[
argc
++] = "bar";

516 
argv
[
argc
] = 
NULL
;

517 
optind
 = 
start
;

518 
opterr
 = 1;

519 
	`getopt_loop
 (
argc
, 
argv
, ":abp:q:",

520 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

521 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

522 
	`ASSERT
 (
a_seen
 == 1);

523 
	`ASSERT
 (
b_seen
 == 0);

524 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

525 
	`ASSERT
 (
q_value
 == 
NULL
);

526 
	`ASSERT
 (
non_options_count
 == 0);

527 
	`ASSERT
 (
unrecognized
 == 'x');

528 
	`ASSERT
 (
optind
 == 5);

529 
	`ASSERT
 (!
output
);

531 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

533 int 
a_seen
 = 0;

534 int 
b_seen
 = 0;

535 const char *
p_value
 = 
NULL
;

536 const char *
q_value
 = 
NULL
;

537 int 
non_options_count
 = 0;

538 const char *
non_options
[10];

539 int 
unrecognized
 = 0;

540 
bool
 
output
;

541 int 
argc
 = 0;

542 const char *
argv
[10];

544 
argv
[
argc
++] = "program";

545 
argv
[
argc
++] = "-p";

546 
argv
[
argc
++] = "foo";

547 
argv
[
argc
++] = "-:";

548 
argv
[
argc
++] = "-a";

549 
argv
[
argc
++] = "bar";

550 
argv
[
argc
] = 
NULL
;

551 
optind
 = 
start
;

552 
opterr
 = 42;

553 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

554 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

555 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

556 
	`ASSERT
 (
a_seen
 == 1);

557 
	`ASSERT
 (
b_seen
 == 0);

558 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

559 
	`ASSERT
 (
q_value
 == 
NULL
);

560 
	`ASSERT
 (
non_options_count
 == 0);

561 
	`ASSERT
 (
unrecognized
 == ':');

562 
	`ASSERT
 (
optind
 == 5);

563 
	`ASSERT
 (
output
);

565 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

567 int 
a_seen
 = 0;

568 int 
b_seen
 = 0;

569 const char *
p_value
 = 
NULL
;

570 const char *
q_value
 = 
NULL
;

571 int 
non_options_count
 = 0;

572 const char *
non_options
[10];

573 int 
unrecognized
 = 0;

574 
bool
 
output
;

575 int 
argc
 = 0;

576 const char *
argv
[10];

578 
argv
[
argc
++] = "program";

579 
argv
[
argc
++] = "-p";

580 
argv
[
argc
++] = "foo";

581 
argv
[
argc
++] = "-:";

582 
argv
[
argc
++] = "-a";

583 
argv
[
argc
++] = "bar";

584 
argv
[
argc
] = 
NULL
;

585 
optind
 = 
start
;

586 
opterr
 = 0;

587 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

588 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

589 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

590 
	`ASSERT
 (
a_seen
 == 1);

591 
	`ASSERT
 (
b_seen
 == 0);

592 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

593 
	`ASSERT
 (
q_value
 == 
NULL
);

594 
	`ASSERT
 (
non_options_count
 == 0);

595 
	`ASSERT
 (
unrecognized
 == ':');

596 
	`ASSERT
 (
optind
 == 5);

597 
	`ASSERT
 (!
output
);

599 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

601 int 
a_seen
 = 0;

602 int 
b_seen
 = 0;

603 const char *
p_value
 = 
NULL
;

604 const char *
q_value
 = 
NULL
;

605 int 
non_options_count
 = 0;

606 const char *
non_options
[10];

607 int 
unrecognized
 = 0;

608 
bool
 
output
;

609 int 
argc
 = 0;

610 const char *
argv
[10];

612 
argv
[
argc
++] = "program";

613 
argv
[
argc
++] = "-p";

614 
argv
[
argc
++] = "foo";

615 
argv
[
argc
++] = "-:";

616 
argv
[
argc
++] = "-a";

617 
argv
[
argc
++] = "bar";

618 
argv
[
argc
] = 
NULL
;

619 
optind
 = 
start
;

620 
opterr
 = 1;

621 
	`getopt_loop
 (
argc
, 
argv
, ":abp:q:",

622 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

623 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

624 
	`ASSERT
 (
a_seen
 == 1);

625 
	`ASSERT
 (
b_seen
 == 0);

626 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

627 
	`ASSERT
 (
q_value
 == 
NULL
);

628 
	`ASSERT
 (
non_options_count
 == 0);

629 
	`ASSERT
 (
unrecognized
 == ':');

630 
	`ASSERT
 (
optind
 == 5);

631 
	`ASSERT
 (!
output
);

635 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

637 int 
a_seen
 = 0;

638 int 
b_seen
 = 0;

639 const char *
p_value
 = 
NULL
;

640 const char *
q_value
 = 
NULL
;

641 int 
non_options_count
 = 0;

642 const char *
non_options
[10];

643 int 
unrecognized
 = 0;

644 
bool
 
output
;

645 int 
argc
 = 0;

646 const char *
argv
[10];

648 
argv
[
argc
++] = "program";

649 
argv
[
argc
++] = "-ap";

650 
argv
[
argc
] = 
NULL
;

651 
optind
 = 
start
;

652 
opterr
 = 1;

653 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

654 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

655 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

656 
	`ASSERT
 (
a_seen
 == 1);

657 
	`ASSERT
 (
b_seen
 == 0);

658 
	`ASSERT
 (
p_value
 == 
NULL
);

659 
	`ASSERT
 (
q_value
 == 
NULL
);

660 
	`ASSERT
 (
non_options_count
 == 0);

661 
	`ASSERT
 (
unrecognized
 == 'p');

662 
	`ASSERT
 (
optind
 == 2);

663 
	`ASSERT
 (
output
);

665 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

667 int 
a_seen
 = 0;

668 int 
b_seen
 = 0;

669 const char *
p_value
 = 
NULL
;

670 const char *
q_value
 = 
NULL
;

671 int 
non_options_count
 = 0;

672 const char *
non_options
[10];

673 int 
unrecognized
 = 0;

674 
bool
 
output
;

675 int 
argc
 = 0;

676 const char *
argv
[10];

678 
argv
[
argc
++] = "program";

679 
argv
[
argc
++] = "-ap";

680 
argv
[
argc
] = 
NULL
;

681 
optind
 = 
start
;

682 
opterr
 = 0;

683 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

684 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

685 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

686 
	`ASSERT
 (
a_seen
 == 1);

687 
	`ASSERT
 (
b_seen
 == 0);

688 
	`ASSERT
 (
p_value
 == 
NULL
);

689 
	`ASSERT
 (
q_value
 == 
NULL
);

690 
	`ASSERT
 (
non_options_count
 == 0);

691 
	`ASSERT
 (
unrecognized
 == 'p');

692 
	`ASSERT
 (
optind
 == 2);

693 
	`ASSERT
 (!
output
);

695 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

697 int 
a_seen
 = 0;

698 int 
b_seen
 = 0;

699 const char *
p_value
 = 
NULL
;

700 const char *
q_value
 = 
NULL
;

701 int 
non_options_count
 = 0;

702 const char *
non_options
[10];

703 int 
unrecognized
 = 0;

704 
bool
 
output
;

705 int 
argc
 = 0;

706 const char *
argv
[10];

708 
argv
[
argc
++] = "program";

709 
argv
[
argc
++] = "-ap";

710 
argv
[
argc
] = 
NULL
;

711 
optind
 = 
start
;

712 
opterr
 = 1;

713 
	`getopt_loop
 (
argc
, 
argv
, ":abp:q:",

714 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

715 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

716 
	`ASSERT
 (
a_seen
 == 1);

717 
	`ASSERT
 (
b_seen
 == 0);

718 
	`ASSERT
 (
p_value
 == 
NULL
);

719 
	`ASSERT
 (
q_value
 == 
NULL
);

720 
	`ASSERT
 (
non_options_count
 == 0);

721 
	`ASSERT
 (
unrecognized
 == 'p');

722 
	`ASSERT
 (
optind
 == 2);

723 
	`ASSERT
 (!
output
);

727 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

729 int 
a_seen
 = 0;

730 int 
b_seen
 = 0;

731 const char *
p_value
 = 
NULL
;

732 const char *
q_value
 = 
NULL
;

733 int 
non_options_count
 = 0;

734 const char *
non_options
[10];

735 int 
unrecognized
 = 0;

736 
bool
 
output
;

737 int 
argc
 = 0;

738 const char *
argv
[10];

740 
argv
[
argc
++] = "program";

741 
argv
[
argc
++] = "donald";

742 
argv
[
argc
++] = "-p";

743 
argv
[
argc
++] = "billy";

744 
argv
[
argc
++] = "duck";

745 
argv
[
argc
++] = "-a";

746 
argv
[
argc
++] = "bar";

747 
argv
[
argc
] = 
NULL
;

748 
optind
 = 
start
;

749 
opterr
 = 1;

750 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

751 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

752 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

753 if (
posixly
)

755 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

756 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

757 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

758 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

759 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

760 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

761 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

762 
	`ASSERT
 (
argv
[7] == 
NULL
);

763 
	`ASSERT
 (
a_seen
 == 0);

764 
	`ASSERT
 (
b_seen
 == 0);

765 
	`ASSERT
 (
p_value
 == 
NULL
);

766 
	`ASSERT
 (
q_value
 == 
NULL
);

767 
	`ASSERT
 (
non_options_count
 == 0);

768 
	`ASSERT
 (
unrecognized
 == 0);

769 
	`ASSERT
 (
optind
 == 1);

770 
	`ASSERT
 (!
output
);

774 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

775 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

776 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

777 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

778 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "donald") == 0);

779 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "duck") == 0);

780 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

781 
	`ASSERT
 (
argv
[7] == 
NULL
);

782 
	`ASSERT
 (
a_seen
 == 1);

783 
	`ASSERT
 (
b_seen
 == 0);

784 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

785 
	`ASSERT
 (
q_value
 == 
NULL
);

786 
	`ASSERT
 (
non_options_count
 == 0);

787 
	`ASSERT
 (
unrecognized
 == 0);

788 
	`ASSERT
 (
optind
 == 4);

789 
	`ASSERT
 (!
output
);

794 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

796 int 
a_seen
 = 0;

797 int 
b_seen
 = 0;

798 const char *
p_value
 = 
NULL
;

799 const char *
q_value
 = 
NULL
;

800 int 
non_options_count
 = 0;

801 const char *
non_options
[10];

802 int 
unrecognized
 = 0;

803 
bool
 
output
;

804 int 
argc
 = 0;

805 const char *
argv
[20];

807 
argv
[
argc
++] = "program";

808 
argv
[
argc
++] = "donald";

809 
argv
[
argc
++] = "-p";

810 
argv
[
argc
++] = "billy";

811 
argv
[
argc
++] = "duck";

812 
argv
[
argc
++] = "-a";

813 
argv
[
argc
++] = "--";

814 
argv
[
argc
++] = "-b";

815 
argv
[
argc
++] = "foo";

816 
argv
[
argc
++] = "-q";

817 
argv
[
argc
++] = "johnny";

818 
argv
[
argc
++] = "bar";

819 
argv
[
argc
] = 
NULL
;

820 
optind
 = 
start
;

821 
opterr
 = 1;

822 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:",

823 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

824 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

825 if (
posixly
)

827 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

828 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

829 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

830 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

831 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

832 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

833 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "--") == 0);

834 
	`ASSERT
 (
	`strcmp
 (
argv
[7], "-b") == 0);

835 
	`ASSERT
 (
	`strcmp
 (
argv
[8], "foo") == 0);

836 
	`ASSERT
 (
	`strcmp
 (
argv
[9], "-q") == 0);

837 
	`ASSERT
 (
	`strcmp
 (
argv
[10], "johnny") == 0);

838 
	`ASSERT
 (
	`strcmp
 (
argv
[11], "bar") == 0);

839 
	`ASSERT
 (
argv
[12] == 
NULL
);

840 
	`ASSERT
 (
a_seen
 == 0);

841 
	`ASSERT
 (
b_seen
 == 0);

842 
	`ASSERT
 (
p_value
 == 
NULL
);

843 
	`ASSERT
 (
q_value
 == 
NULL
);

844 
	`ASSERT
 (
non_options_count
 == 0);

845 
	`ASSERT
 (
unrecognized
 == 0);

846 
	`ASSERT
 (
optind
 == 1);

847 
	`ASSERT
 (!
output
);

851 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

852 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

853 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

854 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

855 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "--") == 0);

856 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "donald") == 0);

857 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "duck") == 0);

858 
	`ASSERT
 (
	`strcmp
 (
argv
[7], "-b") == 0);

859 
	`ASSERT
 (
	`strcmp
 (
argv
[8], "foo") == 0);

860 
	`ASSERT
 (
	`strcmp
 (
argv
[9], "-q") == 0);

861 
	`ASSERT
 (
	`strcmp
 (
argv
[10], "johnny") == 0);

862 
	`ASSERT
 (
	`strcmp
 (
argv
[11], "bar") == 0);

863 
	`ASSERT
 (
argv
[12] == 
NULL
);

864 
	`ASSERT
 (
a_seen
 == 1);

865 
	`ASSERT
 (
b_seen
 == 0);

866 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

867 
	`ASSERT
 (
q_value
 == 
NULL
);

868 
	`ASSERT
 (
non_options_count
 == 0);

869 
	`ASSERT
 (
unrecognized
 == 0);

870 
	`ASSERT
 (
optind
 == 5);

871 
	`ASSERT
 (!
output
);

875 #if 
GNULIB_TEST_GETOPT_GNU


877 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

879 int 
a_seen
 = 0;

880 int 
b_seen
 = 0;

881 const char *
p_value
 = 
NULL
;

882 const char *
q_value
 = 
NULL
;

883 int 
non_options_count
 = 0;

884 const char *
non_options
[10];

885 int 
unrecognized
 = 0;

886 
bool
 
output
;

887 int 
argc
 = 0;

888 const char *
argv
[10];

890 
argv
[
argc
++] = "program";

891 
argv
[
argc
++] = "donald";

892 
argv
[
argc
++] = "-p";

893 
argv
[
argc
++] = "billy";

894 
argv
[
argc
++] = "duck";

895 
argv
[
argc
++] = "-a";

896 
argv
[
argc
++] = "bar";

897 
argv
[
argc
] = 
NULL
;

898 
optind
 = 
start
;

899 
opterr
 = 1;

900 
	`getopt_loop
 (
argc
, 
argv
, "-abp:q:",

901 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

902 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

903 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

904 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

905 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

906 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

907 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

908 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

909 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

910 
	`ASSERT
 (
argv
[7] == 
NULL
);

911 
	`ASSERT
 (
a_seen
 == 1);

912 
	`ASSERT
 (
b_seen
 == 0);

913 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

914 
	`ASSERT
 (
q_value
 == 
NULL
);

915 
	`ASSERT
 (
non_options_count
 == 3);

916 
	`ASSERT
 (
	`strcmp
 (
non_options
[0], "donald") == 0);

917 
	`ASSERT
 (
	`strcmp
 (
non_options
[1], "duck") == 0);

918 
	`ASSERT
 (
	`strcmp
 (
non_options
[2], "bar") == 0);

919 
	`ASSERT
 (
unrecognized
 == 0);

920 
	`ASSERT
 (
optind
 == 7);

921 
	`ASSERT
 (!
output
);

925 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

927 int 
a_seen
 = 0;

928 int 
b_seen
 = 0;

929 const char *
p_value
 = 
NULL
;

930 const char *
q_value
 = 
NULL
;

931 int 
non_options_count
 = 0;

932 const char *
non_options
[10];

933 int 
unrecognized
 = 0;

934 
bool
 
output
;

935 int 
argc
 = 0;

936 const char *
argv
[20];

938 
argv
[
argc
++] = "program";

939 
argv
[
argc
++] = "donald";

940 
argv
[
argc
++] = "-p";

941 
argv
[
argc
++] = "billy";

942 
argv
[
argc
++] = "duck";

943 
argv
[
argc
++] = "-a";

944 
argv
[
argc
++] = "--";

945 
argv
[
argc
++] = "-b";

946 
argv
[
argc
++] = "foo";

947 
argv
[
argc
++] = "-q";

948 
argv
[
argc
++] = "johnny";

949 
argv
[
argc
++] = "bar";

950 
argv
[
argc
] = 
NULL
;

951 
optind
 = 
start
;

952 
opterr
 = 1;

953 
	`getopt_loop
 (
argc
, 
argv
, "-abp:q:",

954 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

955 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

956 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

957 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

958 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

959 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

960 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

961 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

962 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "--") == 0);

963 
	`ASSERT
 (
	`strcmp
 (
argv
[7], "-b") == 0);

964 
	`ASSERT
 (
	`strcmp
 (
argv
[8], "foo") == 0);

965 
	`ASSERT
 (
	`strcmp
 (
argv
[9], "-q") == 0);

966 
	`ASSERT
 (
	`strcmp
 (
argv
[10], "johnny") == 0);

967 
	`ASSERT
 (
	`strcmp
 (
argv
[11], "bar") == 0);

968 
	`ASSERT
 (
argv
[12] == 
NULL
);

969 
	`ASSERT
 (
a_seen
 == 1);

970 
	`ASSERT
 (
b_seen
 == 0);

971 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

972 
	`ASSERT
 (
q_value
 == 
NULL
);

973 
	`ASSERT
 (!
output
);

974 if (
non_options_count
 == 2)

977 
	`ASSERT
 (
non_options_count
 == 2);

978 
	`ASSERT
 (
	`strcmp
 (
non_options
[0], "donald") == 0);

979 
	`ASSERT
 (
	`strcmp
 (
non_options
[1], "duck") == 0);

980 
	`ASSERT
 (
unrecognized
 == 0);

981 
	`ASSERT
 (
optind
 == 7);

986 
	`ASSERT
 (
non_options_count
 == 7);

987 
	`ASSERT
 (
	`strcmp
 (
non_options
[0], "donald") == 0);

988 
	`ASSERT
 (
	`strcmp
 (
non_options
[1], "duck") == 0);

989 
	`ASSERT
 (
	`strcmp
 (
non_options
[2], "-b") == 0);

990 
	`ASSERT
 (
	`strcmp
 (
non_options
[3], "foo") == 0);

991 
	`ASSERT
 (
	`strcmp
 (
non_options
[4], "-q") == 0);

992 
	`ASSERT
 (
	`strcmp
 (
non_options
[5], "johnny") == 0);

993 
	`ASSERT
 (
	`strcmp
 (
non_options
[6], "bar") == 0);

994 
	`ASSERT
 (
unrecognized
 == 0);

995 
	`ASSERT
 (
optind
 == 12);

1000 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1002 int 
a_seen
 = 0;

1003 int 
b_seen
 = 0;

1004 const char *
p_value
 = 
NULL
;

1005 const char *
q_value
 = 
NULL
;

1006 int 
non_options_count
 = 0;

1007 const char *
non_options
[10];

1008 int 
unrecognized
 = 0;

1009 
bool
 
output
;

1010 int 
argc
 = 0;

1011 const char *
argv
[10];

1013 
argv
[
argc
++] = "program";

1014 
argv
[
argc
++] = "donald";

1015 
argv
[
argc
++] = "-p";

1016 
argv
[
argc
++] = "billy";

1017 
argv
[
argc
++] = "duck";

1018 
argv
[
argc
++] = "-a";

1019 
argv
[
argc
++] = "bar";

1020 
argv
[
argc
] = 
NULL
;

1021 
optind
 = 
start
;

1022 
opterr
 = 1;

1023 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:-",

1024 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1025 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1026 if (
posixly
)

1028 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1029 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1030 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1031 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1032 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1033 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1034 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1035 
	`ASSERT
 (
argv
[7] == 
NULL
);

1036 
	`ASSERT
 (
a_seen
 == 0);

1037 
	`ASSERT
 (
b_seen
 == 0);

1038 
	`ASSERT
 (
p_value
 == 
NULL
);

1039 
	`ASSERT
 (
q_value
 == 
NULL
);

1040 
	`ASSERT
 (
non_options_count
 == 0);

1041 
	`ASSERT
 (
unrecognized
 == 0);

1042 
	`ASSERT
 (
optind
 == 1);

1043 
	`ASSERT
 (!
output
);

1047 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1048 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

1049 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

1050 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

1051 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "donald") == 0);

1052 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "duck") == 0);

1053 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1054 
	`ASSERT
 (
argv
[7] == 
NULL
);

1055 
	`ASSERT
 (
a_seen
 == 1);

1056 
	`ASSERT
 (
b_seen
 == 0);

1057 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1058 
	`ASSERT
 (
q_value
 == 
NULL
);

1059 
	`ASSERT
 (
non_options_count
 == 0);

1060 
	`ASSERT
 (
unrecognized
 == 0);

1061 
	`ASSERT
 (
optind
 == 4);

1062 
	`ASSERT
 (!
output
);

1068 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1070 int 
a_seen
 = 0;

1071 int 
b_seen
 = 0;

1072 const char *
p_value
 = 
NULL
;

1073 const char *
q_value
 = 
NULL
;

1074 int 
non_options_count
 = 0;

1075 const char *
non_options
[10];

1076 int 
unrecognized
 = 0;

1077 
bool
 
output
;

1078 int 
argc
 = 0;

1079 const char *
argv
[10];

1081 
argv
[
argc
++] = "program";

1082 
argv
[
argc
++] = "donald";

1083 
argv
[
argc
++] = "-p";

1084 
argv
[
argc
++] = "billy";

1085 
argv
[
argc
++] = "duck";

1086 
argv
[
argc
++] = "-a";

1087 
argv
[
argc
++] = "bar";

1088 
argv
[
argc
] = 
NULL
;

1089 
optind
 = 
start
;

1090 
opterr
 = 1;

1091 
	`getopt_loop
 (
argc
, 
argv
, "+abp:q:",

1092 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1093 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1094 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1095 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1096 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1097 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1098 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1099 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1100 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1101 
	`ASSERT
 (
argv
[7] == 
NULL
);

1102 
	`ASSERT
 (
a_seen
 == 0);

1103 
	`ASSERT
 (
b_seen
 == 0);

1104 
	`ASSERT
 (
p_value
 == 
NULL
);

1105 
	`ASSERT
 (
q_value
 == 
NULL
);

1106 
	`ASSERT
 (
non_options_count
 == 0);

1107 
	`ASSERT
 (
unrecognized
 == 0);

1108 
	`ASSERT
 (
optind
 == 1);

1109 
	`ASSERT
 (!
output
);

1111 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1113 int 
a_seen
 = 0;

1114 int 
b_seen
 = 0;

1115 const char *
p_value
 = 
NULL
;

1116 const char *
q_value
 = 
NULL
;

1117 int 
non_options_count
 = 0;

1118 const char *
non_options
[10];

1119 int 
unrecognized
 = 0;

1120 
bool
 
output
;

1121 int 
argc
 = 0;

1122 const char *
argv
[10];

1124 
argv
[
argc
++] = "program";

1125 
argv
[
argc
++] = "-+";

1126 
argv
[
argc
] = 
NULL
;

1127 
optind
 = 
start
;

1128 
	`getopt_loop
 (
argc
, 
argv
, "+abp:q:",

1129 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1130 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1131 
	`ASSERT
 (
a_seen
 == 0);

1132 
	`ASSERT
 (
b_seen
 == 0);

1133 
	`ASSERT
 (
p_value
 == 
NULL
);

1134 
	`ASSERT
 (
q_value
 == 
NULL
);

1135 
	`ASSERT
 (
non_options_count
 == 0);

1136 
	`ASSERT
 (
unrecognized
 == '+');

1137 
	`ASSERT
 (
optind
 == 2);

1138 
	`ASSERT
 (
output
);

1142 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1144 int 
a_seen
 = 0;

1145 int 
b_seen
 = 0;

1146 const char *
p_value
 = 
NULL
;

1147 const char *
q_value
 = 
NULL
;

1148 int 
non_options_count
 = 0;

1149 const char *
non_options
[10];

1150 int 
unrecognized
 = 0;

1151 
bool
 
output
;

1152 int 
argc
 = 0;

1153 const char *
argv
[20];

1155 
argv
[
argc
++] = "program";

1156 
argv
[
argc
++] = "donald";

1157 
argv
[
argc
++] = "-p";

1158 
argv
[
argc
++] = "billy";

1159 
argv
[
argc
++] = "duck";

1160 
argv
[
argc
++] = "-a";

1161 
argv
[
argc
++] = "--";

1162 
argv
[
argc
++] = "-b";

1163 
argv
[
argc
++] = "foo";

1164 
argv
[
argc
++] = "-q";

1165 
argv
[
argc
++] = "johnny";

1166 
argv
[
argc
++] = "bar";

1167 
argv
[
argc
] = 
NULL
;

1168 
optind
 = 
start
;

1169 
opterr
 = 1;

1170 
	`getopt_loop
 (
argc
, 
argv
, "+abp:q:",

1171 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1172 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1173 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1174 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1175 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1176 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1177 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1178 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1179 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "--") == 0);

1180 
	`ASSERT
 (
	`strcmp
 (
argv
[7], "-b") == 0);

1181 
	`ASSERT
 (
	`strcmp
 (
argv
[8], "foo") == 0);

1182 
	`ASSERT
 (
	`strcmp
 (
argv
[9], "-q") == 0);

1183 
	`ASSERT
 (
	`strcmp
 (
argv
[10], "johnny") == 0);

1184 
	`ASSERT
 (
	`strcmp
 (
argv
[11], "bar") == 0);

1185 
	`ASSERT
 (
argv
[12] == 
NULL
);

1186 
	`ASSERT
 (
a_seen
 == 0);

1187 
	`ASSERT
 (
b_seen
 == 0);

1188 
	`ASSERT
 (
p_value
 == 
NULL
);

1189 
	`ASSERT
 (
q_value
 == 
NULL
);

1190 
	`ASSERT
 (
non_options_count
 == 0);

1191 
	`ASSERT
 (
unrecognized
 == 0);

1192 
	`ASSERT
 (
optind
 == 1);

1193 
	`ASSERT
 (!
output
);

1198 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1200 int 
a_seen
 = 0;

1201 int 
b_seen
 = 0;

1202 const char *
p_value
 = 
NULL
;

1203 const char *
q_value
 = 
NULL
;

1204 int 
non_options_count
 = 0;

1205 const char *
non_options
[10];

1206 int 
unrecognized
 = 0;

1207 
bool
 
output
;

1208 int 
argc
 = 0;

1209 const char *
argv
[10];

1211 
argv
[
argc
++] = "program";

1212 
argv
[
argc
++] = "donald";

1213 
argv
[
argc
++] = "-p";

1214 
argv
[
argc
++] = "billy";

1215 
argv
[
argc
++] = "duck";

1216 
argv
[
argc
++] = "-a";

1217 
argv
[
argc
++] = "bar";

1218 
argv
[
argc
] = 
NULL
;

1219 
optind
 = 
start
;

1220 
opterr
 = 1;

1221 
	`getopt_loop
 (
argc
, 
argv
, "abp:q:+",

1222 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1223 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1224 if (
posixly
)

1226 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1227 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1228 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1229 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1230 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1231 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1232 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1233 
	`ASSERT
 (
argv
[7] == 
NULL
);

1234 
	`ASSERT
 (
a_seen
 == 0);

1235 
	`ASSERT
 (
b_seen
 == 0);

1236 
	`ASSERT
 (
p_value
 == 
NULL
);

1237 
	`ASSERT
 (
q_value
 == 
NULL
);

1238 
	`ASSERT
 (
non_options_count
 == 0);

1239 
	`ASSERT
 (
unrecognized
 == 0);

1240 
	`ASSERT
 (
optind
 == 1);

1241 
	`ASSERT
 (!
output
);

1245 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1246 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

1247 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

1248 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

1249 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "donald") == 0);

1250 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "duck") == 0);

1251 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1252 
	`ASSERT
 (
argv
[7] == 
NULL
);

1253 
	`ASSERT
 (
a_seen
 == 1);

1254 
	`ASSERT
 (
b_seen
 == 0);

1255 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1256 
	`ASSERT
 (
q_value
 == 
NULL
);

1257 
	`ASSERT
 (
non_options_count
 == 0);

1258 
	`ASSERT
 (
unrecognized
 == 0);

1259 
	`ASSERT
 (
optind
 == 4);

1260 
	`ASSERT
 (!
output
);

1264 #if 
GNULIB_TEST_GETOPT_GNU


1268 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1270 int 
a_seen
 = 0;

1271 int 
b_seen
 = 0;

1272 const char *
p_value
 = 
NULL
;

1273 const char *
q_value
 = 
NULL
;

1274 int 
non_options_count
 = 0;

1275 const char *
non_options
[10];

1276 int 
unrecognized
 = 0;

1277 
bool
 
output
;

1278 int 
argc
 = 0;

1279 const char *
argv
[10];

1281 
argv
[
argc
++] = "program";

1282 
argv
[
argc
++] = "donald";

1283 
argv
[
argc
++] = "-p";

1284 
argv
[
argc
++] = "billy";

1285 
argv
[
argc
++] = "duck";

1286 
argv
[
argc
++] = "-a";

1287 
argv
[
argc
++] = "bar";

1288 
argv
[
argc
] = 
NULL
;

1289 
optind
 = 
start
;

1290 
opterr
 = 1;

1291 
	`getopt_loop
 (
argc
, 
argv
, "+:abp:q:",

1292 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1293 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1294 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1295 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1296 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1297 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1298 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1299 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1300 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1301 
	`ASSERT
 (
argv
[7] == 
NULL
);

1302 
	`ASSERT
 (
a_seen
 == 0);

1303 
	`ASSERT
 (
b_seen
 == 0);

1304 
	`ASSERT
 (
p_value
 == 
NULL
);

1305 
	`ASSERT
 (
q_value
 == 
NULL
);

1306 
	`ASSERT
 (
non_options_count
 == 0);

1307 
	`ASSERT
 (
unrecognized
 == 0);

1308 
	`ASSERT
 (
optind
 == 1);

1309 
	`ASSERT
 (!
output
);

1311 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1313 int 
a_seen
 = 0;

1314 int 
b_seen
 = 0;

1315 const char *
p_value
 = 
NULL
;

1316 const char *
q_value
 = 
NULL
;

1317 int 
non_options_count
 = 0;

1318 const char *
non_options
[10];

1319 int 
unrecognized
 = 0;

1320 
bool
 
output
;

1321 int 
argc
 = 0;

1322 const char *
argv
[10];

1324 
argv
[
argc
++] = "program";

1325 
argv
[
argc
++] = "-p";

1326 
argv
[
argc
] = 
NULL
;

1327 
optind
 = 
start
;

1328 
	`getopt_loop
 (
argc
, 
argv
, "+:abp:q:",

1329 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1330 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1331 
	`ASSERT
 (
a_seen
 == 0);

1332 
	`ASSERT
 (
b_seen
 == 0);

1333 
	`ASSERT
 (
p_value
 == 
NULL
);

1334 
	`ASSERT
 (
q_value
 == 
NULL
);

1335 
	`ASSERT
 (
non_options_count
 == 0);

1336 
	`ASSERT
 (
unrecognized
 == 'p');

1337 
	`ASSERT
 (
optind
 == 2);

1338 
	`ASSERT
 (!
output
);

1340 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1342 int 
a_seen
 = 0;

1343 int 
b_seen
 = 0;

1344 const char *
p_value
 = 
NULL
;

1345 const char *
q_value
 = 
NULL
;

1346 int 
non_options_count
 = 0;

1347 const char *
non_options
[10];

1348 int 
unrecognized
 = 0;

1349 
bool
 
output
;

1350 int 
argc
 = 0;

1351 const char *
argv
[10];

1353 
argv
[
argc
++] = "program";

1354 
argv
[
argc
++] = "-b";

1355 
argv
[
argc
++] = "-p";

1356 
argv
[
argc
] = 
NULL
;

1357 
optind
 = 
start
;

1358 
	`getopt_loop
 (
argc
, 
argv
, "+:abp:q:",

1359 &
a_seen
, &
b_seen
, &
p_value
, &
q_value
,

1360 &
non_options_count
, 
non_options
, &
unrecognized
, &
output
);

1361 
	`ASSERT
 (
a_seen
 == 0);

1362 
	`ASSERT
 (
b_seen
 == 1);

1363 
	`ASSERT
 (
p_value
 == 
NULL
);

1364 
	`ASSERT
 (
q_value
 == 
NULL
);

1365 
	`ASSERT
 (
non_options_count
 == 0);

1366 
	`ASSERT
 (
unrecognized
 == 'p');

1367 
	`ASSERT
 (
optind
 == 3);

1368 
	`ASSERT
 (!
output
);

1376 for (
start
 = 
OPTIND_MIN
; start <= 1; start++)

1378 int 
argc
 = 0;

1379 const char *
argv
[10];

1380 int 
pos
 = 
	`ftell
 (
stderr
);

1382 
argv
[
argc
++] = "program";

1383 
argv
[
argc
++] = "-W";

1384 
argv
[
argc
++] = "dummy";

1385 
argv
[
argc
] = 
NULL
;

1386 
optind
 = 
start
;

1387 
opterr
 = 1;

1388 
	`ASSERT
 (
	`getopt
 (
argc
, (char **) 
argv
, "W;") == 'W');

1389 
	`ASSERT
 (
	`ftell
 (
stderr
) == 
pos
);

1390 
	`ASSERT
 (
optind
 == 2);

1393 
	}
}

	@gnulib-tests/test-getopt_long.h

21 static int 
	ga_seen
;

22 static int 
	gb_seen
;

23 static int 
	gq_seen
;

25 static const struct 
option
 
	glong_options_required
[] =

27 { "alpha", 
no_argument
, 
NULL
, 'a' },

28 { "beta", 
no_argument
, &
b_seen
, 1 },

29 { "prune", 
required_argument
, 
NULL
, 'p' },

30 { "quetsche", 
required_argument
, &
q_seen
, 1 },

31 { "xtremely-",
no_argument
, 
NULL
, 1003 },

32 { "xtra", 
no_argument
, 
NULL
, 1001 },

33 { "xtreme", 
no_argument
, 
NULL
, 1002 },

34 { "xtremely", 
no_argument
, 
NULL
, 1003 },

35 { 
NULL
, 0, NULL, 0 }

38 static const struct 
option
 
	glong_options_optional
[] =

40 { "alpha", 
no_argument
, 
NULL
, 'a' },

41 { "beta", 
no_argument
, &
b_seen
, 1 },

42 { "prune", 
optional_argument
, 
NULL
, 'p' },

43 { "quetsche", 
optional_argument
, &
q_seen
, 1 },

44 { 
NULL
, 0, NULL, 0 }

48 
	$getopt_long_loop
 (int 
argc
, const char **
argv
,

49 const char *
options
, const struct 
option
 *
long_options
,

50 const char **
p_value
, const char **
q_value
,

51 int *
non_options_count
, const char **
non_options
,

52 int *
unrecognized
)

54 int 
option_index
 = -1;

55 int 
c
;

57 
opterr
 = 0;

58 
q_seen
 = 0;

59 while ((
c
 = 
	`getopt_long
 (
argc
, (char **) 
argv
, 
options
, 
long_options
,

60 &
option_index
))

63 switch (
c
)

67 if (
q_seen
)

68 *
q_value
 = 
optarg
;

71 
a_seen
++;

74 
b_seen
 = 1;

77 *
p_value
 = 
optarg
;

80 *
q_value
 = 
optarg
;

84 
	`ASSERT
 (
options
[0] == '-');

85 
non_options
[(*
non_options_count
)++] = 
optarg
;

89 
	`ASSERT
 (
options
[0] == ':'

90 || ((
options
[0] == '-' || options[0] == '+')

91 && 
options
[1] == ':'));

94 *
unrecognized
 = 
optopt
;

97 *
unrecognized
 = 
c
;

101 
	}
}

107 
	$do_getopt_long
 (int 
argc
, const char **
argv
, const char *
shortopts
,

108 const struct 
option
 *
longopts
, int *
longind
)

110 return 
	`getopt_long
 (
argc
, (char **) 
argv
, 
shortopts
, 
longopts
, 
longind
);

111 
	}
}

114 
	$test_getopt_long
 (void)

116 int 
start
;

120 int 
argc
 = 0;

121 const char *
argv
[10];

122 int 
option_index
;

123 int 
c
;

125 
argv
[
argc
++] = "program";

126 
argv
[
argc
++] = "--x";

127 
argv
[
argc
] = 
NULL
;

128 
optind
 = 1;

129 
opterr
 = 0;

130 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

131 
	`ASSERT
 (
c
 == '?');

132 
	`ASSERT
 (
optopt
 == 0);

135 int 
argc
 = 0;

136 const char *
argv
[10];

137 int 
option_index
;

138 int 
c
;

140 
argv
[
argc
++] = "program";

141 
argv
[
argc
++] = "--xt";

142 
argv
[
argc
] = 
NULL
;

143 
optind
 = 1;

144 
opterr
 = 0;

145 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

146 
	`ASSERT
 (
c
 == '?');

147 
	`ASSERT
 (
optopt
 == 0);

150 int 
argc
 = 0;

151 const char *
argv
[10];

152 int 
option_index
;

153 int 
c
;

155 
argv
[
argc
++] = "program";

156 
argv
[
argc
++] = "--xtr";

157 
argv
[
argc
] = 
NULL
;

158 
optind
 = 1;

159 
opterr
 = 0;

160 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

161 
	`ASSERT
 (
c
 == '?');

162 
	`ASSERT
 (
optopt
 == 0);

165 int 
argc
 = 0;

166 const char *
argv
[10];

167 int 
option_index
;

168 int 
c
;

170 
argv
[
argc
++] = "program";

171 
argv
[
argc
++] = "--xtra";

172 
argv
[
argc
] = 
NULL
;

173 
optind
 = 1;

174 
opterr
 = 0;

175 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

176 
	`ASSERT
 (
c
 == 1001);

179 int 
argc
 = 0;

180 const char *
argv
[10];

181 int 
option_index
;

182 int 
c
;

184 
argv
[
argc
++] = "program";

185 
argv
[
argc
++] = "--xtre";

186 
argv
[
argc
] = 
NULL
;

187 
optind
 = 1;

188 
opterr
 = 0;

189 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

190 
	`ASSERT
 (
c
 == '?');

191 
	`ASSERT
 (
optopt
 == 0);

194 int 
argc
 = 0;

195 const char *
argv
[10];

196 int 
option_index
;

197 int 
c
;

199 
argv
[
argc
++] = "program";

200 
argv
[
argc
++] = "--xtrem";

201 
argv
[
argc
] = 
NULL
;

202 
optind
 = 1;

203 
opterr
 = 0;

204 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

205 
	`ASSERT
 (
c
 == '?');

206 
	`ASSERT
 (
optopt
 == 0);

209 int 
argc
 = 0;

210 const char *
argv
[10];

211 int 
option_index
;

212 int 
c
;

214 
argv
[
argc
++] = "program";

215 
argv
[
argc
++] = "--xtreme";

216 
argv
[
argc
] = 
NULL
;

217 
optind
 = 1;

218 
opterr
 = 0;

219 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

220 
	`ASSERT
 (
c
 == 1002);

223 int 
argc
 = 0;

224 const char *
argv
[10];

225 int 
option_index
;

226 int 
c
;

228 
argv
[
argc
++] = "program";

229 
argv
[
argc
++] = "--xtremel";

230 
argv
[
argc
] = 
NULL
;

231 
optind
 = 1;

232 
opterr
 = 0;

233 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

234 
	`ASSERT
 (
c
 == 1003);

237 int 
argc
 = 0;

238 const char *
argv
[10];

239 int 
option_index
;

240 int 
c
;

242 
argv
[
argc
++] = "program";

243 
argv
[
argc
++] = "--xtremely";

244 
argv
[
argc
] = 
NULL
;

245 
optind
 = 1;

246 
opterr
 = 0;

247 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "ab", 
long_options_required
, &
option_index
);

248 
	`ASSERT
 (
c
 == 1003);

253 int 
argc
 = 0;

254 const char *
argv
[10];

255 int 
option_index
;

256 int 
c
;

258 
argv
[
argc
++] = "program";

259 
argv
[
argc
++] = "-W";

260 
argv
[
argc
] = 
NULL
;

261 
optind
 = 1;

262 
opterr
 = 0;

263 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "W;", 
long_options_required
, &
option_index
);

264 
	`ASSERT
 (
c
 == '?');

265 
	`ASSERT
 (
optopt
 == 'W');

268 int 
argc
 = 0;

269 const char *
argv
[10];

270 int 
option_index
;

271 int 
c
;

273 
argv
[
argc
++] = "program";

274 
argv
[
argc
++] = "-Wunknown";

275 
argv
[
argc
] = 
NULL
;

276 
optind
 = 1;

277 
opterr
 = 0;

278 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "W;", 
long_options_required
, &
option_index
);

281 if (
c
 == '?')

283 
	`ASSERT
 (
optopt
 == 0);

284 
	`ASSERT
 (
optarg
 == 
NULL
);

288 
	`ASSERT
 (
c
 == 'W');

289 
	`ASSERT
 (
	`strcmp
 (
optarg
, "unknown") == 0);

293 int 
argc
 = 0;

294 const char *
argv
[10];

295 int 
option_index
;

296 int 
c
;

298 
argv
[
argc
++] = "program";

299 
argv
[
argc
++] = "-W";

300 
argv
[
argc
++] = "unknown";

301 
argv
[
argc
] = 
NULL
;

302 
optind
 = 1;

303 
opterr
 = 0;

304 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "W;", 
long_options_required
, &
option_index
);

307 if (
c
 == '?')

309 
	`ASSERT
 (
optopt
 == 0);

310 
	`ASSERT
 (
optarg
 == 
NULL
);

314 
	`ASSERT
 (
c
 == 'W');

315 
	`ASSERT
 (
	`strcmp
 (
optarg
, "unknown") == 0);

322 int 
argc
 = 0;

323 const char *
argv
[10];

324 int 
option_index
;

325 int 
c
;

327 
argv
[
argc
++] = "program";

328 
argv
[
argc
++] = "-W";

329 
argv
[
argc
++] = "dummy";

330 
argv
[
argc
] = 
NULL
;

331 
optind
 = 1;

332 
opterr
 = 0;

333 
c
 = 
	`do_getopt_long
 (
argc
, 
argv
, "W;", 
NULL
, &
option_index
);

334 
	`ASSERT
 (
c
 == 'W');

335 
	`ASSERT
 (
optind
 == 2);

339 for (
start
 = 0; start <= 1; start++)

341 const char *
p_value
 = 
NULL
;

342 const char *
q_value
 = 
NULL
;

343 int 
non_options_count
 = 0;

344 const char *
non_options
[10];

345 int 
unrecognized
 = 0;

346 int 
argc
 = 0;

347 const char *
argv
[10];

348 
a_seen
 = 0;

349 
b_seen
 = 0;

351 
argv
[
argc
++] = "program";

352 
argv
[
argc
++] = "-a";

353 
argv
[
argc
++] = "foo";

354 
argv
[
argc
++] = "bar";

355 
argv
[
argc
] = 
NULL
;

356 
optind
 = 
start
;

357 
	`getopt_long_loop
 (
argc
, 
argv
, "ab", 
long_options_required
,

358 &
p_value
, &
q_value
,

359 &
non_options_count
, 
non_options
, &
unrecognized
);

360 
	`ASSERT
 (
a_seen
 == 1);

361 
	`ASSERT
 (
b_seen
 == 0);

362 
	`ASSERT
 (
p_value
 == 
NULL
);

363 
	`ASSERT
 (
q_value
 == 
NULL
);

364 
	`ASSERT
 (
non_options_count
 == 0);

365 
	`ASSERT
 (
unrecognized
 == 0);

366 
	`ASSERT
 (
optind
 == 2);

368 for (
start
 = 0; start <= 1; start++)

370 const char *
p_value
 = 
NULL
;

371 const char *
q_value
 = 
NULL
;

372 int 
non_options_count
 = 0;

373 const char *
non_options
[10];

374 int 
unrecognized
 = 0;

375 int 
argc
 = 0;

376 const char *
argv
[10];

377 
a_seen
 = 0;

378 
b_seen
 = 0;

380 
argv
[
argc
++] = "program";

381 
argv
[
argc
++] = "-b";

382 
argv
[
argc
++] = "-a";

383 
argv
[
argc
++] = "foo";

384 
argv
[
argc
++] = "bar";

385 
argv
[
argc
] = 
NULL
;

386 
optind
 = 
start
;

387 
	`getopt_long_loop
 (
argc
, 
argv
, "ab", 
long_options_required
,

388 &
p_value
, &
q_value
,

389 &
non_options_count
, 
non_options
, &
unrecognized
);

390 
	`ASSERT
 (
a_seen
 == 1);

391 
	`ASSERT
 (
b_seen
 == 1);

392 
	`ASSERT
 (
p_value
 == 
NULL
);

393 
	`ASSERT
 (
q_value
 == 
NULL
);

394 
	`ASSERT
 (
non_options_count
 == 0);

395 
	`ASSERT
 (
unrecognized
 == 0);

396 
	`ASSERT
 (
optind
 == 3);

398 for (
start
 = 0; start <= 1; start++)

400 const char *
p_value
 = 
NULL
;

401 const char *
q_value
 = 
NULL
;

402 int 
non_options_count
 = 0;

403 const char *
non_options
[10];

404 int 
unrecognized
 = 0;

405 int 
argc
 = 0;

406 const char *
argv
[10];

407 
a_seen
 = 0;

408 
b_seen
 = 0;

410 
argv
[
argc
++] = "program";

411 
argv
[
argc
++] = "-ba";

412 
argv
[
argc
++] = "foo";

413 
argv
[
argc
++] = "bar";

414 
argv
[
argc
] = 
NULL
;

415 
optind
 = 
start
;

416 
	`getopt_long_loop
 (
argc
, 
argv
, "ab", 
long_options_required
,

417 &
p_value
, &
q_value
,

418 &
non_options_count
, 
non_options
, &
unrecognized
);

419 
	`ASSERT
 (
a_seen
 == 1);

420 
	`ASSERT
 (
b_seen
 == 1);

421 
	`ASSERT
 (
p_value
 == 
NULL
);

422 
	`ASSERT
 (
q_value
 == 
NULL
);

423 
	`ASSERT
 (
non_options_count
 == 0);

424 
	`ASSERT
 (
unrecognized
 == 0);

425 
	`ASSERT
 (
optind
 == 2);

427 for (
start
 = 0; start <= 1; start++)

429 const char *
p_value
 = 
NULL
;

430 const char *
q_value
 = 
NULL
;

431 int 
non_options_count
 = 0;

432 const char *
non_options
[10];

433 int 
unrecognized
 = 0;

434 int 
argc
 = 0;

435 const char *
argv
[10];

436 
a_seen
 = 0;

437 
b_seen
 = 0;

439 
argv
[
argc
++] = "program";

440 
argv
[
argc
++] = "-ab";

441 
argv
[
argc
++] = "-a";

442 
argv
[
argc
++] = "foo";

443 
argv
[
argc
++] = "bar";

444 
argv
[
argc
] = 
NULL
;

445 
optind
 = 
start
;

446 
	`getopt_long_loop
 (
argc
, 
argv
, "ab", 
long_options_required
,

447 &
p_value
, &
q_value
,

448 &
non_options_count
, 
non_options
, &
unrecognized
);

449 
	`ASSERT
 (
a_seen
 == 2);

450 
	`ASSERT
 (
b_seen
 == 1);

451 
	`ASSERT
 (
p_value
 == 
NULL
);

452 
	`ASSERT
 (
q_value
 == 
NULL
);

453 
	`ASSERT
 (
non_options_count
 == 0);

454 
	`ASSERT
 (
unrecognized
 == 0);

455 
	`ASSERT
 (
optind
 == 3);

459 for (
start
 = 0; start <= 1; start++)

461 const char *
p_value
 = 
NULL
;

462 const char *
q_value
 = 
NULL
;

463 int 
non_options_count
 = 0;

464 const char *
non_options
[10];

465 int 
unrecognized
 = 0;

466 int 
argc
 = 0;

467 const char *
argv
[10];

468 
a_seen
 = 0;

469 
b_seen
 = 0;

471 
argv
[
argc
++] = "program";

472 
argv
[
argc
++] = "--alpha";

473 
argv
[
argc
++] = "foo";

474 
argv
[
argc
++] = "bar";

475 
argv
[
argc
] = 
NULL
;

476 
optind
 = 
start
;

477 
	`getopt_long_loop
 (
argc
, 
argv
, "ab", 
long_options_required
,

478 &
p_value
, &
q_value
,

479 &
non_options_count
, 
non_options
, &
unrecognized
);

480 
	`ASSERT
 (
a_seen
 == 1);

481 
	`ASSERT
 (
b_seen
 == 0);

482 
	`ASSERT
 (
p_value
 == 
NULL
);

483 
	`ASSERT
 (
q_value
 == 
NULL
);

484 
	`ASSERT
 (
non_options_count
 == 0);

485 
	`ASSERT
 (
unrecognized
 == 0);

486 
	`ASSERT
 (
optind
 == 2);

488 for (
start
 = 0; start <= 1; start++)

490 const char *
p_value
 = 
NULL
;

491 const char *
q_value
 = 
NULL
;

492 int 
non_options_count
 = 0;

493 const char *
non_options
[10];

494 int 
unrecognized
 = 0;

495 int 
argc
 = 0;

496 const char *
argv
[10];

497 
a_seen
 = 0;

498 
b_seen
 = 0;

500 
argv
[
argc
++] = "program";

501 
argv
[
argc
++] = "--beta";

502 
argv
[
argc
++] = "--alpha";

503 
argv
[
argc
++] = "foo";

504 
argv
[
argc
++] = "bar";

505 
argv
[
argc
] = 
NULL
;

506 
optind
 = 
start
;

507 
	`getopt_long_loop
 (
argc
, 
argv
, "ab", 
long_options_required
,

508 &
p_value
, &
q_value
,

509 &
non_options_count
, 
non_options
, &
unrecognized
);

510 
	`ASSERT
 (
a_seen
 == 1);

511 
	`ASSERT
 (
b_seen
 == 1);

512 
	`ASSERT
 (
p_value
 == 
NULL
);

513 
	`ASSERT
 (
q_value
 == 
NULL
);

514 
	`ASSERT
 (
non_options_count
 == 0);

515 
	`ASSERT
 (
unrecognized
 == 0);

516 
	`ASSERT
 (
optind
 == 3);

518 for (
start
 = 0; start <= 1; start++)

520 const char *
p_value
 = 
NULL
;

521 const char *
q_value
 = 
NULL
;

522 int 
non_options_count
 = 0;

523 const char *
non_options
[10];

524 int 
unrecognized
 = 0;

525 int 
argc
 = 0;

526 const char *
argv
[10];

527 
a_seen
 = 0;

528 
b_seen
 = 0;

530 
argv
[
argc
++] = "program";

531 
argv
[
argc
++] = "--alpha";

532 
argv
[
argc
++] = "--beta";

533 
argv
[
argc
++] = "--alpha";

534 
argv
[
argc
++] = "--beta";

535 
argv
[
argc
++] = "foo";

536 
argv
[
argc
++] = "bar";

537 
argv
[
argc
] = 
NULL
;

538 
optind
 = 
start
;

539 
	`getopt_long_loop
 (
argc
, 
argv
, "ab", 
long_options_required
,

540 &
p_value
, &
q_value
,

541 &
non_options_count
, 
non_options
, &
unrecognized
);

542 
	`ASSERT
 (
a_seen
 == 2);

543 
	`ASSERT
 (
b_seen
 == 1);

544 
	`ASSERT
 (
p_value
 == 
NULL
);

545 
	`ASSERT
 (
q_value
 == 
NULL
);

546 
	`ASSERT
 (
non_options_count
 == 0);

547 
	`ASSERT
 (
unrecognized
 == 0);

548 
	`ASSERT
 (
optind
 == 5);

552 for (
start
 = 0; start <= 1; start++)

554 const char *
p_value
 = 
NULL
;

555 const char *
q_value
 = 
NULL
;

556 int 
non_options_count
 = 0;

557 const char *
non_options
[10];

558 int 
unrecognized
 = 0;

559 int 
argc
 = 0;

560 const char *
argv
[10];

561 
a_seen
 = 0;

562 
b_seen
 = 0;

564 
argv
[
argc
++] = "program";

565 
argv
[
argc
++] = "-Walpha";

566 
argv
[
argc
++] = "foo";

567 
argv
[
argc
++] = "bar";

568 
argv
[
argc
] = 
NULL
;

569 
optind
 = 
start
;

570 
	`getopt_long_loop
 (
argc
, 
argv
, "abW;", 
long_options_required
,

571 &
p_value
, &
q_value
,

572 &
non_options_count
, 
non_options
, &
unrecognized
);

573 
	`ASSERT
 (
a_seen
 == 1);

574 
	`ASSERT
 (
b_seen
 == 0);

575 
	`ASSERT
 (
p_value
 == 
NULL
);

576 
	`ASSERT
 (
q_value
 == 
NULL
);

577 
	`ASSERT
 (
non_options_count
 == 0);

578 
	`ASSERT
 (
unrecognized
 == 0);

579 
	`ASSERT
 (
optind
 == 2);

581 for (
start
 = 0; start <= 1; start++)

583 const char *
p_value
 = 
NULL
;

584 const char *
q_value
 = 
NULL
;

585 int 
non_options_count
 = 0;

586 const char *
non_options
[10];

587 int 
unrecognized
 = 0;

588 int 
argc
 = 0;

589 const char *
argv
[10];

590 
a_seen
 = 0;

591 
b_seen
 = 0;

593 
argv
[
argc
++] = "program";

594 
argv
[
argc
++] = "-W";

595 
argv
[
argc
++] = "beta";

596 
argv
[
argc
++] = "-W";

597 
argv
[
argc
++] = "alpha";

598 
argv
[
argc
++] = "foo";

599 
argv
[
argc
++] = "bar";

600 
argv
[
argc
] = 
NULL
;

601 
optind
 = 
start
;

602 
	`getopt_long_loop
 (
argc
, 
argv
, "aW;b", 
long_options_required
,

603 &
p_value
, &
q_value
,

604 &
non_options_count
, 
non_options
, &
unrecognized
);

605 
	`ASSERT
 (
a_seen
 == 1);

606 
	`ASSERT
 (
b_seen
 == 1);

607 
	`ASSERT
 (
p_value
 == 
NULL
);

608 
	`ASSERT
 (
q_value
 == 
NULL
);

609 
	`ASSERT
 (
non_options_count
 == 0);

610 
	`ASSERT
 (
unrecognized
 == 0);

611 
	`ASSERT
 (
optind
 == 5);

613 for (
start
 = 0; start <= 1; start++)

615 const char *
p_value
 = 
NULL
;

616 const char *
q_value
 = 
NULL
;

617 int 
non_options_count
 = 0;

618 const char *
non_options
[10];

619 int 
unrecognized
 = 0;

620 int 
argc
 = 0;

621 const char *
argv
[10];

622 
a_seen
 = 0;

623 
b_seen
 = 0;

625 
argv
[
argc
++] = "program";

626 
argv
[
argc
++] = "-Walpha";

627 
argv
[
argc
++] = "-Wbeta";

628 
argv
[
argc
++] = "-Walpha";

629 
argv
[
argc
++] = "-Wbeta";

630 
argv
[
argc
++] = "foo";

631 
argv
[
argc
++] = "bar";

632 
argv
[
argc
] = 
NULL
;

633 
optind
 = 
start
;

634 
	`getopt_long_loop
 (
argc
, 
argv
, "W;ab", 
long_options_required
,

635 &
p_value
, &
q_value
,

636 &
non_options_count
, 
non_options
, &
unrecognized
);

637 
	`ASSERT
 (
a_seen
 == 2);

638 
	`ASSERT
 (
b_seen
 == 1);

639 
	`ASSERT
 (
p_value
 == 
NULL
);

640 
	`ASSERT
 (
q_value
 == 
NULL
);

641 
	`ASSERT
 (
non_options_count
 == 0);

642 
	`ASSERT
 (
unrecognized
 == 0);

643 
	`ASSERT
 (
optind
 == 5);

647 for (
start
 = 0; start <= 1; start++)

649 const char *
p_value
 = 
NULL
;

650 const char *
q_value
 = 
NULL
;

651 int 
non_options_count
 = 0;

652 const char *
non_options
[10];

653 int 
unrecognized
 = 0;

654 int 
argc
 = 0;

655 const char *
argv
[10];

656 
a_seen
 = 0;

657 
b_seen
 = 0;

659 
argv
[
argc
++] = "program";

660 
argv
[
argc
++] = "-pfoo";

661 
argv
[
argc
++] = "bar";

662 
argv
[
argc
] = 
NULL
;

663 
optind
 = 
start
;

664 
	`getopt_long_loop
 (
argc
, 
argv
, "p:q:", 
long_options_required
,

665 &
p_value
, &
q_value
,

666 &
non_options_count
, 
non_options
, &
unrecognized
);

667 
	`ASSERT
 (
a_seen
 == 0);

668 
	`ASSERT
 (
b_seen
 == 0);

669 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

670 
	`ASSERT
 (
q_value
 == 
NULL
);

671 
	`ASSERT
 (
non_options_count
 == 0);

672 
	`ASSERT
 (
unrecognized
 == 0);

673 
	`ASSERT
 (
optind
 == 2);

675 for (
start
 = 0; start <= 1; start++)

677 const char *
p_value
 = 
NULL
;

678 const char *
q_value
 = 
NULL
;

679 int 
non_options_count
 = 0;

680 const char *
non_options
[10];

681 int 
unrecognized
 = 0;

682 int 
argc
 = 0;

683 const char *
argv
[10];

684 
a_seen
 = 0;

685 
b_seen
 = 0;

687 
argv
[
argc
++] = "program";

688 
argv
[
argc
++] = "-p";

689 
argv
[
argc
++] = "foo";

690 
argv
[
argc
++] = "bar";

691 
argv
[
argc
] = 
NULL
;

692 
optind
 = 
start
;

693 
	`getopt_long_loop
 (
argc
, 
argv
, "p:q:", 
long_options_required
,

694 &
p_value
, &
q_value
,

695 &
non_options_count
, 
non_options
, &
unrecognized
);

696 
	`ASSERT
 (
a_seen
 == 0);

697 
	`ASSERT
 (
b_seen
 == 0);

698 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

699 
	`ASSERT
 (
q_value
 == 
NULL
);

700 
	`ASSERT
 (
non_options_count
 == 0);

701 
	`ASSERT
 (
unrecognized
 == 0);

702 
	`ASSERT
 (
optind
 == 3);

704 for (
start
 = 0; start <= 1; start++)

706 const char *
p_value
 = 
NULL
;

707 const char *
q_value
 = 
NULL
;

708 int 
non_options_count
 = 0;

709 const char *
non_options
[10];

710 int 
unrecognized
 = 0;

711 int 
argc
 = 0;

712 const char *
argv
[10];

713 
a_seen
 = 0;

714 
b_seen
 = 0;

716 
argv
[
argc
++] = "program";

717 
argv
[
argc
++] = "-ab";

718 
argv
[
argc
++] = "-q";

719 
argv
[
argc
++] = "baz";

720 
argv
[
argc
++] = "-pfoo";

721 
argv
[
argc
++] = "bar";

722 
argv
[
argc
] = 
NULL
;

723 
optind
 = 
start
;

724 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

725 &
p_value
, &
q_value
,

726 &
non_options_count
, 
non_options
, &
unrecognized
);

727 
	`ASSERT
 (
a_seen
 == 1);

728 
	`ASSERT
 (
b_seen
 == 1);

729 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

730 
	`ASSERT
 (
q_value
 != 
NULL
 && 
	`strcmp
 (q_value, "baz") == 0);

731 
	`ASSERT
 (
non_options_count
 == 0);

732 
	`ASSERT
 (
unrecognized
 == 0);

733 
	`ASSERT
 (
optind
 == 5);

737 for (
start
 = 0; start <= 1; start++)

739 const char *
p_value
 = 
NULL
;

740 const char *
q_value
 = 
NULL
;

741 int 
non_options_count
 = 0;

742 const char *
non_options
[10];

743 int 
unrecognized
 = 0;

744 int 
argc
 = 0;

745 const char *
argv
[10];

746 
a_seen
 = 0;

747 
b_seen
 = 0;

749 
argv
[
argc
++] = "program";

750 
argv
[
argc
++] = "--p=foo";

751 
argv
[
argc
++] = "bar";

752 
argv
[
argc
] = 
NULL
;

753 
optind
 = 
start
;

754 
	`getopt_long_loop
 (
argc
, 
argv
, "p:q:", 
long_options_required
,

755 &
p_value
, &
q_value
,

756 &
non_options_count
, 
non_options
, &
unrecognized
);

757 
	`ASSERT
 (
a_seen
 == 0);

758 
	`ASSERT
 (
b_seen
 == 0);

759 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

760 
	`ASSERT
 (
q_value
 == 
NULL
);

761 
	`ASSERT
 (
non_options_count
 == 0);

762 
	`ASSERT
 (
unrecognized
 == 0);

763 
	`ASSERT
 (
optind
 == 2);

765 for (
start
 = 0; start <= 1; start++)

767 const char *
p_value
 = 
NULL
;

768 const char *
q_value
 = 
NULL
;

769 int 
non_options_count
 = 0;

770 const char *
non_options
[10];

771 int 
unrecognized
 = 0;

772 int 
argc
 = 0;

773 const char *
argv
[10];

774 
a_seen
 = 0;

775 
b_seen
 = 0;

777 
argv
[
argc
++] = "program";

778 
argv
[
argc
++] = "--p";

779 
argv
[
argc
++] = "foo";

780 
argv
[
argc
++] = "bar";

781 
argv
[
argc
] = 
NULL
;

782 
optind
 = 
start
;

783 
	`getopt_long_loop
 (
argc
, 
argv
, "p:q:", 
long_options_required
,

784 &
p_value
, &
q_value
,

785 &
non_options_count
, 
non_options
, &
unrecognized
);

786 
	`ASSERT
 (
a_seen
 == 0);

787 
	`ASSERT
 (
b_seen
 == 0);

788 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

789 
	`ASSERT
 (
q_value
 == 
NULL
);

790 
	`ASSERT
 (
non_options_count
 == 0);

791 
	`ASSERT
 (
unrecognized
 == 0);

792 
	`ASSERT
 (
optind
 == 3);

794 for (
start
 = 0; start <= 1; start++)

796 const char *
p_value
 = 
NULL
;

797 const char *
q_value
 = 
NULL
;

798 int 
non_options_count
 = 0;

799 const char *
non_options
[10];

800 int 
unrecognized
 = 0;

801 int 
argc
 = 0;

802 const char *
argv
[10];

803 
a_seen
 = 0;

804 
b_seen
 = 0;

806 
argv
[
argc
++] = "program";

807 
argv
[
argc
++] = "-ab";

808 
argv
[
argc
++] = "--q";

809 
argv
[
argc
++] = "baz";

810 
argv
[
argc
++] = "--p=foo";

811 
argv
[
argc
++] = "bar";

812 
argv
[
argc
] = 
NULL
;

813 
optind
 = 
start
;

814 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

815 &
p_value
, &
q_value
,

816 &
non_options_count
, 
non_options
, &
unrecognized
);

817 
	`ASSERT
 (
a_seen
 == 1);

818 
	`ASSERT
 (
b_seen
 == 1);

819 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

820 
	`ASSERT
 (
q_value
 != 
NULL
 && 
	`strcmp
 (q_value, "baz") == 0);

821 
	`ASSERT
 (
non_options_count
 == 0);

822 
	`ASSERT
 (
unrecognized
 == 0);

823 
	`ASSERT
 (
optind
 == 5);

827 for (
start
 = 0; start <= 1; start++)

829 const char *
p_value
 = 
NULL
;

830 const char *
q_value
 = 
NULL
;

831 int 
non_options_count
 = 0;

832 const char *
non_options
[10];

833 int 
unrecognized
 = 0;

834 int 
argc
 = 0;

835 const char *
argv
[10];

836 
a_seen
 = 0;

837 
b_seen
 = 0;

839 
argv
[
argc
++] = "program";

840 
argv
[
argc
++] = "-Wp=foo";

841 
argv
[
argc
++] = "bar";

842 
argv
[
argc
] = 
NULL
;

843 
optind
 = 
start
;

844 
	`getopt_long_loop
 (
argc
, 
argv
, "p:q:W;", 
long_options_required
,

845 &
p_value
, &
q_value
,

846 &
non_options_count
, 
non_options
, &
unrecognized
);

847 
	`ASSERT
 (
a_seen
 == 0);

848 
	`ASSERT
 (
b_seen
 == 0);

849 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

850 
	`ASSERT
 (
q_value
 == 
NULL
);

851 
	`ASSERT
 (
non_options_count
 == 0);

852 
	`ASSERT
 (
unrecognized
 == 0);

853 
	`ASSERT
 (
optind
 == 2);

855 for (
start
 = 0; start <= 1; start++)

857 const char *
p_value
 = 
NULL
;

858 const char *
q_value
 = 
NULL
;

859 int 
non_options_count
 = 0;

860 const char *
non_options
[10];

861 int 
unrecognized
 = 0;

862 int 
argc
 = 0;

863 const char *
argv
[10];

864 
a_seen
 = 0;

865 
b_seen
 = 0;

867 
argv
[
argc
++] = "program";

868 
argv
[
argc
++] = "-W";

869 
argv
[
argc
++] = "p";

870 
argv
[
argc
++] = "foo";

871 
argv
[
argc
++] = "bar";

872 
argv
[
argc
] = 
NULL
;

873 
optind
 = 
start
;

874 
	`getopt_long_loop
 (
argc
, 
argv
, "p:W;q:", 
long_options_required
,

875 &
p_value
, &
q_value
,

876 &
non_options_count
, 
non_options
, &
unrecognized
);

877 
	`ASSERT
 (
a_seen
 == 0);

878 
	`ASSERT
 (
b_seen
 == 0);

879 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

880 
	`ASSERT
 (
q_value
 == 
NULL
);

881 
	`ASSERT
 (
non_options_count
 == 0);

882 
	`ASSERT
 (
unrecognized
 == 0);

883 
	`ASSERT
 (
optind
 == 4);

885 for (
start
 = 0; start <= 1; start++)

887 const char *
p_value
 = 
NULL
;

888 const char *
q_value
 = 
NULL
;

889 int 
non_options_count
 = 0;

890 const char *
non_options
[10];

891 int 
unrecognized
 = 0;

892 int 
argc
 = 0;

893 const char *
argv
[10];

894 
a_seen
 = 0;

895 
b_seen
 = 0;

897 
argv
[
argc
++] = "program";

898 
argv
[
argc
++] = "-ab";

899 
argv
[
argc
++] = "-Wq";

900 
argv
[
argc
++] = "baz";

901 
argv
[
argc
++] = "-W";

902 
argv
[
argc
++] = "p=foo";

903 
argv
[
argc
++] = "bar";

904 
argv
[
argc
] = 
NULL
;

905 
optind
 = 
start
;

906 
	`getopt_long_loop
 (
argc
, 
argv
, "W;abp:q:", 
long_options_required
,

907 &
p_value
, &
q_value
,

908 &
non_options_count
, 
non_options
, &
unrecognized
);

909 
	`ASSERT
 (
a_seen
 == 1);

910 
	`ASSERT
 (
b_seen
 == 1);

911 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

912 
	`ASSERT
 (
q_value
 != 
NULL
 && 
	`strcmp
 (q_value, "baz") == 0);

913 
	`ASSERT
 (
non_options_count
 == 0);

914 
	`ASSERT
 (
unrecognized
 == 0);

915 
	`ASSERT
 (
optind
 == 6);

919 for (
start
 = 0; start <= 1; start++)

921 const char *
p_value
 = 
NULL
;

922 const char *
q_value
 = 
NULL
;

923 int 
non_options_count
 = 0;

924 const char *
non_options
[10];

925 int 
unrecognized
 = 0;

926 int 
argc
 = 0;

927 const char *
argv
[10];

928 
a_seen
 = 0;

929 
b_seen
 = 0;

931 
argv
[
argc
++] = "program";

932 
argv
[
argc
++] = "-pfoo";

933 
argv
[
argc
++] = "bar";

934 
argv
[
argc
] = 
NULL
;

935 
optind
 = 
start
;

936 
	`getopt_long_loop
 (
argc
, 
argv
, "p::q::", 
long_options_optional
,

937 &
p_value
, &
q_value
,

938 &
non_options_count
, 
non_options
, &
unrecognized
);

939 
	`ASSERT
 (
a_seen
 == 0);

940 
	`ASSERT
 (
b_seen
 == 0);

941 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

942 
	`ASSERT
 (
q_value
 == 
NULL
);

943 
	`ASSERT
 (
non_options_count
 == 0);

944 
	`ASSERT
 (
unrecognized
 == 0);

945 
	`ASSERT
 (
optind
 == 2);

947 for (
start
 = 0; start <= 1; start++)

949 const char *
p_value
 = 
NULL
;

950 const char *
q_value
 = 
NULL
;

951 int 
non_options_count
 = 0;

952 const char *
non_options
[10];

953 int 
unrecognized
 = 0;

954 int 
argc
 = 0;

955 const char *
argv
[10];

956 
a_seen
 = 0;

957 
b_seen
 = 0;

959 
argv
[
argc
++] = "program";

960 
argv
[
argc
++] = "-p";

961 
argv
[
argc
++] = "foo";

962 
argv
[
argc
++] = "bar";

963 
argv
[
argc
] = 
NULL
;

964 
optind
 = 
start
;

965 
	`getopt_long_loop
 (
argc
, 
argv
, "p::q::", 
long_options_optional
,

966 &
p_value
, &
q_value
,

967 &
non_options_count
, 
non_options
, &
unrecognized
);

968 
	`ASSERT
 (
a_seen
 == 0);

969 
	`ASSERT
 (
b_seen
 == 0);

970 
	`ASSERT
 (
p_value
 == 
NULL
);

971 
	`ASSERT
 (
q_value
 == 
NULL
);

972 
	`ASSERT
 (
non_options_count
 == 0);

973 
	`ASSERT
 (
unrecognized
 == 0);

974 
	`ASSERT
 (
optind
 == 2);

976 for (
start
 = 0; start <= 1; start++)

978 const char *
p_value
 = 
NULL
;

979 const char *
q_value
 = 
NULL
;

980 int 
non_options_count
 = 0;

981 const char *
non_options
[10];

982 int 
unrecognized
 = 0;

983 int 
argc
 = 0;

984 const char *
argv
[10];

985 
a_seen
 = 0;

986 
b_seen
 = 0;

988 
argv
[
argc
++] = "program";

989 
argv
[
argc
++] = "-p";

990 
argv
[
argc
++] = "-a";

991 
argv
[
argc
++] = "bar";

992 
argv
[
argc
] = 
NULL
;

993 
optind
 = 
start
;

994 
	`getopt_long_loop
 (
argc
, 
argv
, "abp::q::", 
long_options_optional
,

995 &
p_value
, &
q_value
,

996 &
non_options_count
, 
non_options
, &
unrecognized
);

997 
	`ASSERT
 (
a_seen
 == 1);

998 
	`ASSERT
 (
b_seen
 == 0);

999 
	`ASSERT
 (
p_value
 == 
NULL
);

1000 
	`ASSERT
 (
q_value
 == 
NULL
);

1001 
	`ASSERT
 (
non_options_count
 == 0);

1002 
	`ASSERT
 (
unrecognized
 == 0);

1003 
	`ASSERT
 (
optind
 == 3);

1007 for (
start
 = 0; start <= 1; start++)

1009 const char *
p_value
 = 
NULL
;

1010 const char *
q_value
 = 
NULL
;

1011 int 
non_options_count
 = 0;

1012 const char *
non_options
[10];

1013 int 
unrecognized
 = 0;

1014 int 
argc
 = 0;

1015 const char *
argv
[10];

1016 
a_seen
 = 0;

1017 
b_seen
 = 0;

1019 
argv
[
argc
++] = "program";

1020 
argv
[
argc
++] = "--p=foo";

1021 
argv
[
argc
++] = "bar";

1022 
argv
[
argc
] = 
NULL
;

1023 
optind
 = 
start
;

1024 
	`getopt_long_loop
 (
argc
, 
argv
, "p::q::", 
long_options_optional
,

1025 &
p_value
, &
q_value
,

1026 &
non_options_count
, 
non_options
, &
unrecognized
);

1027 
	`ASSERT
 (
a_seen
 == 0);

1028 
	`ASSERT
 (
b_seen
 == 0);

1029 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

1030 
	`ASSERT
 (
q_value
 == 
NULL
);

1031 
	`ASSERT
 (
non_options_count
 == 0);

1032 
	`ASSERT
 (
unrecognized
 == 0);

1033 
	`ASSERT
 (
optind
 == 2);

1035 for (
start
 = 0; start <= 1; start++)

1037 const char *
p_value
 = 
NULL
;

1038 const char *
q_value
 = 
NULL
;

1039 int 
non_options_count
 = 0;

1040 const char *
non_options
[10];

1041 int 
unrecognized
 = 0;

1042 int 
argc
 = 0;

1043 const char *
argv
[10];

1044 
a_seen
 = 0;

1045 
b_seen
 = 0;

1047 
argv
[
argc
++] = "program";

1048 
argv
[
argc
++] = "--p";

1049 
argv
[
argc
++] = "foo";

1050 
argv
[
argc
++] = "bar";

1051 
argv
[
argc
] = 
NULL
;

1052 
optind
 = 
start
;

1053 
	`getopt_long_loop
 (
argc
, 
argv
, "p::q::", 
long_options_optional
,

1054 &
p_value
, &
q_value
,

1055 &
non_options_count
, 
non_options
, &
unrecognized
);

1056 
	`ASSERT
 (
a_seen
 == 0);

1057 
	`ASSERT
 (
b_seen
 == 0);

1058 
	`ASSERT
 (
p_value
 == 
NULL
);

1059 
	`ASSERT
 (
q_value
 == 
NULL
);

1060 
	`ASSERT
 (
non_options_count
 == 0);

1061 
	`ASSERT
 (
unrecognized
 == 0);

1062 
	`ASSERT
 (
optind
 == 2);

1064 for (
start
 = 0; start <= 1; start++)

1066 const char *
p_value
 = 
NULL
;

1067 const char *
q_value
 = 
NULL
;

1068 int 
non_options_count
 = 0;

1069 const char *
non_options
[10];

1070 int 
unrecognized
 = 0;

1071 int 
argc
 = 0;

1072 const char *
argv
[10];

1073 
a_seen
 = 0;

1074 
b_seen
 = 0;

1076 
argv
[
argc
++] = "program";

1077 
argv
[
argc
++] = "--p=";

1078 
argv
[
argc
++] = "foo";

1079 
argv
[
argc
++] = "bar";

1080 
argv
[
argc
] = 
NULL
;

1081 
optind
 = 
start
;

1082 
	`getopt_long_loop
 (
argc
, 
argv
, "p::q::", 
long_options_optional
,

1083 &
p_value
, &
q_value
,

1084 &
non_options_count
, 
non_options
, &
unrecognized
);

1085 
	`ASSERT
 (
a_seen
 == 0);

1086 
	`ASSERT
 (
b_seen
 == 0);

1087 
	`ASSERT
 (
p_value
 != 
NULL
 && *p_value == '\0');

1088 
	`ASSERT
 (
q_value
 == 
NULL
);

1089 
	`ASSERT
 (
non_options_count
 == 0);

1090 
	`ASSERT
 (
unrecognized
 == 0);

1091 
	`ASSERT
 (
optind
 == 2);

1093 for (
start
 = 0; start <= 1; start++)

1095 const char *
p_value
 = 
NULL
;

1096 const char *
q_value
 = 
NULL
;

1097 int 
non_options_count
 = 0;

1098 const char *
non_options
[10];

1099 int 
unrecognized
 = 0;

1100 int 
argc
 = 0;

1101 const char *
argv
[10];

1102 
a_seen
 = 0;

1103 
b_seen
 = 0;

1105 
argv
[
argc
++] = "program";

1106 
argv
[
argc
++] = "--p";

1107 
argv
[
argc
++] = "-a";

1108 
argv
[
argc
++] = "bar";

1109 
argv
[
argc
] = 
NULL
;

1110 
optind
 = 
start
;

1111 
	`getopt_long_loop
 (
argc
, 
argv
, "abp::q::", 
long_options_optional
,

1112 &
p_value
, &
q_value
,

1113 &
non_options_count
, 
non_options
, &
unrecognized
);

1114 
	`ASSERT
 (
a_seen
 == 1);

1115 
	`ASSERT
 (
b_seen
 == 0);

1116 
	`ASSERT
 (
p_value
 == 
NULL
);

1117 
	`ASSERT
 (
q_value
 == 
NULL
);

1118 
	`ASSERT
 (
non_options_count
 == 0);

1119 
	`ASSERT
 (
unrecognized
 == 0);

1120 
	`ASSERT
 (
optind
 == 3);

1124 for (
start
 = 0; start <= 1; start++)

1126 const char *
p_value
 = 
NULL
;

1127 const char *
q_value
 = 
NULL
;

1128 int 
non_options_count
 = 0;

1129 const char *
non_options
[10];

1130 int 
unrecognized
 = 0;

1131 int 
argc
 = 0;

1132 const char *
argv
[10];

1133 
a_seen
 = 0;

1134 
b_seen
 = 0;

1136 
argv
[
argc
++] = "program";

1137 
argv
[
argc
++] = "-Wp=foo";

1138 
argv
[
argc
++] = "bar";

1139 
argv
[
argc
] = 
NULL
;

1140 
optind
 = 
start
;

1141 
	`getopt_long_loop
 (
argc
, 
argv
, "p::q::W;", 
long_options_optional
,

1142 &
p_value
, &
q_value
,

1143 &
non_options_count
, 
non_options
, &
unrecognized
);

1144 
	`ASSERT
 (
a_seen
 == 0);

1145 
	`ASSERT
 (
b_seen
 == 0);

1146 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

1147 
	`ASSERT
 (
q_value
 == 
NULL
);

1148 
	`ASSERT
 (
non_options_count
 == 0);

1149 
	`ASSERT
 (
unrecognized
 == 0);

1150 
	`ASSERT
 (
optind
 == 2);

1152 for (
start
 = 0; start <= 1; start++)

1154 const char *
p_value
 = 
NULL
;

1155 const char *
q_value
 = 
NULL
;

1156 int 
non_options_count
 = 0;

1157 const char *
non_options
[10];

1158 int 
unrecognized
 = 0;

1159 int 
argc
 = 0;

1160 const char *
argv
[10];

1161 
a_seen
 = 0;

1162 
b_seen
 = 0;

1164 
argv
[
argc
++] = "program";

1165 
argv
[
argc
++] = "-Wp";

1166 
argv
[
argc
++] = "foo";

1167 
argv
[
argc
++] = "bar";

1168 
argv
[
argc
] = 
NULL
;

1169 
optind
 = 
start
;

1170 
	`getopt_long_loop
 (
argc
, 
argv
, "p::q::W;", 
long_options_optional
,

1171 &
p_value
, &
q_value
,

1172 &
non_options_count
, 
non_options
, &
unrecognized
);

1173 
	`ASSERT
 (
a_seen
 == 0);

1174 
	`ASSERT
 (
b_seen
 == 0);

1175 
	`ASSERT
 (
p_value
 == 
NULL
);

1176 
	`ASSERT
 (
q_value
 == 
NULL
);

1177 
	`ASSERT
 (
non_options_count
 == 0);

1178 
	`ASSERT
 (
unrecognized
 == 0);

1179 
	`ASSERT
 (
optind
 == 2);

1181 for (
start
 = 0; start <= 1; start++)

1183 const char *
p_value
 = 
NULL
;

1184 const char *
q_value
 = 
NULL
;

1185 int 
non_options_count
 = 0;

1186 const char *
non_options
[10];

1187 int 
unrecognized
 = 0;

1188 int 
argc
 = 0;

1189 const char *
argv
[10];

1190 
a_seen
 = 0;

1191 
b_seen
 = 0;

1193 
argv
[
argc
++] = "program";

1194 
argv
[
argc
++] = "-Wp=";

1195 
argv
[
argc
++] = "foo";

1196 
argv
[
argc
++] = "bar";

1197 
argv
[
argc
] = 
NULL
;

1198 
optind
 = 
start
;

1199 
	`getopt_long_loop
 (
argc
, 
argv
, "W;p::q::", 
long_options_optional
,

1200 &
p_value
, &
q_value
,

1201 &
non_options_count
, 
non_options
, &
unrecognized
);

1202 
	`ASSERT
 (
a_seen
 == 0);

1203 
	`ASSERT
 (
b_seen
 == 0);

1204 
	`ASSERT
 (
p_value
 != 
NULL
 && *p_value == '\0');

1205 
	`ASSERT
 (
q_value
 == 
NULL
);

1206 
	`ASSERT
 (
non_options_count
 == 0);

1207 
	`ASSERT
 (
unrecognized
 == 0);

1208 
	`ASSERT
 (
optind
 == 2);

1210 for (
start
 = 0; start <= 1; start++)

1212 const char *
p_value
 = 
NULL
;

1213 const char *
q_value
 = 
NULL
;

1214 int 
non_options_count
 = 0;

1215 const char *
non_options
[10];

1216 int 
unrecognized
 = 0;

1217 int 
argc
 = 0;

1218 const char *
argv
[10];

1219 
a_seen
 = 0;

1220 
b_seen
 = 0;

1222 
argv
[
argc
++] = "program";

1223 
argv
[
argc
++] = "-W";

1224 
argv
[
argc
++] = "p=";

1225 
argv
[
argc
++] = "foo";

1226 
argv
[
argc
++] = "bar";

1227 
argv
[
argc
] = 
NULL
;

1228 
optind
 = 
start
;

1229 
	`getopt_long_loop
 (
argc
, 
argv
, "W;p::q::", 
long_options_optional
,

1230 &
p_value
, &
q_value
,

1231 &
non_options_count
, 
non_options
, &
unrecognized
);

1232 
	`ASSERT
 (
a_seen
 == 0);

1233 
	`ASSERT
 (
b_seen
 == 0);

1234 
	`ASSERT
 (
p_value
 != 
NULL
 && *p_value == '\0');

1235 
	`ASSERT
 (
q_value
 == 
NULL
);

1236 
	`ASSERT
 (
non_options_count
 == 0);

1237 
	`ASSERT
 (
unrecognized
 == 0);

1238 
	`ASSERT
 (
optind
 == 3);

1240 for (
start
 = 0; start <= 1; start++)

1242 const char *
p_value
 = 
NULL
;

1243 const char *
q_value
 = 
NULL
;

1244 int 
non_options_count
 = 0;

1245 const char *
non_options
[10];

1246 int 
unrecognized
 = 0;

1247 int 
argc
 = 0;

1248 const char *
argv
[10];

1249 
a_seen
 = 0;

1250 
b_seen
 = 0;

1252 
argv
[
argc
++] = "program";

1253 
argv
[
argc
++] = "-W";

1254 
argv
[
argc
++] = "p";

1255 
argv
[
argc
++] = "-a";

1256 
argv
[
argc
++] = "bar";

1257 
argv
[
argc
] = 
NULL
;

1258 
optind
 = 
start
;

1259 
	`getopt_long_loop
 (
argc
, 
argv
, "W;abp::q::", 
long_options_optional
,

1260 &
p_value
, &
q_value
,

1261 &
non_options_count
, 
non_options
, &
unrecognized
);

1262 
	`ASSERT
 (
a_seen
 == 1);

1263 
	`ASSERT
 (
b_seen
 == 0);

1265 
	`ASSERT
 (
q_value
 == 
NULL
);

1266 
	`ASSERT
 (
non_options_count
 == 0);

1267 
	`ASSERT
 (
unrecognized
 == 0);

1268 
	`ASSERT
 (
optind
 == 4);

1272 for (
start
 = 0; start <= 1; start++)

1274 const char *
p_value
 = 
NULL
;

1275 const char *
q_value
 = 
NULL
;

1276 int 
non_options_count
 = 0;

1277 const char *
non_options
[10];

1278 int 
unrecognized
 = 0;

1279 int 
argc
 = 0;

1280 const char *
argv
[10];

1281 
a_seen
 = 0;

1282 
b_seen
 = 0;

1284 
argv
[
argc
++] = "program";

1285 
argv
[
argc
++] = "-p";

1286 
argv
[
argc
++] = "foo";

1287 
argv
[
argc
++] = "-x";

1288 
argv
[
argc
++] = "-a";

1289 
argv
[
argc
++] = "bar";

1290 
argv
[
argc
] = 
NULL
;

1291 
optind
 = 
start
;

1292 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

1293 &
p_value
, &
q_value
,

1294 &
non_options_count
, 
non_options
, &
unrecognized
);

1295 
	`ASSERT
 (
a_seen
 == 1);

1296 
	`ASSERT
 (
b_seen
 == 0);

1297 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

1298 
	`ASSERT
 (
q_value
 == 
NULL
);

1299 
	`ASSERT
 (
non_options_count
 == 0);

1300 
	`ASSERT
 (
unrecognized
 == 'x');

1301 
	`ASSERT
 (
optind
 == 5);

1303 for (
start
 = 0; start <= 1; start++)

1305 const char *
p_value
 = 
NULL
;

1306 const char *
q_value
 = 
NULL
;

1307 int 
non_options_count
 = 0;

1308 const char *
non_options
[10];

1309 int 
unrecognized
 = 0;

1310 int 
argc
 = 0;

1311 const char *
argv
[10];

1312 
a_seen
 = 0;

1313 
b_seen
 = 0;

1315 
argv
[
argc
++] = "program";

1316 
argv
[
argc
++] = "-p";

1317 
argv
[
argc
++] = "foo";

1318 
argv
[
argc
++] = "-:";

1319 
argv
[
argc
++] = "-a";

1320 
argv
[
argc
++] = "bar";

1321 
argv
[
argc
] = 
NULL
;

1322 
optind
 = 
start
;

1323 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

1324 &
p_value
, &
q_value
,

1325 &
non_options_count
, 
non_options
, &
unrecognized
);

1326 
	`ASSERT
 (
a_seen
 == 1);

1327 
	`ASSERT
 (
b_seen
 == 0);

1328 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

1329 
	`ASSERT
 (
q_value
 == 
NULL
);

1330 
	`ASSERT
 (
non_options_count
 == 0);

1331 
	`ASSERT
 (
unrecognized
 == ':');

1332 
	`ASSERT
 (
optind
 == 5);

1336 for (
start
 = 0; start <= 1; start++)

1338 const char *
p_value
 = 
NULL
;

1339 const char *
q_value
 = 
NULL
;

1340 int 
non_options_count
 = 0;

1341 const char *
non_options
[10];

1342 int 
unrecognized
 = 0;

1343 int 
argc
 = 0;

1344 const char *
argv
[10];

1345 
a_seen
 = 0;

1346 
b_seen
 = 0;

1348 
argv
[
argc
++] = "program";

1349 
argv
[
argc
++] = "-p";

1350 
argv
[
argc
++] = "foo";

1351 
argv
[
argc
++] = "--a=";

1352 
argv
[
argc
++] = "bar";

1353 
argv
[
argc
] = 
NULL
;

1354 
optind
 = 
start
;

1355 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

1356 &
p_value
, &
q_value
,

1357 &
non_options_count
, 
non_options
, &
unrecognized
);

1358 
	`ASSERT
 (
a_seen
 == 0);

1359 
	`ASSERT
 (
b_seen
 == 0);

1360 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

1361 
	`ASSERT
 (
q_value
 == 
NULL
);

1362 
	`ASSERT
 (
non_options_count
 == 0);

1363 
	`ASSERT
 (
unrecognized
 == 'a');

1364 
	`ASSERT
 (
optind
 == 4);

1366 for (
start
 = 0; start <= 1; start++)

1368 const char *
p_value
 = 
NULL
;

1369 const char *
q_value
 = 
NULL
;

1370 int 
non_options_count
 = 0;

1371 const char *
non_options
[10];

1372 int 
unrecognized
 = 0;

1373 int 
argc
 = 0;

1374 const char *
argv
[10];

1375 
a_seen
 = 0;

1376 
b_seen
 = 0;

1378 
argv
[
argc
++] = "program";

1379 
argv
[
argc
++] = "-p";

1380 
argv
[
argc
++] = "foo";

1381 
argv
[
argc
++] = "--b=";

1382 
argv
[
argc
++] = "bar";

1383 
argv
[
argc
] = 
NULL
;

1384 
optind
 = 
start
;

1385 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

1386 &
p_value
, &
q_value
,

1387 &
non_options_count
, 
non_options
, &
unrecognized
);

1388 
	`ASSERT
 (
a_seen
 == 0);

1389 
	`ASSERT
 (
b_seen
 == 0);

1390 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "foo") == 0);

1391 
	`ASSERT
 (
q_value
 == 
NULL
);

1392 
	`ASSERT
 (
non_options_count
 == 0);

1395 
	`ASSERT
 (
unrecognized
 == 1 || unrecognized == 0);

1396 
	`ASSERT
 (
optind
 == 4);

1400 for (
start
 = 0; start <= 1; start++)

1402 const char *
p_value
 = 
NULL
;

1403 const char *
q_value
 = 
NULL
;

1404 int 
non_options_count
 = 0;

1405 const char *
non_options
[10];

1406 int 
unrecognized
 = 0;

1407 int 
argc
 = 0;

1408 const char *
argv
[10];

1409 
a_seen
 = 0;

1410 
b_seen
 = 0;

1412 
argv
[
argc
++] = "program";

1413 
argv
[
argc
++] = "donald";

1414 
argv
[
argc
++] = "-p";

1415 
argv
[
argc
++] = "billy";

1416 
argv
[
argc
++] = "duck";

1417 
argv
[
argc
++] = "-a";

1418 
argv
[
argc
++] = "bar";

1419 
argv
[
argc
] = 
NULL
;

1420 
optind
 = 
start
;

1421 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

1422 &
p_value
, &
q_value
,

1423 &
non_options_count
, 
non_options
, &
unrecognized
);

1424 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1425 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

1426 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

1427 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

1428 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "donald") == 0);

1429 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "duck") == 0);

1430 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1431 
	`ASSERT
 (
argv
[7] == 
NULL
);

1432 
	`ASSERT
 (
a_seen
 == 1);

1433 
	`ASSERT
 (
b_seen
 == 0);

1434 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1435 
	`ASSERT
 (
q_value
 == 
NULL
);

1436 
	`ASSERT
 (
non_options_count
 == 0);

1437 
	`ASSERT
 (
unrecognized
 == 0);

1438 
	`ASSERT
 (
optind
 == 4);

1442 for (
start
 = 0; start <= 1; start++)

1444 const char *
p_value
 = 
NULL
;

1445 const char *
q_value
 = 
NULL
;

1446 int 
non_options_count
 = 0;

1447 const char *
non_options
[10];

1448 int 
unrecognized
 = 0;

1449 int 
argc
 = 0;

1450 const char *
argv
[20];

1451 
a_seen
 = 0;

1452 
b_seen
 = 0;

1454 
argv
[
argc
++] = "program";

1455 
argv
[
argc
++] = "donald";

1456 
argv
[
argc
++] = "-p";

1457 
argv
[
argc
++] = "billy";

1458 
argv
[
argc
++] = "duck";

1459 
argv
[
argc
++] = "-a";

1460 
argv
[
argc
++] = "--";

1461 
argv
[
argc
++] = "-b";

1462 
argv
[
argc
++] = "foo";

1463 
argv
[
argc
++] = "-q";

1464 
argv
[
argc
++] = "johnny";

1465 
argv
[
argc
++] = "bar";

1466 
argv
[
argc
] = 
NULL
;

1467 
optind
 = 
start
;

1468 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

1469 &
p_value
, &
q_value
,

1470 &
non_options_count
, 
non_options
, &
unrecognized
);

1471 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1472 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

1473 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

1474 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

1475 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "--") == 0);

1476 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "donald") == 0);

1477 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "duck") == 0);

1478 
	`ASSERT
 (
	`strcmp
 (
argv
[7], "-b") == 0);

1479 
	`ASSERT
 (
	`strcmp
 (
argv
[8], "foo") == 0);

1480 
	`ASSERT
 (
	`strcmp
 (
argv
[9], "-q") == 0);

1481 
	`ASSERT
 (
	`strcmp
 (
argv
[10], "johnny") == 0);

1482 
	`ASSERT
 (
	`strcmp
 (
argv
[11], "bar") == 0);

1483 
	`ASSERT
 (
argv
[12] == 
NULL
);

1484 
	`ASSERT
 (
a_seen
 == 1);

1485 
	`ASSERT
 (
b_seen
 == 0);

1486 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1487 
	`ASSERT
 (
q_value
 == 
NULL
);

1488 
	`ASSERT
 (
non_options_count
 == 0);

1489 
	`ASSERT
 (
unrecognized
 == 0);

1490 
	`ASSERT
 (
optind
 == 5);

1494 for (
start
 = 0; start <= 1; start++)

1496 const char *
p_value
 = 
NULL
;

1497 const char *
q_value
 = 
NULL
;

1498 int 
non_options_count
 = 0;

1499 const char *
non_options
[10];

1500 int 
unrecognized
 = 0;

1501 int 
argc
 = 0;

1502 const char *
argv
[10];

1503 
a_seen
 = 0;

1504 
b_seen
 = 0;

1506 
argv
[
argc
++] = "program";

1507 
argv
[
argc
++] = "donald";

1508 
argv
[
argc
++] = "-p";

1509 
argv
[
argc
++] = "billy";

1510 
argv
[
argc
++] = "duck";

1511 
argv
[
argc
++] = "-a";

1512 
argv
[
argc
++] = "bar";

1513 
argv
[
argc
] = 
NULL
;

1514 
optind
 = 
start
;

1515 
	`getopt_long_loop
 (
argc
, 
argv
, "-abp:q:", 
long_options_required
,

1516 &
p_value
, &
q_value
,

1517 &
non_options_count
, 
non_options
, &
unrecognized
);

1518 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1519 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1520 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1521 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1522 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1523 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1524 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1525 
	`ASSERT
 (
argv
[7] == 
NULL
);

1526 
	`ASSERT
 (
a_seen
 == 1);

1527 
	`ASSERT
 (
b_seen
 == 0);

1528 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1529 
	`ASSERT
 (
q_value
 == 
NULL
);

1530 
	`ASSERT
 (
non_options_count
 == 3);

1531 
	`ASSERT
 (
	`strcmp
 (
non_options
[0], "donald") == 0);

1532 
	`ASSERT
 (
	`strcmp
 (
non_options
[1], "duck") == 0);

1533 
	`ASSERT
 (
	`strcmp
 (
non_options
[2], "bar") == 0);

1534 
	`ASSERT
 (
unrecognized
 == 0);

1535 
	`ASSERT
 (
optind
 == 7);

1539 for (
start
 = 0; start <= 1; start++)

1541 const char *
p_value
 = 
NULL
;

1542 const char *
q_value
 = 
NULL
;

1543 int 
non_options_count
 = 0;

1544 const char *
non_options
[10];

1545 int 
unrecognized
 = 0;

1546 int 
argc
 = 0;

1547 const char *
argv
[20];

1548 
a_seen
 = 0;

1549 
b_seen
 = 0;

1551 
argv
[
argc
++] = "program";

1552 
argv
[
argc
++] = "donald";

1553 
argv
[
argc
++] = "-p";

1554 
argv
[
argc
++] = "billy";

1555 
argv
[
argc
++] = "duck";

1556 
argv
[
argc
++] = "-a";

1557 
argv
[
argc
++] = "--";

1558 
argv
[
argc
++] = "-b";

1559 
argv
[
argc
++] = "foo";

1560 
argv
[
argc
++] = "-q";

1561 
argv
[
argc
++] = "johnny";

1562 
argv
[
argc
++] = "bar";

1563 
argv
[
argc
] = 
NULL
;

1564 
optind
 = 
start
;

1565 
	`getopt_long_loop
 (
argc
, 
argv
, "-abp:q:", 
long_options_required
,

1566 &
p_value
, &
q_value
,

1567 &
non_options_count
, 
non_options
, &
unrecognized
);

1568 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1569 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1570 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1571 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1572 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1573 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1574 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "--") == 0);

1575 
	`ASSERT
 (
	`strcmp
 (
argv
[7], "-b") == 0);

1576 
	`ASSERT
 (
	`strcmp
 (
argv
[8], "foo") == 0);

1577 
	`ASSERT
 (
	`strcmp
 (
argv
[9], "-q") == 0);

1578 
	`ASSERT
 (
	`strcmp
 (
argv
[10], "johnny") == 0);

1579 
	`ASSERT
 (
	`strcmp
 (
argv
[11], "bar") == 0);

1580 
	`ASSERT
 (
argv
[12] == 
NULL
);

1581 
	`ASSERT
 (
a_seen
 == 1);

1582 
	`ASSERT
 (
b_seen
 == 0);

1583 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1584 
	`ASSERT
 (
q_value
 == 
NULL
);

1585 if (
non_options_count
 == 2)

1588 
	`ASSERT
 (
non_options_count
 == 2);

1589 
	`ASSERT
 (
	`strcmp
 (
non_options
[0], "donald") == 0);

1590 
	`ASSERT
 (
	`strcmp
 (
non_options
[1], "duck") == 0);

1591 
	`ASSERT
 (
unrecognized
 == 0);

1592 
	`ASSERT
 (
optind
 == 7);

1597 
	`ASSERT
 (
non_options_count
 == 7);

1598 
	`ASSERT
 (
	`strcmp
 (
non_options
[0], "donald") == 0);

1599 
	`ASSERT
 (
	`strcmp
 (
non_options
[1], "duck") == 0);

1600 
	`ASSERT
 (
	`strcmp
 (
non_options
[2], "-b") == 0);

1601 
	`ASSERT
 (
	`strcmp
 (
non_options
[3], "foo") == 0);

1602 
	`ASSERT
 (
	`strcmp
 (
non_options
[4], "-q") == 0);

1603 
	`ASSERT
 (
	`strcmp
 (
non_options
[5], "johnny") == 0);

1604 
	`ASSERT
 (
	`strcmp
 (
non_options
[6], "bar") == 0);

1605 
	`ASSERT
 (
unrecognized
 == 0);

1606 
	`ASSERT
 (
optind
 == 12);

1611 for (
start
 = 0; start <= 1; start++)

1613 const char *
p_value
 = 
NULL
;

1614 const char *
q_value
 = 
NULL
;

1615 int 
non_options_count
 = 0;

1616 const char *
non_options
[10];

1617 int 
unrecognized
 = 0;

1618 int 
argc
 = 0;

1619 const char *
argv
[10];

1620 
a_seen
 = 0;

1621 
b_seen
 = 0;

1623 
argv
[
argc
++] = "program";

1624 
argv
[
argc
++] = "donald";

1625 
argv
[
argc
++] = "-p";

1626 
argv
[
argc
++] = "billy";

1627 
argv
[
argc
++] = "duck";

1628 
argv
[
argc
++] = "-a";

1629 
argv
[
argc
++] = "bar";

1630 
argv
[
argc
] = 
NULL
;

1631 
optind
 = 
start
;

1632 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:-", 
long_options_required
,

1633 &
p_value
, &
q_value
,

1634 &
non_options_count
, 
non_options
, &
unrecognized
);

1635 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1636 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

1637 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

1638 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

1639 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "donald") == 0);

1640 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "duck") == 0);

1641 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1642 
	`ASSERT
 (
argv
[7] == 
NULL
);

1643 
	`ASSERT
 (
a_seen
 == 1);

1644 
	`ASSERT
 (
b_seen
 == 0);

1645 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1646 
	`ASSERT
 (
q_value
 == 
NULL
);

1647 
	`ASSERT
 (
non_options_count
 == 0);

1648 
	`ASSERT
 (
unrecognized
 == 0);

1649 
	`ASSERT
 (
optind
 == 4);

1654 for (
start
 = 0; start <= 1; start++)

1656 const char *
p_value
 = 
NULL
;

1657 const char *
q_value
 = 
NULL
;

1658 int 
non_options_count
 = 0;

1659 const char *
non_options
[10];

1660 int 
unrecognized
 = 0;

1661 int 
argc
 = 0;

1662 const char *
argv
[10];

1663 
a_seen
 = 0;

1664 
b_seen
 = 0;

1666 
argv
[
argc
++] = "program";

1667 
argv
[
argc
++] = "donald";

1668 
argv
[
argc
++] = "-p";

1669 
argv
[
argc
++] = "billy";

1670 
argv
[
argc
++] = "duck";

1671 
argv
[
argc
++] = "-a";

1672 
argv
[
argc
++] = "bar";

1673 
argv
[
argc
] = 
NULL
;

1674 
optind
 = 
start
;

1675 
	`getopt_long_loop
 (
argc
, 
argv
, "+abp:q:", 
long_options_required
,

1676 &
p_value
, &
q_value
,

1677 &
non_options_count
, 
non_options
, &
unrecognized
);

1678 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1679 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1680 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1681 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1682 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1683 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1684 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1685 
	`ASSERT
 (
argv
[7] == 
NULL
);

1686 
	`ASSERT
 (
a_seen
 == 0);

1687 
	`ASSERT
 (
b_seen
 == 0);

1688 
	`ASSERT
 (
p_value
 == 
NULL
);

1689 
	`ASSERT
 (
q_value
 == 
NULL
);

1690 
	`ASSERT
 (
non_options_count
 == 0);

1691 
	`ASSERT
 (
unrecognized
 == 0);

1692 
	`ASSERT
 (
optind
 == 1);

1694 for (
start
 = 0; start <= 1; start++)

1696 const char *
p_value
 = 
NULL
;

1697 const char *
q_value
 = 
NULL
;

1698 int 
non_options_count
 = 0;

1699 const char *
non_options
[10];

1700 int 
unrecognized
 = 0;

1701 int 
argc
 = 0;

1702 const char *
argv
[10];

1703 
a_seen
 = 0;

1704 
b_seen
 = 0;

1706 
argv
[
argc
++] = "program";

1707 
argv
[
argc
++] = "-+";

1708 
argv
[
argc
] = 
NULL
;

1709 
optind
 = 
start
;

1710 
	`getopt_long_loop
 (
argc
, 
argv
, "+abp:q:", 
long_options_required
,

1711 &
p_value
, &
q_value
,

1712 &
non_options_count
, 
non_options
, &
unrecognized
);

1713 
	`ASSERT
 (
a_seen
 == 0);

1714 
	`ASSERT
 (
b_seen
 == 0);

1715 
	`ASSERT
 (
p_value
 == 
NULL
);

1716 
	`ASSERT
 (
q_value
 == 
NULL
);

1717 
	`ASSERT
 (
non_options_count
 == 0);

1718 
	`ASSERT
 (
unrecognized
 == '+');

1719 
	`ASSERT
 (
optind
 == 2);

1723 for (
start
 = 0; start <= 1; start++)

1725 const char *
p_value
 = 
NULL
;

1726 const char *
q_value
 = 
NULL
;

1727 int 
non_options_count
 = 0;

1728 const char *
non_options
[10];

1729 int 
unrecognized
 = 0;

1730 int 
argc
 = 0;

1731 const char *
argv
[20];

1732 
a_seen
 = 0;

1733 
b_seen
 = 0;

1735 
argv
[
argc
++] = "program";

1736 
argv
[
argc
++] = "donald";

1737 
argv
[
argc
++] = "-p";

1738 
argv
[
argc
++] = "billy";

1739 
argv
[
argc
++] = "duck";

1740 
argv
[
argc
++] = "-a";

1741 
argv
[
argc
++] = "--";

1742 
argv
[
argc
++] = "-b";

1743 
argv
[
argc
++] = "foo";

1744 
argv
[
argc
++] = "-q";

1745 
argv
[
argc
++] = "johnny";

1746 
argv
[
argc
++] = "bar";

1747 
argv
[
argc
] = 
NULL
;

1748 
optind
 = 
start
;

1749 
	`getopt_long_loop
 (
argc
, 
argv
, "+abp:q:", 
long_options_required
,

1750 &
p_value
, &
q_value
,

1751 &
non_options_count
, 
non_options
, &
unrecognized
);

1752 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1753 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1754 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1755 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1756 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1757 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1758 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "--") == 0);

1759 
	`ASSERT
 (
	`strcmp
 (
argv
[7], "-b") == 0);

1760 
	`ASSERT
 (
	`strcmp
 (
argv
[8], "foo") == 0);

1761 
	`ASSERT
 (
	`strcmp
 (
argv
[9], "-q") == 0);

1762 
	`ASSERT
 (
	`strcmp
 (
argv
[10], "johnny") == 0);

1763 
	`ASSERT
 (
	`strcmp
 (
argv
[11], "bar") == 0);

1764 
	`ASSERT
 (
argv
[12] == 
NULL
);

1765 
	`ASSERT
 (
a_seen
 == 0);

1766 
	`ASSERT
 (
b_seen
 == 0);

1767 
	`ASSERT
 (
p_value
 == 
NULL
);

1768 
	`ASSERT
 (
q_value
 == 
NULL
);

1769 
	`ASSERT
 (
non_options_count
 == 0);

1770 
	`ASSERT
 (
unrecognized
 == 0);

1771 
	`ASSERT
 (
optind
 == 1);

1775 for (
start
 = 0; start <= 1; start++)

1777 const char *
p_value
 = 
NULL
;

1778 const char *
q_value
 = 
NULL
;

1779 int 
non_options_count
 = 0;

1780 const char *
non_options
[10];

1781 int 
unrecognized
 = 0;

1782 int 
argc
 = 0;

1783 const char *
argv
[10];

1784 
a_seen
 = 0;

1785 
b_seen
 = 0;

1787 
argv
[
argc
++] = "program";

1788 
argv
[
argc
++] = "donald";

1789 
argv
[
argc
++] = "-p";

1790 
argv
[
argc
++] = "billy";

1791 
argv
[
argc
++] = "duck";

1792 
argv
[
argc
++] = "-a";

1793 
argv
[
argc
++] = "bar";

1794 
argv
[
argc
] = 
NULL
;

1795 
optind
 = 
start
;

1796 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:+", 
long_options_required
,

1797 &
p_value
, &
q_value
,

1798 &
non_options_count
, 
non_options
, &
unrecognized
);

1799 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1800 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "-p") == 0);

1801 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "billy") == 0);

1802 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "-a") == 0);

1803 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "donald") == 0);

1804 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "duck") == 0);

1805 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1806 
	`ASSERT
 (
argv
[7] == 
NULL
);

1807 
	`ASSERT
 (
a_seen
 == 1);

1808 
	`ASSERT
 (
b_seen
 == 0);

1809 
	`ASSERT
 (
p_value
 != 
NULL
 && 
	`strcmp
 (p_value, "billy") == 0);

1810 
	`ASSERT
 (
q_value
 == 
NULL
);

1811 
	`ASSERT
 (
non_options_count
 == 0);

1812 
	`ASSERT
 (
unrecognized
 == 0);

1813 
	`ASSERT
 (
optind
 == 4);

1815 
	}
}

1822 
	$test_getopt_long_posix
 (void)

1824 int 
start
;

1827 for (
start
 = 0; start <= 1; start++)

1829 const char *
p_value
 = 
NULL
;

1830 const char *
q_value
 = 
NULL
;

1831 int 
non_options_count
 = 0;

1832 const char *
non_options
[10];

1833 int 
unrecognized
 = 0;

1834 int 
argc
 = 0;

1835 const char *
argv
[10];

1836 
a_seen
 = 0;

1837 
b_seen
 = 0;

1839 
argv
[
argc
++] = "program";

1840 
argv
[
argc
++] = "donald";

1841 
argv
[
argc
++] = "-p";

1842 
argv
[
argc
++] = "billy";

1843 
argv
[
argc
++] = "duck";

1844 
argv
[
argc
++] = "-a";

1845 
argv
[
argc
++] = "bar";

1846 
argv
[
argc
] = 
NULL
;

1847 
optind
 = 
start
;

1848 
	`getopt_long_loop
 (
argc
, 
argv
, "abp:q:", 
long_options_required
,

1849 &
p_value
, &
q_value
,

1850 &
non_options_count
, 
non_options
, &
unrecognized
);

1851 
	`ASSERT
 (
	`strcmp
 (
argv
[0], "program") == 0);

1852 
	`ASSERT
 (
	`strcmp
 (
argv
[1], "donald") == 0);

1853 
	`ASSERT
 (
	`strcmp
 (
argv
[2], "-p") == 0);

1854 
	`ASSERT
 (
	`strcmp
 (
argv
[3], "billy") == 0);

1855 
	`ASSERT
 (
	`strcmp
 (
argv
[4], "duck") == 0);

1856 
	`ASSERT
 (
	`strcmp
 (
argv
[5], "-a") == 0);

1857 
	`ASSERT
 (
	`strcmp
 (
argv
[6], "bar") == 0);

1858 
	`ASSERT
 (
argv
[7] == 
NULL
);

1859 
	`ASSERT
 (
a_seen
 == 0);

1860 
	`ASSERT
 (
b_seen
 == 0);

1861 
	`ASSERT
 (
p_value
 == 
NULL
);

1862 
	`ASSERT
 (
q_value
 == 
NULL
);

1863 
	`ASSERT
 (
non_options_count
 == 0);

1864 
	`ASSERT
 (
unrecognized
 == 0);

1865 
	`ASSERT
 (
optind
 == 1);

1869 for (
start
 = 0; start <= 1; start++)

1871 const char *
p_value
 = 
NULL
;

1872 const char *
q_value
 = 
NULL
;

1873 int 
non_options_count
 = 0;

1874 const char *
non_options
[10];

1875 int 
unrecognized
 = 0;

1876 int 
argc
 = 0;

1877 const char *
argv
[10];

1878 
a_seen
 = 0;

1879 
b_seen
 = 0;

1881 
argv
[
argc
++] = "program";

1882 
argv
[
argc
++] = "-p";

1883 
argv
[
argc
++] = "billy";

1884 
argv
[
argc
] = 
NULL
;

1885 
optind
 = 
start
;

1886 
	`getopt_long_loop
 (
argc
, 
argv
, "p::", 
long_options_required
,

1887 &
p_value
, &
q_value
,

1888 &
non_options_count
, 
non_options
, &
unrecognized
);

1889 
	`ASSERT
 (
a_seen
 == 0);

1890 
	`ASSERT
 (
b_seen
 == 0);

1891 
	`ASSERT
 (
p_value
 == 
NULL
);

1892 
	`ASSERT
 (
q_value
 == 
NULL
);

1893 
	`ASSERT
 (
non_options_count
 == 0);

1894 
	`ASSERT
 (
unrecognized
 == 0);

1895 
	`ASSERT
 (
optind
 == 2);

1899 for (
start
 = 0; start <= 1; start++)

1901 const char *
p_value
 = 
NULL
;

1902 const char *
q_value
 = 
NULL
;

1903 int 
non_options_count
 = 0;

1904 const char *
non_options
[10];

1905 int 
unrecognized
 = 0;

1906 int 
argc
 = 0;

1907 const char *
argv
[10];

1908 
a_seen
 = 0;

1909 
b_seen
 = 0;

1911 
argv
[
argc
++] = "program";

1912 
argv
[
argc
++] = "-a";

1913 
argv
[
argc
++] = "billy";

1914 
argv
[
argc
++] = "-b";

1915 
argv
[
argc
] = 
NULL
;

1916 
optind
 = 
start
;

1917 
	`getopt_long_loop
 (
argc
, 
argv
, "-ab", 
long_options_required
,

1918 &
p_value
, &
q_value
,

1919 &
non_options_count
, 
non_options
, &
unrecognized
);

1920 
	`ASSERT
 (
a_seen
 == 1);

1921 
	`ASSERT
 (
b_seen
 == 1);

1922 
	`ASSERT
 (
p_value
 == 
NULL
);

1923 
	`ASSERT
 (
q_value
 == 
NULL
);

1924 
	`ASSERT
 (
non_options_count
 == 1);

1925 
	`ASSERT
 (
	`strcmp
 (
non_options
[0], "billy") == 0);

1926 
	`ASSERT
 (
unrecognized
 == 0);

1927 
	`ASSERT
 (
optind
 == 4);

1929 
	}
}

1935 
	$do_getopt_long_only
 (int 
argc
, const char **
argv
, const char *
shortopts
,

1936 const struct 
option
 *
longopts
, int *
longind
)

1938 return 
	`getopt_long_only
 (
argc
, (char **) 
argv
, 
shortopts
, 
longopts
, 
longind
);

1939 
	}
}

1942 
	$test_getopt_long_only
 (void)

1946 int 
argc
 = 0;

1947 const char *
argv
[10];

1948 int 
option_index
;

1949 int 
c
;

1951 
argv
[
argc
++] = "program";

1952 
argv
[
argc
++] = "-x";

1953 
argv
[
argc
] = 
NULL
;

1954 
optind
 = 1;

1955 
opterr
 = 0;

1956 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "ab", 
long_options_required
,

1957 &
option_index
);

1958 
	`ASSERT
 (
c
 == '?');

1959 
	`ASSERT
 (
optopt
 == 0);

1962 int 
argc
 = 0;

1963 const char *
argv
[10];

1964 int 
option_index
;

1965 int 
c
;

1967 
argv
[
argc
++] = "program";

1968 
argv
[
argc
++] = "-x";

1969 
argv
[
argc
] = 
NULL
;

1970 
optind
 = 1;

1971 
opterr
 = 0;

1972 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx", 
long_options_required
,

1973 &
option_index
);

1974 
	`ASSERT
 (
c
 == 'x');

1975 
	`ASSERT
 (
optopt
 == 0);

1978 int 
argc
 = 0;

1979 const char *
argv
[10];

1980 int 
option_index
;

1981 int 
c
;

1983 
argv
[
argc
++] = "program";

1984 
argv
[
argc
++] = "--x";

1985 
argv
[
argc
] = 
NULL
;

1986 
optind
 = 1;

1987 
opterr
 = 0;

1988 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx", 
long_options_required
,

1989 &
option_index
);

1990 
	`ASSERT
 (
c
 == '?');

1991 
	`ASSERT
 (
optopt
 == 0);

1994 int 
argc
 = 0;

1995 const char *
argv
[10];

1996 int 
option_index
;

1997 int 
c
;

1999 
argv
[
argc
++] = "program";

2000 
argv
[
argc
++] = "-b";

2001 
argv
[
argc
] = 
NULL
;

2002 
optind
 = 1;

2003 
opterr
 = 0;

2004 
b_seen
 = 0;

2005 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx", 
long_options_required
,

2006 &
option_index
);

2007 
	`ASSERT
 (
c
 == 'b');

2008 
	`ASSERT
 (
b_seen
 == 0);

2011 int 
argc
 = 0;

2012 const char *
argv
[10];

2013 int 
option_index
;

2014 int 
c
;

2016 
argv
[
argc
++] = "program";

2017 
argv
[
argc
++] = "--b";

2018 
argv
[
argc
] = 
NULL
;

2019 
optind
 = 1;

2020 
opterr
 = 0;

2021 
b_seen
 = 0;

2022 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx", 
long_options_required
,

2023 &
option_index
);

2024 
	`ASSERT
 (
c
 == 0);

2025 
	`ASSERT
 (
b_seen
 == 1);

2028 int 
argc
 = 0;

2029 const char *
argv
[10];

2030 int 
option_index
;

2031 int 
c
;

2033 
argv
[
argc
++] = "program";

2034 
argv
[
argc
++] = "-xt";

2035 
argv
[
argc
] = 
NULL
;

2036 
optind
 = 1;

2037 
opterr
 = 0;

2038 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "ab", 
long_options_required
,

2039 &
option_index
);

2040 
	`ASSERT
 (
c
 == '?');

2041 
	`ASSERT
 (
optopt
 == 0);

2044 int 
argc
 = 0;

2045 const char *
argv
[10];

2046 int 
option_index
;

2047 int 
c
;

2049 
argv
[
argc
++] = "program";

2050 
argv
[
argc
++] = "-xt";

2051 
argv
[
argc
] = 
NULL
;

2052 
optind
 = 1;

2053 
opterr
 = 0;

2054 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx", 
long_options_required
,

2055 &
option_index
);

2056 
	`ASSERT
 (
c
 == '?');

2057 
	`ASSERT
 (
optopt
 == 0);

2060 int 
argc
 = 0;

2061 const char *
argv
[10];

2062 int 
option_index
;

2063 int 
c
;

2065 
argv
[
argc
++] = "program";

2066 
argv
[
argc
++] = "-xtra";

2067 
argv
[
argc
] = 
NULL
;

2068 
optind
 = 1;

2069 
opterr
 = 0;

2070 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "ab", 
long_options_required
,

2071 &
option_index
);

2072 
	`ASSERT
 (
c
 == 1001);

2075 int 
argc
 = 0;

2076 const char *
argv
[10];

2077 int 
option_index
;

2078 int 
c
;

2080 
argv
[
argc
++] = "program";

2081 
argv
[
argc
++] = "-xtreme";

2082 
argv
[
argc
] = 
NULL
;

2083 
optind
 = 1;

2084 
opterr
 = 0;

2085 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx:", 
long_options_required
,

2086 &
option_index
);

2087 
	`ASSERT
 (
c
 == 1002);

2090 int 
argc
 = 0;

2091 const char *
argv
[10];

2092 int 
option_index
;

2093 int 
c
;

2095 
argv
[
argc
++] = "program";

2096 
argv
[
argc
++] = "-xtremel";

2097 
argv
[
argc
] = 
NULL
;

2098 
optind
 = 1;

2099 
opterr
 = 0;

2100 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "ab", 
long_options_required
,

2101 &
option_index
);

2106 
	`ASSERT
 (
c
 == 1003 || c == '?');

2107 
	`ASSERT
 (
optind
 == 2);

2110 int 
argc
 = 0;

2111 const char *
argv
[10];

2112 int 
option_index
;

2113 int 
c
;

2115 
argv
[
argc
++] = "program";

2116 
argv
[
argc
++] = "-xtremel";

2117 
argv
[
argc
] = 
NULL
;

2118 
optind
 = 1;

2119 
opterr
 = 0;

2120 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx::", 
long_options_required
,

2121 &
option_index
);

2126 
	`ASSERT
 (
c
 == 1003 || c == '?');

2127 
	`ASSERT
 (
optind
 == 2);

2128 
	`ASSERT
 (
optarg
 == 
NULL
);

2131 int 
argc
 = 0;

2132 const char *
argv
[10];

2133 int 
option_index
;

2134 int 
c
;

2136 
argv
[
argc
++] = "program";

2137 
argv
[
argc
++] = "-xtras";

2138 
argv
[
argc
] = 
NULL
;

2139 
optind
 = 1;

2140 
opterr
 = 0;

2141 
c
 = 
	`do_getopt_long_only
 (
argc
, 
argv
, "abx::", 
long_options_required
,

2142 &
option_index
);

2143 
	`ASSERT
 (
c
 == 'x');

2144 
	`ASSERT
 (
	`strcmp
 (
optarg
, "tras") == 0);

2146 
	}
}

	@gnulib-tests/test-hash.c

20 #include 
	~<config.h
>

22 #include 
	~"hash.h
"

23 #include 
	~"hash-pjw.h
"

24 #include 
	~"inttostr.h
"

26 #include 
	~<stdio.h
>

27 #include 
	~<stdlib.h
>

28 #include 
	~<stdbool.h
>

29 #include 
	~<string.h
>

30 #include 
	~<unistd.h
>

32 #include 
	~"macros.h
"

34 #define 
	#STREQ
(
a
, 
b
) (
	`strcmp
 (a, b) == 0)

	)

35 #define 
	#ARRAY_CARDINALITY
(
Array
) (sizeof (Array) / sizeof *(Array))

	)

37 static 
bool


38 
	$hash_compare_strings
 (void const *
x
, void const *
y
)

40 
	`ASSERT
 (
x
 != 
y
);

41 return 
	`STREQ
 (
x
, 
y
) ? 
true
 : 
false
;

42 
	}
}

45 
	$hash_freer
 (void *
x
)

47 
	`free
 (
x
);

48 
	}
}

51 
	$insert_new
 (
Hash_table
 *
ht
, const void *
ent
)

53 void *
e
 = 
	`hash_insert
 (
ht
, 
ent
);

54 
	`ASSERT
 (
e
 == 
ent
);

55 
	}
}

57 static 
bool


58 
	$walk
 (void *
ent
, void *
data
)

60 char *
str
 = 
ent
;

61 unsigned int *
map
 = 
data
;

62 switch (*
str
)

64 case 'a': *
map
 |= 1; return 
true
;

65 case 'b': *
map
 |= 2; return 
true
;

66 case 'c': *
map
 |= 4; return 
true
;

68 *
map
 |= 8;

69 return 
false
;

70 
	}
}

73 
	$get_seed
 (char const *
str
, unsigned int *
seed
)

75 
size_t
 
len
 = 
	`strlen
 (
str
);

76 if (
len
 == 0 || 
	`strspn
 (
str
, "0123456789") != len || 10 < len)

79 *
seed
 = 
	`atoi
 (
str
);

81 
	}
}

84 
	$main
 (int 
argc
, char **
argv
)

86 unsigned int 
i
;

87 unsigned int 
k
;

88 unsigned int 
table_size
[] = {1, 2, 3, 4, 5, 23, 53};

89 
Hash_table
 *
ht
;

90 
Hash_tuning
 
tuning
;

92 
	`hash_reset_tuning
 (&
tuning
);

93 
tuning
.
shrink_threshold
 = 0.3;

94 
tuning
.
shrink_factor
 = 0.707;

95 
tuning
.
growth_threshold
 = 1.5;

96 
tuning
.
growth_factor
 = 2.0;

97 
tuning
.
is_n_buckets
 = 
true
;

99 if (1 < 
argc
)

101 unsigned int 
seed
;

102 if (
	`get_seed
 (
argv
[1], &
seed
) != 0)

104 
	`fprintf
 (
stderr
, "invalid seed: %s\n", 
argv
[1]);

105 
	`exit
 (
EXIT_FAILURE
);

108 
	`srand
 (
seed
);

111 for (
i
 = 0; i < 
	`ARRAY_CARDINALITY
 (
table_size
); i++)

113 
size_t
 
sz
 = 
table_size
[
i
];

114 
ht
 = 
	`hash_initialize
 (
sz
, 
NULL
, 
hash_pjw
, 
hash_compare_strings
, NULL);

115 
	`ASSERT
 (
ht
);

116 
	`insert_new
 (
ht
, "a");

118 char *
str1
 = 
	`strdup
 ("a");

119 char *
str2
;

120 
	`ASSERT
 (
str1
);

121 
str2
 = 
	`hash_insert
 (
ht
, 
str1
);

122 
	`ASSERT
 (
str1
 != 
str2
);

123 
	`ASSERT
 (
	`STREQ
 (
str1
, 
str2
));

124 
	`free
 (
str1
);

126 
	`insert_new
 (
ht
, "b");

127 
	`insert_new
 (
ht
, "c");

128 
i
 = 0;

129 
	`ASSERT
 (
	`hash_do_for_each
 (
ht
, 
walk
, &
i
) == 3);

130 
	`ASSERT
 (
i
 == 7);

132 void *
buf
[5] = { 
NULL
 };

133 
	`ASSERT
 (
	`hash_get_entries
 (
ht
, 
NULL
, 0) == 0);

134 
	`ASSERT
 (
	`hash_get_entries
 (
ht
, 
buf
, 5) == 3);

135 
	`ASSERT
 (
	`STREQ
 (
buf
[0], "a") || STREQ (buf[0], "b") || STREQ (buf[0], "c"));

137 
	`ASSERT
 (
	`hash_delete
 (
ht
, "a"));

138 
	`ASSERT
 (
	`hash_delete
 (
ht
, "a") == 
NULL
);

139 
	`ASSERT
 (
	`hash_delete
 (
ht
, "b"));

140 
	`ASSERT
 (
	`hash_delete
 (
ht
, "c"));

142 
	`ASSERT
 (
	`hash_rehash
 (
ht
, 47));

143 
	`ASSERT
 (
	`hash_rehash
 (
ht
, 467));

146 
	`hash_clear
 (
ht
);

147 
	`hash_free
 (
ht
);

149 
ht
 = 
	`hash_initialize
 (
sz
, 
NULL
, 
hash_pjw
, 
hash_compare_strings
, NULL);

150 
	`ASSERT
 (
ht
);

152 
	`insert_new
 (
ht
, "z");

153 
	`insert_new
 (
ht
, "y");

154 
	`insert_new
 (
ht
, "x");

155 
	`insert_new
 (
ht
, "w");

156 
	`insert_new
 (
ht
, "v");

157 
	`insert_new
 (
ht
, "u");

159 
	`hash_clear
 (
ht
);

160 
	`ASSERT
 (
	`hash_get_n_entries
 (
ht
) == 0);

161 
	`hash_free
 (
ht
);

164 
ht
 = 
	`hash_initialize
 (
sz
, 
NULL
, NULL, NULL, NULL);

165 
	`ASSERT
 (
ht
);

167 char *
str
 = 
	`strdup
 ("a");

168 
	`ASSERT
 (
str
);

169 
	`insert_new
 (
ht
, "a");

170 
	`insert_new
 (
ht
, 
str
);

171 
	`ASSERT
 (
	`hash_lookup
 (
ht
, 
str
) == str);

172 
	`free
 (
str
);

174 
	`hash_free
 (
ht
);

177 
	`hash_reset_tuning
 (&
tuning
);

178 
tuning
.
shrink_threshold
 = 0.3;

179 
tuning
.
shrink_factor
 = 0.707;

180 
tuning
.
growth_threshold
 = 1.5;

181 
tuning
.
growth_factor
 = 2.0;

182 
tuning
.
is_n_buckets
 = 
true
;

184 
ht
 = 
	`hash_initialize
 (4651, &
tuning
, 
hash_pjw
, 
hash_compare_strings
,

185 
hash_freer
);

186 
	`ASSERT
 (!
ht
);

189 
tuning
.
growth_threshold
 = 0.89;

192 for (
k
 = 0; k < 2; k++)

194 
Hash_tuning
 const *
tune
 = (
k
 == 0 ? 
NULL
 : &
tuning
);

196 
ht
 = 
	`hash_initialize
 (4651, 
tune
, 
hash_pjw
,

197 
hash_compare_strings
, 
hash_freer
);

198 
	`ASSERT
 (
ht
);

199 for (
i
 = 0; i < 10000; i++)

201 unsigned int 
op
 = 
	`rand
 () % 10;

202 switch (
op
)

211 char 
buf
[50];

212 char const *
p
 = 
	`uinttostr
 (
i
, 
buf
);

213 char *
p_dup
 = 
	`strdup
 (
p
);

214 
	`ASSERT
 (
p_dup
);

215 
	`insert_new
 (
ht
, 
p_dup
);

221 
size_t
 
n
 = 
	`hash_get_n_entries
 (
ht
);

222 
	`ASSERT
 (
	`hash_rehash
 (
ht
, 
n
 + 
	`rand
 () % 20));

228 
size_t
 
n
 = 
	`hash_get_n_entries
 (
ht
);

229 
size_t
 
delta
 = 
	`rand
 () % 20;

230 if (
delta
 < 
n
)

231 
	`ASSERT
 (
	`hash_rehash
 (
ht
, 
n
 - 
delta
));

239 
size_t
 
n
 = 
	`hash_get_n_entries
 (
ht
);

240 if (
n
)

242 
size_t
 
kk
 = 
	`rand
 () % 
n
;

243 void const *
p
;

244 void *
v
;

245 for (
p
 = 
	`hash_get_first
 (
ht
); 
kk
;

246 --
kk
, 
p
 = 
	`hash_get_next
 (
ht
, p))

250 
	`ASSERT
 (
p
);

251 
v
 = 
	`hash_delete
 (
ht
, 
p
);

252 
	`ASSERT
 (
v
);

253 
	`free
 (
v
);

258 
	`ASSERT
 (
	`hash_table_ok
 (
ht
));

261 
	`hash_free
 (
ht
);

265 
	}
}

	@gnulib-tests/test-iconv-h.c

19 #include 
	~<config.h
>

21 #if 
HAVE_ICONV


22 #include 
	~<iconv.h
>

26 
	$main
 ()

29 
	}
}

	@gnulib-tests/test-iconv.c

21 #include 
	~<config.h
>

23 #if 
HAVE_ICONV


24 #include 
	~<iconv.h
>

26 #ifndef 
ICONV_CONST


27 #define 
	#ICONV_CONST


	)

30 #include 
	~"signature.h
"

31 
SIGNATURE_CHECK
 (
iconv
, 
size_t
, (
iconv_t
, 
ICONV_CONST
 char **, size_t *,

32 char **, 
size_t
 *));

33 
SIGNATURE_CHECK
 (
iconv_close
, int, (
iconv_t
 
x
));

34 
SIGNATURE_CHECK
 (
iconv_open
, 
iconv_t
, (char const *, char const *));

38 #include 
	~<errno.h
>

39 #include 
	~<string.h
>

41 #include 
	~"macros.h
"

44 
	$main
 ()

46 #if 
HAVE_ICONV


49 
iconv_t
 
cd_88591_to_utf8
 = 
	`iconv_open
 ("UTF-8", "ISO-8859-1");

50 
iconv_t
 
cd_utf8_to_88591
 = 
	`iconv_open
 ("ISO-8859-1", "UTF-8");

52 
	`ASSERT
 (
cd_88591_to_utf8
 != (
iconv_t
)(-1));

53 
	`ASSERT
 (
cd_utf8_to_88591
 != (
iconv_t
)(-1));

57 static const char 
input
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

58 static const char 
expected
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

59 char 
buf
[50];

60 const char *
inptr
 = 
input
;

61 
size_t
 
inbytesleft
 = 
	`strlen
 (
input
);

62 char *
outptr
 = 
buf
;

63 
size_t
 
outbytesleft
 = sizeof (
buf
);

64 
size_t
 
res
 = 
	`iconv
 (
cd_88591_to_utf8
,

65 (
ICONV_CONST
 char **) &
inptr
, &
inbytesleft
,

66 &
outptr
, &
outbytesleft
);

67 
	`ASSERT
 (
res
 == 0 && 
inbytesleft
 == 0);

68 
	`ASSERT
 (
outptr
 == 
buf
 + 
	`strlen
 (
expected
));

69 
	`ASSERT
 (
	`memcmp
 (
buf
, 
expected
, 
	`strlen
 (expected)) == 0);

74 static const char 
input
[] = "\304";

75 static char 
buf
[2] = { (char)0xDE, (char)0xAD };

76 const char *
inptr
 = 
input
;

77 
size_t
 
inbytesleft
 = 1;

78 char *
outptr
 = 
buf
;

79 
size_t
 
outbytesleft
 = 1;

80 
size_t
 
res
 = 
	`iconv
 (
cd_88591_to_utf8
,

81 (
ICONV_CONST
 char **) &
inptr
, &
inbytesleft
,

82 &
outptr
, &
outbytesleft
);

83 
	`ASSERT
 (
res
 == (
size_t
)(-1) && 
errno
 == 
E2BIG
);

84 
	`ASSERT
 (
inbytesleft
 == 1);

85 
	`ASSERT
 (
outbytesleft
 == 1);

86 
	`ASSERT
 ((unsigned char) 
buf
[1] == 0xAD);

87 
	`ASSERT
 ((unsigned char) 
buf
[0] == 0xDE);

92 static const char 
input
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

93 static const char 
expected
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

94 char 
buf
[50];

95 const char *
inptr
 = 
input
;

96 
size_t
 
inbytesleft
 = 
	`strlen
 (
input
);

97 char *
outptr
 = 
buf
;

98 
size_t
 
outbytesleft
 = sizeof (
buf
);

99 
size_t
 
res
 = 
	`iconv
 (
cd_utf8_to_88591
,

100 (
ICONV_CONST
 char **) &
inptr
, &
inbytesleft
,

101 &
outptr
, &
outbytesleft
);

102 
	`ASSERT
 (
res
 == 0 && 
inbytesleft
 == 0);

103 
	`ASSERT
 (
outptr
 == 
buf
 + 
	`strlen
 (
expected
));

104 
	`ASSERT
 (
	`memcmp
 (
buf
, 
expected
, 
	`strlen
 (expected)) == 0);

109 static const char 
input
[] = "\342\202\254";

110 char 
buf
[10];

111 const char *
inptr
 = 
input
;

112 
size_t
 
inbytesleft
 = 
	`strlen
 (
input
);

113 char *
outptr
 = 
buf
;

114 
size_t
 
outbytesleft
 = sizeof (
buf
);

115 
size_t
 
res
 = 
	`iconv
 (
cd_utf8_to_88591
,

116 (
ICONV_CONST
 char **) &
inptr
, &
inbytesleft
,

117 &
outptr
, &
outbytesleft
);

118 if (
res
 == (
size_t
)(-1))

120 
	`ASSERT
 (
errno
 == 
EILSEQ
);

121 
	`ASSERT
 (
inbytesleft
 == 
	`strlen
 (
input
) && 
outptr
 == 
buf
);

125 
	`ASSERT
 (
res
 == 1);

126 
	`ASSERT
 (
inbytesleft
 == 0);

132 static const char 
input
[] = "\342";

133 char 
buf
[10];

134 const char *
inptr
 = 
input
;

135 
size_t
 
inbytesleft
 = 1;

136 char *
outptr
 = 
buf
;

137 
size_t
 
outbytesleft
 = sizeof (
buf
);

138 
size_t
 
res
 = 
	`iconv
 (
cd_utf8_to_88591
,

139 (
ICONV_CONST
 char **) &
inptr
, &
inbytesleft
,

140 &
outptr
, &
outbytesleft
);

141 
	`ASSERT
 (
res
 == (
size_t
)(-1) && 
errno
 == 
EINVAL
);

142 
	`ASSERT
 (
inbytesleft
 == 1 && 
outptr
 == 
buf
);

145 
	`iconv_close
 (
cd_88591_to_utf8
);

146 
	`iconv_close
 (
cd_utf8_to_88591
);

150 
	}
}

	@gnulib-tests/test-ignore-value.c

22 #include 
	~<config.h
>

24 #include 
	~"ignore-value.h
"

26 #include 
	~<stdio.h
>

28 #ifndef 
_GL_ATTRIBUTE_RETURN_CHECK


29 #if 
__GNUC__
 < 3 || (__GNUC__ == 3 && 
__GNUC_MINOR__
 < 4)

30 #define 
	#_GL_ATTRIBUTE_RETURN_CHECK


	)

32 #define 
	#_GL_ATTRIBUTE_RETURN_CHECK
 
	`__attribute__
((
__warn_unused_result__
))

	)

36 struct 
	ss
 { int 
	mi
; };

37 static char 
	$doChar
 (void) 
_GL_ATTRIBUTE_RETURN_CHECK
;

38 static int 
	$doInt
 (void) 
_GL_ATTRIBUTE_RETURN_CHECK
;

39 static 
off_t
 
	$doOff
 (void) 
_GL_ATTRIBUTE_RETURN_CHECK
;

40 static void *
	$doPtr
 (void) 
_GL_ATTRIBUTE_RETURN_CHECK
;

41 static struct 
s
 
	$doStruct
 (void) 
_GL_ATTRIBUTE_RETURN_CHECK
;

44 
	$doChar
 (void)

47 
	}
}

50 
	$doInt
 (void)

53 
	}
}

55 static 
off_t


56 
	$doOff
 (void)

59 
	}
}

62 
	$doPtr
 (void)

64 return 
NULL
;

65 
	}
}

67 static struct 
s


68 
	$doStruct
 (void)

70 static struct 
s
 
s1
;

71 return 
s1
;

72 
	}
}

75 
	$main
 (void)

80 
	`ignore_value
 (
	`doChar
 ());

81 
	`ignore_value
 (
	`doInt
 ());

82 
	`ignore_value
 (
	`doOff
 ());

83 
	`ignore_value
 (
	`doPtr
 ());

84 
	`ignore_value
 (
	`doStruct
 ());

86 
	}
}

	@gnulib-tests/test-intprops.c

23 #if (
__GNUC__
 == 4 && 3 <= 
__GNUC_MINOR__
) || 4 < __GNUC__

24 #pragma 
GCC
 
diagnostic
 
ignored
 "-Wtype-limits"

27 #include 
	~<config.h
>

29 #include 
	~"intprops.h
"

30 #include 
	~"verify.h
"

32 #include 
	~<stdbool.h
>

33 #include 
	~<inttypes.h
>

35 #include 
	~"macros.h
"

42 #if 
__GNUC__
 || 
__SUNPRO_C


43 #define 
	#VERIFY
(
x
) do { 
	`verify
 (x); } while (0)

	)

45 #define 
	#VERIFY
(
x
) 
	`ASSERT
 (x)

	)

49 
	$main
 (void)

55 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (
bool
));

56 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (char));

57 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (signed char));

58 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (unsigned char));

59 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (short int));

60 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (unsigned short int));

61 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (int));

62 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (unsigned int));

63 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (long int));

64 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (unsigned long int));

65 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (
intmax_t
));

66 
	`ASSERT
 (
	`TYPE_IS_INTEGER
 (
uintmax_t
));

67 
	`ASSERT
 (! 
	`TYPE_IS_INTEGER
 (float));

68 
	`ASSERT
 (! 
	`TYPE_IS_INTEGER
 (double));

69 
	`ASSERT
 (! 
	`TYPE_IS_INTEGER
 (long double));

73 
	`VERIFY
 (
	`TYPE_SIGNED
 (signed char));

74 
	`VERIFY
 (! 
	`TYPE_SIGNED
 (unsigned char));

75 
	`VERIFY
 (
	`TYPE_SIGNED
 (short int));

76 
	`VERIFY
 (! 
	`TYPE_SIGNED
 (unsigned short int));

77 
	`VERIFY
 (
	`TYPE_SIGNED
 (int));

78 
	`VERIFY
 (! 
	`TYPE_SIGNED
 (unsigned int));

79 
	`VERIFY
 (
	`TYPE_SIGNED
 (long int));

80 
	`VERIFY
 (! 
	`TYPE_SIGNED
 (unsigned long int));

81 
	`VERIFY
 (
	`TYPE_SIGNED
 (
intmax_t
));

82 
	`VERIFY
 (! 
	`TYPE_SIGNED
 (
uintmax_t
));

83 
	`ASSERT
 (
	`TYPE_SIGNED
 (float));

84 
	`ASSERT
 (
	`TYPE_SIGNED
 (double));

85 
	`ASSERT
 (
	`TYPE_SIGNED
 (long double));

88 
	`VERIFY
 (
INT_MIN
 + 
INT_MAX
 < 0

89 ? (
	`TYPE_TWOS_COMPLEMENT
 (int)

90 && ! 
	`TYPE_ONES_COMPLEMENT
 (int) && ! 
	`TYPE_SIGNED_MAGNITUDE
 (int))

91 : (! 
	`TYPE_TWOS_COMPLEMENT
 (int)

92 && (
	`TYPE_ONES_COMPLEMENT
 (int) || 
	`TYPE_SIGNED_MAGNITUDE
 (int))));

95 
	`VERIFY
 (
	`TYPE_MINIMUM
 (char) == 
CHAR_MIN
);

96 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (char) == 
CHAR_MAX
);

97 
	`VERIFY
 (
	`TYPE_MINIMUM
 (unsigned char) == 0);

98 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (unsigned char) == 
UCHAR_MAX
);

99 
	`VERIFY
 (
	`TYPE_MINIMUM
 (signed char) == 
SCHAR_MIN
);

100 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (signed char) == 
SCHAR_MAX
);

101 
	`VERIFY
 (
	`TYPE_MINIMUM
 (short int) == 
SHRT_MIN
);

102 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (short int) == 
SHRT_MAX
);

103 
	`VERIFY
 (
	`TYPE_MINIMUM
 (unsigned short int) == 0);

104 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (unsigned short int) == 
USHRT_MAX
);

105 
	`VERIFY
 (
	`TYPE_MINIMUM
 (int) == 
INT_MIN
);

106 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (int) == 
INT_MAX
);

107 
	`VERIFY
 (
	`TYPE_MINIMUM
 (unsigned int) == 0);

108 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (unsigned int) == 
UINT_MAX
);

109 
	`VERIFY
 (
	`TYPE_MINIMUM
 (long int) == 
LONG_MIN
);

110 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (long int) == 
LONG_MAX
);

111 
	`VERIFY
 (
	`TYPE_MINIMUM
 (unsigned long int) == 0);

112 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (unsigned long int) == 
ULONG_MAX
);

113 
	`VERIFY
 (
	`TYPE_MINIMUM
 (
intmax_t
) == 
INTMAX_MIN
);

114 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (
intmax_t
) == 
INTMAX_MAX
);

115 
	`VERIFY
 (
	`TYPE_MINIMUM
 (
uintmax_t
) == 0);

116 
	`VERIFY
 (
	`TYPE_MAXIMUM
 (
uintmax_t
) == 
UINTMAX_MAX
);

119 
	`VERIFY
 (
	`INT_BITS_STRLEN_BOUND
 (1) == 1);

120 
	`VERIFY
 (
	`INT_BITS_STRLEN_BOUND
 (2620) == 789);

123 #ifdef 
INT32_MAX


124 
	`VERIFY
 (
	`INT_STRLEN_BOUND
 (
int32_t
) == sizeof ("-2147483648") - 1);

125 
	`VERIFY
 (
	`INT_BUFSIZE_BOUND
 (
int32_t
) == sizeof ("-2147483648"));

127 #ifdef 
INT64_MAX


128 
	`VERIFY
 (
	`INT_STRLEN_BOUND
 (
int64_t
) == sizeof ("-9223372036854775808") - 1);

129 
	`VERIFY
 (
	`INT_BUFSIZE_BOUND
 (
int64_t
) == sizeof ("-9223372036854775808"));

134 #define 
	#CHECK_BINOP
(
op
, 
a
, 
b
, 
min
, 
max
, 
overflow
) \

135 (
INT_
##
op
##
	`_RANGE_OVERFLOW
 (
a
, 
b
, 
min
, 
max
) == (
overflow
) \

136 && 
INT_
##
op
##
	`_OVERFLOW
 (
a
, 
b
) == (
overflow
))

	)

137 #define 
	#CHECK_UNOP
(
op
, 
a
, 
min
, 
max
, 
overflow
) \

138 (
INT_
##
op
##
	`_RANGE_OVERFLOW
 (
a
, 
min
, 
max
) == (
overflow
) \

139 && 
INT_
##
op
##
	`_OVERFLOW
 (
a
) == (
overflow
))

	)

142 
	`VERIFY
 (
	`INT_ADD_RANGE_OVERFLOW
 (
INT_MAX
, 1, 
INT_MIN
, INT_MAX));

143 
	`VERIFY
 (
	`INT_ADD_OVERFLOW
 (
INT_MAX
, 1));

144 
	`VERIFY
 (
	`CHECK_BINOP
 (
ADD
, 
INT_MAX
, 1, 
INT_MIN
, INT_MAX, 
true
));

145 
	`VERIFY
 (
	`CHECK_BINOP
 (
ADD
, 
INT_MAX
, -1, 
INT_MIN
, INT_MAX, 
false
));

146 
	`VERIFY
 (
	`CHECK_BINOP
 (
ADD
, 
INT_MIN
, 1, INT_MIN, 
INT_MAX
, 
false
));

147 
	`VERIFY
 (
	`CHECK_BINOP
 (
ADD
, 
INT_MIN
, -1, INT_MIN, 
INT_MAX
, 
true
));

148 
	`VERIFY
 (
	`CHECK_BINOP
 (
ADD
, 
UINT_MAX
, 1u, 0u, UINT_MAX, 
true
));

149 
	`VERIFY
 (
	`CHECK_BINOP
 (
ADD
, 0u, 1u, 0u, 
UINT_MAX
, 
false
));

151 
	`VERIFY
 (
	`CHECK_BINOP
 (
SUBTRACT
, 
INT_MAX
, 1, 
INT_MIN
, INT_MAX, 
false
));

152 
	`VERIFY
 (
	`CHECK_BINOP
 (
SUBTRACT
, 
INT_MAX
, -1, 
INT_MIN
, INT_MAX, 
true
));

153 
	`VERIFY
 (
	`CHECK_BINOP
 (
SUBTRACT
, 
INT_MIN
, 1, INT_MIN, 
INT_MAX
, 
true
));

154 
	`VERIFY
 (
	`CHECK_BINOP
 (
SUBTRACT
, 
INT_MIN
, -1, INT_MIN, 
INT_MAX
, 
false
));

155 
	`VERIFY
 (
	`CHECK_BINOP
 (
SUBTRACT
, 
UINT_MAX
, 1u, 0u, UINT_MAX, 
false
));

156 
	`VERIFY
 (
	`CHECK_BINOP
 (
SUBTRACT
, 0u, 1u, 0u, 
UINT_MAX
, 
true
));

158 
	`VERIFY
 (
	`CHECK_UNOP
 (
NEGATE
, 
INT_MIN
, INT_MIN, 
INT_MAX
,

159 
	`TYPE_TWOS_COMPLEMENT
 (int)));

160 
	`VERIFY
 (
	`CHECK_UNOP
 (
NEGATE
, 0, 
INT_MIN
, 
INT_MAX
, 
false
));

161 
	`VERIFY
 (
	`CHECK_UNOP
 (
NEGATE
, 
INT_MAX
, 
INT_MIN
, INT_MAX, 
false
));

162 
	`VERIFY
 (
	`CHECK_UNOP
 (
NEGATE
, 0u, 0u, 
UINT_MAX
, 
false
));

163 
	`VERIFY
 (
	`CHECK_UNOP
 (
NEGATE
, 1u, 0u, 
UINT_MAX
, 
true
));

164 
	`VERIFY
 (
	`CHECK_UNOP
 (
NEGATE
, 
UINT_MAX
, 0u, UINT_MAX, 
true
));

166 
	`VERIFY
 (
	`CHECK_BINOP
 (
MULTIPLY
, 
INT_MAX
, INT_MAX, 
INT_MIN
, INT_MAX, 
true
));

167 
	`VERIFY
 (
	`CHECK_BINOP
 (
MULTIPLY
, 
INT_MAX
, 
INT_MIN
, INT_MIN, INT_MAX, 
true
));

168 
	`VERIFY
 (
	`CHECK_BINOP
 (
MULTIPLY
, 
INT_MIN
, 
INT_MAX
, INT_MIN, INT_MAX, 
true
));

169 
	`VERIFY
 (
	`CHECK_BINOP
 (
MULTIPLY
, 
INT_MIN
, INT_MIN, INT_MIN, 
INT_MAX
, 
true
));

170 
	`VERIFY
 (
	`CHECK_BINOP
 (
MULTIPLY
, -1, 
INT_MIN
, INT_MIN, 
INT_MAX
,

171 
	`INT_NEGATE_OVERFLOW
 (
INT_MIN
)));

172 
	`VERIFY
 (
	`CHECK_BINOP
 (
MULTIPLY
, 
LONG_MIN
 / 
INT_MAX
, (long int) INT_MAX,

173 
LONG_MIN
, LONG_MIN, 
false
));

175 
	`VERIFY
 (
	`CHECK_BINOP
 (
DIVIDE
, 
INT_MIN
, -1, INT_MIN, 
INT_MAX
,

176 
	`INT_NEGATE_OVERFLOW
 (
INT_MIN
)));

177 
	`VERIFY
 (
	`CHECK_BINOP
 (
DIVIDE
, 
INT_MAX
, 1, 
INT_MIN
, INT_MAX, 
false
));

178 
	`VERIFY
 (
	`CHECK_BINOP
 (
DIVIDE
, (unsigned int) 
INT_MIN
,

179 -1u, 0u, 
UINT_MAX
, 
false
));

181 
	`VERIFY
 (
	`CHECK_BINOP
 (
REMAINDER
, 
INT_MIN
, -1, INT_MIN, 
INT_MAX
,

182 
	`INT_NEGATE_OVERFLOW
 (
INT_MIN
)));

183 
	`VERIFY
 (
	`CHECK_BINOP
 (
REMAINDER
, 
INT_MAX
, 1, 
INT_MIN
, INT_MAX, 
false
));

184 
	`VERIFY
 (
	`CHECK_BINOP
 (
REMAINDER
, (unsigned int) 
INT_MIN
,

185 -1u, 0u, 
UINT_MAX
, 
false
));

187 
	`VERIFY
 (
	`CHECK_BINOP
 (
LEFT_SHIFT
, 
UINT_MAX
, 1, 0u, UINT_MAX, 
true
));

188 
	`VERIFY
 (
	`CHECK_BINOP
 (
LEFT_SHIFT
, 
UINT_MAX
 / 2 + 1, 1, 0u, UINT_MAX, 
true
));

189 
	`VERIFY
 (
	`CHECK_BINOP
 (
LEFT_SHIFT
, 
UINT_MAX
 / 2, 1, 0u, UINT_MAX, 
false
));

192 #define 
	#CHECK_SUM
(
a
, 
b
, 
overflow
) \

193 
	`VERIFY
 (
	`INT_ADD_OVERFLOW
 (
a
, 
b
) == (
overflow
)); \

194 
	`VERIFY
 (
	`INT_ADD_OVERFLOW
 (
b
, 
a
) == (
overflow
))

	)

195 
	`CHECK_SUM
 (-1, 
LONG_MIN
, 
true
);

196 
	`CHECK_SUM
 (-1, 
UINT_MAX
, 
false
);

197 
	`CHECK_SUM
 (-1L, 
INT_MIN
, INT_MIN == 
LONG_MIN
);

198 
	`CHECK_SUM
 (0u, -1, 
true
);

199 
	`CHECK_SUM
 (0u, 0, 
false
);

200 
	`CHECK_SUM
 (0u, 1, 
false
);

201 
	`CHECK_SUM
 (1, 
LONG_MAX
, 
true
);

202 
	`CHECK_SUM
 (1, 
UINT_MAX
, 
true
);

203 
	`CHECK_SUM
 (1L, 
INT_MAX
, INT_MAX == 
LONG_MAX
);

204 
	`CHECK_SUM
 (1u, 
INT_MAX
, INT_MAX == 
UINT_MAX
);

205 
	`CHECK_SUM
 (1u, 
INT_MIN
, 
true
);

207 
	`VERIFY
 (! 
	`INT_SUBTRACT_OVERFLOW
 (
INT_MAX
, 1u));

208 
	`VERIFY
 (! 
	`INT_SUBTRACT_OVERFLOW
 (
UINT_MAX
, 1));

209 
	`VERIFY
 (! 
	`INT_SUBTRACT_OVERFLOW
 (0u, -1));

210 
	`VERIFY
 (
	`INT_SUBTRACT_OVERFLOW
 (
UINT_MAX
, -1));

211 
	`VERIFY
 (
	`INT_SUBTRACT_OVERFLOW
 (
INT_MIN
, 1u));

212 
	`VERIFY
 (
	`INT_SUBTRACT_OVERFLOW
 (-1, 0u));

214 #define 
	#CHECK_PRODUCT
(
a
, 
b
, 
overflow
) \

215 
	`VERIFY
 (
	`INT_MULTIPLY_OVERFLOW
 (
a
, 
b
) == (
overflow
)); \

216 
	`VERIFY
 (
	`INT_MULTIPLY_OVERFLOW
 (
b
, 
a
) == (
overflow
))

	)

218 
	`CHECK_PRODUCT
 (-1, 1u, 
true
);

219 
	`CHECK_PRODUCT
 (-1, 
INT_MIN
, 
	`INT_NEGATE_OVERFLOW
 (INT_MIN));

220 
	`CHECK_PRODUCT
 (-1, 
UINT_MAX
, 
true
);

221 
	`CHECK_PRODUCT
 (-12345, 
LONG_MAX
 / -12345 - 1, 
true
);

222 
	`CHECK_PRODUCT
 (-12345, 
LONG_MAX
 / -12345, 
false
);

223 
	`CHECK_PRODUCT
 (0, -1, 
false
);

224 
	`CHECK_PRODUCT
 (0, 0, 
false
);

225 
	`CHECK_PRODUCT
 (0, 0u, 
false
);

226 
	`CHECK_PRODUCT
 (0, 1, 
false
);

227 
	`CHECK_PRODUCT
 (0, 
INT_MAX
, 
false
);

228 
	`CHECK_PRODUCT
 (0, 
INT_MIN
, 
false
);

229 
	`CHECK_PRODUCT
 (0, 
UINT_MAX
, 
false
);

230 
	`CHECK_PRODUCT
 (0u, -1, 
false
);

231 
	`CHECK_PRODUCT
 (0u, 0, 
false
);

232 
	`CHECK_PRODUCT
 (0u, 0u, 
false
);

233 
	`CHECK_PRODUCT
 (0u, 1, 
false
);

234 
	`CHECK_PRODUCT
 (0u, 
INT_MAX
, 
false
);

235 
	`CHECK_PRODUCT
 (0u, 
INT_MIN
, 
false
);

236 
	`CHECK_PRODUCT
 (0u, 
UINT_MAX
, 
false
);

237 
	`CHECK_PRODUCT
 (1, 
INT_MAX
, 
false
);

238 
	`CHECK_PRODUCT
 (1, 
INT_MIN
, 
false
);

239 
	`CHECK_PRODUCT
 (1, 
UINT_MAX
, 
false
);

240 
	`CHECK_PRODUCT
 (1u, 
INT_MIN
, 
true
);

241 
	`CHECK_PRODUCT
 (1u, 
INT_MAX
, 
UINT_MAX
 < INT_MAX);

242 
	`CHECK_PRODUCT
 (
INT_MAX
, 
UINT_MAX
, 
true
);

243 
	`CHECK_PRODUCT
 (
INT_MAX
, 
ULONG_MAX
, 
true
);

244 
	`CHECK_PRODUCT
 (
INT_MIN
, 
LONG_MAX
 / INT_MIN - 1, 
true
);

245 
	`CHECK_PRODUCT
 (
INT_MIN
, 
LONG_MAX
 / INT_MIN, 
false
);

246 
	`CHECK_PRODUCT
 (
INT_MIN
, 
UINT_MAX
, 
true
);

247 
	`CHECK_PRODUCT
 (
INT_MIN
, 
ULONG_MAX
, 
true
);

249 
	`VERIFY
 (
	`INT_DIVIDE_OVERFLOW
 (
INT_MIN
, -1L)

250 == (
	`TYPE_TWOS_COMPLEMENT
 (long int) && 
INT_MIN
 == 
LONG_MIN
));

251 
	`VERIFY
 (! 
	`INT_DIVIDE_OVERFLOW
 (
INT_MIN
, 
UINT_MAX
));

252 
	`VERIFY
 (! 
	`INT_DIVIDE_OVERFLOW
 (
INTMAX_MIN
, 
UINTMAX_MAX
));

253 
	`VERIFY
 (! 
	`INT_DIVIDE_OVERFLOW
 (
INTMAX_MIN
, 
UINT_MAX
));

254 
	`VERIFY
 (
	`INT_DIVIDE_OVERFLOW
 (-11, 10u));

255 
	`VERIFY
 (
	`INT_DIVIDE_OVERFLOW
 (-10, 10u));

256 
	`VERIFY
 (! 
	`INT_DIVIDE_OVERFLOW
 (-9, 10u));

257 
	`VERIFY
 (
	`INT_DIVIDE_OVERFLOW
 (11u, -10));

258 
	`VERIFY
 (
	`INT_DIVIDE_OVERFLOW
 (10u, -10));

259 
	`VERIFY
 (! 
	`INT_DIVIDE_OVERFLOW
 (9u, -10));

261 
	`VERIFY
 (
	`INT_REMAINDER_OVERFLOW
 (
INT_MIN
, -1L)

262 == (
	`TYPE_TWOS_COMPLEMENT
 (long int) && 
INT_MIN
 == 
LONG_MIN
));

263 
	`VERIFY
 (
	`INT_REMAINDER_OVERFLOW
 (-1, 
UINT_MAX
));

264 
	`VERIFY
 (
	`INT_REMAINDER_OVERFLOW
 ((
intmax_t
) -1, 
UINTMAX_MAX
));

265 
	`VERIFY
 (
	`INT_REMAINDER_OVERFLOW
 (
INTMAX_MIN
, 
UINT_MAX
)

266 == (
INTMAX_MAX
 < 
UINT_MAX


267 && - (unsigned int) 
INTMAX_MIN
 % 
UINT_MAX
 != 0));

268 
	`VERIFY
 (
	`INT_REMAINDER_OVERFLOW
 (
INT_MIN
, 
ULONG_MAX
)

269 == (
INT_MIN
 % 
ULONG_MAX
 != 1));

270 
	`VERIFY
 (! 
	`INT_REMAINDER_OVERFLOW
 (1u, -1));

271 
	`VERIFY
 (! 
	`INT_REMAINDER_OVERFLOW
 (37*39u, -39));

272 
	`VERIFY
 (
	`INT_REMAINDER_OVERFLOW
 (37*39u + 1, -39));

273 
	`VERIFY
 (
	`INT_REMAINDER_OVERFLOW
 (37*39u - 1, -39));

274 
	`VERIFY
 (! 
	`INT_REMAINDER_OVERFLOW
 (
LONG_MAX
, -
INT_MAX
));

277 
	}
}

	@gnulib-tests/test-inttostr.c

21 #include 
	~<config.h
>

23 #include 
	~"inttostr.h
"

24 #include 
	~"intprops.h
"

25 #include 
	~<inttypes.h
>

26 #include 
	~<stdio.h
>

27 #include 
	~<stdlib.h
>

28 #include 
	~<string.h
>

30 #include 
	~"macros.h
"

32 #define 
	#STREQ
(
a
, 
b
) (
	`strcmp
 (a, b) == 0)

	)

33 #define 
	#FMT
(
T
) (
	`TYPE_SIGNED
 (T) ? "%jd" : "%ju")

	)

34 #define 
	#CAST_VAL
(
T
,
V
) (
	`TYPE_SIGNED
 (T) ? (
intmax_t
) (V) : (
uintmax_t
) (V))

	)

35 #define 
	#V_min
(
T
) (
	`CAST_VAL
 (T, 
	`TYPE_MINIMUM
 (T)))

	)

36 #define 
	#V_max
(
T
) (
	`CAST_VAL
 (T, 
	`TYPE_MAXIMUM
 (T)))

	)

37 #define 
	#IS_TIGHT
(
T
) (
	`_GL_SIGNED_TYPE_OR_EXPR
 (T) == 
	`TYPE_SIGNED
 (T))

	)

38 #define 
	#ISDIGIT
(
c
) ((unsigned int) (c) - '0' <= 9)

	)

46 #define 
	#CK
(
T
, 
Fn
) \

49 char 
ref
[100]; \

50 char *
buf
 = 
	`malloc
 (
	`INT_BUFSIZE_BOUND
 (
T
)); \

51 char const *
p
; \

52 
	`ASSERT
 (
buf
); \

53 *
buf
 = '\0'; \

54 
	`ASSERT
 (
	`snprintf
 (
ref
, sizeof ref, 
	`FMT
 (
T
), 
	`V_min
 (T)) < sizeof ref); \

55 
	`ASSERT
 (
	`STREQ
 ((
p
 = 
	`Fn
 (
	`TYPE_MINIMUM
 (
T
), 
buf
)), 
ref
)); \

57 
	`ASSERT
 (! 
	`TYPE_SIGNED
 (
T
) || (
p
 == 
buf
 && *p == '-')); \

58 
	`ASSERT
 (
	`snprintf
 (
ref
, sizeof ref, 
	`FMT
 (
T
), 
	`V_max
 (T)) < sizeof ref); \

59 
	`ASSERT
 (
	`STREQ
 ((
p
 = 
	`Fn
 (
	`TYPE_MAXIMUM
 (
T
), 
buf
)), 
ref
)); \

61 
	`ASSERT
 (! 
	`IS_TIGHT
 (
T
) || 
	`TYPE_SIGNED
 (T) \

62 || (
p
 == 
buf
 && 
	`ISDIGIT
 (*p))); \

63 
	`free
 (
buf
); \

65 while (0)

	)

68 
	$main
 (void)

70 
size_t
 
b_size
 = 2;

71 char *
b
 = 
	`malloc
 (
b_size
);

72 
	`ASSERT
 (
b
);

77 if (
	`snprintf
 (
b
, 
b_size
, "%ju", (
uintmax_t
) 3) == 1

78 && 
b
[0] == '3' && b[1] == '\0')

80 
	`CK
 (int, 
inttostr
);

81 
	`CK
 (unsigned int, 
uinttostr
);

82 
	`CK
 (
off_t
, 
offtostr
);

83 
	`CK
 (
uintmax_t
, 
umaxtostr
);

84 
	`CK
 (
intmax_t
, 
imaxtostr
);

90 
	}
}

	@gnulib-tests/test-inttypes.c

21 #include 
	~<config.h
>

23 #define 
	#__STDC_LIMIT_MACROS
 1

	)

24 #define 
	#__STDC_CONSTANT_MACROS
 1

	)

25 #define 
	#__STDC_FORMAT_MACROS
 1

	)

26 #include 
	~<inttypes.h
>

28 #include 
	~<stddef.h
>

32 const char *
	gk
 =

33 #ifdef 
INT8_MAX


34 
PRId8
 
PRIi8


36 #ifdef 
UINT8_MAX


37 
PRIo8
 
PRIu8
 
PRIx8
 
PRIX8


39 #ifdef 
INT16_MAX


40 
PRId16
 
PRIi16


42 #ifdef 
UINT16_MAX


43 
PRIo16
 
PRIu16
 
PRIx16
 
PRIX16


45 #ifdef 
INT32_MAX


46 
PRId32
 
PRIi32


48 #ifdef 
UINT32_MAX


49 
PRIo32
 
PRIu32
 
PRIx32
 
PRIX32


51 #ifdef 
INT64_MAX


52 
PRId64
 
PRIi64


54 #ifdef 
UINT64_MAX


55 
PRIo64
 
PRIu64
 
PRIx64
 
PRIX64


57 
PRIdLEAST8
 
PRIiLEAST8
 
PRIoLEAST8
 
PRIuLEAST8
 
PRIxLEAST8
 
PRIXLEAST8


58 
PRIdLEAST16
 
PRIiLEAST16
 
PRIoLEAST16
 
PRIuLEAST16
 
PRIxLEAST16
 
PRIXLEAST16


59 
PRIdLEAST32
 
PRIiLEAST32
 
PRIoLEAST32
 
PRIuLEAST32
 
PRIxLEAST32
 
PRIXLEAST32


60 
PRIdLEAST64
 
PRIiLEAST64


61 
PRIoLEAST64
 
PRIuLEAST64
 
PRIxLEAST64
 
PRIXLEAST64


62 
PRIdFAST8
 
PRIiFAST8
 
PRIoFAST8
 
PRIuFAST8
 
PRIxFAST8
 
PRIXFAST8


63 
PRIdFAST16
 
PRIiFAST16
 
PRIoFAST16
 
PRIuFAST16
 
PRIxFAST16
 
PRIXFAST16


64 
PRIdFAST32
 
PRIiFAST32
 
PRIoFAST32
 
PRIuFAST32
 
PRIxFAST32
 
PRIXFAST32


65 
PRIdFAST64
 
PRIiFAST64


66 
PRIoFAST64
 
PRIuFAST64
 
PRIxFAST64
 
PRIXFAST64


67 
PRIdMAX
 
PRIiMAX
 
PRIoMAX
 
PRIuMAX
 
PRIxMAX
 
PRIXMAX


68 #ifdef 
INTPTR_MAX


69 
PRIdPTR
 
PRIiPTR


71 #ifdef 
UINTPTR_MAX


72 
PRIoPTR
 
PRIuPTR
 
PRIxPTR
 
PRIXPTR


75 const char *
	gl
 =

76 #ifdef 
INT8_MAX


77 
SCNd8
 
SCNi8


79 #ifdef 
UINT8_MAX


80 
SCNo8
 
SCNu8
 
SCNx8


82 #ifdef 
INT16_MAX


83 
SCNd16
 
SCNi16


85 #ifdef 
UINT16_MAX


86 
SCNo16
 
SCNu16
 
SCNx16


88 #ifdef 
INT32_MAX


89 
SCNd32
 
SCNi32


91 #ifdef 
UINT32_MAX


92 
SCNo32
 
SCNu32
 
SCNx32


94 #ifdef 
INT64_MAX


95 
SCNd64
 
SCNi64


97 #ifdef 
UINT64_MAX


98 
SCNo64
 
SCNu64
 
SCNx64


100 
SCNdLEAST8
 
SCNiLEAST8
 
SCNoLEAST8
 
SCNuLEAST8
 
SCNxLEAST8


101 
SCNdLEAST16
 
SCNiLEAST16
 
SCNoLEAST16
 
SCNuLEAST16
 
SCNxLEAST16


102 
SCNdLEAST32
 
SCNiLEAST32
 
SCNoLEAST32
 
SCNuLEAST32
 
SCNxLEAST32


103 
SCNdLEAST64
 
SCNiLEAST64


104 
SCNoLEAST64
 
SCNuLEAST64
 
SCNxLEAST64


105 
SCNdFAST8
 
SCNiFAST8
 
SCNoFAST8
 
SCNuFAST8
 
SCNxFAST8


106 
SCNdFAST16
 
SCNiFAST16
 
SCNoFAST16
 
SCNuFAST16
 
SCNxFAST16


107 
SCNdFAST32
 
SCNiFAST32
 
SCNoFAST32
 
SCNuFAST32
 
SCNxFAST32


108 
SCNdFAST64
 
SCNiFAST64


109 
SCNoFAST64
 
SCNuFAST64
 
SCNxFAST64


110 
SCNdMAX
 
SCNiMAX
 
SCNoMAX
 
SCNuMAX
 
SCNxMAX


111 #ifdef 
INTPTR_MAX


112 
SCNdPTR
 
SCNiPTR


114 #ifdef 
UINTPTR_MAX


115 
SCNoPTR
 
SCNuPTR
 
SCNxPTR


120 
	$main
 (void)

123 
	}
}

	@gnulib-tests/test-isblank.c

21 #include 
	~<config.h
>

23 #include 
	~<ctype.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
isblank
, int, (int));

28 #include 
	~<limits.h
>

29 #include 
	~<stdio.h
>

31 #include 
	~"macros.h
"

34 
	$main
 (int 
argc
, char *
argv
[])

36 unsigned int 
c
;

47 for (
c
 = 0; c <= 
UCHAR_MAX
; c++)

48 
	`ASSERT
 (!
	`isblank
 (
c
) == !(c == ' ' || c == '\t'));

49 
	`ASSERT
 (!
	`isblank
 (
EOF
));

52 
	}
}

	@gnulib-tests/test-iswblank.c

19 #include 
	~<config.h
>

21 #include 
	~<wctype.h
>

23 #include 
	~"macros.h
"

26 
wint_t
 
	ge
 = 
WEOF
;

29 
	$main
 (void)

32 (void) 
	`iswblank
 (0);

34 
	`ASSERT
 (!
	`iswblank
 (
e
));

37 
	}
}

	@gnulib-tests/test-langinfo.c

21 #include 
	~<config.h
>

23 #include 
	~<langinfo.h
>

26 int 
	gitems
[] =

29 
CODESET
,

31 
RADIXCHAR
,

32 
THOUSEP
,

34 
D_T_FMT
,

35 
D_FMT
,

36 
T_FMT
,

37 
T_FMT_AMPM
,

38 
AM_STR
,

39 
PM_STR
,

40 
DAY_1
,

41 
DAY_2
,

42 
DAY_3
,

43 
DAY_4
,

44 
DAY_5
,

45 
DAY_6
,

46 
DAY_7
,

47 
ABDAY_1
,

48 
ABDAY_2
,

49 
ABDAY_3
,

50 
ABDAY_4
,

51 
ABDAY_5
,

52 
ABDAY_6
,

53 
ABDAY_7
,

54 
MON_1
,

55 
MON_2
,

56 
MON_3
,

57 
MON_4
,

58 
MON_5
,

59 
MON_6
,

60 
MON_7
,

61 
MON_8
,

62 
MON_9
,

63 
MON_10
,

64 
MON_11
,

65 
MON_12
,

66 
ABMON_1
,

67 
ABMON_2
,

68 
ABMON_3
,

69 
ABMON_4
,

70 
ABMON_5
,

71 
ABMON_6
,

72 
ABMON_7
,

73 
ABMON_8
,

74 
ABMON_9
,

75 
ABMON_10
,

76 
ABMON_11
,

77 
ABMON_12
,

78 
ERA
,

79 
ERA_D_FMT
,

80 
ERA_D_T_FMT
,

81 
ERA_T_FMT
,

82 
ALT_DIGITS
,

84 
CRNCYSTR
,

86 
YESEXPR
,

87 
NOEXPR


91 
	$main
 (void)

94 
	}
}

	@gnulib-tests/test-locale.c

21 #include 
	~<config.h
>

23 #include 
	~<locale.h
>

25 #include 
	~"verify.h
"

27 int 
	ga
[] =

29 
LC_ALL
,

30 
LC_COLLATE
,

31 
LC_CTYPE
,

32 
LC_MESSAGES
,

33 
LC_MONETARY
,

34 
LC_NUMERIC
,

35 
LC_TIME


38 #if 
HAVE_NEWLOCALE


40 
locale_t
 
	gb
 = 
LC_GLOBAL_LOCALE
;

45 
verify
 (sizeof 
NULL
 == sizeof (void *));

48 
	$main
 ()

51 
	}
}

	@gnulib-tests/test-localename.c

21 #include 
	~<config.h
>

23 #include 
	~"localename.h
"

25 #include 
	~<locale.h
>

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

29 #include 
	~"macros.h
"

32 #if 
HAVE_NEWLOCALE


34 static struct { int 
	mcat
; int 
	mmask
; const char *
	mstring
; } const 
	gcategories
[] =

36 { 
LC_CTYPE
, 
LC_CTYPE_MASK
, "LC_CTYPE" },

37 { 
LC_NUMERIC
, 
LC_NUMERIC_MASK
, "LC_NUMERIC" },

38 { 
LC_TIME
, 
LC_TIME_MASK
, "LC_TIME" },

39 { 
LC_COLLATE
, 
LC_COLLATE_MASK
, "LC_COLLATE" },

40 { 
LC_MONETARY
, 
LC_MONETARY_MASK
, "LC_MONETARY" },

41 { 
LC_MESSAGES
, 
LC_MESSAGES_MASK
, "LC_MESSAGES" }

42 #ifdef 
LC_PAPER


43 , { 
LC_PAPER
, 
LC_PAPER_MASK
, "LC_PAPER" }

45 #ifdef 
LC_NAME


46 , { 
LC_NAME
, 
LC_NAME_MASK
, "LC_NAME" }

48 #ifdef 
LC_ADDRESS


49 , { 
LC_ADDRESS
, 
LC_ADDRESS_MASK
, "LC_ADDRESS" }

51 #ifdef 
LC_TELEPHONE


52 , { 
LC_TELEPHONE
, 
LC_TELEPHONE_MASK
, "LC_TELEPHONE" }

54 #ifdef 
LC_MEASUREMENT


55 , { 
LC_MEASUREMENT
, 
LC_MEASUREMENT_MASK
, "LC_MEASUREMENT" }

57 #ifdef 
LC_IDENTIFICATION


58 , { 
LC_IDENTIFICATION
, 
LC_IDENTIFICATION_MASK
, "LC_IDENTIFICATION" }

66 
	$test_locale_name
 (void)

68 const char *
name
;

71 
	`ASSERT
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES") != 
NULL
);

74 
	`setlocale
 (
LC_ALL
, "en_US.UTF-8");

75 #if 
HAVE_NEWLOCALE


76 
	`uselocale
 (
LC_GLOBAL_LOCALE
);

81 
	`unsetenv
 ("LC_ALL");

82 
	`unsetenv
 ("LC_CTYPE");

83 
	`unsetenv
 ("LC_MESSAGES");

84 
	`unsetenv
 ("LC_NUMERIC");

85 
	`unsetenv
 ("LANG");

86 
	`setlocale
 (
LC_ALL
, "");

87 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"),

88 
	`gl_locale_name_default
 ()) == 0);

89 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_NUMERIC
, "LC_NUMERIC"),

90 
	`gl_locale_name_default
 ()) == 0);

95 
	`setenv
 ("LC_ALL", "", 1);

96 
	`unsetenv
 ("LC_CTYPE");

97 
	`unsetenv
 ("LC_MESSAGES");

98 
	`unsetenv
 ("LANG");

99 
	`setlocale
 (
LC_ALL
, "");

100 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"),

101 
	`gl_locale_name_default
 ()) == 0);

103 
	`unsetenv
 ("LC_ALL");

104 
	`setenv
 ("LC_CTYPE", "", 1);

105 
	`unsetenv
 ("LC_MESSAGES");

106 
	`unsetenv
 ("LANG");

107 
	`setlocale
 (
LC_ALL
, "");

108 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"),

109 
	`gl_locale_name_default
 ()) == 0);

111 
	`unsetenv
 ("LC_ALL");

112 
	`unsetenv
 ("LC_CTYPE");

113 
	`setenv
 ("LC_MESSAGES", "", 1);

114 
	`unsetenv
 ("LANG");

115 
	`setlocale
 (
LC_ALL
, "");

116 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"),

117 
	`gl_locale_name_default
 ()) == 0);

119 
	`unsetenv
 ("LC_ALL");

120 
	`unsetenv
 ("LC_CTYPE");

121 
	`unsetenv
 ("LC_MESSAGES");

122 
	`setenv
 ("LANG", "", 1);

123 
	`setlocale
 (
LC_ALL
, "");

124 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"),

125 
	`gl_locale_name_default
 ()) == 0);

130 
	`setenv
 ("LC_ALL", "C", 1);

131 
	`unsetenv
 ("LC_CTYPE");

132 
	`unsetenv
 ("LC_MESSAGES");

133 
	`unsetenv
 ("LANG");

134 
	`setlocale
 (
LC_ALL
, "");

135 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"), "C") == 0);

137 
	`unsetenv
 ("LC_ALL");

138 
	`setenv
 ("LC_CTYPE", "C", 1);

139 
	`setenv
 ("LC_MESSAGES", "C", 1);

140 
	`unsetenv
 ("LANG");

141 
	`setlocale
 (
LC_ALL
, "");

142 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"), "C") == 0);

144 
	`unsetenv
 ("LC_ALL");

145 
	`unsetenv
 ("LC_CTYPE");

146 
	`unsetenv
 ("LC_MESSAGES");

147 
	`setenv
 ("LANG", "C", 1);

148 
	`setlocale
 (
LC_ALL
, "");

149 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES"), "C") == 0);

153 
	`unsetenv
 ("LC_ALL");

154 
	`unsetenv
 ("LC_CTYPE");

155 
	`setenv
 ("LC_MESSAGES", "fr_FR.UTF-8", 1);

156 
	`setenv
 ("LANG", "de_DE.UTF-8", 1);

157 if (
	`setlocale
 (
LC_ALL
, "") != 
NULL
)

159 
name
 = 
	`gl_locale_name
 (
LC_CTYPE
, "LC_CTYPE");

160 
	`ASSERT
 (
	`strcmp
 (
name
, "de_DE.UTF-8") == 0);

161 
name
 = 
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES");

162 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

165 
	`unsetenv
 ("LC_ALL");

166 
	`unsetenv
 ("LC_CTYPE");

167 
	`setenv
 ("LC_MESSAGES", "fr_FR.UTF-8", 1);

168 
	`unsetenv
 ("LANG");

169 if (
	`setlocale
 (
LC_ALL
, "") != 
NULL
)

171 
name
 = 
	`gl_locale_name
 (
LC_CTYPE
, "LC_CTYPE");

172 
	`ASSERT
 (
	`strcmp
 (
name
, 
	`gl_locale_name_default
 ()) == 0);

173 
name
 = 
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES");

174 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

177 #if 
HAVE_NEWLOCALE


180 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, "fr_FR.UTF-8", 
NULL
);

181 if (
locale
 != 
NULL
)

183 
	`uselocale
 (
locale
);

184 
name
 = 
	`gl_locale_name
 (
LC_CTYPE
, "LC_CTYPE");

185 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

186 
name
 = 
	`gl_locale_name
 (
LC_MESSAGES
, "LC_MESSAGES");

187 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

194 unsigned int 
i
;

196 for (
i
 = 0; i < 
	`SIZEOF
 (
categories
); i++)

198 int 
category_mask
 = 
categories
[
i
].
mask
;

199 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, "fr_FR.UTF-8", 
NULL
);

200 if (
locale
 != 
NULL
)

202 
locale
 = 
	`newlocale
 (
category_mask
, "de_DE.UTF-8", locale);

203 if (
locale
 != 
NULL
)

205 unsigned int 
j
;

207 
	`uselocale
 (
locale
);

208 for (
j
 = 0; j < 
	`SIZEOF
 (
categories
); j++)

210 const char *
name_j
 =

211 
	`gl_locale_name
 (
categories
[
j
].
cat
, categories[j].
string
);

212 if (
j
 == 
i
)

213 
	`ASSERT
 (
	`strcmp
 (
name_j
, "de_DE.UTF-8") == 0);

215 
	`ASSERT
 (
	`strcmp
 (
name_j
, "fr_FR.UTF-8") == 0);

222 
	}
}

226 
	$test_locale_name_thread
 (void)

229 
	`setlocale
 (
LC_ALL
, "en_US.UTF-8");

231 #if 
HAVE_NEWLOCALE


234 
	`uselocale
 (
LC_GLOBAL_LOCALE
);

235 
	`ASSERT
 (
	`gl_locale_name_thread
 (
LC_CTYPE
, "LC_CTYPE") == 
NULL
);

236 
	`ASSERT
 (
	`gl_locale_name_thread
 (
LC_MESSAGES
, "LC_MESSAGES") == 
NULL
);

240 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, "fr_FR.UTF-8", 
NULL
);

241 if (
locale
 != 
NULL
)

243 const char *
name
;

245 
	`uselocale
 (
locale
);

246 
name
 = 
	`gl_locale_name_thread
 (
LC_CTYPE
, "LC_CTYPE");

247 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

248 
name
 = 
	`gl_locale_name_thread
 (
LC_MESSAGES
, "LC_MESSAGES");

249 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

256 unsigned int 
i
;

258 for (
i
 = 0; i < 
	`SIZEOF
 (
categories
); i++)

260 int 
category_mask
 = 
categories
[
i
].
mask
;

261 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, "fr_FR.UTF-8", 
NULL
);

262 if (
locale
 != 
NULL
)

264 
locale
 = 
	`newlocale
 (
category_mask
, "de_DE.UTF-8", locale);

265 if (
locale
 != 
NULL
)

267 unsigned int 
j
;

269 
	`uselocale
 (
locale
);

270 for (
j
 = 0; j < 
	`SIZEOF
 (
categories
); j++)

272 const char *
name_j
 =

273 
	`gl_locale_name_thread
 (
categories
[
j
].
cat
,

274 
categories
[
j
].
string
);

275 if (
j
 == 
i
)

276 
	`ASSERT
 (
	`strcmp
 (
name_j
, "de_DE.UTF-8") == 0);

278 
	`ASSERT
 (
	`strcmp
 (
name_j
, "fr_FR.UTF-8") == 0);

289 static const char * const 
choices
[] =

396 unsigned char 
available
[
	`SIZEOF
 (
choices
)];

398 const char *
unsaved_names
[
	`SIZEOF
 (
choices
)][SIZEOF (
categories
)];

401 char *
saved_names
[
	`SIZEOF
 (
choices
)][SIZEOF (
categories
)];

402 unsigned int 
j
;

404 for (
j
 = 0; j < 
	`SIZEOF
 (
choices
); j++)

406 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, 
choices
[
j
], 
NULL
);

407 
available
[
j
] = (
locale
 != 
NULL
);

408 if (
locale
 != 
NULL
)

410 unsigned int 
i
;

412 
	`uselocale
 (
locale
);

413 for (
i
 = 0; i < 
	`SIZEOF
 (
categories
); i++)

415 
unsaved_names
[
j
][
i
] = 
	`gl_locale_name_thread
 (
categories
[i].
cat
, categories[i].
string
);

416 
saved_names
[
j
][
i
] = 
	`strdup
 (
unsaved_names
[j][i]);

418 
	`uselocale
 (
LC_GLOBAL_LOCALE
);

419 
	`freelocale
 (
locale
);

423 for (
j
 = 0; j < 
	`SIZEOF
 (
choices
); j++)

424 if (
available
[
j
])

426 unsigned int 
i
;

428 for (
i
 = 0; i < 
	`SIZEOF
 (
categories
); i++)

429 
	`ASSERT
 (
	`strcmp
 (
unsaved_names
[
j
][
i
], 
saved_names
[j][i]) == 0);

433 for (
j
 = 
	`SIZEOF
 (
choices
); j > 0; )

435 
j
--;

436 if (
available
[
j
])

438 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, 
choices
[
j
], 
NULL
);

439 unsigned int 
i
;

441 
	`ASSERT
 (
locale
 != 
NULL
);

442 
	`uselocale
 (
locale
);

443 for (
i
 = 0; i < 
	`SIZEOF
 (
categories
); i++)

445 const char *
name
 = 
	`gl_locale_name_thread
 (
categories
[
i
].
cat
, categories[i].
string
);

446 
	`ASSERT
 (
	`strcmp
 (
unsaved_names
[
j
][
i
], 
name
) == 0);

448 
	`uselocale
 (
LC_GLOBAL_LOCALE
);

452 for (
j
 = 0; j < 
	`SIZEOF
 (
choices
); j++)

453 if (
available
[
j
])

455 unsigned int 
i
;

457 for (
i
 = 0; i < 
	`SIZEOF
 (
categories
); i++)

458 
	`ASSERT
 (
	`strcmp
 (
unsaved_names
[
j
][
i
], 
saved_names
[j][i]) == 0);

463 
	`ASSERT
 (
	`gl_locale_name_thread
 (
LC_CTYPE
, "LC_CTYPE") == 
NULL
);

464 
	`ASSERT
 (
	`gl_locale_name_thread
 (
LC_MESSAGES
, "LC_MESSAGES") == 
NULL
);

466 
	}
}

470 
	$test_locale_name_posix
 (void)

472 const char *
name
;

475 
	`setlocale
 (
LC_ALL
, "en_US.UTF-8");

476 #if 
HAVE_NEWLOCALE


477 
	`uselocale
 (
LC_GLOBAL_LOCALE
);

482 
	`unsetenv
 ("LC_ALL");

483 
	`unsetenv
 ("LC_CTYPE");

484 
	`unsetenv
 ("LC_MESSAGES");

485 
	`unsetenv
 ("LC_NUMERIC");

486 
	`unsetenv
 ("LANG");

487 
	`setlocale
 (
LC_ALL
, "");

488 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

489 
	`ASSERT
 (
name
 == 
NULL
 || 
	`strcmp
 (name, 
	`gl_locale_name_default
 ()) == 0);

490 
name
 = 
	`gl_locale_name_posix
 (
LC_NUMERIC
, "LC_NUMERIC");

491 
	`ASSERT
 (
name
 == 
NULL
 || 
	`strcmp
 (name, 
	`gl_locale_name_default
 ()) == 0);

496 
	`setenv
 ("LC_ALL", "", 1);

497 
	`unsetenv
 ("LC_CTYPE");

498 
	`unsetenv
 ("LC_MESSAGES");

499 
	`unsetenv
 ("LANG");

500 
	`setlocale
 (
LC_ALL
, "");

501 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

502 
	`ASSERT
 (
name
 == 
NULL
 || 
	`strcmp
 (name, 
	`gl_locale_name_default
 ()) == 0);

504 
	`unsetenv
 ("LC_ALL");

505 
	`setenv
 ("LC_CTYPE", "", 1);

506 
	`unsetenv
 ("LC_MESSAGES");

507 
	`unsetenv
 ("LANG");

508 
	`setlocale
 (
LC_ALL
, "");

509 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

510 
	`ASSERT
 (
name
 == 
NULL
 || 
	`strcmp
 (name, 
	`gl_locale_name_default
 ()) == 0);

512 
	`unsetenv
 ("LC_ALL");

513 
	`unsetenv
 ("LC_CTYPE");

514 
	`setenv
 ("LC_MESSAGES", "", 1);

515 
	`unsetenv
 ("LANG");

516 
	`setlocale
 (
LC_ALL
, "");

517 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

518 
	`ASSERT
 (
name
 == 
NULL
 || 
	`strcmp
 (name, 
	`gl_locale_name_default
 ()) == 0);

520 
	`unsetenv
 ("LC_ALL");

521 
	`unsetenv
 ("LC_CTYPE");

522 
	`unsetenv
 ("LC_MESSAGES");

523 
	`setenv
 ("LANG", "", 1);

524 
	`setlocale
 (
LC_ALL
, "");

525 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

526 
	`ASSERT
 (
name
 == 
NULL
 || 
	`strcmp
 (name, 
	`gl_locale_name_default
 ()) == 0);

531 
	`setenv
 ("LC_ALL", "C", 1);

532 
	`unsetenv
 ("LC_CTYPE");

533 
	`unsetenv
 ("LC_MESSAGES");

534 
	`unsetenv
 ("LANG");

535 
	`setlocale
 (
LC_ALL
, "");

536 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

537 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

539 
	`unsetenv
 ("LC_ALL");

540 
	`setenv
 ("LC_CTYPE", "C", 1);

541 
	`setenv
 ("LC_MESSAGES", "C", 1);

542 
	`unsetenv
 ("LANG");

543 
	`setlocale
 (
LC_ALL
, "");

544 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

545 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

547 
	`unsetenv
 ("LC_ALL");

548 
	`unsetenv
 ("LC_CTYPE");

549 
	`unsetenv
 ("LC_MESSAGES");

550 
	`setenv
 ("LANG", "C", 1);

551 
	`setlocale
 (
LC_ALL
, "");

552 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

553 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

557 
	`unsetenv
 ("LC_ALL");

558 
	`unsetenv
 ("LC_CTYPE");

559 
	`setenv
 ("LC_MESSAGES", "fr_FR.UTF-8", 1);

560 
	`setenv
 ("LANG", "de_DE.UTF-8", 1);

561 if (
	`setlocale
 (
LC_ALL
, "") != 
NULL
)

563 
name
 = 
	`gl_locale_name_posix
 (
LC_CTYPE
, "LC_CTYPE");

564 
	`ASSERT
 (
	`strcmp
 (
name
, "de_DE.UTF-8") == 0);

565 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

566 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

569 
	`unsetenv
 ("LC_ALL");

570 
	`unsetenv
 ("LC_CTYPE");

571 
	`setenv
 ("LC_MESSAGES", "fr_FR.UTF-8", 1);

572 
	`unsetenv
 ("LANG");

573 if (
	`setlocale
 (
LC_ALL
, "") != 
NULL
)

575 
name
 = 
	`gl_locale_name_posix
 (
LC_CTYPE
, "LC_CTYPE");

576 
	`ASSERT
 (
name
 == 
NULL
 || 
	`strcmp
 (name, 
	`gl_locale_name_default
 ()) == 0);

577 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

578 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

581 #if 
HAVE_NEWLOCALE


584 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, "fr_FR.UTF-8", 
NULL
);

585 if (
locale
 != 
NULL
)

587 
	`unsetenv
 ("LC_ALL");

588 
	`unsetenv
 ("LC_CTYPE");

589 
	`unsetenv
 ("LC_MESSAGES");

590 
	`setenv
 ("LANG", "C", 1);

591 
	`setlocale
 (
LC_ALL
, "");

592 
	`uselocale
 (
locale
);

593 
name
 = 
	`gl_locale_name_posix
 (
LC_MESSAGES
, "LC_MESSAGES");

594 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

598 
	}
}

602 
	$test_locale_name_environ
 (void)

604 const char *
name
;

607 
	`setlocale
 (
LC_ALL
, "en_US.UTF-8");

608 #if 
HAVE_NEWLOCALE


609 
	`uselocale
 (
LC_GLOBAL_LOCALE
);

614 
	`unsetenv
 ("LC_ALL");

615 
	`unsetenv
 ("LC_CTYPE");

616 
	`unsetenv
 ("LC_MESSAGES");

617 
	`unsetenv
 ("LC_NUMERIC");

618 
	`unsetenv
 ("LANG");

619 
	`ASSERT
 (
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES") == 
NULL
);

620 
	`ASSERT
 (
	`gl_locale_name_environ
 (
LC_NUMERIC
, "LC_NUMERIC") == 
NULL
);

625 
	`setenv
 ("LC_ALL", "", 1);

626 
	`unsetenv
 ("LC_CTYPE");

627 
	`unsetenv
 ("LC_MESSAGES");

628 
	`unsetenv
 ("LANG");

629 
	`ASSERT
 (
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES") == 
NULL
);

631 
	`unsetenv
 ("LC_ALL");

632 
	`setenv
 ("LC_CTYPE", "", 1);

633 
	`unsetenv
 ("LC_MESSAGES");

634 
	`unsetenv
 ("LANG");

635 
	`ASSERT
 (
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES") == 
NULL
);

637 
	`unsetenv
 ("LC_ALL");

638 
	`unsetenv
 ("LC_CTYPE");

639 
	`setenv
 ("LC_MESSAGES", "", 1);

640 
	`unsetenv
 ("LANG");

641 
	`ASSERT
 (
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES") == 
NULL
);

643 
	`unsetenv
 ("LC_ALL");

644 
	`unsetenv
 ("LC_CTYPE");

645 
	`unsetenv
 ("LC_MESSAGES");

646 
	`setenv
 ("LANG", "", 1);

647 
	`ASSERT
 (
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES") == 
NULL
);

652 
	`setenv
 ("LC_ALL", "C", 1);

653 
	`unsetenv
 ("LC_CTYPE");

654 
	`unsetenv
 ("LC_MESSAGES");

655 
	`unsetenv
 ("LANG");

656 
name
 = 
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES");

657 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

659 
	`unsetenv
 ("LC_ALL");

660 
	`setenv
 ("LC_CTYPE", "C", 1);

661 
	`setenv
 ("LC_MESSAGES", "C", 1);

662 
	`unsetenv
 ("LANG");

663 
name
 = 
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES");

664 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

666 
	`unsetenv
 ("LC_ALL");

667 
	`unsetenv
 ("LC_CTYPE");

668 
	`unsetenv
 ("LC_MESSAGES");

669 
	`setenv
 ("LANG", "C", 1);

670 
name
 = 
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES");

671 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

675 
	`unsetenv
 ("LC_ALL");

676 
	`unsetenv
 ("LC_CTYPE");

677 
	`setenv
 ("LC_MESSAGES", "fr_FR.UTF-8", 1);

678 
	`setenv
 ("LANG", "de_DE.UTF-8", 1);

679 
name
 = 
	`gl_locale_name_environ
 (
LC_CTYPE
, "LC_CTYPE");

680 
	`ASSERT
 (
	`strcmp
 (
name
, "de_DE.UTF-8") == 0);

681 
name
 = 
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES");

682 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

684 
	`unsetenv
 ("LC_ALL");

685 
	`unsetenv
 ("LC_CTYPE");

686 
	`setenv
 ("LC_MESSAGES", "fr_FR.UTF-8", 1);

687 
	`unsetenv
 ("LANG");

688 
name
 = 
	`gl_locale_name_environ
 (
LC_CTYPE
, "LC_CTYPE");

689 
	`ASSERT
 (
name
 == 
NULL
);

690 
name
 = 
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES");

691 
	`ASSERT
 (
	`strcmp
 (
name
, "fr_FR.UTF-8") == 0);

693 #if 
HAVE_NEWLOCALE


696 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, "fr_FR.UTF-8", 
NULL
);

697 if (
locale
 != 
NULL
)

699 
	`unsetenv
 ("LC_ALL");

700 
	`unsetenv
 ("LC_CTYPE");

701 
	`unsetenv
 ("LC_MESSAGES");

702 
	`setenv
 ("LANG", "C", 1);

703 
	`setlocale
 (
LC_ALL
, "");

704 
	`uselocale
 (
locale
);

705 
name
 = 
	`gl_locale_name_environ
 (
LC_MESSAGES
, "LC_MESSAGES");

706 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

710 
	}
}

714 
	$test_locale_name_default
 (void)

716 const char *
name
 = 
	`gl_locale_name_default
 ();

718 
	`ASSERT
 (
name
 != 
NULL
);

722 #if !((
defined
 
__APPLE__
 && defined 
__MACH__
) || (defined 
_WIN32
 || defined 
__WIN32__
 || defined 
__CYGWIN__
))

723 
	`ASSERT
 (
	`strcmp
 (
name
, "C") == 0);

726 #if 
HAVE_NEWLOCALE


729 
locale_t
 
locale
 = 
	`newlocale
 (
LC_ALL_MASK
, "fr_FR.UTF-8", 
NULL
);

730 if (
locale
 != 
NULL
)

732 
	`uselocale
 (
locale
);

733 
	`ASSERT
 (
	`strcmp
 (
	`gl_locale_name_default
 (), 
name
) == 0);

737 
	}
}

740 
	$main
 ()

742 
	`test_locale_name
 ();

743 
	`test_locale_name_thread
 ();

744 
	`test_locale_name_posix
 ();

745 
	`test_locale_name_environ
 ();

746 
	`test_locale_name_default
 ();

749 
	}
}

	@gnulib-tests/test-lock.c

21 #include 
	~<config.h
>

23 #if 
USE_POSIX_THREADS
 || 
USE_SOLARIS_THREADS
 || 
USE_PTH_THREADS
 || 
USE_WIN32_THREADS


25 #if 
USE_POSIX_THREADS


26 #define 
	#TEST_POSIX_THREADS
 1

	)

28 #if 
USE_SOLARIS_THREADS


29 #define 
	#TEST_SOLARIS_THREADS
 1

	)

31 #if 
USE_PTH_THREADS


32 #define 
	#TEST_PTH_THREADS
 1

	)

34 #if 
USE_WIN32_THREADS


35 #define 
	#TEST_WIN32_THREADS
 1

	)

41 #define 
	#ENABLE_LOCKING
 1

	)

46 #define 
	#DO_TEST_LOCK
 1

	)

47 #define 
	#DO_TEST_RWLOCK
 1

	)

48 #define 
	#DO_TEST_RECURSIVE_LOCK
 1

	)

49 #define 
	#DO_TEST_ONCE
 1

	)

53 #define 
	#EXPLICIT_YIELD
 1

	)

56 #define 
	#ENABLE_DEBUGGING
 0

	)

59 #define 
	#THREAD_COUNT
 10

	)

64 #define 
	#REPEAT_COUNT
 50000

	)

66 #include 
	~<stdio.h
>

67 #include 
	~<stdlib.h
>

68 #include 
	~<string.h
>

70 #if !
ENABLE_LOCKING


71 #undef 
USE_POSIX_THREADS


72 #undef 
USE_SOLARIS_THREADS


73 #undef 
USE_PTH_THREADS


74 #undef 
USE_WIN32_THREADS


76 #include 
	~"glthread/lock.h
"

78 #if !
ENABLE_LOCKING


79 #if 
TEST_POSIX_THREADS


80 #define 
	#USE_POSIX_THREADS
 1

	)

82 #if 
TEST_SOLARIS_THREADS


83 #define 
	#USE_SOLARIS_THREADS
 1

	)

85 #if 
TEST_PTH_THREADS


86 #define 
	#USE_PTH_THREADS
 1

	)

88 #if 
TEST_WIN32_THREADS


89 #define 
	#USE_WIN32_THREADS
 1

	)

93 #include 
	~"glthread/thread.h
"

94 #include 
	~"glthread/yield.h
"

96 #if 
ENABLE_DEBUGGING


97 #define 
	#dbgprintf
 
printf


	)

99 #define 
	#dbgprintf
 if (0) 
printf


	)

102 #if 
EXPLICIT_YIELD


103 #define 
	#yield
() 
	`gl_thread_yield
 ()

	)

105 #define 
	#yield
()

	)

108 #define 
	#ACCOUNT_COUNT
 4

	)

110 static int 
	gaccount
[
ACCOUNT_COUNT
];

113 
	$random_account
 (void)

115 return ((unsigned int) 
	`rand
 () >> 3) % 
ACCOUNT_COUNT
;

116 
	}
}

119 
	$check_accounts
 (void)

121 int 
i
, 
sum
;

123 
sum
 = 0;

124 for (
i
 = 0; i < 
ACCOUNT_COUNT
; i++)

125 
sum
 += 
account
[
i
];

126 if (
sum
 != 
ACCOUNT_COUNT
 * 1000)

127 
	`abort
 ();

128 
	}
}

137 
	$gl_lock_define_initialized
(static, 
my_lock
)

140 
	$lock_mutator_thread
 (void *
arg
)

142 int 
repeat
;

144 for (
repeat
 = 
REPEAT_COUNT
; repeat > 0; repeat--)

146 int 
i1
, 
i2
, 
value
;

148 
	`dbgprintf
 ("Mutator %p before lock\n", 
	`gl_thread_self_pointer
 ());

149 
	`gl_lock_lock
 (
my_lock
);

150 
	`dbgprintf
 ("Mutator %p after lock\n", 
	`gl_thread_self_pointer
 ());

152 
i1
 = 
	`random_account
 ();

153 
i2
 = 
	`random_account
 ();

154 
value
 = ((unsigned int) 
	`rand
 () >> 3) % 10;

155 
account
[
i1
] += 
value
;

156 
account
[
i2
] -= 
value
;

158 
	`dbgprintf
 ("Mutator %p before unlock\n", 
	`gl_thread_self_pointer
 ());

159 
	`gl_lock_unlock
 (
my_lock
);

160 
	`dbgprintf
 ("Mutator %p after unlock\n", 
	`gl_thread_self_pointer
 ());

162 
	`dbgprintf
 ("Mutator %p before check lock\n", 
	`gl_thread_self_pointer
 ());

163 
	`gl_lock_lock
 (
my_lock
);

164 
	`check_accounts
 ();

165 
	`gl_lock_unlock
 (
my_lock
);

166 
	`dbgprintf
 ("Mutator %p after check unlock\n", 
	`gl_thread_self_pointer
 ());

168 
	`yield
 ();

171 
	`dbgprintf
 ("Mutator %p dying.\n", 
	`gl_thread_self_pointer
 ());

172 return 
NULL
;

173 
	}
}

175 static volatile int 
	glock_checker_done
;

178 
	$lock_checker_thread
 (void *
arg
)

180 while (!
lock_checker_done
)

182 
	`dbgprintf
 ("Checker %p before check lock\n", 
	`gl_thread_self_pointer
 ());

183 
	`gl_lock_lock
 (
my_lock
);

184 
	`check_accounts
 ();

185 
	`gl_lock_unlock
 (
my_lock
);

186 
	`dbgprintf
 ("Checker %p after check unlock\n", 
	`gl_thread_self_pointer
 ());

188 
	`yield
 ();

191 
	`dbgprintf
 ("Checker %p dying.\n", 
	`gl_thread_self_pointer
 ());

192 return 
NULL
;

193 
	}
}

196 
	$test_lock
 (void)

198 int 
i
;

199 
gl_thread_t
 
checkerthread
;

200 
gl_thread_t
 
threads
[
THREAD_COUNT
];

203 for (
i
 = 0; i < 
ACCOUNT_COUNT
; i++)

204 
account
[
i
] = 1000;

205 
lock_checker_done
 = 0;

208 
checkerthread
 = 
	`gl_thread_create
 (
lock_checker_thread
, 
NULL
);

209 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

210 
threads
[
i
] = 
	`gl_thread_create
 (
lock_mutator_thread
, 
NULL
);

213 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

214 
	`gl_thread_join
 (
threads
[
i
], 
NULL
);

215 
lock_checker_done
 = 1;

216 
	`gl_thread_join
 (
checkerthread
, 
NULL
);

217 
	`check_accounts
 ();

218 
	}
}

227 
	$gl_rwlock_define_initialized
(static, 
my_rwlock
)

230 
	$rwlock_mutator_thread
 (void *
arg
)

232 int 
repeat
;

234 for (
repeat
 = 
REPEAT_COUNT
; repeat > 0; repeat--)

236 int 
i1
, 
i2
, 
value
;

238 
	`dbgprintf
 ("Mutator %p before wrlock\n", 
	`gl_thread_self_pointer
 ());

239 
	`gl_rwlock_wrlock
 (
my_rwlock
);

240 
	`dbgprintf
 ("Mutator %p after wrlock\n", 
	`gl_thread_self_pointer
 ());

242 
i1
 = 
	`random_account
 ();

243 
i2
 = 
	`random_account
 ();

244 
value
 = ((unsigned int) 
	`rand
 () >> 3) % 10;

245 
account
[
i1
] += 
value
;

246 
account
[
i2
] -= 
value
;

248 
	`dbgprintf
 ("Mutator %p before unlock\n", 
	`gl_thread_self_pointer
 ());

249 
	`gl_rwlock_unlock
 (
my_rwlock
);

250 
	`dbgprintf
 ("Mutator %p after unlock\n", 
	`gl_thread_self_pointer
 ());

252 
	`yield
 ();

255 
	`dbgprintf
 ("Mutator %p dying.\n", 
	`gl_thread_self_pointer
 ());

256 return 
NULL
;

257 
	}
}

259 static volatile int 
	grwlock_checker_done
;

262 
	$rwlock_checker_thread
 (void *
arg
)

264 while (!
rwlock_checker_done
)

266 
	`dbgprintf
 ("Checker %p before check rdlock\n", 
	`gl_thread_self_pointer
 ());

267 
	`gl_rwlock_rdlock
 (
my_rwlock
);

268 
	`check_accounts
 ();

269 
	`gl_rwlock_unlock
 (
my_rwlock
);

270 
	`dbgprintf
 ("Checker %p after check unlock\n", 
	`gl_thread_self_pointer
 ());

272 
	`yield
 ();

275 
	`dbgprintf
 ("Checker %p dying.\n", 
	`gl_thread_self_pointer
 ());

276 return 
NULL
;

277 
	}
}

280 
	$test_rwlock
 (void)

282 int 
i
;

283 
gl_thread_t
 
checkerthreads
[
THREAD_COUNT
];

284 
gl_thread_t
 
threads
[
THREAD_COUNT
];

287 for (
i
 = 0; i < 
ACCOUNT_COUNT
; i++)

288 
account
[
i
] = 1000;

289 
rwlock_checker_done
 = 0;

292 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

293 
checkerthreads
[
i
] = 
	`gl_thread_create
 (
rwlock_checker_thread
, 
NULL
);

294 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

295 
threads
[
i
] = 
	`gl_thread_create
 (
rwlock_mutator_thread
, 
NULL
);

298 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

299 
	`gl_thread_join
 (
threads
[
i
], 
NULL
);

300 
rwlock_checker_done
 = 1;

301 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

302 
	`gl_thread_join
 (
checkerthreads
[
i
], 
NULL
);

303 
	`check_accounts
 ();

304 
	}
}

313 
	$gl_recursive_lock_define_initialized
(static, 
my_reclock
)

316 
	$recshuffle
 (void)

318 int 
i1
, 
i2
, 
value
;

320 
	`dbgprintf
 ("Mutator %p before lock\n", 
	`gl_thread_self_pointer
 ());

321 
	`gl_recursive_lock_lock
 (
my_reclock
);

322 
	`dbgprintf
 ("Mutator %p after lock\n", 
	`gl_thread_self_pointer
 ());

324 
i1
 = 
	`random_account
 ();

325 
i2
 = 
	`random_account
 ();

326 
value
 = ((unsigned int) 
	`rand
 () >> 3) % 10;

327 
account
[
i1
] += 
value
;

328 
account
[
i2
] -= 
value
;

331 if (((unsigned int) 
	`rand
 () >> 3) % 2)

332 
	`recshuffle
 ();

334 
	`dbgprintf
 ("Mutator %p before unlock\n", 
	`gl_thread_self_pointer
 ());

335 
	`gl_recursive_lock_unlock
 (
my_reclock
);

336 
	`dbgprintf
 ("Mutator %p after unlock\n", 
	`gl_thread_self_pointer
 ());

337 
	}
}

340 
	$reclock_mutator_thread
 (void *
arg
)

342 int 
repeat
;

344 for (
repeat
 = 
REPEAT_COUNT
; repeat > 0; repeat--)

346 
	`recshuffle
 ();

348 
	`dbgprintf
 ("Mutator %p before check lock\n", 
	`gl_thread_self_pointer
 ());

349 
	`gl_recursive_lock_lock
 (
my_reclock
);

350 
	`check_accounts
 ();

351 
	`gl_recursive_lock_unlock
 (
my_reclock
);

352 
	`dbgprintf
 ("Mutator %p after check unlock\n", 
	`gl_thread_self_pointer
 ());

354 
	`yield
 ();

357 
	`dbgprintf
 ("Mutator %p dying.\n", 
	`gl_thread_self_pointer
 ());

358 return 
NULL
;

359 
	}
}

361 static volatile int 
	greclock_checker_done
;

364 
	$reclock_checker_thread
 (void *
arg
)

366 while (!
reclock_checker_done
)

368 
	`dbgprintf
 ("Checker %p before check lock\n", 
	`gl_thread_self_pointer
 ());

369 
	`gl_recursive_lock_lock
 (
my_reclock
);

370 
	`check_accounts
 ();

371 
	`gl_recursive_lock_unlock
 (
my_reclock
);

372 
	`dbgprintf
 ("Checker %p after check unlock\n", 
	`gl_thread_self_pointer
 ());

374 
	`yield
 ();

377 
	`dbgprintf
 ("Checker %p dying.\n", 
	`gl_thread_self_pointer
 ());

378 return 
NULL
;

379 
	}
}

382 
	$test_recursive_lock
 (void)

384 int 
i
;

385 
gl_thread_t
 
checkerthread
;

386 
gl_thread_t
 
threads
[
THREAD_COUNT
];

389 for (
i
 = 0; i < 
ACCOUNT_COUNT
; i++)

390 
account
[
i
] = 1000;

391 
reclock_checker_done
 = 0;

394 
checkerthread
 = 
	`gl_thread_create
 (
reclock_checker_thread
, 
NULL
);

395 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

396 
threads
[
i
] = 
	`gl_thread_create
 (
reclock_mutator_thread
, 
NULL
);

399 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

400 
	`gl_thread_join
 (
threads
[
i
], 
NULL
);

401 
reclock_checker_done
 = 1;

402 
	`gl_thread_join
 (
checkerthread
, 
NULL
);

403 
	`check_accounts
 ();

404 
	}
}

412 
	$gl_once_define
(static, 
fresh_once
)

413 static int 
ready
[
THREAD_COUNT
];

414 static 
gl_lock_t
 
ready_lock
[
THREAD_COUNT
];

415 #if 
ENABLE_LOCKING


416 static 
gl_rwlock_t
 
fire_signal
[
REPEAT_COUNT
];

418 static volatile int 
fire_signal_state
;

420 static 
gl_once_t
 
once_control
;

421 static int 
performed
;

422 
	$gl_lock_define_initialized
(static, 
performed_lock
)

425 
	$once_execute
 (void)

427 
	`gl_lock_lock
 (
performed_lock
);

428 
performed
++;

429 
	`gl_lock_unlock
 (
performed_lock
);

430 
	}
}

433 
	$once_contender_thread
 (void *
arg
)

435 int 
id
 = (int) (long) 
arg
;

436 int 
repeat
;

438 for (
repeat
 = 0; repeat <= 
REPEAT_COUNT
; repeat++)

441 
	`gl_lock_lock
 (
ready_lock
[
id
]);

442 
ready
[
id
] = 1;

443 
	`gl_lock_unlock
 (
ready_lock
[
id
]);

445 if (
repeat
 == 
REPEAT_COUNT
)

448 
	`dbgprintf
 ("Contender %p waiting for signal for round %d\n",

449 
	`gl_thread_self_pointer
 (), 
repeat
);

450 #if 
ENABLE_LOCKING


452 
	`gl_rwlock_rdlock
 (
fire_signal
[
repeat
]);

454 
	`gl_rwlock_unlock
 (
fire_signal
[
repeat
]);

457 while (
fire_signal_state
 <= 
repeat
)

458 
	`yield
 ();

460 
	`dbgprintf
 ("Contender %p got the signal for round %d\n",

461 
	`gl_thread_self_pointer
 (), 
repeat
);

464 
	`gl_once
 (
once_control
, 
once_execute
);

467 return 
NULL
;

468 
	}
}

471 
	$test_once
 (void)

473 int 
i
, 
repeat
;

474 
gl_thread_t
 
threads
[
THREAD_COUNT
];

477 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

479 
ready
[
i
] = 0;

480 
	`gl_lock_init
 (
ready_lock
[
i
]);

482 #if 
ENABLE_LOCKING


483 for (
i
 = 0; i < 
REPEAT_COUNT
; i++)

484 
	`gl_rwlock_init
 (
fire_signal
[
i
]);

486 
fire_signal_state
 = 0;

490 for (
i
 = 
REPEAT_COUNT
-1; i >= 0; i--)

491 
	`gl_rwlock_wrlock
 (
fire_signal
[
i
]);

494 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

495 
threads
[
i
] = 
	`gl_thread_create
 (
once_contender_thread
, (void *) (long) i);

497 for (
repeat
 = 0; repeat <= 
REPEAT_COUNT
; repeat++)

500 
	`dbgprintf
 ("Main thread before synchonizing for round %d\n", 
repeat
);

503 int 
ready_count
 = 0;

504 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

506 
	`gl_lock_lock
 (
ready_lock
[
i
]);

507 
ready_count
 += 
ready
[
i
];

508 
	`gl_lock_unlock
 (
ready_lock
[
i
]);

510 if (
ready_count
 == 
THREAD_COUNT
)

512 
	`yield
 ();

514 
	`dbgprintf
 ("Main thread after synchonizing for round %d\n", 
repeat
);

516 if (
repeat
 > 0)

520 if (
performed
 != 1)

521 
	`abort
 ();

524 if (
repeat
 == 
REPEAT_COUNT
)

528 
	`memcpy
 (&
once_control
, &
fresh_once
, sizeof (
gl_once_t
));

531 
performed
 = 0;

534 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

536 
	`gl_lock_lock
 (
ready_lock
[
i
]);

537 
ready
[
i
] = 0;

538 
	`gl_lock_unlock
 (
ready_lock
[
i
]);

542 
	`dbgprintf
 ("Main thread giving signal for round %d\n", 
repeat
);

543 #if 
ENABLE_LOCKING


544 
	`gl_rwlock_unlock
 (
fire_signal
[
repeat
]);

546 
fire_signal_state
 = 
repeat
 + 1;

551 for (
i
 = 0; i < 
THREAD_COUNT
; i++)

552 
	`gl_thread_join
 (
threads
[
i
], 
NULL
);

553 
	}
}

559 
	$main
 ()

561 #if 
TEST_PTH_THREADS


562 if (!
	`pth_init
 ())

563 
	`abort
 ();

566 #if 
DO_TEST_LOCK


567 
	`printf
 ("Starting test_lock ..."); 
	`fflush
 (
stdout
);

568 
	`test_lock
 ();

569 
	`printf
 (" OK\n"); 
	`fflush
 (
stdout
);

571 #if 
DO_TEST_RWLOCK


572 
	`printf
 ("Starting test_rwlock ..."); 
	`fflush
 (
stdout
);

573 
	`test_rwlock
 ();

574 
	`printf
 (" OK\n"); 
	`fflush
 (
stdout
);

576 #if 
DO_TEST_RECURSIVE_LOCK


577 
	`printf
 ("Starting test_recursive_lock ..."); 
	`fflush
 (
stdout
);

578 
	`test_recursive_lock
 ();

579 
	`printf
 (" OK\n"); 
	`fflush
 (
stdout
);

581 #if 
DO_TEST_ONCE


582 
	`printf
 ("Starting test_once ..."); 
	`fflush
 (
stdout
);

583 
	`test_once
 ();

584 
	`printf
 (" OK\n"); 
	`fflush
 (
stdout
);

588 
	}
}

594 #include 
	~<stdio.h
>

597 
	$main
 ()

599 
	`fputs
 ("Skipping test: multithreading not enabled\n", 
stderr
);

601 
	}
}

	@gnulib-tests/test-lseek.c

21 #include 
	~<config.h
>

23 #include 
	~<unistd.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
lseek
, 
off_t
, (int, off_t, int));

28 #include 
	~<errno.h
>

30 #include 
	~"macros.h
"

36 
	$main
 (int 
argc
, char **
argv
)

38 if (
argc
 != 2)

40 switch (*
argv
[1])

43 
	`ASSERT
 (
	`lseek
 (0, (
off_t
)2, 
SEEK_SET
) == 2);

44 
	`ASSERT
 (
	`lseek
 (0, (
off_t
)-4, 
SEEK_CUR
) == -1);

45 
	`ASSERT
 (
errno
 == 
EINVAL
);

46 
errno
 = 0;

47 #if ! 
defined
 
__BEOS__


50 
	`ASSERT
 (
	`lseek
 (0, (
off_t
)0, 
SEEK_CUR
) == 2);

53 
	`ASSERT
 (
	`lseek
 (0, (
off_t
)0, (
SEEK_SET
 | 
SEEK_CUR
 | 
SEEK_END
) + 1) == -1);

54 
	`ASSERT
 (
errno
 == 
EINVAL
);

56 
	`ASSERT
 (
	`lseek
 (1, (
off_t
)2, 
SEEK_SET
) == 2);

57 
errno
 = 0;

58 
	`ASSERT
 (
	`lseek
 (1, (
off_t
)-4, 
SEEK_CUR
) == -1);

59 
	`ASSERT
 (
errno
 == 
EINVAL
);

60 
errno
 = 0;

61 #if ! 
defined
 
__BEOS__


64 
	`ASSERT
 (
	`lseek
 (1, (
off_t
)0, 
SEEK_CUR
) == 2);

67 
	`ASSERT
 (
	`lseek
 (1, (
off_t
)0, (
SEEK_SET
 | 
SEEK_CUR
 | 
SEEK_END
) + 1) == -1);

68 
	`ASSERT
 (
errno
 == 
EINVAL
);

73 
errno
 = 0;

74 
	`ASSERT
 (
	`lseek
 (0, (
off_t
)0, 
SEEK_CUR
) == -1);

75 
	`ASSERT
 (
errno
 == 
ESPIPE
);

76 
errno
 = 0;

77 
	`ASSERT
 (
	`lseek
 (1, (
off_t
)0, 
SEEK_CUR
) == -1);

78 
	`ASSERT
 (
errno
 == 
ESPIPE
);

84 
	`close
 (0);

85 
	`close
 (1);

87 
errno
 = 0;

88 
	`ASSERT
 (
	`lseek
 (0, (
off_t
)0, 
SEEK_CUR
) == -1);

89 
	`ASSERT
 (
errno
 == 
EBADF
);

91 
errno
 = 0;

92 
	`ASSERT
 (
	`lseek
 (1, (
off_t
)0, 
SEEK_CUR
) == -1);

93 
	`ASSERT
 (
errno
 == 
EBADF
);

96 
errno
 = 0;

97 
	`ASSERT
 (
	`lseek
 (-1, (
off_t
)0, 
SEEK_CUR
) == -1);

98 
	`ASSERT
 (
errno
 == 
EBADF
);

100 
errno
 = 0;

101 
	`ASSERT
 (
	`lseek
 (99, (
off_t
)0, 
SEEK_CUR
) == -1);

102 
	`ASSERT
 (
errno
 == 
EBADF
);

110 
	}
}

	@gnulib-tests/test-lstat.c

21 #include 
	~<config.h
>

23 #include 
	~<sys/stat.h
>

29 #include 
	~"signature.h
"

30 
SIGNATURE_CHECK
 (
lstat
, int, (char const *, struct 
stat
 *));

32 #include 
	~<fcntl.h
>

33 #include 
	~<errno.h
>

34 #include 
	~<stdbool.h
>

35 #include 
	~<stdio.h
>

36 #include 
	~<stdlib.h
>

37 #include 
	~<unistd.h
>

39 #include 
	~"same-inode.h
"

40 #include 
	~"ignore-value.h
"

41 #include 
	~"macros.h
"

43 #define 
	#BASE
 "test-lstat.t"

	)

45 #include 
	~"test-lstat.h
"

50 
	$do_lstat
 (char const *
name
, struct 
stat
 *
st
)

52 return 
	`lstat
 (
name
, 
st
);

53 
	}
}

56 
	$main
 (void)

59 
	`ignore_value
 (
	`system
 ("rm -rf " 
BASE
 "*"));

61 return 
	`test_lstat_func
 (
do_lstat
, 
true
);

62 
	}
}

	@gnulib-tests/test-lstat.h

28 
test_lstat_func
 (int (*
func
) (char const *, struct 
stat
 *), 
bool
 
print
)

30 struct 
stat
 
st1
;

31 struct 
stat
 
st2
;

34 
	`ASSERT
 (
	`func
 (".", &
st1
) == 0);

35 
	`ASSERT
 (
	`func
 ("./", &
st2
) == 0);

36 
	`ASSERT
 (
	`SAME_INODE
 (
st1
, 
st2
));

37 
	`ASSERT
 (
	`S_ISDIR
 (
st1
.
st_mode
));

38 
	`ASSERT
 (
	`S_ISDIR
 (
st2
.
st_mode
));

39 
	`ASSERT
 (
	`func
 ("/", &
st1
) == 0);

40 
	`ASSERT
 (
	`func
 ("///", &
st2
) == 0);

41 
	`ASSERT
 (
	`SAME_INODE
 (
st1
, 
st2
));

42 
	`ASSERT
 (
	`S_ISDIR
 (
st1
.
st_mode
));

43 
	`ASSERT
 (
	`S_ISDIR
 (
st2
.
st_mode
));

44 
	`ASSERT
 (
	`func
 ("..", &
st1
) == 0);

45 
	`ASSERT
 (
	`S_ISDIR
 (
st1
.
st_mode
));

48 
errno
 = 0;

49 
	`ASSERT
 (
	`func
 ("", &
st1
) == -1);

50 
	`ASSERT
 (
errno
 == 
ENOENT
);

51 
errno
 = 0;

52 
	`ASSERT
 (
	`func
 ("nosuch", &
st1
) == -1);

53 
	`ASSERT
 (
errno
 == 
ENOENT
);

54 
errno
 = 0;

55 
	`ASSERT
 (
	`func
 ("nosuch/", &
st1
) == -1);

56 
	`ASSERT
 (
errno
 == 
ENOENT
);

58 
	`ASSERT
 (
	`close
 (
	`creat
 (
BASE
 "file", 0600)) == 0);

59 
	`ASSERT
 (
	`func
 (
BASE
 "file", &
st1
) == 0);

60 
	`ASSERT
 (
	`S_ISREG
 (
st1
.
st_mode
));

61 
errno
 = 0;

62 
	`ASSERT
 (
	`func
 (
BASE
 "file/", &
st1
) == -1);

63 
	`ASSERT
 (
errno
 == 
ENOTDIR
);

72 if (
	`symlink
 (".", 
BASE
 "link1") != 0)

74 
	`ASSERT
 (
	`unlink
 (
BASE
 "file") == 0);

75 if (
print
)

76 
	`fputs
 ("skipping test: symlinks not supported on this file system\n",

77 
stderr
);

80 
	`ASSERT
 (
	`symlink
 (
BASE
 "file", BASE "link2") == 0);

81 
	`ASSERT
 (
	`symlink
 (
BASE
 "nosuch", BASE "link3") == 0);

82 
	`ASSERT
 (
	`symlink
 (
BASE
 "link4", BASE "link4") == 0);

84 
	`ASSERT
 (
	`func
 (
BASE
 "link1", &
st1
) == 0);

85 
	`ASSERT
 (
	`S_ISLNK
 (
st1
.
st_mode
));

86 
	`ASSERT
 (
	`func
 (
BASE
 "link1/", &
st1
) == 0);

87 
	`ASSERT
 (
	`stat
 (
BASE
 "link1", &
st2
) == 0);

88 
	`ASSERT
 (
	`S_ISDIR
 (
st1
.
st_mode
));

89 
	`ASSERT
 (
	`S_ISDIR
 (
st2
.
st_mode
));

90 
	`ASSERT
 (
	`SAME_INODE
 (
st1
, 
st2
));

92 
	`ASSERT
 (
	`func
 (
BASE
 "link2", &
st1
) == 0);

93 
	`ASSERT
 (
	`S_ISLNK
 (
st1
.
st_mode
));

94 
errno
 = 0;

95 
	`ASSERT
 (
	`func
 (
BASE
 "link2/", &
st1
) == -1);

96 
	`ASSERT
 (
errno
 == 
ENOTDIR
);

98 
	`ASSERT
 (
	`func
 (
BASE
 "link3", &
st1
) == 0);

99 
	`ASSERT
 (
	`S_ISLNK
 (
st1
.
st_mode
));

100 
errno
 = 0;

101 
	`ASSERT
 (
	`func
 (
BASE
 "link3/", &
st1
) == -1);

102 
	`ASSERT
 (
errno
 == 
ENOENT
);

104 
	`ASSERT
 (
	`func
 (
BASE
 "link4", &
st1
) == 0);

105 
	`ASSERT
 (
	`S_ISLNK
 (
st1
.
st_mode
));

106 
errno
 = 0;

107 
	`ASSERT
 (
	`func
 (
BASE
 "link4/", &
st1
) == -1);

108 
	`ASSERT
 (
errno
 == 
ELOOP
);

111 
	`ASSERT
 (
	`unlink
 (
BASE
 "file") == 0);

112 
	`ASSERT
 (
	`unlink
 (
BASE
 "link1") == 0);

113 
	`ASSERT
 (
	`unlink
 (
BASE
 "link2") == 0);

114 
	`ASSERT
 (
	`unlink
 (
BASE
 "link3") == 0);

115 
	`ASSERT
 (
	`unlink
 (
BASE
 "link4") == 0);

118 
	}
}

	@gnulib-tests/test-malloc-gnu.c

19 #include 
	~<config.h
>

21 #include 
	~<stdlib.h
>

24 
	$main
 ()

27 if (
	`malloc
 (0) == 
NULL
)

31 
	}
}

	@gnulib-tests/test-malloca.c

21 #include 
	~<config.h
>

23 #include 
	~"malloca.h
"

25 #include 
	~<stdlib.h
>

28 
	$do_allocation
 (int 
n
)

30 void *
ptr
 = 
	`malloca
 (
n
);

31 
	`freea
 (
ptr
);

32 
	`safe_alloca
 (
n
);

33 
	}
}

35 void (*
func
) (int) = 
do_allocation
;

38 
	$main
 ()

40 int 
i
;

43 
	`unsetenv
 ("MALLOC_PERTURB_");

46 for (
i
 = 0; i < 50000; i++)

51 
	`func
 (34);

52 
	`func
 (134);

53 
	`func
 (399);

54 
	`func
 (510823);

55 
	`func
 (129321);

56 
	`func
 (0);

57 
	`func
 (4070);

58 
	`func
 (4095);

59 
	`func
 (1);

60 
	`func
 (16582);

64 
	}
}

	@gnulib-tests/test-mbrtowc-w32.c

19 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #include 
	~<errno.h
>

24 #include 
	~<locale.h
>

25 #include 
	~<stdio.h
>

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

29 #include 
	~"macros.h
"

31 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && !defined 
__CYGWIN__


34 
	$test_one_locale
 (const char *
name
, int 
codepage
)

36 
mbstate_t
 
state
;

37 
wchar_t
 
wc
;

38 
size_t
 
ret
;

43 char 
name_with_codepage
[1024];

45 
	`sprintf
 (
name_with_codepage
, "%s.%d", 
name
, 
codepage
);

48 if (
	`setlocale
 (
LC_ALL
, 
name_with_codepage
) == 
NULL
)

57 extern 
	`__declspec
(
dllimport
) unsigned int 
__lc_codepage
;

60 if (
	`setlocale
 (
LC_ALL
, 
name
) == 
NULL
)

64 
__lc_codepage
 = 
codepage
;

65 switch (
codepage
)

69 
MB_CUR_MAX
 = 1;

74 
MB_CUR_MAX
 = 2;

78 
MB_CUR_MAX
 = 4;

83 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

84 if (
	`mbrtowc
 (&
wc
, " ", 1, &
state
) == (
size_t
)(-1))

91 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

92 
wc
 = (
wchar_t
) 0xBADFACE;

93 
ret
 = 
	`mbrtowc
 (&
wc
, "x", 0, &
state
);

97 
	`ASSERT
 (
ret
 == (
size_t
)(-2) || ret == (size_t)(-1) || ret == 0);

98 
	`ASSERT
 (
	`mbsinit
 (&
state
));

103 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

104 
wc
 = (
wchar_t
) 0xBADFACE;

105 
ret
 = 
	`mbrtowc
 (&
wc
, "", 1, &
state
);

106 
	`ASSERT
 (
ret
 == 0);

107 
	`ASSERT
 (
wc
 == 0);

108 
	`ASSERT
 (
	`mbsinit
 (&
state
));

109 
ret
 = 
	`mbrtowc
 (
NULL
, "", 1, &
state
);

110 
	`ASSERT
 (
ret
 == 0);

111 
	`ASSERT
 (
	`mbsinit
 (&
state
));

116 int 
c
;

117 char 
buf
[1];

119 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

120 for (
c
 = 0; c < 0x100; c++)

121 switch (
c
)

145 
buf
[0] = 
c
;

146 
wc
 = (
wchar_t
) 0xBADFACE;

147 
ret
 = 
	`mbrtowc
 (&
wc
, 
buf
, 1, &
state
);

148 
	`ASSERT
 (
ret
 == 1);

149 
	`ASSERT
 (
wc
 == 
c
);

150 
	`ASSERT
 (
	`mbsinit
 (&
state
));

151 
ret
 = 
	`mbrtowc
 (
NULL
, 
buf
, 1, &
state
);

152 
	`ASSERT
 (
ret
 == 1);

153 
	`ASSERT
 (
	`mbsinit
 (&
state
));

160 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

161 
wc
 = (
wchar_t
) 0xBADFACE;

162 
ret
 = 
	`mbrtowc
 (&
wc
, 
NULL
, 5, &
state
);

163 
	`ASSERT
 (
ret
 == 0);

164 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

165 
	`ASSERT
 (
	`mbsinit
 (&
state
));

168 switch (
codepage
)

173 char 
input
[] = "B\374\337er";

174 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

176 
wc
 = (
wchar_t
) 0xBADFACE;

177 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

178 
	`ASSERT
 (
ret
 == 1);

179 
	`ASSERT
 (
wc
 == 'B');

180 
	`ASSERT
 (
	`mbsinit
 (&
state
));

181 
input
[0] = '\0';

183 
wc
 = (
wchar_t
) 0xBADFACE;

184 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

185 
	`ASSERT
 (
ret
 == 1);

186 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\374');

187 
	`ASSERT
 (
wc
 == 0x00FC);

188 
	`ASSERT
 (
	`mbsinit
 (&
state
));

189 
input
[1] = '\0';

192 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 2, 3, &
state
);

193 
	`ASSERT
 (
ret
 == 1);

194 
	`ASSERT
 (
	`mbsinit
 (&
state
));

196 
wc
 = (
wchar_t
) 0xBADFACE;

197 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 2, 3, &
state
);

198 
	`ASSERT
 (
ret
 == 1);

199 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\337');

200 
	`ASSERT
 (
wc
 == 0x00DF);

201 
	`ASSERT
 (
	`mbsinit
 (&
state
));

202 
input
[2] = '\0';

204 
wc
 = (
wchar_t
) 0xBADFACE;

205 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 2, &
state
);

206 
	`ASSERT
 (
ret
 == 1);

207 
	`ASSERT
 (
wc
 == 'e');

208 
	`ASSERT
 (
	`mbsinit
 (&
state
));

209 
input
[3] = '\0';

211 
wc
 = (
wchar_t
) 0xBADFACE;

212 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 4, 1, &
state
);

213 
	`ASSERT
 (
ret
 == 1);

214 
	`ASSERT
 (
wc
 == 'r');

215 
	`ASSERT
 (
	`mbsinit
 (&
state
));

222 char 
input
[] = "x\302\341\346y";

223 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

225 
wc
 = (
wchar_t
) 0xBADFACE;

226 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

227 
	`ASSERT
 (
ret
 == 1);

228 
	`ASSERT
 (
wc
 == 'x');

229 
	`ASSERT
 (
	`mbsinit
 (&
state
));

230 
input
[0] = '\0';

232 
wc
 = (
wchar_t
) 0xBADFACE;

233 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

234 
	`ASSERT
 (
ret
 == 1);

235 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\302');

236 
	`ASSERT
 (
wc
 == 0x0622);

237 
	`ASSERT
 (
	`mbsinit
 (&
state
));

238 
input
[1] = '\0';

241 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 2, 3, &
state
);

242 
	`ASSERT
 (
ret
 == 1);

243 
	`ASSERT
 (
	`mbsinit
 (&
state
));

245 
wc
 = (
wchar_t
) 0xBADFACE;

246 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 2, 3, &
state
);

247 
	`ASSERT
 (
ret
 == 1);

248 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\341');

249 
	`ASSERT
 (
wc
 == 0x0644);

250 
	`ASSERT
 (
	`mbsinit
 (&
state
));

251 
input
[2] = '\0';

253 
wc
 = (
wchar_t
) 0xBADFACE;

254 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 2, &
state
);

255 
	`ASSERT
 (
ret
 == 1);

256 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\346');

257 
	`ASSERT
 (
wc
 == 0x0648);

258 
	`ASSERT
 (
	`mbsinit
 (&
state
));

259 
input
[3] = '\0';

261 
wc
 = (
wchar_t
) 0xBADFACE;

262 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 4, 1, &
state
);

263 
	`ASSERT
 (
ret
 == 1);

264 
	`ASSERT
 (
wc
 == 'y');

265 
	`ASSERT
 (
	`mbsinit
 (&
state
));

272 char 
input
[] = "<\223\372\226\173\214\352>";

273 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

275 
wc
 = (
wchar_t
) 0xBADFACE;

276 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

277 
	`ASSERT
 (
ret
 == 1);

278 
	`ASSERT
 (
wc
 == '<');

279 
	`ASSERT
 (
	`mbsinit
 (&
state
));

280 
input
[0] = '\0';

282 
wc
 = (
wchar_t
) 0xBADFACE;

283 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 2, &
state
);

284 
	`ASSERT
 (
ret
 == 2);

285 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

286 
	`ASSERT
 (
wc
 == 0x65E5);

287 
	`ASSERT
 (
	`mbsinit
 (&
state
));

288 
input
[1] = '\0';

289 
input
[2] = '\0';

291 
wc
 = (
wchar_t
) 0xBADFACE;

292 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 1, &
state
);

293 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

294 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

295 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

296 
input
[3] = '\0';

298 
wc
 = (
wchar_t
) 0xBADFACE;

299 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 4, 4, &
state
);

300 
	`ASSERT
 (
ret
 == 1);

301 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

302 
	`ASSERT
 (
wc
 == 0x672C);

303 
	`ASSERT
 (
	`mbsinit
 (&
state
));

304 
input
[4] = '\0';

307 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 5, 3, &
state
);

308 
	`ASSERT
 (
ret
 == 2);

309 
	`ASSERT
 (
	`mbsinit
 (&
state
));

311 
wc
 = (
wchar_t
) 0xBADFACE;

312 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 5, 3, &
state
);

313 
	`ASSERT
 (
ret
 == 2);

314 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

315 
	`ASSERT
 (
wc
 == 0x8A9E);

316 
	`ASSERT
 (
	`mbsinit
 (&
state
));

317 
input
[5] = '\0';

318 
input
[6] = '\0';

320 
wc
 = (
wchar_t
) 0xBADFACE;

321 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 7, 1, &
state
);

322 
	`ASSERT
 (
ret
 == 1);

323 
	`ASSERT
 (
wc
 == '>');

324 
	`ASSERT
 (
	`mbsinit
 (&
state
));

327 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

328 
wc
 = (
wchar_t
) 0xBADFACE;

329 
ret
 = 
	`mbrtowc
 (&
wc
, "\377", 1, &
state
);

330 
	`ASSERT
 (
ret
 == (
size_t
)-1);

331 
	`ASSERT
 (
errno
 == 
EILSEQ
);

333 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

334 
wc
 = (
wchar_t
) 0xBADFACE;

335 
ret
 = 
	`mbrtowc
 (&
wc
, "\225\377", 2, &
state
);

336 
	`ASSERT
 (
ret
 == (
size_t
)-1);

337 
	`ASSERT
 (
errno
 == 
EILSEQ
);

344 char 
input
[] = "<\244\351\245\273\273\171>";

345 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

347 
wc
 = (
wchar_t
) 0xBADFACE;

348 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

349 
	`ASSERT
 (
ret
 == 1);

350 
	`ASSERT
 (
wc
 == '<');

351 
	`ASSERT
 (
	`mbsinit
 (&
state
));

352 
input
[0] = '\0';

354 
wc
 = (
wchar_t
) 0xBADFACE;

355 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 2, &
state
);

356 
	`ASSERT
 (
ret
 == 2);

357 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

358 
	`ASSERT
 (
wc
 == 0x65E5);

359 
	`ASSERT
 (
	`mbsinit
 (&
state
));

360 
input
[1] = '\0';

361 
input
[2] = '\0';

363 
wc
 = (
wchar_t
) 0xBADFACE;

364 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 1, &
state
);

365 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

366 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

367 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

368 
input
[3] = '\0';

370 
wc
 = (
wchar_t
) 0xBADFACE;

371 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 4, 4, &
state
);

372 
	`ASSERT
 (
ret
 == 1);

373 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

374 
	`ASSERT
 (
wc
 == 0x672C);

375 
	`ASSERT
 (
	`mbsinit
 (&
state
));

376 
input
[4] = '\0';

379 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 5, 3, &
state
);

380 
	`ASSERT
 (
ret
 == 2);

381 
	`ASSERT
 (
	`mbsinit
 (&
state
));

383 
wc
 = (
wchar_t
) 0xBADFACE;

384 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 5, 3, &
state
);

385 
	`ASSERT
 (
ret
 == 2);

386 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

387 
	`ASSERT
 (
wc
 == 0x8A9E);

388 
	`ASSERT
 (
	`mbsinit
 (&
state
));

389 
input
[5] = '\0';

390 
input
[6] = '\0';

392 
wc
 = (
wchar_t
) 0xBADFACE;

393 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 7, 1, &
state
);

394 
	`ASSERT
 (
ret
 == 1);

395 
	`ASSERT
 (
wc
 == '>');

396 
	`ASSERT
 (
	`mbsinit
 (&
state
));

399 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

400 
wc
 = (
wchar_t
) 0xBADFACE;

401 
ret
 = 
	`mbrtowc
 (&
wc
, "\377", 1, &
state
);

402 
	`ASSERT
 (
ret
 == (
size_t
)-1);

403 
	`ASSERT
 (
errno
 == 
EILSEQ
);

405 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

406 
wc
 = (
wchar_t
) 0xBADFACE;

407 
ret
 = 
	`mbrtowc
 (&
wc
, "\225\377", 2, &
state
);

408 
	`ASSERT
 (
ret
 == (
size_t
)-1);

409 
	`ASSERT
 (
errno
 == 
EILSEQ
);

416 char 
input
[] = "<\310\325\261\276\325\132>";

417 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

419 
wc
 = (
wchar_t
) 0xBADFACE;

420 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

421 
	`ASSERT
 (
ret
 == 1);

422 
	`ASSERT
 (
wc
 == '<');

423 
	`ASSERT
 (
	`mbsinit
 (&
state
));

424 
input
[0] = '\0';

426 
wc
 = (
wchar_t
) 0xBADFACE;

427 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 2, &
state
);

428 
	`ASSERT
 (
ret
 == 2);

429 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

430 
	`ASSERT
 (
wc
 == 0x65E5);

431 
	`ASSERT
 (
	`mbsinit
 (&
state
));

432 
input
[1] = '\0';

433 
input
[2] = '\0';

435 
wc
 = (
wchar_t
) 0xBADFACE;

436 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 1, &
state
);

437 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

438 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

439 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

440 
input
[3] = '\0';

442 
wc
 = (
wchar_t
) 0xBADFACE;

443 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 4, 4, &
state
);

444 
	`ASSERT
 (
ret
 == 1);

445 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

446 
	`ASSERT
 (
wc
 == 0x672C);

447 
	`ASSERT
 (
	`mbsinit
 (&
state
));

448 
input
[4] = '\0';

451 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 5, 3, &
state
);

452 
	`ASSERT
 (
ret
 == 2);

453 
	`ASSERT
 (
	`mbsinit
 (&
state
));

455 
wc
 = (
wchar_t
) 0xBADFACE;

456 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 5, 3, &
state
);

457 
	`ASSERT
 (
ret
 == 2);

458 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

459 
	`ASSERT
 (
wc
 == 0x8A9E);

460 
	`ASSERT
 (
	`mbsinit
 (&
state
));

461 
input
[5] = '\0';

462 
input
[6] = '\0';

464 
wc
 = (
wchar_t
) 0xBADFACE;

465 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 7, 1, &
state
);

466 
	`ASSERT
 (
ret
 == 1);

467 
	`ASSERT
 (
wc
 == '>');

468 
	`ASSERT
 (
	`mbsinit
 (&
state
));

471 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

472 
wc
 = (
wchar_t
) 0xBADFACE;

473 
ret
 = 
	`mbrtowc
 (&
wc
, "\377", 1, &
state
);

474 
	`ASSERT
 (
ret
 == (
size_t
)-1);

475 
	`ASSERT
 (
errno
 == 
EILSEQ
);

477 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

478 
wc
 = (
wchar_t
) 0xBADFACE;

479 
ret
 = 
	`mbrtowc
 (&
wc
, "\225\377", 2, &
state
);

480 
	`ASSERT
 (
ret
 == (
size_t
)-1);

481 
	`ASSERT
 (
errno
 == 
EILSEQ
);

488 char 
input
[] = "B\250\271\201\060\211\070er";

489 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

491 
wc
 = (
wchar_t
) 0xBADFACE;

492 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

493 
	`ASSERT
 (
ret
 == 1);

494 
	`ASSERT
 (
wc
 == 'B');

495 
	`ASSERT
 (
	`mbsinit
 (&
state
));

496 
input
[0] = '\0';

498 
wc
 = (
wchar_t
) 0xBADFACE;

499 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

500 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

501 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

502 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

503 
input
[1] = '\0';

505 
wc
 = (
wchar_t
) 0xBADFACE;

506 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 2, 7, &
state
);

507 
	`ASSERT
 (
ret
 == 1);

508 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

509 
	`ASSERT
 (
wc
 == 0x00FC);

510 
	`ASSERT
 (
	`mbsinit
 (&
state
));

511 
input
[2] = '\0';

514 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 3, 6, &
state
);

515 
	`ASSERT
 (
ret
 == 4);

516 
	`ASSERT
 (
	`mbsinit
 (&
state
));

518 
wc
 = (
wchar_t
) 0xBADFACE;

519 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 6, &
state
);

520 
	`ASSERT
 (
ret
 == 4);

521 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

522 
	`ASSERT
 (
wc
 == 0x00DF);

523 
	`ASSERT
 (
	`mbsinit
 (&
state
));

524 
input
[3] = '\0';

525 
input
[4] = '\0';

526 
input
[5] = '\0';

527 
input
[6] = '\0';

529 
wc
 = (
wchar_t
) 0xBADFACE;

530 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 7, 2, &
state
);

531 
	`ASSERT
 (
ret
 == 1);

532 
	`ASSERT
 (
wc
 == 'e');

533 
	`ASSERT
 (
	`mbsinit
 (&
state
));

534 
input
[5] = '\0';

536 
wc
 = (
wchar_t
) 0xBADFACE;

537 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 8, 1, &
state
);

538 
	`ASSERT
 (
ret
 == 1);

539 
	`ASSERT
 (
wc
 == 'r');

540 
	`ASSERT
 (
	`mbsinit
 (&
state
));

543 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

544 
wc
 = (
wchar_t
) 0xBADFACE;

545 
ret
 = 
	`mbrtowc
 (&
wc
, "\377", 1, &
state
);

546 
	`ASSERT
 (
ret
 == (
size_t
)-1);

547 
	`ASSERT
 (
errno
 == 
EILSEQ
);

549 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

550 
wc
 = (
wchar_t
) 0xBADFACE;

551 
ret
 = 
	`mbrtowc
 (&
wc
, "\225\377", 2, &
state
);

552 
	`ASSERT
 (
ret
 == (
size_t
)-1);

553 
	`ASSERT
 (
errno
 == 
EILSEQ
);

555 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

556 
wc
 = (
wchar_t
) 0xBADFACE;

557 
ret
 = 
	`mbrtowc
 (&
wc
, "\201\045", 2, &
state
);

558 
	`ASSERT
 (
ret
 == (
size_t
)-1);

559 
	`ASSERT
 (
errno
 == 
EILSEQ
);

561 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

562 
wc
 = (
wchar_t
) 0xBADFACE;

563 
ret
 = 
	`mbrtowc
 (&
wc
, "\201\060\377", 3, &
state
);

564 
	`ASSERT
 (
ret
 == (
size_t
)-1);

565 
	`ASSERT
 (
errno
 == 
EILSEQ
);

567 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

568 
wc
 = (
wchar_t
) 0xBADFACE;

569 
ret
 = 
	`mbrtowc
 (&
wc
, "\201\060\377\064", 4, &
state
);

570 
	`ASSERT
 (
ret
 == (
size_t
)-1);

571 
	`ASSERT
 (
errno
 == 
EILSEQ
);

573 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

574 
wc
 = (
wchar_t
) 0xBADFACE;

575 
ret
 = 
	`mbrtowc
 (&
wc
, "\201\060\211\072", 4, &
state
);

576 
	`ASSERT
 (
ret
 == (
size_t
)-1);

577 
	`ASSERT
 (
errno
 == 
EILSEQ
);

584 char 
input
[] = "B\303\274\303\237er";

585 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

587 
wc
 = (
wchar_t
) 0xBADFACE;

588 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

589 
	`ASSERT
 (
ret
 == 1);

590 
	`ASSERT
 (
wc
 == 'B');

591 
	`ASSERT
 (
	`mbsinit
 (&
state
));

592 
input
[0] = '\0';

594 
wc
 = (
wchar_t
) 0xBADFACE;

595 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

596 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

597 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

598 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

599 
input
[1] = '\0';

601 
wc
 = (
wchar_t
) 0xBADFACE;

602 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 2, 5, &
state
);

603 
	`ASSERT
 (
ret
 == 1);

604 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

605 
	`ASSERT
 (
wc
 == 0x00FC);

606 
	`ASSERT
 (
	`mbsinit
 (&
state
));

607 
input
[2] = '\0';

610 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 3, 4, &
state
);

611 
	`ASSERT
 (
ret
 == 2);

612 
	`ASSERT
 (
	`mbsinit
 (&
state
));

614 
wc
 = (
wchar_t
) 0xBADFACE;

615 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 4, &
state
);

616 
	`ASSERT
 (
ret
 == 2);

617 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

618 
	`ASSERT
 (
wc
 == 0x00DF);

619 
	`ASSERT
 (
	`mbsinit
 (&
state
));

620 
input
[3] = '\0';

621 
input
[4] = '\0';

623 
wc
 = (
wchar_t
) 0xBADFACE;

624 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 5, 2, &
state
);

625 
	`ASSERT
 (
ret
 == 1);

626 
	`ASSERT
 (
wc
 == 'e');

627 
	`ASSERT
 (
	`mbsinit
 (&
state
));

628 
input
[5] = '\0';

630 
wc
 = (
wchar_t
) 0xBADFACE;

631 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 6, 1, &
state
);

632 
	`ASSERT
 (
ret
 == 1);

633 
	`ASSERT
 (
wc
 == 'r');

634 
	`ASSERT
 (
	`mbsinit
 (&
state
));

637 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

638 
wc
 = (
wchar_t
) 0xBADFACE;

639 
ret
 = 
	`mbrtowc
 (&
wc
, "\377", 1, &
state
);

640 
	`ASSERT
 (
ret
 == (
size_t
)-1);

641 
	`ASSERT
 (
errno
 == 
EILSEQ
);

643 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

644 
wc
 = (
wchar_t
) 0xBADFACE;

645 
ret
 = 
	`mbrtowc
 (&
wc
, "\303\300", 2, &
state
);

646 
	`ASSERT
 (
ret
 == (
size_t
)-1);

647 
	`ASSERT
 (
errno
 == 
EILSEQ
);

649 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

650 
wc
 = (
wchar_t
) 0xBADFACE;

651 
ret
 = 
	`mbrtowc
 (&
wc
, "\343\300", 2, &
state
);

652 
	`ASSERT
 (
ret
 == (
size_t
)-1);

653 
	`ASSERT
 (
errno
 == 
EILSEQ
);

655 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

656 
wc
 = (
wchar_t
) 0xBADFACE;

657 
ret
 = 
	`mbrtowc
 (&
wc
, "\343\300\200", 3, &
state
);

658 
	`ASSERT
 (
ret
 == (
size_t
)-1);

659 
	`ASSERT
 (
errno
 == 
EILSEQ
);

661 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

662 
wc
 = (
wchar_t
) 0xBADFACE;

663 
ret
 = 
	`mbrtowc
 (&
wc
, "\343\200\300", 3, &
state
);

664 
	`ASSERT
 (
ret
 == (
size_t
)-1);

665 
	`ASSERT
 (
errno
 == 
EILSEQ
);

667 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

668 
wc
 = (
wchar_t
) 0xBADFACE;

669 
ret
 = 
	`mbrtowc
 (&
wc
, "\363\300", 2, &
state
);

670 
	`ASSERT
 (
ret
 == (
size_t
)-1);

671 
	`ASSERT
 (
errno
 == 
EILSEQ
);

673 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

674 
wc
 = (
wchar_t
) 0xBADFACE;

675 
ret
 = 
	`mbrtowc
 (&
wc
, "\363\300\200\200", 4, &
state
);

676 
	`ASSERT
 (
ret
 == (
size_t
)-1);

677 
	`ASSERT
 (
errno
 == 
EILSEQ
);

679 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

680 
wc
 = (
wchar_t
) 0xBADFACE;

681 
ret
 = 
	`mbrtowc
 (&
wc
, "\363\200\300", 3, &
state
);

682 
	`ASSERT
 (
ret
 == (
size_t
)-1);

683 
	`ASSERT
 (
errno
 == 
EILSEQ
);

685 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

686 
wc
 = (
wchar_t
) 0xBADFACE;

687 
ret
 = 
	`mbrtowc
 (&
wc
, "\363\200\300\200", 4, &
state
);

688 
	`ASSERT
 (
ret
 == (
size_t
)-1);

689 
	`ASSERT
 (
errno
 == 
EILSEQ
);

691 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

692 
wc
 = (
wchar_t
) 0xBADFACE;

693 
ret
 = 
	`mbrtowc
 (&
wc
, "\363\200\200\300", 4, &
state
);

694 
	`ASSERT
 (
ret
 == (
size_t
)-1);

695 
	`ASSERT
 (
errno
 == 
EILSEQ
);

702 
	}
}

705 
	$main
 (int 
argc
, char *
argv
[])

707 int 
codepage
 = 
	`atoi
 (
argv
[
argc
 - 1]);

708 int 
result
;

709 int 
i
;

711 
result
 = 77;

712 for (
i
 = 1; i < 
argc
 - 1; i++)

714 int 
ret
 = 
	`test_one_locale
 (
argv
[
i
], 
codepage
);

716 if (
ret
 != 77)

717 
result
 = 
ret
;

720 if (
result
 == 77)

722 
	`fprintf
 (
stderr
, "Skipping test: found no locale with codepage %d\n",

723 
codepage
);

725 return 
result
;

726 
	}
}

731 
	$main
 (int 
argc
, char *
argv
[])

733 
	`fputs
 ("Skipping test: not a native Windows system\n", 
stderr
);

735 
	}
}

	@gnulib-tests/test-mbrtowc.c

21 #include 
	~<config.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
mbrtowc
, 
size_t
, (
wchar_t
 *, char const *, size_t,

27 
mbstate_t
 *));

29 #include 
	~<locale.h
>

30 #include 
	~<stdio.h
>

31 #include 
	~<string.h
>

33 #include 
	~"macros.h
"

36 
	$main
 (int 
argc
, char *
argv
[])

38 
mbstate_t
 
state
;

39 
wchar_t
 
wc
;

40 
size_t
 
ret
;

43 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

48 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

49 
wc
 = (
wchar_t
) 0xBADFACE;

50 
ret
 = 
	`mbrtowc
 (&
wc
, "x", 0, &
state
);

54 
	`ASSERT
 (
ret
 == (
size_t
)(-2) || ret == (size_t)(-1) || ret == 0);

55 
	`ASSERT
 (
	`mbsinit
 (&
state
));

60 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

61 
wc
 = (
wchar_t
) 0xBADFACE;

62 
ret
 = 
	`mbrtowc
 (&
wc
, "", 1, &
state
);

63 
	`ASSERT
 (
ret
 == 0);

64 
	`ASSERT
 (
wc
 == 0);

65 
	`ASSERT
 (
	`mbsinit
 (&
state
));

66 
ret
 = 
	`mbrtowc
 (
NULL
, "", 1, &
state
);

67 
	`ASSERT
 (
ret
 == 0);

68 
	`ASSERT
 (
	`mbsinit
 (&
state
));

73 int 
c
;

74 char 
buf
[1];

76 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

77 for (
c
 = 0; c < 0x100; c++)

78 switch (
c
)

102 
buf
[0] = 
c
;

103 
wc
 = (
wchar_t
) 0xBADFACE;

104 
ret
 = 
	`mbrtowc
 (&
wc
, 
buf
, 1, &
state
);

105 
	`ASSERT
 (
ret
 == 1);

106 
	`ASSERT
 (
wc
 == 
c
);

107 
	`ASSERT
 (
	`mbsinit
 (&
state
));

108 
ret
 = 
	`mbrtowc
 (
NULL
, 
buf
, 1, &
state
);

109 
	`ASSERT
 (
ret
 == 1);

110 
	`ASSERT
 (
	`mbsinit
 (&
state
));

117 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

118 
wc
 = (
wchar_t
) 0xBADFACE;

119 
ret
 = 
	`mbrtowc
 (&
wc
, 
NULL
, 5, &
state
);

120 
	`ASSERT
 (
ret
 == 0);

121 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

122 
	`ASSERT
 (
	`mbsinit
 (&
state
));

125 if (
argc
 > 1)

126 switch (
argv
[1][0])

131 char 
input
[] = "B\374\337er";

132 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

134 
wc
 = (
wchar_t
) 0xBADFACE;

135 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

136 
	`ASSERT
 (
ret
 == 1);

137 
	`ASSERT
 (
wc
 == 'B');

138 
	`ASSERT
 (
	`mbsinit
 (&
state
));

139 
input
[0] = '\0';

141 
wc
 = (
wchar_t
) 0xBADFACE;

142 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

143 
	`ASSERT
 (
ret
 == 1);

144 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\374');

145 
	`ASSERT
 (
	`mbsinit
 (&
state
));

146 
input
[1] = '\0';

149 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 2, 3, &
state
);

150 
	`ASSERT
 (
ret
 == 1);

151 
	`ASSERT
 (
	`mbsinit
 (&
state
));

153 
wc
 = (
wchar_t
) 0xBADFACE;

154 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 2, 3, &
state
);

155 
	`ASSERT
 (
ret
 == 1);

156 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\337');

157 
	`ASSERT
 (
	`mbsinit
 (&
state
));

158 
input
[2] = '\0';

160 
wc
 = (
wchar_t
) 0xBADFACE;

161 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 2, &
state
);

162 
	`ASSERT
 (
ret
 == 1);

163 
	`ASSERT
 (
wc
 == 'e');

164 
	`ASSERT
 (
	`mbsinit
 (&
state
));

165 
input
[3] = '\0';

167 
wc
 = (
wchar_t
) 0xBADFACE;

168 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 4, 1, &
state
);

169 
	`ASSERT
 (
ret
 == 1);

170 
	`ASSERT
 (
wc
 == 'r');

171 
	`ASSERT
 (
	`mbsinit
 (&
state
));

178 char 
input
[] = "B\303\274\303\237er";

179 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

181 
wc
 = (
wchar_t
) 0xBADFACE;

182 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

183 
	`ASSERT
 (
ret
 == 1);

184 
	`ASSERT
 (
wc
 == 'B');

185 
	`ASSERT
 (
	`mbsinit
 (&
state
));

186 
input
[0] = '\0';

188 
wc
 = (
wchar_t
) 0xBADFACE;

189 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

190 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

191 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

192 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

193 
input
[1] = '\0';

195 
wc
 = (
wchar_t
) 0xBADFACE;

196 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 2, 5, &
state
);

197 
	`ASSERT
 (
ret
 == 1);

198 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

199 
	`ASSERT
 (
	`mbsinit
 (&
state
));

200 
input
[2] = '\0';

203 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 3, 4, &
state
);

204 
	`ASSERT
 (
ret
 == 2);

205 
	`ASSERT
 (
	`mbsinit
 (&
state
));

207 
wc
 = (
wchar_t
) 0xBADFACE;

208 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 4, &
state
);

209 
	`ASSERT
 (
ret
 == 2);

210 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

211 
	`ASSERT
 (
	`mbsinit
 (&
state
));

212 
input
[3] = '\0';

213 
input
[4] = '\0';

215 
wc
 = (
wchar_t
) 0xBADFACE;

216 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 5, 2, &
state
);

217 
	`ASSERT
 (
ret
 == 1);

218 
	`ASSERT
 (
wc
 == 'e');

219 
	`ASSERT
 (
	`mbsinit
 (&
state
));

220 
input
[5] = '\0';

222 
wc
 = (
wchar_t
) 0xBADFACE;

223 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 6, 1, &
state
);

224 
	`ASSERT
 (
ret
 == 1);

225 
	`ASSERT
 (
wc
 == 'r');

226 
	`ASSERT
 (
	`mbsinit
 (&
state
));

233 char 
input
[] = "<\306\374\313\334\270\354>";

234 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

236 
wc
 = (
wchar_t
) 0xBADFACE;

237 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

238 
	`ASSERT
 (
ret
 == 1);

239 
	`ASSERT
 (
wc
 == '<');

240 
	`ASSERT
 (
	`mbsinit
 (&
state
));

241 
input
[0] = '\0';

243 
wc
 = (
wchar_t
) 0xBADFACE;

244 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 2, &
state
);

245 
	`ASSERT
 (
ret
 == 2);

246 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

247 
	`ASSERT
 (
	`mbsinit
 (&
state
));

248 
input
[1] = '\0';

249 
input
[2] = '\0';

251 
wc
 = (
wchar_t
) 0xBADFACE;

252 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 1, &
state
);

253 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

254 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

255 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

256 
input
[3] = '\0';

258 
wc
 = (
wchar_t
) 0xBADFACE;

259 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 4, 4, &
state
);

260 
	`ASSERT
 (
ret
 == 1);

261 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

262 
	`ASSERT
 (
	`mbsinit
 (&
state
));

263 
input
[4] = '\0';

266 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 5, 3, &
state
);

267 
	`ASSERT
 (
ret
 == 2);

268 
	`ASSERT
 (
	`mbsinit
 (&
state
));

270 
wc
 = (
wchar_t
) 0xBADFACE;

271 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 5, 3, &
state
);

272 
	`ASSERT
 (
ret
 == 2);

273 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

274 
	`ASSERT
 (
	`mbsinit
 (&
state
));

275 
input
[5] = '\0';

276 
input
[6] = '\0';

278 
wc
 = (
wchar_t
) 0xBADFACE;

279 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 7, 1, &
state
);

280 
	`ASSERT
 (
ret
 == 1);

281 
	`ASSERT
 (
wc
 == '>');

282 
	`ASSERT
 (
	`mbsinit
 (&
state
));

289 char 
input
[] = "B\250\271\201\060\211\070er";

290 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

292 
wc
 = (
wchar_t
) 0xBADFACE;

293 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

294 
	`ASSERT
 (
ret
 == 1);

295 
	`ASSERT
 (
wc
 == 'B');

296 
	`ASSERT
 (
	`mbsinit
 (&
state
));

297 
input
[0] = '\0';

299 
wc
 = (
wchar_t
) 0xBADFACE;

300 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

301 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

302 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

303 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

304 
input
[1] = '\0';

306 
wc
 = (
wchar_t
) 0xBADFACE;

307 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 2, 7, &
state
);

308 
	`ASSERT
 (
ret
 == 1);

309 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

310 
	`ASSERT
 (
	`mbsinit
 (&
state
));

311 
input
[2] = '\0';

314 
ret
 = 
	`mbrtowc
 (
NULL
, 
input
 + 3, 6, &
state
);

315 
	`ASSERT
 (
ret
 == 4);

316 
	`ASSERT
 (
	`mbsinit
 (&
state
));

318 
wc
 = (
wchar_t
) 0xBADFACE;

319 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 6, &
state
);

320 
	`ASSERT
 (
ret
 == 4);

321 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

322 
	`ASSERT
 (
	`mbsinit
 (&
state
));

323 
input
[3] = '\0';

324 
input
[4] = '\0';

325 
input
[5] = '\0';

326 
input
[6] = '\0';

328 
wc
 = (
wchar_t
) 0xBADFACE;

329 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 7, 2, &
state
);

330 
	`ASSERT
 (
ret
 == 1);

331 
	`ASSERT
 (
wc
 == 'e');

332 
	`ASSERT
 (
	`mbsinit
 (&
state
));

333 
input
[5] = '\0';

335 
wc
 = (
wchar_t
) 0xBADFACE;

336 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 8, 1, &
state
);

337 
	`ASSERT
 (
ret
 == 1);

338 
	`ASSERT
 (
wc
 == 'r');

339 
	`ASSERT
 (
	`mbsinit
 (&
state
));

345 
	}
}

	@gnulib-tests/test-mbscasecmp.c

21 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #include 
	~<locale.h
>

27 #include 
	~"macros.h
"

30 
	$main
 ()

33 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

36 
	`ASSERT
 (
	`mbscasecmp
 ("paragraph", "Paragraph") == 0);

38 
	`ASSERT
 (
	`mbscasecmp
 ("paragrapH", "parAgRaph") == 0);

40 
	`ASSERT
 (
	`mbscasecmp
 ("paragraph", "paraLyzed") < 0);

41 
	`ASSERT
 (
	`mbscasecmp
 ("paraLyzed", "paragraph") > 0);

43 
	`ASSERT
 (
	`mbscasecmp
 ("para", "paragraph") < 0);

44 
	`ASSERT
 (
	`mbscasecmp
 ("paragraph", "para") > 0);

49 
	`ASSERT
 (
	`mbscasecmp
 ("\303\266zg\303\274r", "\303\226ZG\303\234R") == 0);

50 
	`ASSERT
 (
	`mbscasecmp
 ("\303\226ZG\303\234R", "\303\266zg\303\274r") == 0);

53 
	`ASSERT
 (
	`mbscasecmp
 ("turkish", "TURK\304\260SH") == 0);

54 
	`ASSERT
 (
	`mbscasecmp
 ("TURK\304\260SH", "turkish") == 0);

57 
	}
}

	@gnulib-tests/test-mbsinit.c

21 #include 
	~<config.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
mbsinit
, int, (const 
mbstate_t
 *));

28 #include 
	~<locale.h
>

30 #include 
	~"macros.h
"

33 
	$main
 (int 
argc
, char *
argv
[])

35 static 
mbstate_t
 
state
;

37 
	`ASSERT
 (
	`mbsinit
 (
NULL
));

39 
	`ASSERT
 (
	`mbsinit
 (&
state
));

41 if (
argc
 > 1)

43 static const char 
input
[1] = "\303";

44 
wchar_t
 
wc
;

45 
size_t
 
ret
;

48 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

51 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

52 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

53 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

57 
	}
}

	@gnulib-tests/test-mbsrtowcs.c

21 #include 
	~<config.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
mbsrtowcs
, 
size_t
, (
wchar_t
 *, char const **, size_t,

27 
mbstate_t
 *));

29 #include 
	~<locale.h
>

30 #include 
	~<stdio.h
>

31 #include 
	~<string.h
>

33 #include 
	~"macros.h
"

36 
	$main
 (int 
argc
, char *
argv
[])

38 
mbstate_t
 
state
;

39 
wchar_t
 
wc
;

40 
size_t
 
ret
;

43 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

48 const char *
src
;

50 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

52 
src
 = "";

53 
ret
 = 
	`mbsrtowcs
 (
NULL
, &
src
, 0, &
state
);

54 
	`ASSERT
 (
ret
 == 0);

55 
	`ASSERT
 (
	`mbsinit
 (&
state
));

57 
src
 = "";

58 
ret
 = 
	`mbsrtowcs
 (
NULL
, &
src
, 1, &
state
);

59 
	`ASSERT
 (
ret
 == 0);

60 
	`ASSERT
 (
	`mbsinit
 (&
state
));

62 
wc
 = (
wchar_t
) 0xBADFACE;

63 
src
 = "";

64 
ret
 = 
	`mbsrtowcs
 (&
wc
, &
src
, 0, &
state
);

65 
	`ASSERT
 (
ret
 == 0);

66 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

67 
	`ASSERT
 (
	`mbsinit
 (&
state
));

69 
wc
 = (
wchar_t
) 0xBADFACE;

70 
src
 = "";

71 
ret
 = 
	`mbsrtowcs
 (&
wc
, &
src
, 1, &
state
);

72 
	`ASSERT
 (
ret
 == 0);

73 
	`ASSERT
 (
wc
 == 0);

74 
	`ASSERT
 (
	`mbsinit
 (&
state
));

77 if (
argc
 > 1)

79 int 
unlimited
;

81 for (
unlimited
 = 0; unlimited < 2; unlimited++)

83 #define 
	#BUFSIZE
 10

	)

84 
wchar_t
 
buf
[
BUFSIZE
];

85 const char *
src
;

86 
mbstate_t
 
temp_state
;

89 
size_t
 
i
;

90 for (
i
 = 0; i < 
BUFSIZE
; i++)

91 
buf
[
i
] = (
wchar_t
) 0xBADFACE;

94 switch (
argv
[1][0])

99 char 
input
[] = "B\374\337er";

100 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

102 
wc
 = (
wchar_t
) 0xBADFACE;

103 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

104 
	`ASSERT
 (
ret
 == 1);

105 
	`ASSERT
 (
wc
 == 'B');

106 
	`ASSERT
 (
	`mbsinit
 (&
state
));

107 
input
[0] = '\0';

109 
wc
 = (
wchar_t
) 0xBADFACE;

110 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

111 
	`ASSERT
 (
ret
 == 1);

112 
	`ASSERT
 (
	`wctob
 (
wc
) == (unsigned char) '\374');

113 
	`ASSERT
 (
	`mbsinit
 (&
state
));

114 
input
[1] = '\0';

116 
src
 = 
input
 + 2;

117 
temp_state
 = 
state
;

118 
ret
 = 
	`mbsrtowcs
 (
NULL
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 1, &
temp_state
);

119 
	`ASSERT
 (
ret
 == 3);

120 
	`ASSERT
 (
src
 == 
input
 + 2);

121 
	`ASSERT
 (
	`mbsinit
 (&
state
));

123 
src
 = 
input
 + 2;

124 
ret
 = 
	`mbsrtowcs
 (
buf
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 1, &
state
);

125 
	`ASSERT
 (
ret
 == (
unlimited
 ? 3 : 1));

126 
	`ASSERT
 (
src
 == (
unlimited
 ? 
NULL
 : 
input
 + 3));

127 
	`ASSERT
 (
	`wctob
 (
buf
[0]) == (unsigned char) '\337');

128 if (
unlimited
)

130 
	`ASSERT
 (
buf
[1] == 'e');

131 
	`ASSERT
 (
buf
[2] == 'r');

132 
	`ASSERT
 (
buf
[3] == 0);

133 
	`ASSERT
 (
buf
[4] == (
wchar_t
) 0xBADFACE);

136 
	`ASSERT
 (
buf
[1] == (
wchar_t
) 0xBADFACE);

137 
	`ASSERT
 (
	`mbsinit
 (&
state
));

144 char 
input
[] = "B\303\274\303\237er";

145 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

147 
wc
 = (
wchar_t
) 0xBADFACE;

148 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

149 
	`ASSERT
 (
ret
 == 1);

150 
	`ASSERT
 (
wc
 == 'B');

151 
	`ASSERT
 (
	`mbsinit
 (&
state
));

152 
input
[0] = '\0';

154 
wc
 = (
wchar_t
) 0xBADFACE;

155 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

156 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

157 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

158 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

159 
input
[1] = '\0';

161 
src
 = 
input
 + 2;

162 
temp_state
 = 
state
;

163 
ret
 = 
	`mbsrtowcs
 (
NULL
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 2, &
temp_state
);

164 
	`ASSERT
 (
ret
 == 4);

165 
	`ASSERT
 (
src
 == 
input
 + 2);

166 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

168 
src
 = 
input
 + 2;

169 
ret
 = 
	`mbsrtowcs
 (
buf
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 2, &
state
);

170 
	`ASSERT
 (
ret
 == (
unlimited
 ? 4 : 2));

171 
	`ASSERT
 (
src
 == (
unlimited
 ? 
NULL
 : 
input
 + 5));

172 
	`ASSERT
 (
	`wctob
 (
buf
[0]) == 
EOF
);

173 
	`ASSERT
 (
	`wctob
 (
buf
[1]) == 
EOF
);

174 if (
unlimited
)

176 
	`ASSERT
 (
buf
[2] == 'e');

177 
	`ASSERT
 (
buf
[3] == 'r');

178 
	`ASSERT
 (
buf
[4] == 0);

179 
	`ASSERT
 (
buf
[5] == (
wchar_t
) 0xBADFACE);

182 
	`ASSERT
 (
buf
[2] == (
wchar_t
) 0xBADFACE);

183 
	`ASSERT
 (
	`mbsinit
 (&
state
));

190 char 
input
[] = "<\306\374\313\334\270\354>";

191 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

193 
wc
 = (
wchar_t
) 0xBADFACE;

194 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

195 
	`ASSERT
 (
ret
 == 1);

196 
	`ASSERT
 (
wc
 == '<');

197 
	`ASSERT
 (
	`mbsinit
 (&
state
));

198 
input
[0] = '\0';

200 
wc
 = (
wchar_t
) 0xBADFACE;

201 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 2, &
state
);

202 
	`ASSERT
 (
ret
 == 2);

203 
	`ASSERT
 (
	`wctob
 (
wc
) == 
EOF
);

204 
	`ASSERT
 (
	`mbsinit
 (&
state
));

205 
input
[1] = '\0';

206 
input
[2] = '\0';

208 
wc
 = (
wchar_t
) 0xBADFACE;

209 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 3, 1, &
state
);

210 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

211 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

212 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

213 
input
[3] = '\0';

215 
src
 = 
input
 + 4;

216 
temp_state
 = 
state
;

217 
ret
 = 
	`mbsrtowcs
 (
NULL
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 2, &
temp_state
);

218 
	`ASSERT
 (
ret
 == 3);

219 
	`ASSERT
 (
src
 == 
input
 + 4);

220 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

222 
src
 = 
input
 + 4;

223 
ret
 = 
	`mbsrtowcs
 (
buf
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 2, &
state
);

224 
	`ASSERT
 (
ret
 == (
unlimited
 ? 3 : 2));

225 
	`ASSERT
 (
src
 == (
unlimited
 ? 
NULL
 : 
input
 + 7));

226 
	`ASSERT
 (
	`wctob
 (
buf
[0]) == 
EOF
);

227 
	`ASSERT
 (
	`wctob
 (
buf
[1]) == 
EOF
);

228 if (
unlimited
)

230 
	`ASSERT
 (
buf
[2] == '>');

231 
	`ASSERT
 (
buf
[3] == 0);

232 
	`ASSERT
 (
buf
[4] == (
wchar_t
) 0xBADFACE);

235 
	`ASSERT
 (
buf
[2] == (
wchar_t
) 0xBADFACE);

236 
	`ASSERT
 (
	`mbsinit
 (&
state
));

243 char 
input
[] = "B\250\271\201\060\211\070er";

244 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

246 
wc
 = (
wchar_t
) 0xBADFACE;

247 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
, 1, &
state
);

248 
	`ASSERT
 (
ret
 == 1);

249 
	`ASSERT
 (
wc
 == 'B');

250 
	`ASSERT
 (
	`mbsinit
 (&
state
));

251 
input
[0] = '\0';

253 
wc
 = (
wchar_t
) 0xBADFACE;

254 
ret
 = 
	`mbrtowc
 (&
wc
, 
input
 + 1, 1, &
state
);

255 
	`ASSERT
 (
ret
 == (
size_t
)(-2));

256 
	`ASSERT
 (
wc
 == (
wchar_t
) 0xBADFACE);

257 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

258 
input
[1] = '\0';

260 
src
 = 
input
 + 2;

261 
temp_state
 = 
state
;

262 
ret
 = 
	`mbsrtowcs
 (
NULL
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 2, &
temp_state
);

263 
	`ASSERT
 (
ret
 == 4);

264 
	`ASSERT
 (
src
 == 
input
 + 2);

265 
	`ASSERT
 (!
	`mbsinit
 (&
state
));

267 
src
 = 
input
 + 2;

268 
ret
 = 
	`mbsrtowcs
 (
buf
, &
src
, 
unlimited
 ? 
BUFSIZE
 : 2, &
state
);

269 
	`ASSERT
 (
ret
 == (
unlimited
 ? 4 : 2));

270 
	`ASSERT
 (
src
 == (
unlimited
 ? 
NULL
 : 
input
 + 7));

271 
	`ASSERT
 (
	`wctob
 (
buf
[0]) == 
EOF
);

272 
	`ASSERT
 (
	`wctob
 (
buf
[1]) == 
EOF
);

273 if (
unlimited
)

275 
	`ASSERT
 (
buf
[2] == 'e');

276 
	`ASSERT
 (
buf
[3] == 'r');

277 
	`ASSERT
 (
buf
[4] == 0);

278 
	`ASSERT
 (
buf
[5] == (
wchar_t
) 0xBADFACE);

281 
	`ASSERT
 (
buf
[2] == (
wchar_t
) 0xBADFACE);

282 
	`ASSERT
 (
	`mbsinit
 (&
state
));

295 
	}
}

	@gnulib-tests/test-mbsstr1.c

21 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #include 
	~<stdlib.h
>

27 #include 
	~"macros.h
"

30 
	$main
 ()

35 const char 
input
[] = "foo";

36 const char *
result
 = 
	`mbsstr
 (
input
, "");

37 
	`ASSERT
 (
result
 == 
input
);

41 const char 
input
[] = "foo";

42 const char *
result
 = 
	`mbsstr
 (
input
, "o");

43 
	`ASSERT
 (
result
 == 
input
 + 1);

47 const char 
input
[] = "ABC ABCDAB ABCDABCDABDE";

48 const char *
result
 = 
	`mbsstr
 (
input
, "ABCDABD");

49 
	`ASSERT
 (
result
 == 
input
 + 15);

53 const char 
input
[] = "ABC ABCDAB ABCDABCDABDE";

54 const char *
result
 = 
	`mbsstr
 (
input
, "ABCDABE");

55 
	`ASSERT
 (
result
 == 
NULL
);

61 
size_t
 
repeat
 = 10000;

62 
size_t
 
m
 = 1000000;

63 const char *
needle
 =

66 char *
haystack
 = (char *) 
	`malloc
 (
m
 + 1);

67 if (
haystack
 != 
NULL
)

69 
	`memset
 (
haystack
, 'A', 
m
);

70 
haystack
[0] = 'B';

71 
haystack
[
m
] = '\0';

73 for (; 
repeat
 > 0; repeat--)

75 
	`ASSERT
 (
	`mbsstr
 (
haystack
, 
needle
) == haystack + 1);

78 
	`free
 (
haystack
);

85 
size_t
 
repeat
 = 10000;

86 
size_t
 
m
 = 1000000;

87 const char *
haystack
 =

90 char *
needle
 = (char *) 
	`malloc
 (
m
 + 1);

91 if (
needle
 != 
NULL
)

93 
	`memset
 (
needle
, 'A', 
m
);

94 
needle
[
m
] = '\0';

96 for (; 
repeat
 > 0; repeat--)

98 
	`ASSERT
 (
	`mbsstr
 (
haystack
, 
needle
) == 
NULL
);

101 
	`free
 (
needle
);

107 
size_t
 
m
 = 1000000;

108 char *
haystack
 = (char *) 
	`malloc
 (2 * 
m
 + 2);

109 char *
needle
 = (char *) 
	`malloc
 (
m
 + 2);

110 if (
haystack
 != 
NULL
 && 
needle
 != NULL)

112 const char *
result
;

114 
	`memset
 (
haystack
, 'A', 2 * 
m
);

115 
haystack
[2 * 
m
] = 'B';

116 
haystack
[2 * 
m
 + 1] = '\0';

118 
	`memset
 (
needle
, 'A', 
m
);

119 
needle
[
m
] = 'B';

120 
needle
[
m
 + 1] = '\0';

122 
result
 = 
	`mbsstr
 (
haystack
, 
needle
);

123 
	`ASSERT
 (
result
 == 
haystack
 + 
m
);

125 
	`free
 (
needle
);

126 
	`free
 (
haystack
);

130 
	}
}

	@gnulib-tests/test-mbsstr2.c

21 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #include 
	~<locale.h
>

26 #include 
	~<stdlib.h
>

28 #include 
	~"macros.h
"

31 
	$main
 ()

34 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

38 const char 
input
[] = "f\303\266\303\266";

39 const char *
result
 = 
	`mbsstr
 (
input
, "");

40 
	`ASSERT
 (
result
 == 
input
);

44 const char 
input
[] = "f\303\266\303\266";

45 const char *
result
 = 
	`mbsstr
 (
input
, "\303\266");

46 
	`ASSERT
 (
result
 == 
input
 + 1);

50 const char 
input
[] = "f\303\266\303\266";

51 const char *
result
 = 
	`mbsstr
 (
input
, "\266\303");

52 
	`ASSERT
 (
result
 == 
NULL
);

56 const char 
input
[] = "\303\204BC \303\204BCD\303\204B \303\204BCD\303\204BCD\303\204BDE";

57 const char *
result
 = 
	`mbsstr
 (
input
, "\303\204BCD\303\204BD");

58 
	`ASSERT
 (
result
 == 
input
 + 19);

62 const char 
input
[] = "\303\204BC \303\204BCD\303\204B \303\204BCD\303\204BCD\303\204BDE";

63 const char *
result
 = 
	`mbsstr
 (
input
, "\303\204BCD\303\204BE");

64 
	`ASSERT
 (
result
 == 
NULL
);

70 
size_t
 
repeat
 = 10000;

71 
size_t
 
m
 = 1000000;

72 const char *
needle
 =

75 char *
haystack
 = (char *) 
	`malloc
 (
m
 + 1);

76 if (
haystack
 != 
NULL
)

78 
	`memset
 (
haystack
, 'A', 
m
);

79 
haystack
[0] = '\303'; haystack[1] = '\204';

80 
haystack
[
m
] = '\0';

82 for (; 
repeat
 > 0; repeat--)

84 
	`ASSERT
 (
	`mbsstr
 (
haystack
, 
needle
) == haystack + 2);

87 
	`free
 (
haystack
);

94 
size_t
 
repeat
 = 10000;

95 
size_t
 
m
 = 1000000;

96 const char *
haystack
 =

103 char *
needle
 = (char *) 
	`malloc
 (
m
 + 1);

104 if (
needle
 != 
NULL
)

106 
	`memset
 (
needle
, 'A', 
m
);

107 
needle
[
m
] = '\0';

109 for (; 
repeat
 > 0; repeat--)

111 
	`ASSERT
 (
	`mbsstr
 (
haystack
, 
needle
) == 
NULL
);

114 
	`free
 (
needle
);

120 
size_t
 
m
 = 1000000;

121 char *
haystack
 = (char *) 
	`malloc
 (2 * 
m
 + 3);

122 char *
needle
 = (char *) 
	`malloc
 (
m
 + 3);

123 if (
haystack
 != 
NULL
 && 
needle
 != NULL)

125 const char *
result
;

127 
	`memset
 (
haystack
, 'A', 2 * 
m
);

128 
haystack
[2 * 
m
] = '\303'; haystack[2 * m + 1] = '\207';

129 
haystack
[2 * 
m
 + 2] = '\0';

131 
	`memset
 (
needle
, 'A', 
m
);

132 
needle
[
m
] = '\303'; needle[m + 1] = '\207';

133 
needle
[
m
 + 2] = '\0';

135 
result
 = 
	`mbsstr
 (
haystack
, 
needle
);

136 
	`ASSERT
 (
result
 == 
haystack
 + 
m
);

138 
	`free
 (
needle
);

139 
	`free
 (
haystack
);

143 
	}
}

	@gnulib-tests/test-mbsstr3.c

21 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #include 
	~<locale.h
>

27 #include 
	~"macros.h
"

30 
	$main
 ()

33 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

38 const char 
input
[] = "\312\276\300\375 \312\276\300\375 \312\276\300\375";

39 const char *
result
 = 
	`mbsstr
 (
input
, " ");

40 
	`ASSERT
 (
result
 == 
input
 + 4);

44 const char 
input
[] = "\312\276\300\375";

45 const char *
result
 = 
	`mbsstr
 (
input
, " ");

46 
	`ASSERT
 (
result
 == 
NULL
);

51 const char 
input
[] = "\272\305123\324\313\320\320\241\243";

52 const char *
result
 = 
	`mbsstr
 (
input
, "2");

53 
	`ASSERT
 (
result
 == 
input
 + 3);

59 const char 
input
[] = "\313\320\320\320";

60 const char *
result
 = 
	`mbsstr
 (
input
, "\320\320");

61 
	`ASSERT
 (
result
 == 
input
 + 2);

65 const char 
input
[] = "\203\062\332\066123\324\313\320\320\241\243";

66 const char *
result
 = 
	`mbsstr
 (
input
, "2");

67 
	`ASSERT
 (
result
 == 
input
 + 5);

71 const char 
input
[] = "\312\276\300\375 \312\276\300\375 \312\276\300\375";

72 const char *
result
 = 
	`mbsstr
 (
input
, "\276\300");

73 
	`ASSERT
 (
result
 == 
NULL
);

77 const char 
input
[] = "\312\276\300\375 \312\276\300\375 \312\276\300\375";

78 const char *
result
 = 
	`mbsstr
 (
input
, "\375 ");

79 
	`ASSERT
 (
result
 == 
NULL
);

83 
	}
}

	@gnulib-tests/test-memchr.c

20 #include 
	~<config.h
>

22 #include 
	~<string.h
>

24 #include 
	~"signature.h
"

25 
SIGNATURE_CHECK
 (
memchr
, void *, (void const *, int, 
size_t
));

27 #include 
	~<stdlib.h
>

29 #include 
	~"zerosize-ptr.h
"

30 #include 
	~"macros.h
"

34 #define 
	#MEMCHR
 (char *) 
memchr


	)

37 
	$main
 (void)

39 
size_t
 
n
 = 0x100000;

40 char *
input
 = 
	`malloc
 (
n
);

41 
	`ASSERT
 (
input
);

43 
input
[0] = 'a';

44 
input
[1] = 'b';

45 
	`memset
 (
input
 + 2, 'c', 1024);

46 
	`memset
 (
input
 + 1026, 'd', 
n
 - 1028);

47 
input
[
n
 - 2] = 'e';

48 
input
[
n
 - 1] = 'a';

51 
	`ASSERT
 (
	`MEMCHR
 (
input
, 'a', 
n
) == input);

53 
	`ASSERT
 (
	`MEMCHR
 (
input
, 'a', 0) == 
NULL
);

54 
	`ASSERT
 (
	`MEMCHR
 (
	`zerosize_ptr
 (), 'a', 0) == 
NULL
);

56 
	`ASSERT
 (
	`MEMCHR
 (
input
, 'b', 
n
) == input + 1);

57 
	`ASSERT
 (
	`MEMCHR
 (
input
, 'c', 
n
) == input + 2);

58 
	`ASSERT
 (
	`MEMCHR
 (
input
, 'd', 
n
) == input + 1026);

60 
	`ASSERT
 (
	`MEMCHR
 (
input
 + 1, 'a', 
n
 - 1) == input + n - 1);

61 
	`ASSERT
 (
	`MEMCHR
 (
input
 + 1, 'e', 
n
 - 1) == input + n - 2);

62 
	`ASSERT
 (
	`MEMCHR
 (
input
 + 1, 0x789abc00 | 'e', 
n
 - 1) == input + n - 2);

64 
	`ASSERT
 (
	`MEMCHR
 (
input
, 'f', 
n
) == 
NULL
);

65 
	`ASSERT
 (
	`MEMCHR
 (
input
, '\0', 
n
) == 
NULL
);

70 
size_t
 
repeat
 = 10000;

71 for (; 
repeat
 > 0; repeat--)

73 
	`ASSERT
 (
	`MEMCHR
 (
input
, 'c', 
n
) == input + 2);

79 int 
i
, 
j
;

80 for (
i
 = 0; i < 32; i++)

82 for (
j
 = 0; j < 256; j++)

83 
input
[
i
 + 
j
] = j;

84 for (
j
 = 0; j < 256; j++)

86 
	`ASSERT
 (
	`MEMCHR
 (
input
 + 
i
, 
j
, 256) == input + i + j);

98 char *
page_boundary
 = (char *) 
	`zerosize_ptr
 ();

101 int 
limit
 = 257;

103 if (
page_boundary
 != 
NULL
)

105 for (
n
 = 1; n <= 
limit
; n++)

107 char *
mem
 = 
page_boundary
 - 
n
;

108 
	`memset
 (
mem
, 'X', 
n
);

109 
	`ASSERT
 (
	`MEMCHR
 (
mem
, 'U', 
n
) == 
NULL
);

110 
	`ASSERT
 (
	`MEMCHR
 (
mem
, 0, 
n
) == 
NULL
);

113 
size_t
 
i
;

114 
size_t
 
k
;

116 for (
i
 = 0; i < 
n
; i++)

118 
mem
[
i
] = 'U';

119 for (
k
 = 
i
 + 1; k < 
n
 + 
limit
; k++)

120 
	`ASSERT
 (
	`MEMCHR
 (
mem
, 'U', 
k
) == mem + 
i
);

121 
mem
[
i
] = 0;

122 for (
k
 = 
i
 + 1; k < 
n
 + 
limit
; k++)

123 
	`ASSERT
 (
	`MEMCHR
 (
mem
, 0, 
k
) == mem + 
i
);

124 
mem
[
i
] = 'X';

131 
	`free
 (
input
);

134 
	}
}

	@gnulib-tests/test-nl_langinfo.c

21 #include 
	~<config.h
>

23 #include 
	~<langinfo.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
nl_langinfo
, char *, (
nl_item
));

28 #include 
	~<locale.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

32 #include 
	~"c-strcase.h
"

33 #include 
	~"macros.h
"

38 #if 
__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 3)

39 #pragma 
GCC
 
diagnostic
 
ignored
 "-Wtype-limits"

43 
	$main
 (int 
argc
, char *
argv
[])

45 int 
pass
 = 
	`atoi
 (
argv
[1]);

52 
	`setlocale
 (
LC_ALL
, "");

55 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
CODESET
)) > 0);

56 if (
pass
 == 2)

58 const char *
codeset
 = 
	`nl_langinfo
 (
CODESET
);

59 
	`ASSERT
 (
	`c_strcasecmp
 (
codeset
, "UTF-8") == 0 || c_strcasecmp (codeset, "UTF8") == 0);

62 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
RADIXCHAR
)) > 0);

63 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
THOUSEP
)) >= 0);

65 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
D_T_FMT
)) > 0);

66 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
D_FMT
)) > 0);

67 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
T_FMT
)) > 0);

68 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
T_FMT_AMPM
)) >= (
pass
 == 0 ? 1 : 0));

69 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
AM_STR
)) >= (
pass
 == 0 ? 1 : 0));

70 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
PM_STR
)) >= (
pass
 == 0 ? 1 : 0));

71 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
DAY_1
)) > 0);

72 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
DAY_2
)) > 0);

73 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
DAY_3
)) > 0);

74 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
DAY_4
)) > 0);

75 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
DAY_5
)) > 0);

76 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
DAY_6
)) > 0);

77 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
DAY_7
)) > 0);

78 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABDAY_1
)) > 0);

79 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABDAY_2
)) > 0);

80 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABDAY_3
)) > 0);

81 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABDAY_4
)) > 0);

82 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABDAY_5
)) > 0);

83 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABDAY_6
)) > 0);

84 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABDAY_7
)) > 0);

85 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_1
)) > 0);

86 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_2
)) > 0);

87 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_3
)) > 0);

88 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_4
)) > 0);

89 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_5
)) > 0);

90 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_6
)) > 0);

91 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_7
)) > 0);

92 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_8
)) > 0);

93 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_9
)) > 0);

94 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_10
)) > 0);

95 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_11
)) > 0);

96 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
MON_12
)) > 0);

97 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_1
)) > 0);

98 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_2
)) > 0);

99 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_3
)) > 0);

100 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_4
)) > 0);

101 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_5
)) > 0);

102 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_6
)) > 0);

103 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_7
)) > 0);

104 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_8
)) > 0);

105 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_9
)) > 0);

106 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_10
)) > 0);

107 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_11
)) > 0);

108 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ABMON_12
)) > 0);

109 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ERA
)) >= 0);

110 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ERA_D_FMT
)) >= 0);

111 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ERA_D_T_FMT
)) >= 0);

112 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
ERA_T_FMT
)) >= 0);

113 
	`ASSERT
 (
	`nl_langinfo
 (
ALT_DIGITS
) != 
NULL
);

116 const char *
currency
 = 
	`nl_langinfo
 (
CRNCYSTR
);

117 
	`ASSERT
 (
	`strlen
 (
currency
) >= 0);

118 #if !
defined
 
__NetBSD__


119 if (
pass
 > 0)

120 
	`ASSERT
 (
	`strlen
 (
currency
) >= 1);

124 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
YESEXPR
)) > 0);

125 
	`ASSERT
 (
	`strlen
 (
	`nl_langinfo
 (
NOEXPR
)) > 0);

128 
	}
}

	@gnulib-tests/test-open.c

21 #include 
	~<config.h
>

23 #include 
	~<fcntl.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
open
, int, (char const *, int, ...));

28 #include 
	~<errno.h
>

29 #include 
	~<stdbool.h
>

30 #include 
	~<stdio.h
>

31 #include 
	~<unistd.h
>

33 #include 
	~"macros.h
"

35 #define 
	#BASE
 "test-open.t"

	)

37 #include 
	~"test-open.h
"

40 
	$main
 (void)

42 return 
	`test_open
 (
open
, 
true
);

43 
	}
}

	@gnulib-tests/test-open.h

28 
test_open
 (int (*
func
) (char const *, int, ...), 
bool
 
print
)

30 int 
fd
;

32 
	`unlink
 (
BASE
 "file");

35 
errno
 = 0;

36 
	`ASSERT
 (
	`func
 ("nonexist.ent/", 
O_CREAT
 | 
O_RDONLY
, 0600) == -1);

37 
	`ASSERT
 (
errno
 == 
ENOTDIR
 || errno == 
EISDIR
 || errno == 
ENOENT


38 || 
errno
 == 
EINVAL
);

41 
fd
 = 
	`func
 (
BASE
 "file", 
O_CREAT
 | 
O_RDONLY
, 0600);

42 
	`ASSERT
 (0 <= 
fd
);

43 
	`ASSERT
 (
	`close
 (
fd
) == 0);

46 
errno
 = 0;

47 
	`ASSERT
 (
	`func
 (
BASE
 "file/", 
O_RDONLY
) == -1);

48 
	`ASSERT
 (
errno
 == 
ENOTDIR
 || errno == 
EISDIR
 || errno == 
EINVAL
);

51 
errno
 = 0;

52 
	`ASSERT
 (
	`func
 (".", 
O_WRONLY
) == -1);

53 
	`ASSERT
 (
errno
 == 
EISDIR
 || errno == 
EACCES
);

56 
fd
 = 
	`func
 ("/dev/null", 
O_RDONLY
);

57 
	`ASSERT
 (0 <= 
fd
);

59 char 
c
;

60 
	`ASSERT
 (
	`read
 (
fd
, &
c
, 1) == 0);

62 
	`ASSERT
 (
	`close
 (
fd
) == 0);

63 
fd
 = 
	`func
 ("/dev/null", 
O_WRONLY
);

64 
	`ASSERT
 (0 <= 
fd
);

65 
	`ASSERT
 (
	`write
 (
fd
, "c", 1) == 1);

66 
	`ASSERT
 (
	`close
 (
fd
) == 0);

70 
fd
 = 
	`func
 (
BASE
 "file", 
O_NONBLOCK
 | 
O_RDONLY
);

71 
	`ASSERT
 (0 <= 
fd
);

72 
	`ASSERT
 (
	`close
 (
fd
) == 0);

75 if (
	`symlink
 (
BASE
 "file", BASE "link") != 0)

77 
	`ASSERT
 (
	`unlink
 (
BASE
 "file") == 0);

78 if (
print
)

79 
	`fputs
 ("skipping test: symlinks not supported on this file system\n",

80 
stderr
);

83 
errno
 = 0;

84 
	`ASSERT
 (
	`func
 (
BASE
 "link/", 
O_RDONLY
) == -1);

85 
	`ASSERT
 (
errno
 == 
ENOTDIR
);

86 
fd
 = 
	`func
 (
BASE
 "link", 
O_RDONLY
);

87 
	`ASSERT
 (0 <= 
fd
);

88 
	`ASSERT
 (
	`close
 (
fd
) == 0);

91 
	`ASSERT
 (
	`unlink
 (
BASE
 "file") == 0);

92 
	`ASSERT
 (
	`unlink
 (
BASE
 "link") == 0);

95 
	}
}

	@gnulib-tests/test-pathmax.c

21 #include 
	~<config.h
>

23 #include 
	~"pathmax.h
"

26 #ifdef 
PATH_MAX


27 int 
	ga
 = 
PATH_MAX
;

31 
	$main
 (void)

34 
	}
}

	@gnulib-tests/test-quotearg-simple.c

22 #include 
	~<config.h
>

24 #include 
	~"quotearg.h
"

26 #include 
	~<ctype.h
>

27 #include 
	~<stdbool.h
>

28 #include 
	~<stdint.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

32 #include 
	~"progname.h
"

33 #include 
	~"macros.h
"

35 #include 
	~"test-quotearg.h
"

37 static struct 
result_groups
 
	gresults_g
[] = {

40 
LQ
 
RQ
, LQ RQ },

42 
LQ
 
RQ
, LQ RQ },

44 
LQ
 
RQ
, LQ RQ } },

48 "'a\\b'", 
LQ
 
RQ
, LQ RQ },

50 "'a\\b'", 
LQ
 
RQ
, LQ RQ },

52 "'a\\b'", 
LQ
 
RQ
, LQ RQ } },

56 "'a\\b'", "'" 
LQ
 
RQ
 "'", "'" LQ RQ "'" },

58 "'a\\b'", "'" 
LQ
 
RQ
 "'", "'" LQ RQ "'" },

60 "'a\\b'", "'" 
LQ
 
RQ
 "'", "'" LQ RQ "'" } },

65 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" },

68 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" },

71 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" } },

75 "a:b", "a\\b", "\"" 
LQ_ENC
 
RQ_ENC
 "\"", 
LQ
 
RQ
 },

77 "a:b", "a\\b", "\"" 
LQ_ENC
 
RQ_ENC
 "\"", 
LQ
 
RQ
 },

79 "\"a:b\"", "a\\b", "\"" 
LQ_ENC
 
RQ_ENC
 "\"", 
LQ
 
RQ
 } },

83 "a\\\\b", 
LQ_ENC
 
RQ_ENC
, 
LQ
 
RQ
 },

85 "a\\\\b", 
LQ_ENC
 
RQ_ENC
, 
LQ
 
RQ
 },

87 "a\\\\b", 
LQ_ENC
 
RQ_ENC
, 
LQ
 
RQ
 } },

91 "`a:b'", "`a\\\\b'", "`" 
LQ_ENC
 
RQ_ENC
 "'", "`" 
LQ
 
RQ
 "'" },

93 "`a:b'", "`a\\\\b'", "`" 
LQ_ENC
 
RQ_ENC
 "'", "`" 
LQ
 
RQ
 "'" },

95 "`a\\:b'", "`a\\\\b'", "`" 
LQ_ENC
 
RQ_ENC
 "'", "`" 
LQ
 
RQ
 "'" } },

100 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" },

103 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" },

106 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" } }

109 static struct 
result_groups
 
	gflag_results
[] = {

111 { { "", "1", 1, "simple", " \t\n'\"\033?""?/\\", "a:b", "a\\b", 
LQ
 
RQ
,

112 
LQ
 
RQ
 },

113 { "", "1", 1, "simple", " \t\n'\"\033?""?/\\", "a:b", "a\\b", 
LQ
 
RQ
,

114 
LQ
 
RQ
 },

115 { "", "1", 1, "simple", " \t\n'\"\033?""?/\\", "a:b", "a\\b", 
LQ
 
RQ
,

116 
LQ
 
RQ
 } },

120 "a:b", "a\\b", "\"" 
LQ_ENC
 
RQ_ENC
 "\"", 
LQ
 
RQ
 },

122 "a:b", "a\\b", "\"" 
LQ_ENC
 
RQ_ENC
 "\"", 
LQ
 
RQ
 },

124 "\"a:b\"", "a\\b", "\"" 
LQ_ENC
 
RQ_ENC
 "\"", 
LQ
 
RQ
 } },

129 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" },

132 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" },

135 "\"" 
LQ_ENC
 
RQ_ENC
 "\"", "\"" 
LQ
 
RQ
 "\"" } }

138 static char const *
	gcustom_quotes
[][2] = {

148 static struct 
result_groups
 
	gcustom_results
[] = {

152 
LQ_ENC
 
RQ_ENC
, 
LQ
 
RQ
 },

155 
LQ_ENC
 
RQ_ENC
, 
LQ
 
RQ
 },

158 
LQ_ENC
 
RQ_ENC
, 
LQ
 
RQ
 } },

163 "'" 
LQ_ENC
 
RQ_ENC
 "'", "'" 
LQ
 
RQ
 "'" },

166 "'" 
LQ_ENC
 
RQ_ENC
 "'", "'" 
LQ
 
RQ
 "'" },

169 "'" 
LQ_ENC
 
RQ_ENC
 "'", "'" 
LQ
 
RQ
 "'" } },

174 "(" 
LQ_ENC
 
RQ_ENC
 ")", "(" 
LQ
 
RQ
 ")" },

177 "(" 
LQ_ENC
 
RQ_ENC
 ")", "(" 
LQ
 
RQ
 ")" },

180 "(" 
LQ_ENC
 
RQ_ENC
 ")", "(" 
LQ
 
RQ
 ")" } },

185 ":" 
LQ_ENC
 
RQ_ENC
 " ", ":" 
LQ
 
RQ
 " " },

188 ":" 
LQ_ENC
 
RQ_ENC
 " ", ":" 
LQ
 
RQ
 " " },

191 ":" 
LQ_ENC
 
RQ_ENC
 " ", ":" 
LQ
 
RQ
 " " } },

196 " " 
LQ_ENC
 
RQ_ENC
 ":", " " 
LQ
 
RQ
 ":" },

199 " " 
LQ_ENC
 
RQ_ENC
 ":", " " 
LQ
 
RQ
 ":" },

202 " " 
LQ_ENC
 
RQ_ENC
 ":", " " 
LQ
 
RQ
 ":" } },

207 "# " 
LQ_ENC
 
RQ_ENC
 "\n", "# " 
LQ
 
RQ
 "\n" },

210 "# " 
LQ_ENC
 
RQ_ENC
 "\n", "# " 
LQ
 
RQ
 "\n" },

213 "# " 
LQ_ENC
 
RQ_ENC
 "\n", "# " 
LQ
 
RQ
 "\n" } },

218 "\"'" 
LQ_ENC
 
RQ_ENC
 "'\"", "\"'" 
LQ
 
RQ
 "'\"" },

221 "\"'" 
LQ_ENC
 
RQ_ENC
 "'\"", "\"'" 
LQ
 
RQ
 "'\"" },

224 "\"'" 
LQ_ENC
 
RQ_ENC
 "'\"", "\"'" 
LQ
 
RQ
 "'\"" } }

228 
	$main
 (int 
argc
 
_GL_UNUSED
, char *
argv
[])

230 int 
i
;

231 
bool
 
ascii_only
 = 
MB_CUR_MAX
 == 1 && !
	`isprint
 ((unsigned char) 
LQ
[0]);

233 
	`set_program_name
 (
argv
[0]);

246 
	`ASSERT
 (!
	`isprint
 ('\033'));

247 for (
i
 = 
literal_quoting_style
; i <= 
clocale_quoting_style
; i++)

249 
	`set_quoting_style
 (
NULL
, (enum 
quoting_style
) 
i
);

250 
	`compare_strings
 (
use_quotearg_buffer
, &
results_g
[
i
].
group1
, 
ascii_only
);

251 
	`compare_strings
 (
use_quotearg
, &
results_g
[
i
].
group2
, 
ascii_only
);

252 if (
i
 == 
c_quoting_style
)

253 
	`compare_strings
 (
use_quote_double_quotes
, &
results_g
[
i
].
group2
,

254 
ascii_only
);

255 
	`compare_strings
 (
use_quotearg_colon
, &
results_g
[
i
].
group3
, 
ascii_only
);

258 
	`set_quoting_style
 (
NULL
, 
literal_quoting_style
);

259 
	`ASSERT
 (
	`set_quoting_flags
 (
NULL
, 
QA_ELIDE_NULL_BYTES
) == 0);

260 
	`compare_strings
 (
use_quotearg_buffer
, &
flag_results
[0].
group1
, 
ascii_only
);

261 
	`compare_strings
 (
use_quotearg
, &
flag_results
[0].
group2
, 
ascii_only
);

262 
	`compare_strings
 (
use_quotearg_colon
, &
flag_results
[0].
group3
, 
ascii_only
);

264 
	`set_quoting_style
 (
NULL
, 
c_quoting_style
);

265 
	`ASSERT
 (
	`set_quoting_flags
 (
NULL
, 
QA_ELIDE_OUTER_QUOTES
)

266 == 
QA_ELIDE_NULL_BYTES
);

267 
	`compare_strings
 (
use_quotearg_buffer
, &
flag_results
[1].
group1
, 
ascii_only
);

268 
	`compare_strings
 (
use_quotearg
, &
flag_results
[1].
group2
, 
ascii_only
);

269 
	`compare_strings
 (
use_quote_double_quotes
, &
flag_results
[1].
group2
,

270 
ascii_only
);

271 
	`compare_strings
 (
use_quotearg_colon
, &
flag_results
[1].
group3
, 
ascii_only
);

273 
	`ASSERT
 (
	`set_quoting_flags
 (
NULL
, 
QA_SPLIT_TRIGRAPHS
)

274 == 
QA_ELIDE_OUTER_QUOTES
);

275 
	`compare_strings
 (
use_quotearg_buffer
, &
flag_results
[2].
group1
, 
ascii_only
);

276 
	`compare_strings
 (
use_quotearg
, &
flag_results
[2].
group2
, 
ascii_only
);

277 
	`compare_strings
 (
use_quote_double_quotes
, &
flag_results
[2].
group2
,

278 
ascii_only
);

279 
	`compare_strings
 (
use_quotearg_colon
, &
flag_results
[2].
group3
, 
ascii_only
);

281 
	`ASSERT
 (
	`set_quoting_flags
 (
NULL
, 0) == 
QA_SPLIT_TRIGRAPHS
);

283 for (
i
 = 0; i < sizeof 
custom_quotes
 / sizeof *custom_quotes; ++i)

285 
	`set_custom_quoting
 (
NULL
,

286 
custom_quotes
[
i
][0], custom_quotes[i][1]);

287 
	`compare_strings
 (
use_quotearg_buffer
, &
custom_results
[
i
].
group1
,

288 
ascii_only
);

289 
	`compare_strings
 (
use_quotearg
, &
custom_results
[
i
].
group2
, 
ascii_only
);

290 
	`compare_strings
 (
use_quotearg_colon
, &
custom_results
[
i
].
group3
,

291 
ascii_only
);

294 
	`quotearg_free
 ();

296 
	}
}

	@gnulib-tests/test-quotearg.h

22 struct 
	sresult_strings
 {

23 char const *
	mstr1
;

24 char const *
	mstr2
;

25 
size_t
 
	mlen2
;

26 char const *
	mstr3
;

27 char const *
	mstr4
;

28 char const *
	mstr5
;

29 char const *
	mstr6
;

30 char const *
	mstr7a
;

31 char const *
	mstr7b
;

34 struct 
	sresult_groups
 {

35 struct 
result_strings
 
	mgroup1
;

36 struct 
result_strings
 
	mgroup2
;

37 struct 
result_strings
 
	mgroup3
;

41 #define 
	#LQ
 "\302\253"

	)

42 #define 
	#RQ
 "\302\273"

	)

43 #define 
	#LQ_ENC
 "\\302\\253"

	)

44 #define 
	#RQ_ENC
 "\\302\\273"

	)

45 #define 
	#RQ_ESC
 "\\\302\273"

	)

47 static struct 
result_strings
 
	ginputs
 = {

49 
LQ
 
RQ
, 
NULL


53 
	$compare
 (char const *
a
, 
size_t
 
la
, char const *
b
, size_t 
lb
)

55 
	`ASSERT
 (
la
 == 
lb
);

56 
	`ASSERT
 (
	`memcmp
 (
a
, 
b
, 
la
) == 0);

57 
	`ASSERT
 (
b
[
lb
] == '\0');

58 
	}
}

61 
compare_strings
 (char *(
func
) (char const *, 
size_t
 *),

62 struct 
result_strings
 *
results
, 
bool
 
ascii_only
)

64 
size_t
 
	glen
;

65 char *
	gp
;

67 
	glen
 = 0;

68 
	gp
 = 
func
 (
inputs
.
str1
, &
len
);

69 
compare
 (
results
->
str1
, 
strlen
 (results->str1), 
p
, 
len
);

71 
	glen
 = 
inputs
.
len2
;

72 
	gp
 = 
func
 (
inputs
.
str2
, &
len
);

73 
compare
 (
results
->
str2
, results->
len2
, 
p
, 
len
);

75 
	glen
 = 
SIZE_MAX
;

76 
	gp
 = 
func
 (
inputs
.
str3
, &
len
);

77 
compare
 (
results
->
str3
, 
strlen
 (results->str3), 
p
, 
len
);

79 
	glen
 = 
strlen
 (
inputs
.
str4
);

80 
	gp
 = 
func
 (
inputs
.
str4
, &
len
);

81 
compare
 (
results
->
str4
, 
strlen
 (results->str4), 
p
, 
len
);

83 
	glen
 = 
SIZE_MAX
;

84 
	gp
 = 
func
 (
inputs
.
str5
, &
len
);

85 
compare
 (
results
->
str5
, 
strlen
 (results->str5), 
p
, 
len
);

87 
	glen
 = 
strlen
 (
inputs
.
str6
);

88 
	gp
 = 
func
 (
inputs
.
str6
, &
len
);

89 
compare
 (
results
->
str6
, 
strlen
 (results->str6), 
p
, 
len
);

91 
	glen
 = 
strlen
 (
inputs
.
str7a
);

92 
	gp
 = 
func
 (
inputs
.
str7a
, &
len
);

93 if (
	gascii_only
)

94 
compare
 (
results
->
str7a
, 
strlen
 (results->str7a), 
p
, 
len
);

96 
compare
 (
results
->
str7b
, 
strlen
 (results->str7b), 
p
, 
len
);

100 
	$use_quotearg_buffer
 (const char *
str
, 
size_t
 *
len
)

102 static char 
buf
[100];

103 
size_t
 
size
;

104 
	`memset
 (
buf
, 0xa5, 100);

105 
size
 = 
	`quotearg_buffer
 (
buf
, 100, 
str
, *
len
, 
NULL
);

106 *
len
 = 
size
;

107 
	`ASSERT
 ((unsigned char) 
buf
[
size
 + 1] == 0xa5);

108 return 
buf
;

109 
	}
}

112 
	$use_quotearg
 (const char *
str
, 
size_t
 *
len
)

114 char *
p
 = *
len
 == 
SIZE_MAX
 ? 
	`quotearg
 (
str
) : 
	`quotearg_mem
 (str, *len);

115 *
len
 = 
	`strlen
 (
p
);

116 return 
p
;

117 
	}
}

120 
	$use_quote_double_quotes
 (const char *
str
, 
size_t
 *
len
)

122 char *
p
 = *
len
 == 
SIZE_MAX
 ? 
	`quotearg_char
 (
str
, '"')

123 : 
	`quotearg_char_mem
 (
str
, *
len
, '"');

124 *
len
 = 
	`strlen
 (
p
);

125 return 
p
;

126 
	}
}

129 
	$use_quotearg_colon
 (const char *
str
, 
size_t
 *
len
)

131 char *
p
 = (*
len
 == 
SIZE_MAX
 ? 
	`quotearg_colon
 (
str
)

132 : 
	`quotearg_colon_mem
 (
str
, *
len
));

133 *
len
 = 
	`strlen
 (
p
);

134 return 
p
;

135 
	}
}

	@gnulib-tests/test-realloc-gnu.c

19 #include 
	~<config.h
>

21 #include 
	~<stdlib.h
>

24 
	$main
 ()

27 if (
	`realloc
 (
NULL
, 0) == NULL)

31 
	}
}

	@gnulib-tests/test-setenv.c

21 #include 
	~<config.h
>

23 #include 
	~<stdlib.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
setenv
, int, (char const *, char const *, int));

28 #include 
	~<errno.h
>

29 #include 
	~<string.h
>

30 #include 
	~<unistd.h
>

32 #include 
	~"macros.h
"

35 
	$main
 (void)

38 
	`ASSERT
 (
	`setenv
 ("a", "==", -1) == 0);

39 
	`ASSERT
 (
	`setenv
 ("a", "2", 0) == 0);

40 
	`ASSERT
 (
	`strcmp
 (
	`getenv
 ("a"), "==") == 0);

43 
errno
 = 0;

44 
	`ASSERT
 (
	`setenv
 ("", "", 1) == -1);

45 
	`ASSERT
 (
errno
 == 
EINVAL
);

46 
errno
 = 0;

47 
	`ASSERT
 (
	`setenv
 ("a=b", "", 0) == -1);

48 
	`ASSERT
 (
errno
 == 
EINVAL
);

52 
errno
 = 0;

53 
	`ASSERT
 (
	`setenv
 (
NULL
, "", 0) == -1);

54 
	`ASSERT
 (
errno
 == 
EINVAL
);

58 
	}
}

	@gnulib-tests/test-setlocale1.c

19 #include 
	~<config.h
>

21 #include 
	~<locale.h
>

23 #include 
	~"signature.h
"

24 
SIGNATURE_CHECK
 (
setlocale
, char *, (int, const char *));

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

29 #include 
	~"macros.h
"

32 
	$main
 (int 
argc
, char *
argv
[])

34 char *
name1
;

35 char *
name2
;

40 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

43 
name1
 = 
	`strdup
 (
	`setlocale
 (
LC_ALL
, 
NULL
));

46 if (
	`setlocale
 (
LC_ALL
, "C") == 
NULL
)

52 if (
	`setlocale
 (
LC_ALL
, 
	`getenv
 ("LC_ALL")) == 
NULL
)

55 
name2
 = 
	`strdup
 (
	`setlocale
 (
LC_ALL
, 
NULL
));

58 
	`ASSERT
 (
	`strcmp
 (
name1
, 
name2
) == 0);

61 
	}
}

	@gnulib-tests/test-setlocale2.c

19 #include 
	~<config.h
>

21 #include 
	~<locale.h
>

23 #include 
	~<stdio.h
>

24 #include 
	~<stdlib.h
>

25 #include 
	~<string.h
>

28 
	$main
 ()

32 if (
	`setlocale
 (
LC_ALL
, "") != 
NULL
)

34 if (
	`strcmp
 (
	`setlocale
 (
LC_CTYPE
, 
NULL
), "C") == 0)

36 
	`fprintf
 (
stderr
, "setlocale did not fail for implicit %s\n",

37 
	`getenv
 ("LC_ALL"));

42 if (
	`setlocale
 (
LC_ALL
, "C") == 
NULL
)

47 if (
	`setlocale
 (
LC_ALL
, 
	`getenv
 ("LC_ALL")) != 
NULL
)

49 if (
	`strcmp
 (
	`setlocale
 (
LC_CTYPE
, 
NULL
), "C") == 0)

51 
	`fprintf
 (
stderr
, "setlocale did not fail for explicit %s\n",

52 
	`getenv
 ("LC_ALL"));

57 
	}
}

	@gnulib-tests/test-snprintf.c

21 #include 
	~<config.h
>

23 #include 
	~<stdio.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
snprintf
, int, (char *, 
size_t
, char const *, ...));

28 #include 
	~<string.h
>

30 #include 
	~"macros.h
"

33 
	$main
 (int 
argc
, char *
argv
[])

35 char 
buf
[8];

36 int 
size
;

37 int 
retval
;

39 
retval
 = 
	`snprintf
 (
NULL
, 0, "%d", 12345);

40 
	`ASSERT
 (
retval
 == 5);

42 for (
size
 = 0; size <= 8; size++)

44 
	`memcpy
 (
buf
, "DEADBEEF", 8);

45 
retval
 = 
	`snprintf
 (
buf
, 
size
, "%d", 12345);

46 
	`ASSERT
 (
retval
 == 5);

47 if (
size
 < 6)

49 if (
size
 > 0)

51 
	`ASSERT
 (
	`memcmp
 (
buf
, "12345", 
size
 - 1) == 0);

52 
	`ASSERT
 (
buf
[
size
 - 1] == '\0' || buf[size - 1] == '0' + size);

54 #if !
CHECK_SNPRINTF_POSIX


55 if (
size
 > 0)

57 
	`ASSERT
 (
	`memcmp
 (
buf
 + 
size
, "DEADBEEF" + size, 8 - size) == 0);

61 
	`ASSERT
 (
	`memcmp
 (
buf
, "12345\0EF", 8) == 0);

67 char 
result
[100];

68 
retval
 = 
	`snprintf
 (
result
, sizeof (result), "%2$d %1$d", 33, 55);

69 
	`ASSERT
 (
	`strcmp
 (
result
, "55 33") == 0);

70 
	`ASSERT
 (
retval
 == 
	`strlen
 (
result
));

74 
	}
}

	@gnulib-tests/test-stat.c

21 #include 
	~<config.h
>

23 #include 
	~<sys/stat.h
>

29 #include 
	~"signature.h
"

30 
SIGNATURE_CHECK
 (
stat
, int, (char const *, struct stat *));

32 #include 
	~<fcntl.h
>

33 #include 
	~<errno.h
>

34 #include 
	~<stdbool.h
>

35 #include 
	~<stdio.h
>

36 #include 
	~<unistd.h
>

38 #include 
	~"same-inode.h
"

39 #include 
	~"macros.h
"

41 #define 
	#BASE
 "test-stat.t"

	)

43 #include 
	~"test-stat.h
"

48 
	$do_stat
 (char const *
name
, struct 
stat
 *
st
)

50 return 
	`stat
 (
name
, 
st
);

51 
	}
}

54 
	$main
 (void)

56 return 
	`test_stat_func
 (
do_stat
, 
true
);

57 
	}
}

	@gnulib-tests/test-stat.h

28 
test_stat_func
 (int (*
func
) (char const *, struct 
stat
 *), 
bool
 
print
)

30 struct 
stat
 
st1
;

31 struct 
stat
 
st2
;

32 char *
cwd
 = 
	`getcwd
 (
NULL
, 0);

34 
	`ASSERT
 (
cwd
);

35 
	`ASSERT
 (
	`func
 (".", &
st1
) == 0);

36 
	`ASSERT
 (
	`func
 ("./", &
st2
) == 0);

37 
	`ASSERT
 (
	`SAME_INODE
 (
st1
, 
st2
));

38 
	`ASSERT
 (
	`func
 (
cwd
, &
st2
) == 0);

39 
	`ASSERT
 (
	`SAME_INODE
 (
st1
, 
st2
));

40 
	`ASSERT
 (
	`func
 ("/", &
st1
) == 0);

41 
	`ASSERT
 (
	`func
 ("///", &
st2
) == 0);

42 
	`ASSERT
 (
	`SAME_INODE
 (
st1
, 
st2
));

44 
errno
 = 0;

45 
	`ASSERT
 (
	`func
 ("", &
st1
) == -1);

46 
	`ASSERT
 (
errno
 == 
ENOENT
);

47 
errno
 = 0;

48 
	`ASSERT
 (
	`func
 ("nosuch", &
st1
) == -1);

49 
	`ASSERT
 (
errno
 == 
ENOENT
);

50 
errno
 = 0;

51 
	`ASSERT
 (
	`func
 ("nosuch/", &
st1
) == -1);

52 
	`ASSERT
 (
errno
 == 
ENOENT
);

54 
	`ASSERT
 (
	`close
 (
	`creat
 (
BASE
 "file", 0600)) == 0);

55 
	`ASSERT
 (
	`func
 (
BASE
 "file", &
st1
) == 0);

56 
errno
 = 0;

57 
	`ASSERT
 (
	`func
 (
BASE
 "file/", &
st1
) == -1);

58 
	`ASSERT
 (
errno
 == 
ENOTDIR
);

67 if (
	`symlink
 (".", 
BASE
 "link1") != 0)

69 
	`ASSERT
 (
	`unlink
 (
BASE
 "file") == 0);

70 if (
print
)

71 
	`fputs
 ("skipping test: symlinks not supported on this file system\n",

72 
stderr
);

75 
	`ASSERT
 (
	`symlink
 (
BASE
 "file", BASE "link2") == 0);

76 
	`ASSERT
 (
	`symlink
 (
BASE
 "nosuch", BASE "link3") == 0);

77 
	`ASSERT
 (
	`symlink
 (
BASE
 "link4", BASE "link4") == 0);

79 
	`ASSERT
 (
	`func
 (
BASE
 "link1/", &
st1
) == 0);

80 
	`ASSERT
 (
	`S_ISDIR
 (
st1
.
st_mode
));

82 
errno
 = 0;

83 
	`ASSERT
 (
	`func
 (
BASE
 "link2/", &
st1
) == -1);

84 
	`ASSERT
 (
errno
 == 
ENOTDIR
);

86 
errno
 = 0;

87 
	`ASSERT
 (
	`func
 (
BASE
 "link3/", &
st1
) == -1);

88 
	`ASSERT
 (
errno
 == 
ENOENT
);

90 
errno
 = 0;

91 
	`ASSERT
 (
	`func
 (
BASE
 "link4/", &
st1
) == -1);

92 
	`ASSERT
 (
errno
 == 
ELOOP
);

95 
	`ASSERT
 (
	`unlink
 (
BASE
 "file") == 0);

96 
	`ASSERT
 (
	`unlink
 (
BASE
 "link1") == 0);

97 
	`ASSERT
 (
	`unlink
 (
BASE
 "link2") == 0);

98 
	`ASSERT
 (
	`unlink
 (
BASE
 "link3") == 0);

99 
	`ASSERT
 (
	`unlink
 (
BASE
 "link4") == 0);

102 
	}
}

	@gnulib-tests/test-stdbool.c

23 #ifndef 
__GNUC__


24 #define 
	#ADDRESS_CHECK_OKAY


	)

25 #elif 
__GNUC__
 < 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 < 3)

28 #pragma 
GCC
 
diagnostic
 
ignored
 "-Waddress"

29 #define 
	#ADDRESS_CHECK_OKAY


	)

32 #include 
	~<config.h
>

34 #include 
	~<stdbool.h
>

36 #ifndef 
bool


39 #ifndef 
false


42 #if 
false


45 #ifndef 
true


48 #if 
true
 != 1

51 #ifndef 
__bool_true_false_are_defined


57 #if 
HAVE_STDBOOL_H
 || 3 <= 
__GNUC__


58 struct 
	ss
 { 
_Bool
 
	ms
: 1; _Bool 
	mt
; } 
	gs
;

61 char 
	ga
[
true
 == 1 ? 1 : -1];

62 char 
	gb
[
false
 == 0 ? 1 : -1];

63 char 
	gc
[
__bool_true_false_are_defined
 == 1 ? 1 : -1];

64 #if 
HAVE_STDBOOL_H
 || 3 <= 
__GNUC__


65 char 
	gd
[(
bool
) 0.5 == 
true
 ? 1 : -1];

66 #ifdef 
ADDRESS_CHECK_OKAY


70 #ifdef 
__GNUC__


71 
bool
 
	ge
 = &
s
;

74 char 
	gf
[(
_Bool
) 0.0 == 
false
 ? 1 : -1];

76 char 
	gg
[
true
];

77 char 
	gh
[sizeof (
_Bool
)];

78 #if 
HAVE_STDBOOL_H
 || 3 <= 
__GNUC__


79 char 
	gi
[sizeof 
s
.
t
];

81 enum { 
	mj
 = 
false
, 
	mk
 = 
true
, 
	ml
 = false * true, 
	mm
 = true * 256 };

82 
_Bool
 
	gn
[
m
];

83 char 
	go
[sizeof 
n
 == 
m
 * sizeof n[0] ? 1 : -1];

84 char 
	gp
[-1 - (
_Bool
) 0 < 0 && -1 - (
bool
) 0 < 0 ? 1 : -1];

89 
_Bool
 
	gq
 = 
true
;

90 
_Bool
 *
	gpq
 = &
q
;

93 
	$main
 ()

95 int 
error
 = 0;

97 #if 
HAVE_STDBOOL_H
 || 3 <= 
__GNUC__


98 #ifdef 
ADDRESS_CHECK_OKAY


101 
bool
 
e1
 = &
s
;

102 if (!
e1
)

103 
error
 = 1;

114 char 
digs
[] = "0123456789";

115 if (&(
digs
 + 5)[-2 + (
bool
) 1] != &digs[4])

116 
error
 = 1;

119 return 
error
;

120 
	}
}

	@gnulib-tests/test-stddef.c

21 #include 
	~<config.h
>

23 #include 
	~<stddef.h
>

25 #include 
	~"verify.h
"

28 
wchar_t
 
	ga
 = 'c';

29 
ptrdiff_t
 
	gb
 = 1;

30 
size_t
 
	gc
 = 2;

34 
verify
 (sizeof 
NULL
 == sizeof (void *));

37 struct 
	sd


39 char 
	me
;

40 char 
	mf
;

46 
verify
 (sizeof (
offsetof
 (struct 
d
, 
e
)) == sizeof (
size_t
));

47 
verify
 (
offsetof
 (struct 
d
, 
e
) < -1);

48 
verify
 (
offsetof
 (struct 
d
, 
f
) == 1);

51 
	$main
 (void)

54 
	}
}

	@gnulib-tests/test-stdint.c

21 #include 
	~<config.h
>

24 #define 
	#DO_PEDANTIC
 0

	)

26 #define 
	#__STDC_LIMIT_MACROS
 1

	)

27 #define 
	#__STDC_CONSTANT_MACROS
 1

	)

28 #include 
	~<stdint.h
>

30 #include 
	~"verify.h
"

31 #include 
	~"intprops.h
"

33 #if 
__GNUC__
 >= 2 && 
DO_PEDANTIC


34 #define 
	#verify_same_types
(
expr1
,
expr2
) \

35 extern void 
	`_verify_func
(
__LINE__
) (
	`__typeof__
 (
expr1
) *); \

36 extern void 
	`_verify_func
(
__LINE__
) (
	`__typeof__
 (
expr2
) *);

	)

37 #define 
	#_verify_func
(
line
) 
	`_verify_func2
(line)

	)

38 #define 
	#_verify_func2
(
line
) 
verify_func_
 ## 
	)
line

40 #define 
	#verify_same_types
(
expr1
,
expr2
) extern void 
	`verify_func
 (int)

	)

46 
int8_t
 
a1
[3] = { 
INT8_C
 (17), 
INT8_MIN
, 
INT8_MAX
 };

47 
verify
 (
TYPE_MINIMUM
 (
int8_t
) == 
INT8_MIN
);

48 
verify
 (
TYPE_MAXIMUM
 (
int8_t
) == 
INT8_MAX
);

49 
verify_same_types
 (
INT8_MIN
, (
int8_t
) 0 + 0);

50 
verify_same_types
 (
INT8_MAX
, (
int8_t
) 0 + 0);

52 
int16_t
 
	ga2
[3] = { 
INT16_C
 (17), 
INT16_MIN
, 
INT16_MAX
 };

53 
verify
 (
TYPE_MINIMUM
 (
int16_t
) == 
INT16_MIN
);

54 
verify
 (
TYPE_MAXIMUM
 (
int16_t
) == 
INT16_MAX
);

55 
verify_same_types
 (
INT16_MIN
, (
int16_t
) 0 + 0);

56 
verify_same_types
 (
INT16_MAX
, (
int16_t
) 0 + 0);

58 
int32_t
 
	ga3
[3] = { 
INT32_C
 (17), 
INT32_MIN
, 
INT32_MAX
 };

59 
verify
 (
TYPE_MINIMUM
 (
int32_t
) == 
INT32_MIN
);

60 
verify
 (
TYPE_MAXIMUM
 (
int32_t
) == 
INT32_MAX
);

61 
verify_same_types
 (
INT32_MIN
, (
int32_t
) 0 + 0);

62 
verify_same_types
 (
INT32_MAX
, (
int32_t
) 0 + 0);

64 #ifdef 
INT64_MAX


65 
int64_t
 
	ga4
[3] = { 
INT64_C
 (17), 
INT64_MIN
, 
INT64_MAX
 };

66 
verify
 (
TYPE_MINIMUM
 (
int64_t
) == 
INT64_MIN
);

67 
verify
 (
TYPE_MAXIMUM
 (
int64_t
) == 
INT64_MAX
);

68 
verify_same_types
 (
INT64_MIN
, (
int64_t
) 0 + 0);

69 
verify_same_types
 (
INT64_MAX
, (
int64_t
) 0 + 0);

72 
uint8_t
 
	gb1
[2] = { 
UINT8_C
 (17), 
UINT8_MAX
 };

73 
verify
 (
TYPE_MAXIMUM
 (
uint8_t
) == 
UINT8_MAX
);

74 
verify_same_types
 (
UINT8_MAX
, (
uint8_t
) 0 + 0);

76 
uint16_t
 
	gb2
[2] = { 
UINT16_C
 (17), 
UINT16_MAX
 };

77 
verify
 (
TYPE_MAXIMUM
 (
uint16_t
) == 
UINT16_MAX
);

78 
verify_same_types
 (
UINT16_MAX
, (
uint16_t
) 0 + 0);

80 
uint32_t
 
	gb3
[2] = { 
UINT32_C
 (17), 
UINT32_MAX
 };

81 
verify
 (
TYPE_MAXIMUM
 (
uint32_t
) == 
UINT32_MAX
);

82 
verify_same_types
 (
UINT32_MAX
, (
uint32_t
) 0 + 0);

84 #ifdef 
UINT64_MAX


85 
uint64_t
 
	gb4
[2] = { 
UINT64_C
 (17), 
UINT64_MAX
 };

86 
verify
 (
TYPE_MAXIMUM
 (
uint64_t
) == 
UINT64_MAX
);

87 
verify_same_types
 (
UINT64_MAX
, (
uint64_t
) 0 + 0);

90 #if 
INT8_MIN
 && 
INT8_MAX
 && 
INT16_MIN
 && 
INT16_MAX
 && 
INT32_MIN
 && 
INT32_MAX


93 
err
 
	gor
;

96 #if 
UINT8_MAX
 && 
UINT16_MAX
 && 
UINT32_MAX


99 
err
 
	gor
;

105 
int_least8_t
 
	gc1
[3] = { 17, 
INT_LEAST8_MIN
, 
INT_LEAST8_MAX
 };

106 
verify
 (
TYPE_MINIMUM
 (
int_least8_t
) == 
INT_LEAST8_MIN
);

107 
verify
 (
TYPE_MAXIMUM
 (
int_least8_t
) == 
INT_LEAST8_MAX
);

108 
verify_same_types
 (
INT_LEAST8_MIN
, (
int_least8_t
) 0 + 0);

109 
verify_same_types
 (
INT_LEAST8_MAX
, (
int_least8_t
) 0 + 0);

111 
int_least16_t
 
	gc2
[3] = { 17, 
INT_LEAST16_MIN
, 
INT_LEAST16_MAX
 };

112 
verify
 (
TYPE_MINIMUM
 (
int_least16_t
) == 
INT_LEAST16_MIN
);

113 
verify
 (
TYPE_MAXIMUM
 (
int_least16_t
) == 
INT_LEAST16_MAX
);

114 
verify_same_types
 (
INT_LEAST16_MIN
, (
int_least16_t
) 0 + 0);

115 
verify_same_types
 (
INT_LEAST16_MAX
, (
int_least16_t
) 0 + 0);

117 
int_least32_t
 
	gc3
[3] = { 17, 
INT_LEAST32_MIN
, 
INT_LEAST32_MAX
 };

118 
verify
 (
TYPE_MINIMUM
 (
int_least32_t
) == 
INT_LEAST32_MIN
);

119 
verify
 (
TYPE_MAXIMUM
 (
int_least32_t
) == 
INT_LEAST32_MAX
);

120 
verify_same_types
 (
INT_LEAST32_MIN
, (
int_least32_t
) 0 + 0);

121 
verify_same_types
 (
INT_LEAST32_MAX
, (
int_least32_t
) 0 + 0);

123 #ifdef 
INT_LEAST64_MAX


124 
int_least64_t
 
	gc4
[3] = { 17, 
INT_LEAST64_MIN
, 
INT_LEAST64_MAX
 };

125 
verify
 (
TYPE_MINIMUM
 (
int_least64_t
) == 
INT_LEAST64_MIN
);

126 
verify
 (
TYPE_MAXIMUM
 (
int_least64_t
) == 
INT_LEAST64_MAX
);

127 
verify_same_types
 (
INT_LEAST64_MIN
, (
int_least64_t
) 0 + 0);

128 
verify_same_types
 (
INT_LEAST64_MAX
, (
int_least64_t
) 0 + 0);

131 
uint_least8_t
 
	gd1
[2] = { 17, 
UINT_LEAST8_MAX
 };

132 
verify
 (
TYPE_MAXIMUM
 (
uint_least8_t
) == 
UINT_LEAST8_MAX
);

133 
verify_same_types
 (
UINT_LEAST8_MAX
, (
uint_least8_t
) 0 + 0);

135 
uint_least16_t
 
	gd2
[2] = { 17, 
UINT_LEAST16_MAX
 };

136 
verify
 (
TYPE_MAXIMUM
 (
uint_least16_t
) == 
UINT_LEAST16_MAX
);

137 
verify_same_types
 (
UINT_LEAST16_MAX
, (
uint_least16_t
) 0 + 0);

139 
uint_least32_t
 
	gd3
[2] = { 17, 
UINT_LEAST32_MAX
 };

140 
verify
 (
TYPE_MAXIMUM
 (
uint_least32_t
) == 
UINT_LEAST32_MAX
);

141 
verify_same_types
 (
UINT_LEAST32_MAX
, (
uint_least32_t
) 0 + 0);

143 #ifdef 
UINT_LEAST64_MAX


144 
uint_least64_t
 
	gd4
[2] = { 17, 
UINT_LEAST64_MAX
 };

145 
verify
 (
TYPE_MAXIMUM
 (
uint_least64_t
) == 
UINT_LEAST64_MAX
);

146 
verify_same_types
 (
UINT_LEAST64_MAX
, (
uint_least64_t
) 0 + 0);

149 #if 
INT_LEAST8_MIN
 && 
INT_LEAST8_MAX
 && 
INT_LEAST16_MIN
 && 
INT_LEAST16_MAX
 && 
INT_LEAST32_MIN
 && 
INT_LEAST32_MAX


152 
err
 
	gor
;

155 #if 
UINT_LEAST8_MAX
 && 
UINT_LEAST16_MAX
 && 
UINT_LEAST32_MAX


158 
err
 
	gor
;

164 
int_fast8_t
 
	ge1
[3] = { 17, 
INT_FAST8_MIN
, 
INT_FAST8_MAX
 };

165 
verify
 (
TYPE_MINIMUM
 (
int_fast8_t
) == 
INT_FAST8_MIN
);

166 
verify
 (
TYPE_MAXIMUM
 (
int_fast8_t
) == 
INT_FAST8_MAX
);

167 
verify_same_types
 (
INT_FAST8_MIN
, (
int_fast8_t
) 0 + 0);

168 
verify_same_types
 (
INT_FAST8_MAX
, (
int_fast8_t
) 0 + 0);

170 
int_fast16_t
 
	ge2
[3] = { 17, 
INT_FAST16_MIN
, 
INT_FAST16_MAX
 };

171 
verify
 (
TYPE_MINIMUM
 (
int_fast16_t
) == 
INT_FAST16_MIN
);

172 
verify
 (
TYPE_MAXIMUM
 (
int_fast16_t
) == 
INT_FAST16_MAX
);

173 
verify_same_types
 (
INT_FAST16_MIN
, (
int_fast16_t
) 0 + 0);

174 
verify_same_types
 (
INT_FAST16_MAX
, (
int_fast16_t
) 0 + 0);

176 
int_fast32_t
 
	ge3
[3] = { 17, 
INT_FAST32_MIN
, 
INT_FAST32_MAX
 };

177 
verify
 (
TYPE_MINIMUM
 (
int_fast32_t
) == 
INT_FAST32_MIN
);

178 
verify
 (
TYPE_MAXIMUM
 (
int_fast32_t
) == 
INT_FAST32_MAX
);

179 
verify_same_types
 (
INT_FAST32_MIN
, (
int_fast32_t
) 0 + 0);

180 
verify_same_types
 (
INT_FAST32_MAX
, (
int_fast32_t
) 0 + 0);

182 #ifdef 
INT_FAST64_MAX


183 
int_fast64_t
 
	ge4
[3] = { 17, 
INT_FAST64_MIN
, 
INT_FAST64_MAX
 };

184 
verify
 (
TYPE_MINIMUM
 (
int_fast64_t
) == 
INT_FAST64_MIN
);

185 
verify
 (
TYPE_MAXIMUM
 (
int_fast64_t
) == 
INT_FAST64_MAX
);

186 
verify_same_types
 (
INT_FAST64_MIN
, (
int_fast64_t
) 0 + 0);

187 
verify_same_types
 (
INT_FAST64_MAX
, (
int_fast64_t
) 0 + 0);

190 
uint_fast8_t
 
	gf1
[2] = { 17, 
UINT_FAST8_MAX
 };

191 
verify
 (
TYPE_MAXIMUM
 (
uint_fast8_t
) == 
UINT_FAST8_MAX
);

192 
verify_same_types
 (
UINT_FAST8_MAX
, (
uint_fast8_t
) 0 + 0);

194 
uint_fast16_t
 
	gf2
[2] = { 17, 
UINT_FAST16_MAX
 };

195 
verify
 (
TYPE_MAXIMUM
 (
uint_fast16_t
) == 
UINT_FAST16_MAX
);

196 
verify_same_types
 (
UINT_FAST16_MAX
, (
uint_fast16_t
) 0 + 0);

198 
uint_fast32_t
 
	gf3
[2] = { 17, 
UINT_FAST32_MAX
 };

199 
verify
 (
TYPE_MAXIMUM
 (
uint_fast32_t
) == 
UINT_FAST32_MAX
);

200 
verify_same_types
 (
UINT_FAST32_MAX
, (
uint_fast32_t
) 0 + 0);

202 #ifdef 
UINT_FAST64_MAX


203 
uint_fast64_t
 
	gf4
[2] = { 17, 
UINT_FAST64_MAX
 };

204 
verify
 (
TYPE_MAXIMUM
 (
uint_fast64_t
) == 
UINT_FAST64_MAX
);

205 
verify_same_types
 (
UINT_FAST64_MAX
, (
uint_fast64_t
) 0 + 0);

208 #if 
INT_FAST8_MIN
 && 
INT_FAST8_MAX
 && 
INT_FAST16_MIN
 && 
INT_FAST16_MAX
 && 
INT_FAST32_MIN
 && 
INT_FAST32_MAX


211 
err
 
	gor
;

214 #if 
UINT_FAST8_MAX
 && 
UINT_FAST16_MAX
 && 
UINT_FAST32_MAX


217 
err
 
	gor
;

223 
intptr_t
 
	gg
[3] = { 17, 
INTPTR_MIN
, 
INTPTR_MAX
 };

224 
verify
 (
TYPE_MINIMUM
 (
intptr_t
) == 
INTPTR_MIN
);

225 
verify
 (
TYPE_MAXIMUM
 (
intptr_t
) == 
INTPTR_MAX
);

226 
verify_same_types
 (
INTPTR_MIN
, (
intptr_t
) 0 + 0);

227 
verify_same_types
 (
INTPTR_MAX
, (
intptr_t
) 0 + 0);

229 
uintptr_t
 
	gh
[2] = { 17, 
UINTPTR_MAX
 };

230 
verify
 (
TYPE_MAXIMUM
 (
uintptr_t
) == 
UINTPTR_MAX
);

231 
verify_same_types
 (
UINTPTR_MAX
, (
uintptr_t
) 0 + 0);

233 #if 
INTPTR_MIN
 && 
INTPTR_MAX
 && 
UINTPTR_MAX


236 
err
 
	gor
;

242 
intmax_t
 
	gi
[3] = { 
INTMAX_C
 (17), 
INTMAX_MIN
, 
INTMAX_MAX
 };

243 
verify
 (
TYPE_MINIMUM
 (
intmax_t
) == 
INTMAX_MIN
);

244 
verify
 (
TYPE_MAXIMUM
 (
intmax_t
) == 
INTMAX_MAX
);

245 
verify_same_types
 (
INTMAX_MIN
, (
intmax_t
) 0 + 0);

246 
verify_same_types
 (
INTMAX_MAX
, (
intmax_t
) 0 + 0);

248 
uintmax_t
 
	gj
[2] = { 
UINTMAX_C
 (17), 
UINTMAX_MAX
 };

249 
verify
 (
TYPE_MAXIMUM
 (
uintmax_t
) == 
UINTMAX_MAX
);

250 
verify_same_types
 (
UINTMAX_MAX
, (
uintmax_t
) 0 + 0);

254 #if !(
defined
 
__SUNPRO_C
 || (defined 
__hpux
 && !defined 
__GNUC__
))

255 #if 
INTMAX_MIN
 && 
INTMAX_MAX
 && 
UINTMAX_MAX


258 
err
 
	gor
;

264 #include 
	~<stddef.h
>

266 
verify
 (
TYPE_MINIMUM
 (
ptrdiff_t
) == 
PTRDIFF_MIN
);

267 
verify
 (
TYPE_MAXIMUM
 (
ptrdiff_t
) == 
PTRDIFF_MAX
);

268 
verify_same_types
 (
PTRDIFF_MIN
, (
ptrdiff_t
) 0 + 0);

269 
verify_same_types
 (
PTRDIFF_MAX
, (
ptrdiff_t
) 0 + 0);

271 #if 
PTRDIFF_MIN
 && 
PTRDIFF_MAX


274 
err
 
	gor
;

277 #include 
	~<signal.h
>

279 
verify
 (
TYPE_MINIMUM
 (
sig_atomic_t
) == 
SIG_ATOMIC_MIN
);

280 
verify
 (
TYPE_MAXIMUM
 (
sig_atomic_t
) == 
SIG_ATOMIC_MAX
);

281 
verify_same_types
 (
SIG_ATOMIC_MIN
, (
sig_atomic_t
) 0 + 0);

282 
verify_same_types
 (
SIG_ATOMIC_MAX
, (
sig_atomic_t
) 0 + 0);

284 #if 
SIG_ATOMIC_MIN
 != 17 && 
SIG_ATOMIC_MAX


287 
err
 
	gor
;

290 
verify
 (
TYPE_MAXIMUM
 (
size_t
) == 
SIZE_MAX
);

291 
verify_same_types
 (
SIZE_MAX
, (
size_t
) 0 + 0);

293 #if 
SIZE_MAX


296 
err
 
	gor
;

299 #if 
HAVE_WCHAR_T


300 
verify
 (
TYPE_MINIMUM
 (
wchar_t
) == 
WCHAR_MIN
);

301 
verify
 (
TYPE_MAXIMUM
 (
wchar_t
) == 
WCHAR_MAX
);

302 
verify_same_types
 (
WCHAR_MIN
, (
wchar_t
) 0 + 0);

303 
verify_same_types
 (
WCHAR_MAX
, (
wchar_t
) 0 + 0);

305 #if 
WCHAR_MIN
 != 17 && 
WCHAR_MAX


308 
err
 
	gor
;

312 #if 
HAVE_WINT_T


313 #include 
	~<wchar.h
>

315 
verify
 (
TYPE_MINIMUM
 (
wint_t
) == 
WINT_MIN
);

316 
verify
 (
TYPE_MAXIMUM
 (
wint_t
) == 
WINT_MAX
);

317 
verify_same_types
 (
WINT_MIN
, (
wint_t
) 0 + 0);

318 
verify_same_types
 (
WINT_MAX
, (
wint_t
) 0 + 0);

320 #if 
WINT_MIN
 != 17 && 
WINT_MAX


323 
err
 
	gor
;

329 
verify
 (
INT8_C
 (17) == 17);

330 
verify_same_types
 (
INT8_C
 (17), (
int_least8_t
)0 + 0);

331 
verify
 (
UINT8_C
 (17) == 17);

332 
verify_same_types
 (
UINT8_C
 (17), (
uint_least8_t
)0 + 0);

334 
verify
 (
INT16_C
 (17) == 17);

335 
verify_same_types
 (
INT16_C
 (17), (
int_least16_t
)0 + 0);

336 
verify
 (
UINT16_C
 (17) == 17);

337 
verify_same_types
 (
UINT16_C
 (17), (
uint_least16_t
)0 + 0);

339 
verify
 (
INT32_C
 (17) == 17);

340 
verify_same_types
 (
INT32_C
 (17), (
int_least32_t
)0 + 0);

341 
verify
 (
UINT32_C
 (17) == 17);

342 
verify_same_types
 (
UINT32_C
 (17), (
uint_least32_t
)0 + 0);

344 #ifdef 
INT64_C


345 
verify
 (
INT64_C
 (17) == 17);

346 
verify_same_types
 (
INT64_C
 (17), (
int_least64_t
)0 + 0);

348 #ifdef 
UINT64_C


349 
verify
 (
UINT64_C
 (17) == 17);

350 
verify_same_types
 (
UINT64_C
 (17), (
uint_least64_t
)0 + 0);

353 
verify
 (
INTMAX_C
 (17) == 17);

354 
verify_same_types
 (
INTMAX_C
 (17), (
intmax_t
)0 + 0);

355 
verify
 (
UINTMAX_C
 (17) == 17);

356 
verify_same_types
 (
UINTMAX_C
 (17), (
uintmax_t
)0 + 0);

360 
	$main
 (void)

363 
	}
}

	@gnulib-tests/test-stdio.c

21 #include 
	~<config.h
>

23 #include 
	~<stdio.h
>

25 #include 
	~"verify.h
"

28 int 
	gsk
[] = { 
SEEK_CUR
, 
SEEK_END
, 
SEEK_SET
 };

32 
verify
 (sizeof 
NULL
 == sizeof (void *));

35 
fpos_t
 
	gt1
;

36 
off_t
 
	gt2
;

37 
size_t
 
	gt3
;

38 
ssize_t
 
	gt4
;

39 
va_list
 
	gt5
;

42 
	$main
 (void)

45 
	}
}

	@gnulib-tests/test-stdlib.c

21 #include 
	~<config.h
>

23 #include 
	~<stdlib.h
>

25 #include 
	~"verify.h
"

28 static int 
	gexitcode
 = 
EXIT_SUCCESS
;

29 #if 
EXIT_SUCCESS


35 #if 
EXIT_FAILURE
 != 1

41 
verify
 (sizeof 
NULL
 == sizeof (void *));

43 #if 
GNULIB_TEST_SYSTEM_POSIX


44 #include 
	~"test-sys_wait.h
"

46 #define 
	#test_sys_wait_macros
() 0

	)

50 
	$main
 (void)

52 if (
	`test_sys_wait_macros
 ())

55 return 
exitcode
;

56 
	}
}

	@gnulib-tests/test-strerror.c

22 #include 
	~<config.h
>

24 #include 
	~<string.h
>

26 #include 
	~"signature.h
"

27 
SIGNATURE_CHECK
 (
strerror
, char *, (int));

29 #include 
	~<errno.h
>

31 #include 
	~"macros.h
"

34 
	$main
 (void)

36 char *
str
;

38 
errno
 = 0;

39 
str
 = 
	`strerror
 (
EACCES
);

40 
	`ASSERT
 (
str
);

41 
	`ASSERT
 (*
str
);

42 
	`ASSERT
 (
errno
 == 0);

44 
errno
 = 0;

45 
str
 = 
	`strerror
 (
ETIMEDOUT
);

46 
	`ASSERT
 (
str
);

47 
	`ASSERT
 (*
str
);

48 
	`ASSERT
 (
errno
 == 0);

50 
errno
 = 0;

51 
str
 = 
	`strerror
 (
EOVERFLOW
);

52 
	`ASSERT
 (
str
);

53 
	`ASSERT
 (*
str
);

54 
	`ASSERT
 (
errno
 == 0);

60 
errno
 = 0;

61 
str
 = 
	`strerror
 (0);

62 
	`ASSERT
 (
str
);

63 
	`ASSERT
 (*
str
);

64 
	`ASSERT
 (
errno
 == 0);

65 
	`ASSERT
 (
	`strstr
 (
str
, "nknown") == 
NULL
);

66 
	`ASSERT
 (
	`strstr
 (
str
, "ndefined") == 
NULL
);

71 
errno
 = 0;

72 
str
 = 
	`strerror
 (-3);

73 
	`ASSERT
 (
str
);

74 
	`ASSERT
 (*
str
);

75 
	`ASSERT
 (
errno
 == 0 || errno == 
EINVAL
);

78 
	}
}

	@gnulib-tests/test-striconv.c

21 #include 
	~<config.h
>

23 #include 
	~"striconv.h
"

25 #if 
HAVE_ICONV


26 #include 
	~<iconv.h
>

29 #include 
	~<errno.h
>

30 #include 
	~<stdlib.h
>

31 #include 
	~<string.h
>

33 #include 
	~"macros.h
"

36 
	$main
 ()

38 #if 
HAVE_ICONV


41 
iconv_t
 
cd_88591_to_utf8
 = 
	`iconv_open
 ("UTF-8", "ISO-8859-1");

42 
iconv_t
 
cd_utf8_to_88591
 = 
	`iconv_open
 ("ISO-8859-1", "UTF-8");

44 
	`ASSERT
 (
cd_88591_to_utf8
 != (
iconv_t
)(-1));

45 
	`ASSERT
 (
cd_utf8_to_88591
 != (
iconv_t
)(-1));

51 static const char 
input
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

52 static const char 
expected
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

53 char *
result
 = 
NULL
;

54 
size_t
 
length
 = 0;

55 int 
retval
 = 
	`mem_cd_iconv
 (
input
, 
	`strlen
 (input), 
cd_88591_to_utf8
,

56 &
result
, &
length
);

57 
	`ASSERT
 (
retval
 == 0);

58 
	`ASSERT
 (
length
 == 
	`strlen
 (
expected
));

59 
	`ASSERT
 (
result
 != 
NULL
 && 
	`memcmp
 (result, 
expected
, 
	`strlen
 (expected)) == 0);

60 
	`free
 (
result
);

65 static const char 
input
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

66 static const char 
expected
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

67 char *
result
 = 
NULL
;

68 
size_t
 
length
 = 0;

69 int 
retval
 = 
	`mem_cd_iconv
 (
input
, 
	`strlen
 (input), 
cd_utf8_to_88591
,

70 &
result
, &
length
);

71 
	`ASSERT
 (
retval
 == 0);

72 
	`ASSERT
 (
length
 == 
	`strlen
 (
expected
));

73 
	`ASSERT
 (
result
 != 
NULL
 && 
	`memcmp
 (result, 
expected
, 
	`strlen
 (expected)) == 0);

74 
	`free
 (
result
);

79 static const char 
input
[] = "\342\202\254";

80 char *
result
 = 
NULL
;

81 
size_t
 
length
 = 0;

82 int 
retval
 = 
	`mem_cd_iconv
 (
input
, 
	`strlen
 (input), 
cd_utf8_to_88591
,

83 &
result
, &
length
);

84 
	`ASSERT
 (
retval
 == -1 && 
errno
 == 
EILSEQ
);

85 
	`ASSERT
 (
result
 == 
NULL
);

90 static const char 
input
[] = "\342";

91 char *
result
 = 
NULL
;

92 
size_t
 
length
 = 0;

93 int 
retval
 = 
	`mem_cd_iconv
 (
input
, 
	`strlen
 (input), 
cd_utf8_to_88591
,

94 &
result
, &
length
);

95 
	`ASSERT
 (
retval
 == 0);

96 
	`ASSERT
 (
length
 == 0);

97 
	`free
 (
result
);

104 static const char 
input
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

105 static const char 
expected
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

106 char *
result
 = 
	`str_cd_iconv
 (
input
, 
cd_88591_to_utf8
);

107 
	`ASSERT
 (
result
 != 
NULL
);

108 
	`ASSERT
 (
	`strcmp
 (
result
, 
expected
) == 0);

109 
	`free
 (
result
);

114 static const char 
input
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

115 static const char 
expected
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

116 char *
result
 = 
	`str_cd_iconv
 (
input
, 
cd_utf8_to_88591
);

117 
	`ASSERT
 (
result
 != 
NULL
);

118 
	`ASSERT
 (
	`strcmp
 (
result
, 
expected
) == 0);

119 
	`free
 (
result
);

124 static const char 
input
[] = "Costs: 27 \342\202\254";

125 char *
result
 = 
	`str_cd_iconv
 (
input
, 
cd_utf8_to_88591
);

126 
	`ASSERT
 (
result
 == 
NULL
 && 
errno
 == 
EILSEQ
);

131 static const char 
input
[] = "\342";

132 char *
result
 = 
	`str_cd_iconv
 (
input
, 
cd_utf8_to_88591
);

133 
	`ASSERT
 (
result
 != 
NULL
);

134 
	`ASSERT
 (
	`strcmp
 (
result
, "") == 0);

135 
	`free
 (
result
);

138 
	`iconv_close
 (
cd_88591_to_utf8
);

139 
	`iconv_close
 (
cd_utf8_to_88591
);

145 static const char 
input
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

146 static const char 
expected
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

147 char *
result
 = 
	`str_iconv
 (
input
, "ISO-8859-1", "UTF-8");

148 
	`ASSERT
 (
result
 != 
NULL
);

149 
	`ASSERT
 (
	`strcmp
 (
result
, 
expected
) == 0);

150 
	`free
 (
result
);

155 static const char 
input
[] = "\303\204rger mit b\303\266sen B\303\274bchen ohne Augenma\303\237";

156 static const char 
expected
[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";

157 char *
result
 = 
	`str_iconv
 (
input
, "UTF-8", "ISO-8859-1");

158 
	`ASSERT
 (
result
 != 
NULL
);

159 
	`ASSERT
 (
	`strcmp
 (
result
, 
expected
) == 0);

160 
	`free
 (
result
);

165 static const char 
input
[] = "Costs: 27 \342\202\254";

166 char *
result
 = 
	`str_iconv
 (
input
, "UTF-8", "ISO-8859-1");

167 
	`ASSERT
 (
result
 == 
NULL
 && 
errno
 == 
EILSEQ
);

172 static const char 
input
[] = "\342";

173 char *
result
 = 
	`str_iconv
 (
input
, "UTF-8", "ISO-8859-1");

174 
	`ASSERT
 (
result
 != 
NULL
);

175 
	`ASSERT
 (
	`strcmp
 (
result
, "") == 0);

176 
	`free
 (
result
);

182 
	}
}

	@gnulib-tests/test-string.c

21 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #include 
	~"verify.h
"

29 
verify
 (sizeof 
NULL
 == sizeof (void *));

32 
	$main
 (void)

35 
	}
}

	@gnulib-tests/test-strings.c

21 #include 
	~<config.h
>

23 #include 
	~<strings.h
>

26 
	$main
 ()

29 
	}
}

	@gnulib-tests/test-strnlen.c

20 #include 
	~<config.h
>

22 #include 
	~<string.h
>

24 #include 
	~"signature.h
"

25 
SIGNATURE_CHECK
 (
strnlen
, 
size_t
, (char const *, size_t));

27 #include 
	~<stdlib.h
>

29 #include 
	~"zerosize-ptr.h
"

30 #include 
	~"macros.h
"

33 
	$main
 (void)

35 
size_t
 
i
;

36 char *
page_boundary
 = (char *) 
	`zerosize_ptr
 ();

37 if (!
page_boundary
)

39 
page_boundary
 = 
	`malloc
 (0x1000);

40 
	`ASSERT
 (
page_boundary
);

41 
page_boundary
 += 0x1000;

45 
	`ASSERT
 (
	`strnlen
 ("a", 0) == 0);

46 
	`ASSERT
 (
	`strnlen
 ("a", 1) == 1);

47 
	`ASSERT
 (
	`strnlen
 ("a", 2) == 1);

48 
	`ASSERT
 (
	`strnlen
 ("", 0x100000) == 0);

51 for (
i
 = 0; i < 512; i++)

53 char *
start
 = 
page_boundary
 - 
i
;

54 
size_t
 
j
 = 
i
;

55 
	`memset
 (
start
, 'x', 
i
);

58 if (
i
 != 
j
)

60 
start
[
j
] = 0;

61 
	`ASSERT
 (
	`strnlen
 (
start
, 
i
 + 
j
) == j);

63 
	`ASSERT
 (
	`strnlen
 (
start
, 
i
) == 
j
);

64 
	`ASSERT
 (
	`strnlen
 (
start
, 
j
) == j);

66 while (
j
--);

70 
	}
}

	@gnulib-tests/test-strtoumax.c

19 #include 
	~<config.h
>

21 #include 
	~<inttypes.h
>

23 #include 
	~"signature.h
"

24 #ifndef 
strtoumax


25 
SIGNATURE_CHECK
 (
strtoumax
, 
uintmax_t
, (const char *, char **, int));

28 #include 
	~<errno.h
>

30 #include 
	~"macros.h
"

33 
	$main
 (void)

37 const char 
input
[] = "";

38 char *
ptr
;

39 
uintmax_t
 
result
;

40 
errno
 = 0;

41 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

42 
	`ASSERT
 (
result
 == 0);

43 
	`ASSERT
 (
ptr
 == 
input
);

44 
	`ASSERT
 (
errno
 == 0 || errno == 
EINVAL
);

47 const char 
input
[] = " ";

48 char *
ptr
;

49 
uintmax_t
 
result
;

50 
errno
 = 0;

51 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

52 
	`ASSERT
 (
result
 == 0);

53 
	`ASSERT
 (
ptr
 == 
input
);

54 
	`ASSERT
 (
errno
 == 0 || errno == 
EINVAL
);

57 const char 
input
[] = " +";

58 char *
ptr
;

59 
uintmax_t
 
result
;

60 
errno
 = 0;

61 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

62 
	`ASSERT
 (
result
 == 0);

63 
	`ASSERT
 (
ptr
 == 
input
);

64 
	`ASSERT
 (
errno
 == 0 || errno == 
EINVAL
);

67 const char 
input
[] = " -";

68 char *
ptr
;

69 
uintmax_t
 
result
;

70 
errno
 = 0;

71 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

72 
	`ASSERT
 (
result
 == 0);

73 
	`ASSERT
 (
ptr
 == 
input
);

74 
	`ASSERT
 (
errno
 == 0 || errno == 
EINVAL
);

79 const char 
input
[] = "0";

80 char *
ptr
;

81 
uintmax_t
 
result
;

82 
errno
 = 0;

83 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

84 
	`ASSERT
 (
result
 == 0);

85 
	`ASSERT
 (
ptr
 == 
input
 + 1);

86 
	`ASSERT
 (
errno
 == 0);

89 const char 
input
[] = "+0";

90 char *
ptr
;

91 
uintmax_t
 
result
;

92 
errno
 = 0;

93 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

94 
	`ASSERT
 (
result
 == 0);

95 
	`ASSERT
 (
ptr
 == 
input
 + 2);

96 
	`ASSERT
 (
errno
 == 0);

99 const char 
input
[] = "-0";

100 char *
ptr
;

101 
uintmax_t
 
result
;

102 
errno
 = 0;

103 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

104 
	`ASSERT
 (
result
 == 0);

105 
	`ASSERT
 (
ptr
 == 
input
 + 2);

106 
	`ASSERT
 (
errno
 == 0);

109 const char 
input
[] = "23";

110 char *
ptr
;

111 
uintmax_t
 
result
;

112 
errno
 = 0;

113 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

114 
	`ASSERT
 (
result
 == 23);

115 
	`ASSERT
 (
ptr
 == 
input
 + 2);

116 
	`ASSERT
 (
errno
 == 0);

119 const char 
input
[] = " 23";

120 char *
ptr
;

121 
uintmax_t
 
result
;

122 
errno
 = 0;

123 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

124 
	`ASSERT
 (
result
 == 23);

125 
	`ASSERT
 (
ptr
 == 
input
 + 3);

126 
	`ASSERT
 (
errno
 == 0);

129 const char 
input
[] = "+23";

130 char *
ptr
;

131 
uintmax_t
 
result
;

132 
errno
 = 0;

133 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

134 
	`ASSERT
 (
result
 == 23);

135 
	`ASSERT
 (
ptr
 == 
input
 + 3);

136 
	`ASSERT
 (
errno
 == 0);

139 const char 
input
[] = "-23";

140 char *
ptr
;

141 
uintmax_t
 
result
;

142 
errno
 = 0;

143 
result
 = 
	`strtoumax
 (
input
, &
ptr
, 10);

144 
	`ASSERT
 (
result
 == - (
uintmax_t
) 23);

145 
	`ASSERT
 (
ptr
 == 
input
 + 3);

146 
	`ASSERT
 (
errno
 == 0);

150 
	}
}

	@gnulib-tests/test-symlink.c

21 #include 
	~<config.h
>

23 #include 
	~<unistd.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
symlink
, int, (char const *, char const *));

28 #include 
	~<fcntl.h
>

29 #include 
	~<errno.h
>

30 #include 
	~<stdbool.h
>

31 #include 
	~<stdio.h
>

32 #include 
	~<stdlib.h
>

33 #include 
	~<sys/stat.h
>

35 #include 
	~"ignore-value.h
"

36 #include 
	~"macros.h
"

38 #define 
	#BASE
 "test-symlink.t"

	)

40 #include 
	~"test-symlink.h
"

43 
	$main
 (void)

46 
	`ignore_value
 (
	`system
 ("rm -rf " 
BASE
 "*"));

48 return 
	`test_symlink
 (
symlink
, 
true
);

49 
	}
}

	@gnulib-tests/test-symlink.h

28 
test_symlink
 (int (*
func
) (char const *, char const *), 
bool
 
print
)

30 if (
	`func
 ("nowhere", 
BASE
 "link1"))

32 if (
print
)

33 
	`fputs
 ("skipping test: symlinks not supported on this file system\n",

34 
stderr
);

41 int 
status
;

42 
errno
 = 0;

43 
status
 = 
	`func
 ("", 
BASE
 "link2");

44 if (
status
 == -1)

45 
	`ASSERT
 (
errno
 == 
ENOENT
 || errno == 
EINVAL
);

48 
	`ASSERT
 (
status
 == 0);

49 
	`ASSERT
 (
	`unlink
 (
BASE
 "link2") == 0);

54 
errno
 = 0;

55 
	`ASSERT
 (
	`func
 ("nowhere", "") == -1);

56 
	`ASSERT
 (
errno
 == 
ENOENT
);

57 
errno
 = 0;

58 
	`ASSERT
 (
	`func
 ("nowhere", ".") == -1);

59 
	`ASSERT
 (
errno
 == 
EEXIST
 || errno == 
EINVAL
);

60 
errno
 = 0;

61 
	`ASSERT
 (
	`func
 ("somewhere", 
BASE
 "link1") == -1);

62 
	`ASSERT
 (
errno
 == 
EEXIST
);

63 
errno
 = 0;

64 
	`ASSERT
 (
	`func
 ("nowhere", 
BASE
 "link2/") == -1);

65 
	`ASSERT
 (
errno
 == 
ENOTDIR
 || errno == 
ENOENT
);

66 
	`ASSERT
 (
	`mkdir
 (
BASE
 "dir", 0700) == 0);

67 
errno
 = 0;

68 
	`ASSERT
 (
	`func
 ("nowhere", 
BASE
 "dir") == -1);

69 
	`ASSERT
 (
errno
 == 
EEXIST
);

70 
errno
 = 0;

71 
	`ASSERT
 (
	`func
 ("nowhere", 
BASE
 "dir/") == -1);

72 
	`ASSERT
 (
errno
 == 
EEXIST
 || errno == 
EINVAL
);

73 
	`ASSERT
 (
	`close
 (
	`creat
 (
BASE
 "file", 0600)) == 0);

74 
errno
 = 0;

75 
	`ASSERT
 (
	`func
 ("nowhere", 
BASE
 "file") == -1);

76 
	`ASSERT
 (
errno
 == 
EEXIST
);

77 
errno
 = 0;

78 
	`ASSERT
 (
	`func
 ("nowhere", 
BASE
 "file/") == -1);

79 
	`ASSERT
 (
errno
 == 
EEXIST
 || errno == 
ENOTDIR
 || errno == 
ENOENT
);

82 
	`ASSERT
 (
	`unlink
 (
BASE
 "link1") == 0);

83 
	`ASSERT
 (
	`func
 (
BASE
 "link2", BASE "link1") == 0);

84 
errno
 = 0;

85 
	`ASSERT
 (
	`func
 (
BASE
 "nowhere", BASE "link1/") == -1);

86 
	`ASSERT
 (
errno
 == 
EEXIST
 || errno == 
ENOTDIR
 || errno == 
ENOENT
);

87 
errno
 = 0;

88 
	`ASSERT
 (
	`unlink
 (
BASE
 "link2") == -1);

89 
	`ASSERT
 (
errno
 == 
ENOENT
);

92 
	`ASSERT
 (
	`rmdir
 (
BASE
 "dir") == 0);

93 
	`ASSERT
 (
	`unlink
 (
BASE
 "file") == 0);

94 
	`ASSERT
 (
	`unlink
 (
BASE
 "link1") == 0);

97 
	}
}

	@gnulib-tests/test-sys_stat.c

21 #include 
	~<config.h
>

23 #include 
	~<sys/stat.h
>

25 #include 
	~"verify.h
"

28 int 
	ga
[] =

30 
S_IFMT
,

31 #ifdef 
S_IFBLK


32 
S_IFBLK
,

34 
S_IFCHR
, 
S_IFDIR
, 
S_IFIFO
, 
S_IFREG
,

35 #ifdef 
S_IFLNK


36 
S_IFLNK
,

38 #ifdef 
S_IFSOCK


39 
S_IFSOCK
,

41 
S_IRWXU
, 
S_IRUSR
, 
S_IWUSR
, 
S_IXUSR
,

42 
S_IRWXG
, 
S_IRGRP
, 
S_IWGRP
, 
S_IXGRP
,

43 
S_IRWXO
, 
S_IROTH
, 
S_IWOTH
, 
S_IXOTH
,

44 
S_ISUID
, 
S_ISGID
, 
S_ISVTX
,

45 
S_ISBLK
 (
S_IFREG
),

46 
S_ISCHR
 (
S_IFREG
),

47 
S_ISDIR
 (
S_IFREG
),

48 
S_ISFIFO
 (
S_IFREG
),

49 
S_ISREG
 (
S_IFREG
),

50 
S_ISLNK
 (
S_IFREG
),

51 
S_ISSOCK
 (
S_IFREG
),

52 
S_ISDOOR
 (
S_IFREG
),

53 
S_ISMPB
 (
S_IFREG
),

54 
S_ISNAM
 (
S_IFREG
),

55 
S_ISNWK
 (
S_IFREG
),

56 
S_ISPORT
 (
S_IFREG
),

57 
S_ISCTG
 (
S_IFREG
),

58 
S_ISOFD
 (
S_IFREG
),

59 
S_ISOFL
 (
S_IFREG
),

60 
S_ISWHT
 (
S_IFREG
)

65 
verify
 (
S_IRWXU
 == (
S_IRUSR
 | 
S_IWUSR
 | 
S_IXUSR
));

66 
verify
 (
S_IRWXG
 == (
S_IRGRP
 | 
S_IWGRP
 | 
S_IXGRP
));

67 
verify
 (
S_IRWXO
 == (
S_IROTH
 | 
S_IWOTH
 | 
S_IXOTH
));

69 #ifdef 
S_IFBLK


70 
verify
 (
S_ISBLK
 (
S_IFBLK
));

72 
verify
 (!
S_ISBLK
 (
S_IFCHR
));

73 
verify
 (!
S_ISBLK
 (
S_IFDIR
));

74 
verify
 (!
S_ISBLK
 (
S_IFIFO
));

75 
verify
 (!
S_ISBLK
 (
S_IFREG
));

76 #ifdef 
S_IFLNK


77 
verify
 (!
S_ISBLK
 (
S_IFLNK
));

79 #ifdef 
S_IFSOCK


80 
verify
 (!
S_ISBLK
 (
S_IFSOCK
));

83 #ifdef 
S_IFBLK


84 
verify
 (!
S_ISCHR
 (
S_IFBLK
));

86 
verify
 (
S_ISCHR
 (
S_IFCHR
));

87 
verify
 (!
S_ISCHR
 (
S_IFDIR
));

88 
verify
 (!
S_ISCHR
 (
S_IFIFO
));

89 
verify
 (!
S_ISCHR
 (
S_IFREG
));

90 #ifdef 
S_IFLNK


91 
verify
 (!
S_ISCHR
 (
S_IFLNK
));

93 #ifdef 
S_IFSOCK


94 
verify
 (!
S_ISCHR
 (
S_IFSOCK
));

97 #ifdef 
S_IFBLK


98 
verify
 (!
S_ISDIR
 (
S_IFBLK
));

100 
verify
 (!
S_ISDIR
 (
S_IFCHR
));

101 
verify
 (
S_ISDIR
 (
S_IFDIR
));

102 
verify
 (!
S_ISDIR
 (
S_IFIFO
));

103 
verify
 (!
S_ISDIR
 (
S_IFREG
));

104 #ifdef 
S_IFLNK


105 
verify
 (!
S_ISDIR
 (
S_IFLNK
));

107 #ifdef 
S_IFSOCK


108 
verify
 (!
S_ISDIR
 (
S_IFSOCK
));

111 #ifdef 
S_IFBLK


112 
verify
 (!
S_ISFIFO
 (
S_IFBLK
));

114 
verify
 (!
S_ISFIFO
 (
S_IFCHR
));

115 
verify
 (!
S_ISFIFO
 (
S_IFDIR
));

116 
verify
 (
S_ISFIFO
 (
S_IFIFO
));

117 
verify
 (!
S_ISFIFO
 (
S_IFREG
));

118 #ifdef 
S_IFLNK


119 
verify
 (!
S_ISFIFO
 (
S_IFLNK
));

121 #ifdef 
S_IFSOCK


122 
verify
 (!
S_ISFIFO
 (
S_IFSOCK
));

125 #ifdef 
S_IFBLK


126 
verify
 (!
S_ISREG
 (
S_IFBLK
));

128 
verify
 (!
S_ISREG
 (
S_IFCHR
));

129 
verify
 (!
S_ISREG
 (
S_IFDIR
));

130 
verify
 (!
S_ISREG
 (
S_IFIFO
));

131 
verify
 (
S_ISREG
 (
S_IFREG
));

132 #ifdef 
S_IFLNK


133 
verify
 (!
S_ISREG
 (
S_IFLNK
));

135 #ifdef 
S_IFSOCK


136 
verify
 (!
S_ISREG
 (
S_IFSOCK
));

139 #ifdef 
S_IFBLK


140 
verify
 (!
S_ISLNK
 (
S_IFBLK
));

142 
verify
 (!
S_ISLNK
 (
S_IFCHR
));

143 
verify
 (!
S_ISLNK
 (
S_IFDIR
));

144 
verify
 (!
S_ISLNK
 (
S_IFIFO
));

145 
verify
 (!
S_ISLNK
 (
S_IFREG
));

146 #ifdef 
S_IFLNK


147 
verify
 (
S_ISLNK
 (
S_IFLNK
));

149 #ifdef 
S_IFSOCK


150 
verify
 (!
S_ISLNK
 (
S_IFSOCK
));

153 #ifdef 
S_IFBLK


154 
verify
 (!
S_ISSOCK
 (
S_IFBLK
));

156 
verify
 (!
S_ISSOCK
 (
S_IFCHR
));

157 
verify
 (!
S_ISSOCK
 (
S_IFDIR
));

158 
verify
 (!
S_ISSOCK
 (
S_IFIFO
));

159 
verify
 (!
S_ISSOCK
 (
S_IFREG
));

160 #ifdef 
S_IFLNK


161 
verify
 (!
S_ISSOCK
 (
S_IFLNK
));

163 #ifdef 
S_IFSOCK


164 
verify
 (
S_ISSOCK
 (
S_IFSOCK
));

167 #ifdef 
S_IFBLK


168 
verify
 (!
S_ISDOOR
 (
S_IFBLK
));

170 
verify
 (!
S_ISDOOR
 (
S_IFCHR
));

171 
verify
 (!
S_ISDOOR
 (
S_IFDIR
));

172 
verify
 (!
S_ISDOOR
 (
S_IFIFO
));

173 
verify
 (!
S_ISDOOR
 (
S_IFREG
));

174 #ifdef 
S_IFLNK


175 
verify
 (!
S_ISDOOR
 (
S_IFLNK
));

177 #ifdef 
S_IFSOCK


178 
verify
 (!
S_ISDOOR
 (
S_IFSOCK
));

181 #ifdef 
S_IFBLK


182 
verify
 (!
S_ISMPB
 (
S_IFBLK
));

184 
verify
 (!
S_ISMPB
 (
S_IFCHR
));

185 
verify
 (!
S_ISMPB
 (
S_IFDIR
));

186 
verify
 (!
S_ISMPB
 (
S_IFIFO
));

187 
verify
 (!
S_ISMPB
 (
S_IFREG
));

188 #ifdef 
S_IFLNK


189 
verify
 (!
S_ISMPB
 (
S_IFLNK
));

191 #ifdef 
S_IFSOCK


192 
verify
 (!
S_ISMPB
 (
S_IFSOCK
));

195 #ifdef 
S_IFBLK


196 
verify
 (!
S_ISNAM
 (
S_IFBLK
));

198 
verify
 (!
S_ISNAM
 (
S_IFCHR
));

199 
verify
 (!
S_ISNAM
 (
S_IFDIR
));

200 
verify
 (!
S_ISNAM
 (
S_IFIFO
));

201 
verify
 (!
S_ISNAM
 (
S_IFREG
));

202 #ifdef 
S_IFLNK


203 
verify
 (!
S_ISNAM
 (
S_IFLNK
));

205 #ifdef 
S_IFSOCK


206 
verify
 (!
S_ISNAM
 (
S_IFSOCK
));

209 #ifdef 
S_IFBLK


210 
verify
 (!
S_ISNWK
 (
S_IFBLK
));

212 
verify
 (!
S_ISNWK
 (
S_IFCHR
));

213 
verify
 (!
S_ISNWK
 (
S_IFDIR
));

214 
verify
 (!
S_ISNWK
 (
S_IFIFO
));

215 
verify
 (!
S_ISNWK
 (
S_IFREG
));

216 #ifdef 
S_IFLNK


217 
verify
 (!
S_ISNWK
 (
S_IFLNK
));

219 #ifdef 
S_IFSOCK


220 
verify
 (!
S_ISNWK
 (
S_IFSOCK
));

223 #ifdef 
S_IFBLK


224 
verify
 (!
S_ISPORT
 (
S_IFBLK
));

226 
verify
 (!
S_ISPORT
 (
S_IFCHR
));

227 
verify
 (!
S_ISPORT
 (
S_IFDIR
));

228 
verify
 (!
S_ISPORT
 (
S_IFIFO
));

229 
verify
 (!
S_ISPORT
 (
S_IFREG
));

230 #ifdef 
S_IFLNK


231 
verify
 (!
S_ISPORT
 (
S_IFLNK
));

233 #ifdef 
S_IFSOCK


234 
verify
 (!
S_ISPORT
 (
S_IFSOCK
));

237 #ifdef 
S_IFBLK


238 
verify
 (!
S_ISCTG
 (
S_IFBLK
));

240 
verify
 (!
S_ISCTG
 (
S_IFCHR
));

241 
verify
 (!
S_ISCTG
 (
S_IFDIR
));

242 
verify
 (!
S_ISCTG
 (
S_IFIFO
));

243 
verify
 (!
S_ISCTG
 (
S_IFREG
));

244 #ifdef 
S_IFLNK


245 
verify
 (!
S_ISCTG
 (
S_IFLNK
));

247 #ifdef 
S_IFSOCK


248 
verify
 (!
S_ISCTG
 (
S_IFSOCK
));

251 #ifdef 
S_IFBLK


252 
verify
 (!
S_ISOFD
 (
S_IFBLK
));

254 
verify
 (!
S_ISOFD
 (
S_IFCHR
));

255 
verify
 (!
S_ISOFD
 (
S_IFDIR
));

256 
verify
 (!
S_ISOFD
 (
S_IFIFO
));

257 
verify
 (!
S_ISOFD
 (
S_IFREG
));

258 #ifdef 
S_IFLNK


259 
verify
 (!
S_ISOFD
 (
S_IFLNK
));

261 #ifdef 
S_IFSOCK


262 
verify
 (!
S_ISOFD
 (
S_IFSOCK
));

265 #ifdef 
S_IFBLK


266 
verify
 (!
S_ISOFL
 (
S_IFBLK
));

268 
verify
 (!
S_ISOFL
 (
S_IFCHR
));

269 
verify
 (!
S_ISOFL
 (
S_IFDIR
));

270 
verify
 (!
S_ISOFL
 (
S_IFIFO
));

271 
verify
 (!
S_ISOFL
 (
S_IFREG
));

272 #ifdef 
S_IFLNK


273 
verify
 (!
S_ISOFL
 (
S_IFLNK
));

275 #ifdef 
S_IFSOCK


276 
verify
 (!
S_ISOFL
 (
S_IFSOCK
));

279 #ifdef 
S_IFBLK


280 
verify
 (!
S_ISWHT
 (
S_IFBLK
));

282 
verify
 (!
S_ISWHT
 (
S_IFCHR
));

283 
verify
 (!
S_ISWHT
 (
S_IFDIR
));

284 
verify
 (!
S_ISWHT
 (
S_IFIFO
));

285 
verify
 (!
S_ISWHT
 (
S_IFREG
));

286 #ifdef 
S_IFLNK


287 
verify
 (!
S_ISWHT
 (
S_IFLNK
));

289 #ifdef 
S_IFSOCK


290 
verify
 (!
S_ISWHT
 (
S_IFSOCK
));

294 
verify
 (
S_IRWXU
 == 00700);

295 
verify
 (
S_IRUSR
 == 00400);

296 
verify
 (
S_IWUSR
 == 00200);

297 
verify
 (
S_IXUSR
 == 00100);

298 
verify
 (
S_IRWXG
 == 00070);

299 
verify
 (
S_IRGRP
 == 00040);

300 
verify
 (
S_IWGRP
 == 00020);

301 
verify
 (
S_IXGRP
 == 00010);

302 
verify
 (
S_IRWXO
 == 00007);

303 
verify
 (
S_IROTH
 == 00004);

304 
verify
 (
S_IWOTH
 == 00002);

305 
verify
 (
S_IXOTH
 == 00001);

306 
verify
 (
S_ISUID
 == 04000);

307 
verify
 (
S_ISGID
 == 02000);

308 
verify
 (
S_ISVTX
 == 01000);

310 #if ((0 <= 
UTIME_NOW
 && UTIME_NOW < 1000000000) \

311 || (0 <= 
UTIME_OMIT
 && UTIME_OMIT < 1000000000) \

312 || 
UTIME_NOW
 == 
UTIME_OMIT
)

313 
invalid
 
UTIME
 
macros


317 
nlink_t
 
t1
;

318 
off_t
 
	gt2
;

319 
mode_t
 
	gt3
;

321 struct 
timespec
 
	gst
;

324 
	$main
 (void)

327 
	}
}

	@gnulib-tests/test-sys_types.c

21 #include 
	~<config.h
>

23 #include 
	~<sys/types.h
>

26 
pid_t
 
	gt1
;

27 
size_t
 
	gt2
;

28 
ssize_t
 
	gt3
;

29 
off_t
 
	gt4
;

30 
mode_t
 
	gt5
;

33 
	$main
 (void)

36 
	}
}

	@gnulib-tests/test-sys_wait.h

22 
	$test_sys_wait_macros
 (void)

27 int 
i
;

28 for (
i
 = 0; i < 0x8000; i = (i ? i << 1 : 1))

38 if (
i
 == 0x80)

40 if (!!
	`WIFSIGNALED
 (
i
) + !!
	`WIFEXITED
 (i) + !!
	`WIFSTOPPED
 (i) != 1)

43 
i
 = 
	`WEXITSTATUS
 (i) + 
	`WSTOPSIG
 (i) + 
	`WTERMSIG
 (i);

45 switch (
i
)

49 case 
WNOHANG
:

50 case 
WUNTRACED
:

55 
	}
}

	@gnulib-tests/test-thread_create.c

21 #include 
	~<config.h
>

23 #include 
	~"glthread/thread.h
"

25 #include 
	~<stdio.h
>

26 #include 
	~<string.h
>

28 #include 
	~"macros.h
"

30 static 
gl_thread_t
 
	gmain_thread_before
;

31 static 
gl_thread_t
 
	gmain_thread_after
;

32 static 
gl_thread_t
 
	gworker_thread
;

34 static int 
	gdummy
;

35 static volatile int 
	gwork_done
;

38 
	$worker_thread_func
 (void *
arg
)

40 
work_done
 = 1;

41 return &
dummy
;

42 
	}
}

45 
	$main
 ()

47 
main_thread_before
 = 
	`gl_thread_self
 ();

49 if (
	`glthread_create
 (&
worker_thread
, 
worker_thread_func
, 
NULL
) == 0)

51 void *
ret
;

55 
main_thread_after
 = 
	`gl_thread_self
 ();

56 
	`ASSERT
 (
	`memcmp
 (&
main_thread_before
, &
main_thread_after
,

57 sizeof (
gl_thread_t
))

60 
	`gl_thread_join
 (
worker_thread
, &
ret
);

63 
	`ASSERT
 (
ret
 == &
dummy
);

66 
	`ASSERT
 (
work_done
);

72 #if 
USE_POSIX_THREADS
 || 
USE_SOLARIS_THREADS
 || 
USE_PTH_THREADS
 || 
USE_WIN32_THREADS


73 
	`fputs
 ("glthread_create failed\n", 
stderr
);

76 
	`fputs
 ("Skipping test: multithreading not enabled\n", 
stderr
);

80 
	}
}

	@gnulib-tests/test-thread_self.c

21 #include 
	~<config.h
>

23 #include 
	~"glthread/thread.h
"

25 
gl_thread_t
 
	gmain_thread
;

28 
	$main
 ()

33 
main_thread
 = 
	`gl_thread_self
 ();

36 
	}
}

	@gnulib-tests/test-time.c

21 #include 
	~<config.h
>

23 #include 
	~<time.h
>

25 #include 
	~"verify.h
"

28 struct 
timespec
 
	gt1
;

32 
pid_t
 
	gt2
;

37 
verify
 (sizeof 
NULL
 == sizeof (void *));

40 
	$main
 (void)

43 
	}
}

	@gnulib-tests/test-unistd.c

21 #include 
	~<config.h
>

23 #include 
	~<unistd.h
>

25 #include 
	~"verify.h
"

29 
verify
 (sizeof 
NULL
 == sizeof (void *));

32 int 
	gsk
[] = { 
SEEK_CUR
, 
SEEK_END
, 
SEEK_SET
 };

35 #if ! (
defined
 
STDIN_FILENO
 \

36 && (
	gSTDIN_FILENO
 + 
	gSTDOUT_FILENO
 + 
	gSTDERR_FILENO
 == 3))

37 
missing
 
or
 
broken
 *
_FILENO
 
macros


41 
size_t
 
t1
;

42 
ssize_t
 
	gt2
;

43 #ifdef 
TODO


44 
uid_t
 
	gt3
;

45 
gid_t
 
	gt4
;

47 
off_t
 
	gt5
;

48 
pid_t
 
	gt6
;

49 #ifdef 
TODO


50 
useconds_t
 
	gt7
;

51 
intptr_t
 
	gt8
;

55 
	$main
 (void)

58 
	}
}

	@gnulib-tests/test-unsetenv.c

21 #include 
	~<config.h
>

23 #include 
	~<stdlib.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
unsetenv
, int, (char const *));

28 #include 
	~<errno.h
>

29 #include 
	~<string.h
>

30 #include 
	~<unistd.h
>

32 #include 
	~"macros.h
"

35 
	$main
 (void)

37 char 
entry
[] = "b=2";

40 
	`ASSERT
 (
	`putenv
 ((char *) "a=1") == 0);

41 
	`ASSERT
 (
	`putenv
 (
entry
) == 0);

42 
entry
[0] = 'a';

43 
	`ASSERT
 (
	`unsetenv
 ("a") == 0);

44 
	`ASSERT
 (
	`getenv
 ("a") == 
NULL
);

45 
	`ASSERT
 (
	`unsetenv
 ("a") == 0);

48 
errno
 = 0;

49 
	`ASSERT
 (
	`unsetenv
 ("") == -1);

50 
	`ASSERT
 (
errno
 == 
EINVAL
);

51 
errno
 = 0;

52 
	`ASSERT
 (
	`unsetenv
 ("a=b") == -1);

53 
	`ASSERT
 (
errno
 == 
EINVAL
);

57 
errno
 = 0;

58 
	`ASSERT
 (
	`unsetenv
 (
NULL
) == -1);

59 
	`ASSERT
 (
errno
 == 
EINVAL
);

63 
	}
}

	@gnulib-tests/test-vasnprintf.c

21 #include 
	~<config.h
>

23 #include 
	~"vasnprintf.h
"

25 #include 
	~<stdarg.h
>

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

29 #include 
	~"macros.h
"

32 
test_function
 (char * (*
my_asnprintf
) (char *, 
size_t
 *, const char *, ...))

34 char 
	gbuf
[8];

35 int 
	gsize
;

37 for (
	gsize
 = 0; size <= 8; size++)

39 
size_t
 
	glength
 = 
size
;

40 char *
	gresult
 = 
my_asnprintf
 (
NULL
, &
length
, "%d", 12345);

41 
ASSERT
 (
result
 != 
NULL
);

42 
ASSERT
 (
strcmp
 (
result
, "12345") == 0);

43 
ASSERT
 (
length
 == 5);

44 
free
 (
result
);

47 for (
	gsize
 = 0; size <= 8; size++)

49 
size_t
 
	glength
;

50 char *
	gresult
;

52 
memcpy
 (
buf
, "DEADBEEF", 8);

53 
	glength
 = 
size
;

54 
	gresult
 = 
my_asnprintf
 (
buf
, &
length
, "%d", 12345);

55 
ASSERT
 (
result
 != 
NULL
);

56 
ASSERT
 (
strcmp
 (
result
, "12345") == 0);

57 
ASSERT
 (
length
 == 5);

58 if (
	gsize
 < 6)

59 
ASSERT
 (
result
 != 
buf
);

60 
ASSERT
 (
memcmp
 (
buf
 + 
size
, "DEADBEEF" + size, 8 - size) == 0);

61 if (
	gresult
 != 
buf
)

62 
free
 (
result
);

67 
	$my_asnprintf
 (char *
resultbuf
, 
size_t
 *
lengthp
, const char *
format
, ...)

69 
va_list
 
args
;

70 char *
ret
;

72 
	`va_start
 (
args
, 
format
);

73 
ret
 = 
	`vasnprintf
 (
resultbuf
, 
lengthp
, 
format
, 
args
);

74 
	`va_end
 (
args
);

75 return 
ret
;

76 
	}
}

79 
	$test_vasnprintf
 ()

81 
	`test_function
 (
my_asnprintf
);

82 
	}
}

85 
	$test_asnprintf
 ()

87 
	`test_function
 (
asnprintf
);

88 
	}
}

91 
	$main
 (int 
argc
, char *
argv
[])

93 
	`test_vasnprintf
 ();

94 
	`test_asnprintf
 ();

96 
	}
}

	@gnulib-tests/test-verify.c

22 #include 
	~<config.h
>

24 #include 
	~"verify.h
"

26 #ifndef 
EXP_FAIL


27 #define 
	#EXP_FAIL
 0

	)

30 int 
	gx
;

31 enum { 
	ma
, 
	mb
, 
	mc
 };

33 #if 
EXP_FAIL
 == 1

34 
verify
 (
x
 >= 0);

36 
verify
 (
c
 == 2);

37 #if 
EXP_FAIL
 == 2

38 
verify
 (1 + 1 == 3);

40 
verify
 (1 == 1); verify (1 == 1);

44 
	mitem
 = 
verify_true
 (1 == 1) * 0 + 17

48 
	$function
 (int 
n
)

50 #if 
EXP_FAIL
 == 3

51 
	`verify
 (
n
 >= 0);

53 
	`verify
 (
c
 == 2);

54 #if 
EXP_FAIL
 == 4

55 
	`verify
 (1 + 1 == 3);

57 
	`verify
 (1 == 1); verify (1 == 1);

59 if (
n
)

60 return ((void) 
	`verify_expr
 (1 == 1, 1), verify_expr (1 == 1, 8));

61 #if 
EXP_FAIL
 == 5

62 return 
	`verify_expr
 (1 == 2, 5);

65 
	}
}

68 
	$main
 (void)

70 return !(
	`function
 (0) == 0 && function (1) == 8);

71 
	}
}

	@gnulib-tests/test-version-etc.c

20 #include 
	~<config.h
>

22 #include 
	~"version-etc.h
"

24 #include 
	~"progname.h
"

26 #define 
	#AUTHORS
 "Sergey Poznyakoff", "Eric Blake"

	)

29 
	$main
 (int 
argc
 
_GL_UNUSED
, char **
argv
)

31 
	`set_program_name
 (
argv
[0]);

32 
	`version_etc
 (
stdout
, "test-version-etc", "dummy", "0", 
AUTHORS
,

33 (const char *) 
NULL
);

35 
	}
}

	@gnulib-tests/test-wchar.c

21 #include 
	~<config.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"verify.h
"

28 
wchar_t
 
	ga
 = 'c';

29 
wint_t
 
	gb
 = 'x';

33 
verify
 (sizeof 
NULL
 == sizeof (void *));

36 
	$main
 (void)

39 
	}
}

	@gnulib-tests/test-wcrtomb-w32.c

19 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #include 
	~<locale.h
>

24 #include 
	~<stdio.h
>

25 #include 
	~<stdlib.h
>

26 #include 
	~<string.h
>

28 #include 
	~"macros.h
"

30 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && !defined 
__CYGWIN__


33 
	$test_one_locale
 (const char *
name
, int 
codepage
)

35 char 
buf
[64];

36 
size_t
 
ret
;

41 char 
name_with_codepage
[1024];

43 
	`sprintf
 (
name_with_codepage
, "%s.%d", 
name
, 
codepage
);

46 if (
	`setlocale
 (
LC_ALL
, 
name_with_codepage
) == 
NULL
)

55 extern 
	`__declspec
(
dllimport
) unsigned int 
__lc_codepage
;

58 if (
	`setlocale
 (
LC_ALL
, 
name
) == 
NULL
)

62 
__lc_codepage
 = 
codepage
;

63 switch (
codepage
)

67 
MB_CUR_MAX
 = 1;

72 
MB_CUR_MAX
 = 2;

76 
MB_CUR_MAX
 = 4;

82 
mbstate_t
 
state
;

83 
wchar_t
 
wc
;

85 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

86 if (
	`mbrtowc
 (&
wc
, " ", 1, &
state
) == (
size_t
)(-1))

94 
buf
[0] = 'x';

95 
ret
 = 
	`wcrtomb
 (
buf
, 0, 
NULL
);

96 
	`ASSERT
 (
ret
 == 1);

97 
	`ASSERT
 (
buf
[0] == '\0');

102 int 
c
;

104 for (
c
 = 0; c < 0x100; c++)

105 switch (
c
)

129 
ret
 = 
	`wcrtomb
 (
buf
, 
	`btowc
 (
c
), 
NULL
);

130 
	`ASSERT
 (
ret
 == 1);

131 
	`ASSERT
 (
buf
[0] == (char) 
c
);

138 
ret
 = 
	`wcrtomb
 (
NULL
, '\0', NULL);

139 
	`ASSERT
 (
ret
 == 1);

140 
ret
 = 
	`wcrtomb
 (
NULL
, 
	`btowc
 ('x'), NULL);

141 
	`ASSERT
 (
ret
 == 1);

144 switch (
codepage
)

150 
	`memset
 (
buf
, 'x', 8);

151 
ret
 = 
	`wcrtomb
 (
buf
, 0x00FC, 
NULL
);

152 
	`ASSERT
 (
ret
 == 1);

153 
	`ASSERT
 (
	`memcmp
 (
buf
, "\374", 1) == 0);

154 
	`ASSERT
 (
buf
[1] == 'x');

156 
	`memset
 (
buf
, 'x', 8);

157 
ret
 = 
	`wcrtomb
 (
buf
, 0x00DF, 
NULL
);

158 
	`ASSERT
 (
ret
 == 1);

159 
	`ASSERT
 (
	`memcmp
 (
buf
, "\337", 1) == 0);

160 
	`ASSERT
 (
buf
[1] == 'x');

168 
	`memset
 (
buf
, 'x', 8);

169 
ret
 = 
	`wcrtomb
 (
buf
, 0x0622, 
NULL
);

170 
	`ASSERT
 (
ret
 == 1);

171 
	`ASSERT
 (
	`memcmp
 (
buf
, "\302", 1) == 0);

172 
	`ASSERT
 (
buf
[1] == 'x');

174 
	`memset
 (
buf
, 'x', 8);

175 
ret
 = 
	`wcrtomb
 (
buf
, 0x0644, 
NULL
);

176 
	`ASSERT
 (
ret
 == 1);

177 
	`ASSERT
 (
	`memcmp
 (
buf
, "\341", 1) == 0);

178 
	`ASSERT
 (
buf
[1] == 'x');

180 
	`memset
 (
buf
, 'x', 8);

181 
ret
 = 
	`wcrtomb
 (
buf
, 0x0648, 
NULL
);

182 
	`ASSERT
 (
ret
 == 1);

183 
	`ASSERT
 (
	`memcmp
 (
buf
, "\346", 1) == 0);

184 
	`ASSERT
 (
buf
[1] == 'x');

192 
	`memset
 (
buf
, 'x', 8);

193 
ret
 = 
	`wcrtomb
 (
buf
, 0x65E5, 
NULL
);

194 
	`ASSERT
 (
ret
 == 2);

195 
	`ASSERT
 (
	`memcmp
 (
buf
, "\223\372", 2) == 0);

196 
	`ASSERT
 (
buf
[2] == 'x');

198 
	`memset
 (
buf
, 'x', 8);

199 
ret
 = 
	`wcrtomb
 (
buf
, 0x672C, 
NULL
);

200 
	`ASSERT
 (
ret
 == 2);

201 
	`ASSERT
 (
	`memcmp
 (
buf
, "\226\173", 2) == 0);

202 
	`ASSERT
 (
buf
[2] == 'x');

204 
	`memset
 (
buf
, 'x', 8);

205 
ret
 = 
	`wcrtomb
 (
buf
, 0x8A9E, 
NULL
);

206 
	`ASSERT
 (
ret
 == 2);

207 
	`ASSERT
 (
	`memcmp
 (
buf
, "\214\352", 2) == 0);

208 
	`ASSERT
 (
buf
[2] == 'x');

216 
	`memset
 (
buf
, 'x', 8);

217 
ret
 = 
	`wcrtomb
 (
buf
, 0x65E5, 
NULL
);

218 
	`ASSERT
 (
ret
 == 2);

219 
	`ASSERT
 (
	`memcmp
 (
buf
, "\244\351", 2) == 0);

220 
	`ASSERT
 (
buf
[2] == 'x');

222 
	`memset
 (
buf
, 'x', 8);

223 
ret
 = 
	`wcrtomb
 (
buf
, 0x672C, 
NULL
);

224 
	`ASSERT
 (
ret
 == 2);

225 
	`ASSERT
 (
	`memcmp
 (
buf
, "\245\273", 2) == 0);

226 
	`ASSERT
 (
buf
[2] == 'x');

228 
	`memset
 (
buf
, 'x', 8);

229 
ret
 = 
	`wcrtomb
 (
buf
, 0x8A9E, 
NULL
);

230 
	`ASSERT
 (
ret
 == 2);

231 
	`ASSERT
 (
	`memcmp
 (
buf
, "\273\171", 2) == 0);

232 
	`ASSERT
 (
buf
[2] == 'x');

240 
	`memset
 (
buf
, 'x', 8);

241 
ret
 = 
	`wcrtomb
 (
buf
, 0x65E5, 
NULL
);

242 
	`ASSERT
 (
ret
 == 2);

243 
	`ASSERT
 (
	`memcmp
 (
buf
, "\310\325", 2) == 0);

244 
	`ASSERT
 (
buf
[2] == 'x');

246 
	`memset
 (
buf
, 'x', 8);

247 
ret
 = 
	`wcrtomb
 (
buf
, 0x672C, 
NULL
);

248 
	`ASSERT
 (
ret
 == 2);

249 
	`ASSERT
 (
	`memcmp
 (
buf
, "\261\276", 2) == 0);

250 
	`ASSERT
 (
buf
[2] == 'x');

252 
	`memset
 (
buf
, 'x', 8);

253 
ret
 = 
	`wcrtomb
 (
buf
, 0x8A9E, 
NULL
);

254 
	`ASSERT
 (
ret
 == 2);

255 
	`ASSERT
 (
	`memcmp
 (
buf
, "\325\132", 2) == 0);

256 
	`ASSERT
 (
buf
[2] == 'x');

264 
	`memset
 (
buf
, 'x', 8);

265 
ret
 = 
	`wcrtomb
 (
buf
, 0x00FC, 
NULL
);

266 
	`ASSERT
 (
ret
 == 2);

267 
	`ASSERT
 (
	`memcmp
 (
buf
, "\250\271", 2) == 0);

268 
	`ASSERT
 (
buf
[2] == 'x');

270 
	`memset
 (
buf
, 'x', 8);

271 
ret
 = 
	`wcrtomb
 (
buf
, 0x00DF, 
NULL
);

272 
	`ASSERT
 (
ret
 == 4);

273 
	`ASSERT
 (
	`memcmp
 (
buf
, "\201\060\211\070", 4) == 0);

274 
	`ASSERT
 (
buf
[4] == 'x');

282 
	`memset
 (
buf
, 'x', 8);

283 
ret
 = 
	`wcrtomb
 (
buf
, 0x00FC, 
NULL
);

284 
	`ASSERT
 (
ret
 == 2);

285 
	`ASSERT
 (
	`memcmp
 (
buf
, "\303\274", 2) == 0);

286 
	`ASSERT
 (
buf
[2] == 'x');

288 
	`memset
 (
buf
, 'x', 8);

289 
ret
 = 
	`wcrtomb
 (
buf
, 0x00DF, 
NULL
);

290 
	`ASSERT
 (
ret
 == 2);

291 
	`ASSERT
 (
	`memcmp
 (
buf
, "\303\237", 2) == 0);

292 
	`ASSERT
 (
buf
[2] == 'x');

299 
	}
}

302 
	$main
 (int 
argc
, char *
argv
[])

304 int 
codepage
 = 
	`atoi
 (
argv
[
argc
 - 1]);

305 int 
result
;

306 int 
i
;

308 
result
 = 77;

309 for (
i
 = 1; i < 
argc
 - 1; i++)

311 int 
ret
 = 
	`test_one_locale
 (
argv
[
i
], 
codepage
);

313 if (
ret
 != 77)

314 
result
 = 
ret
;

317 if (
result
 == 77)

319 
	`fprintf
 (
stderr
, "Skipping test: found no locale with codepage %d\n",

320 
codepage
);

322 return 
result
;

323 
	}
}

328 
	$main
 (int 
argc
, char *
argv
[])

330 
	`fputs
 ("Skipping test: not a native Windows system\n", 
stderr
);

332 
	}
}

	@gnulib-tests/test-wcrtomb.c

21 #include 
	~<config.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
wcrtomb
, 
size_t
, (char *, 
wchar_t
, 
mbstate_t
 *));

28 #include 
	~<locale.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

32 #include 
	~"macros.h
"

36 
	$check_character
 (const char *
s
, 
size_t
 
n
)

38 
wchar_t
 
wc
;

39 char 
buf
[64];

40 int 
iret
;

41 
size_t
 
ret
;

43 
wc
 = (
wchar_t
) 0xBADFACE;

44 
iret
 = 
	`mbtowc
 (&
wc
, 
s
, 
n
);

45 
	`ASSERT
 (
iret
 == 
n
);

47 
ret
 = 
	`wcrtomb
 (
buf
, 
wc
, 
NULL
);

48 
	`ASSERT
 (
ret
 == 
n
);

49 
	`ASSERT
 (
	`memcmp
 (
buf
, 
s
, 
n
) == 0);

52 
ret
 = 
	`wcrtomb
 (
NULL
, 
wc
, NULL);

53 
	`ASSERT
 (
ret
 == 1);

54 
	}
}

57 
	$main
 (int 
argc
, char *
argv
[])

59 char 
buf
[64];

60 
size_t
 
ret
;

63 if (
	`setlocale
 (
LC_ALL
, "") == 
NULL
)

68 
buf
[0] = 'x';

69 
ret
 = 
	`wcrtomb
 (
buf
, 0, 
NULL
);

70 
	`ASSERT
 (
ret
 == 1);

71 
	`ASSERT
 (
buf
[0] == '\0');

76 int 
c
;

78 for (
c
 = 0; c < 0x100; c++)

79 switch (
c
)

103 
ret
 = 
	`wcrtomb
 (
buf
, 
	`btowc
 (
c
), 
NULL
);

104 
	`ASSERT
 (
ret
 == 1);

105 
	`ASSERT
 (
buf
[0] == (char) 
c
);

112 
ret
 = 
	`wcrtomb
 (
NULL
, '\0', NULL);

113 
	`ASSERT
 (
ret
 == 1);

114 
ret
 = 
	`wcrtomb
 (
NULL
, 
	`btowc
 ('x'), NULL);

115 
	`ASSERT
 (
ret
 == 1);

118 if (
argc
 > 1)

119 switch (
argv
[1][0])

124 const char 
input
[] = "B\374\337er";

126 
	`check_character
 (
input
 + 1, 1);

127 
	`check_character
 (
input
 + 2, 1);

134 const char 
input
[] = "B\303\274\303\237er";

136 
	`check_character
 (
input
 + 1, 2);

137 
	`check_character
 (
input
 + 3, 2);

144 const char 
input
[] = "<\306\374\313\334\270\354>";

146 
	`check_character
 (
input
 + 1, 2);

147 
	`check_character
 (
input
 + 3, 2);

148 
	`check_character
 (
input
 + 5, 2);

155 const char 
input
[] = "B\250\271\201\060\211\070er";

157 
	`check_character
 (
input
 + 1, 2);

158 
	`check_character
 (
input
 + 3, 4);

164 
	}
}

	@gnulib-tests/test-wctype-h.c

21 #include 
	~<config.h
>

23 #include 
	~<wctype.h
>

25 #include 
	~"macros.h
"

28 
wint_t
 
	ga
 = 'x';

30 
wint_t
 
	ge
 = 
WEOF
;

33 
wctype_t
 
	gp
;

36 
wctrans_t
 
	gq
;

39 
	$main
 (void)

42 (void) 
	`iswalnum
 (0);

43 (void) 
	`iswalpha
 (0);

44 (void) 
	`iswcntrl
 (0);

45 (void) 
	`iswdigit
 (0);

46 (void) 
	`iswgraph
 (0);

47 (void) 
	`iswlower
 (0);

48 (void) 
	`iswprint
 (0);

49 (void) 
	`iswpunct
 (0);

50 (void) 
	`iswspace
 (0);

51 (void) 
	`iswupper
 (0);

52 (void) 
	`iswxdigit
 (0);

55 
	`ASSERT
 (!
	`iswalnum
 (
e
));

56 
	`ASSERT
 (!
	`iswalpha
 (
e
));

57 
	`ASSERT
 (!
	`iswcntrl
 (
e
));

58 
	`ASSERT
 (!
	`iswdigit
 (
e
));

59 
	`ASSERT
 (!
	`iswgraph
 (
e
));

60 
	`ASSERT
 (!
	`iswlower
 (
e
));

61 
	`ASSERT
 (!
	`iswprint
 (
e
));

62 
	`ASSERT
 (!
	`iswpunct
 (
e
));

63 
	`ASSERT
 (!
	`iswspace
 (
e
));

64 
	`ASSERT
 (!
	`iswupper
 (
e
));

65 
	`ASSERT
 (!
	`iswxdigit
 (
e
));

68 (void) 
	`towlower
 (0);

69 (void) 
	`towupper
 (0);

72 
	`ASSERT
 (
	`towlower
 (
e
) == e);

73 
	`ASSERT
 (
	`towupper
 (
e
) == e);

76 
	}
}

	@gnulib-tests/test-wcwidth.c

21 #include 
	~<config.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"signature.h
"

26 
SIGNATURE_CHECK
 (
wcwidth
, int, (
wchar_t
));

28 #include 
	~<locale.h
>

29 #include 
	~<string.h
>

31 #include 
	~"localcharset.h
"

32 #include 
	~"macros.h
"

35 
	$main
 ()

37 
wchar_t
 
wc
;

40 for (
wc
 = 0x20; wc < 0x7F; wc++)

41 
	`ASSERT
 (
	`wcwidth
 (
wc
) == 1);

44 if (
	`setlocale
 (
LC_ALL
, "fr_FR.UTF-8") != 
NULL


50 && 
	`strcmp
 (
	`locale_charset
 (), "UTF-8") == 0)

53 for (
wc
 = 0x20; wc < 0x7F; wc++)

54 
	`ASSERT
 (
	`wcwidth
 (
wc
) == 1);

57 
	`ASSERT
 (
	`wcwidth
 (0x0301) == 0);

58 
	`ASSERT
 (
	`wcwidth
 (0x05B0) == 0);

61 
	`ASSERT
 (
	`wcwidth
 (0x200E) <= 0);

62 
	`ASSERT
 (
	`wcwidth
 (0x2060) <= 0);

64 
	`ASSERT
 (
	`wcwidth
 (0xE0001) <= 0);

65 
	`ASSERT
 (
	`wcwidth
 (0xE0044) <= 0);

69 
	`ASSERT
 (
	`wcwidth
 (0x200B) == 0);

70 
	`ASSERT
 (
	`wcwidth
 (0xFEFF) <= 0);

73 
	`ASSERT
 (
	`wcwidth
 (0x3000) == 2);

74 
	`ASSERT
 (
	`wcwidth
 (0xB250) == 2);

75 
	`ASSERT
 (
	`wcwidth
 (0xFF1A) == 2);

77 
	`ASSERT
 (
	`wcwidth
 (0x20369) == 2);

78 
	`ASSERT
 (
	`wcwidth
 (0x2F876) == 2);

83 
	}
}

	@gnulib-tests/test-xalloc-die.c

21 #include 
	~<config.h
>

23 #include 
	~"xalloc.h
"

24 #include 
	~"progname.h
"

27 
	$main
 (int 
argc
 
_GL_UNUSED
, char **
argv
)

29 
	`set_program_name
 (
argv
[0]);

30 
	`xalloc_die
 ();

32 
	}
}

	@gnulib-tests/test-xstrtol.c

19 #include 
	~<config.h
>

21 #include 
	~<inttypes.h
>

22 #include 
	~<stdlib.h
>

23 #include 
	~<stdio.h
>

25 #include 
	~"xstrtol.h
"

26 #include 
	~"error.h
"

28 #ifndef 
__xstrtol


29 #define 
	#__xstrtol
 
xstrtol


	)

30 #define 
	#__strtol_t
 long int

	)

31 #define 
	#__spec
 "ld"

	)

34 char *
	gprogram_name
;

38 
	$print_no_progname
 (void)

40 
	}
}

43 
	$main
 (int 
argc
, char **
argv
)

45 
strtol_error
 
s_err
;

46 int 
i
;

48 
program_name
 = 
argv
[0];

49 
error_print_progname
 = 
print_no_progname
;

51 for (
i
 = 1; i < 
argc
; i++)

53 char *
p
;

54 
__strtol_t
 
val
;

56 
s_err
 = 
	`__xstrtol
 (
argv
[
i
], &
p
, 0, &
val
, "bckMw0");

57 if (
s_err
 == 
LONGINT_OK
)

59 
	`printf
 ("%s->%" 
__spec
 " (%s)\n", 
argv
[
i
], 
val
, 
p
);

63 
	`xstrtol_fatal
 (
s_err
, -2, 'X', 
NULL
, 
argv
[
i
]);

66 
	`exit
 (0);

67 
	}
}

	@gnulib-tests/test-xstrtoul.c

3 #define 
	#__xstrtol
 
xstrtoul


	)

4 #define 
	#__strtol_t
 unsigned long int

	)

5 #define 
	#__spec
 "lu"

	)

6 #include 
	~"test-xstrtol.c
"

	@gnulib-tests/test-xstrtoumax.c

3 #define 
	#__xstrtol
 
xstrtoumax


	)

4 #define 
	#__strtol_t
 
uintmax_t


	)

5 #define 
	#__spec
 
PRIuMAX


	)

6 #include 
	~"test-xstrtol.c
"

	@gnulib-tests/uinttostr.c

3 #define 
	#anytostr
 
uinttostr


	)

4 #define 
	#inttype
 unsigned int

	)

5 #include 
	~"anytostr.c
"

	@gnulib-tests/umaxtostr.c

3 #define 
	#anytostr
 
umaxtostr


	)

4 #define 
	#inttype
 
uintmax_t


	)

5 #include 
	~"anytostr.c
"

	@gnulib-tests/unistr/test-u8-mbtoucr.c

21 #include 
	~<config.h
>

23 #include 
	~"unistr.h
"

25 #include 
	~"macros.h
"

28 
	$main
 ()

30 
ucs4_t
 
uc
;

31 int 
ret
;

35 static const 
uint8_t
 
input
[] = "";

36 
uc
 = 0xBADFACE;

37 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 1);

38 
	`ASSERT
 (
ret
 == 1);

39 
	`ASSERT
 (
uc
 == 0);

44 
ucs4_t
 
c
;

45 
uint8_t
 
buf
[1];

47 for (
c
 = 0; c < 0x80; c++)

49 
buf
[0] = 
c
;

50 
uc
 = 0xBADFACE;

51 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
buf
, 1);

52 
	`ASSERT
 (
ret
 == 1);

53 
	`ASSERT
 (
uc
 == 
c
);

59 static const 
uint8_t
 
input
[] = { 0xC3, 0x97 };

60 
uc
 = 0xBADFACE;

61 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 2);

62 
	`ASSERT
 (
ret
 == 2);

63 
	`ASSERT
 (
uc
 == 0x00D7);

68 static const 
uint8_t
 
input
[] = { 0xE2, 0x82, 0xAC };

69 
uc
 = 0xBADFACE;

70 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 3);

71 
	`ASSERT
 (
ret
 == 3);

72 
	`ASSERT
 (
uc
 == 0x20AC);

77 static const 
uint8_t
 
input
[] = { 0xF4, 0x8F, 0xBF, 0xBD };

78 
uc
 = 0xBADFACE;

79 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 4);

80 
	`ASSERT
 (
ret
 == 4);

81 
	`ASSERT
 (
uc
 == 0x10FFFD);

86 static const 
uint8_t
 
input
[] = { 0xC1 };

87 
uc
 = 0xBADFACE;

88 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 1);

89 
	`ASSERT
 (
ret
 == -1);

90 
	`ASSERT
 (
uc
 == 0xFFFD);

93 static const 
uint8_t
 
input
[] = { 0xC3 };

94 
uc
 = 0xBADFACE;

95 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 1);

96 
	`ASSERT
 (
ret
 == -2);

97 
	`ASSERT
 (
uc
 == 0xFFFD);

100 static const 
uint8_t
 
input
[] = { 0xE2 };

101 
uc
 = 0xBADFACE;

102 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 1);

103 
	`ASSERT
 (
ret
 == -2);

104 
	`ASSERT
 (
uc
 == 0xFFFD);

107 static const 
uint8_t
 
input
[] = { 0xF4 };

108 
uc
 = 0xBADFACE;

109 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 1);

110 
	`ASSERT
 (
ret
 == -2);

111 
	`ASSERT
 (
uc
 == 0xFFFD);

114 static const 
uint8_t
 
input
[] = { 0xFE };

115 
uc
 = 0xBADFACE;

116 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 1);

117 
	`ASSERT
 (
ret
 == -1);

118 
	`ASSERT
 (
uc
 == 0xFFFD);

123 static const 
uint8_t
 
input
[] = { 0xE0, 0x9F };

124 
uc
 = 0xBADFACE;

125 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 2);

126 
	`ASSERT
 (
ret
 == -1);

127 
	`ASSERT
 (
uc
 == 0xFFFD);

130 static const 
uint8_t
 
input
[] = { 0xE2, 0x82 };

131 
uc
 = 0xBADFACE;

132 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 2);

133 
	`ASSERT
 (
ret
 == -2);

134 
	`ASSERT
 (
uc
 == 0xFFFD);

137 static const 
uint8_t
 
input
[] = { 0xE2, 0xD0 };

138 
uc
 = 0xBADFACE;

139 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 2);

140 
	`ASSERT
 (
ret
 == -1);

141 
	`ASSERT
 (
uc
 == 0xFFFD);

144 static const 
uint8_t
 
input
[] = { 0xF0, 0x8F };

145 
uc
 = 0xBADFACE;

146 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 2);

147 
	`ASSERT
 (
ret
 == -1);

148 
	`ASSERT
 (
uc
 == 0xFFFD);

151 static const 
uint8_t
 
input
[] = { 0xF3, 0x8F };

152 
uc
 = 0xBADFACE;

153 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 2);

154 
	`ASSERT
 (
ret
 == -2);

155 
	`ASSERT
 (
uc
 == 0xFFFD);

158 static const 
uint8_t
 
input
[] = { 0xF3, 0xD0 };

159 
uc
 = 0xBADFACE;

160 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 2);

161 
	`ASSERT
 (
ret
 == -1);

162 
	`ASSERT
 (
uc
 == 0xFFFD);

167 static const 
uint8_t
 
input
[] = { 0xF3, 0x8F, 0xBF };

168 
uc
 = 0xBADFACE;

169 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 3);

170 
	`ASSERT
 (
ret
 == -2);

171 
	`ASSERT
 (
uc
 == 0xFFFD);

174 static const 
uint8_t
 
input
[] = { 0xF3, 0xD0, 0xBF };

175 
uc
 = 0xBADFACE;

176 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 3);

177 
	`ASSERT
 (
ret
 == -1);

178 
	`ASSERT
 (
uc
 == 0xFFFD);

181 static const 
uint8_t
 
input
[] = { 0xF3, 0x8F, 0xD0 };

182 
uc
 = 0xBADFACE;

183 
ret
 = 
	`u8_mbtoucr
 (&
uc
, 
input
, 3);

184 
	`ASSERT
 (
ret
 == -1);

185 
	`ASSERT
 (
uc
 == 0xFFFD);

189 
	}
}

	@gnulib-tests/unistr/test-u8-uctomb.c

21 #include 
	~<config.h
>

23 #include 
	~"unistr.h
"

25 #include 
	~"macros.h
"

27 #define 
	#MAGIC
 0xBA

	)

30 
	$main
 ()

34 
ucs4_t
 
uc
;

36 for (
uc
 = 0; uc < 0x80; uc++)

38 
uint8_t
 
buf
[5] = { 
MAGIC
, MAGIC, MAGIC, MAGIC, MAGIC };

39 int 
ret
;

41 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 0);

42 
	`ASSERT
 (
ret
 == -2);

43 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

45 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 1);

46 
	`ASSERT
 (
ret
 == 1);

47 
	`ASSERT
 (
buf
[0] == 
uc
);

48 
	`ASSERT
 (
buf
[1] == 
MAGIC
);

54 
ucs4_t
 
uc
 = 0x00D7;

55 
uint8_t
 
buf
[5] = { 
MAGIC
, MAGIC, MAGIC, MAGIC, MAGIC };

56 int 
ret
;

58 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 0);

59 
	`ASSERT
 (
ret
 == -2);

60 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

62 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 1);

63 
	`ASSERT
 (
ret
 == -2);

64 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

66 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 2);

67 
	`ASSERT
 (
ret
 == 2);

68 
	`ASSERT
 (
buf
[0] == 0xC3);

69 
	`ASSERT
 (
buf
[1] == 0x97);

70 
	`ASSERT
 (
buf
[2] == 
MAGIC
);

75 
ucs4_t
 
uc
 = 0x20AC;

76 
uint8_t
 
buf
[5] = { 
MAGIC
, MAGIC, MAGIC, MAGIC, MAGIC };

77 int 
ret
;

79 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 0);

80 
	`ASSERT
 (
ret
 == -2);

81 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

83 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 1);

84 
	`ASSERT
 (
ret
 == -2);

85 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

87 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 2);

88 
	`ASSERT
 (
ret
 == -2);

89 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

90 
	`ASSERT
 (
buf
[1] == 
MAGIC
);

92 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 3);

93 
	`ASSERT
 (
ret
 == 3);

94 
	`ASSERT
 (
buf
[0] == 0xE2);

95 
	`ASSERT
 (
buf
[1] == 0x82);

96 
	`ASSERT
 (
buf
[2] == 0xAC);

97 
	`ASSERT
 (
buf
[3] == 
MAGIC
);

102 
ucs4_t
 
uc
 = 0x10FFFD;

103 
uint8_t
 
buf
[5] = { 
MAGIC
, MAGIC, MAGIC, MAGIC, MAGIC };

104 int 
ret
;

106 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 0);

107 
	`ASSERT
 (
ret
 == -2);

108 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

110 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 1);

111 
	`ASSERT
 (
ret
 == -2);

112 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

114 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 2);

115 
	`ASSERT
 (
ret
 == -2);

116 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

117 
	`ASSERT
 (
buf
[1] == 
MAGIC
);

119 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 3);

120 
	`ASSERT
 (
ret
 == -2);

121 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

122 
	`ASSERT
 (
buf
[1] == 
MAGIC
);

123 
	`ASSERT
 (
buf
[2] == 
MAGIC
);

125 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 4);

126 
	`ASSERT
 (
ret
 == 4);

127 
	`ASSERT
 (
buf
[0] == 0xF4);

128 
	`ASSERT
 (
buf
[1] == 0x8F);

129 
	`ASSERT
 (
buf
[2] == 0xBF);

130 
	`ASSERT
 (
buf
[3] == 0xBD);

131 
	`ASSERT
 (
buf
[4] == 
MAGIC
);

136 
ucs4_t
 
invalid
[] = { 0x110000, 0xD800, 0xDBFF, 0xDC00, 0xDFFF };

137 
uint8_t
 
buf
[5] = { 
MAGIC
, MAGIC, MAGIC, MAGIC, MAGIC };

138 
size_t
 
i
;

140 for (
i
 = 0; i < 
	`SIZEOF
 (
invalid
); i++)

142 
ucs4_t
 
uc
 = 
invalid
[
i
];

143 int 
n
;

145 for (
n
 = 0; n <= 4; n++)

147 int 
ret
 = 
	`u8_uctomb
 (
buf
, 
uc
, 
n
);

148 
	`ASSERT
 (
ret
 == -1);

149 
	`ASSERT
 (
buf
[0] == 
MAGIC
);

150 
	`ASSERT
 (
buf
[1] == 
MAGIC
);

151 
	`ASSERT
 (
buf
[2] == 
MAGIC
);

152 
	`ASSERT
 (
buf
[3] == 
MAGIC
);

153 
	`ASSERT
 (
buf
[4] == 
MAGIC
);

159 
	}
}

	@gnulib-tests/uniwidth/test-uc_width.c

21 #include 
	~<config.h
>

23 #include 
	~"uniwidth.h
"

25 #include 
	~"macros.h
"

28 
	$main
 ()

30 
ucs4_t
 
uc
;

33 for (
uc
 = 0x0020; uc < 0x007F; uc++)

34 
	`ASSERT
 (
	`uc_width
 (
uc
, "ISO-8859-2") == 1);

37 
	`ASSERT
 (
	`uc_width
 (0x0301, "UTF-8") == 0);

38 
	`ASSERT
 (
	`uc_width
 (0x05B0, "UTF-8") == 0);

41 
	`ASSERT
 (
	`uc_width
 (0x200E, "UTF-8") == 0);

42 
	`ASSERT
 (
	`uc_width
 (0x2060, "UTF-8") == 0);

43 
	`ASSERT
 (
	`uc_width
 (0xE0001, "UTF-8") == 0);

44 
	`ASSERT
 (
	`uc_width
 (0xE0044, "UTF-8") == 0);

47 
	`ASSERT
 (
	`uc_width
 (0x200B, "UTF-8") == 0);

48 
	`ASSERT
 (
	`uc_width
 (0xFEFF, "UTF-8") == 0);

51 
	`ASSERT
 (
	`uc_width
 (0x3000, "UTF-8") == 2);

52 
	`ASSERT
 (
	`uc_width
 (0xB250, "UTF-8") == 2);

53 
	`ASSERT
 (
	`uc_width
 (0xFF1A, "UTF-8") == 2);

54 
	`ASSERT
 (
	`uc_width
 (0x20369, "UTF-8") == 2);

55 
	`ASSERT
 (
	`uc_width
 (0x2F876, "UTF-8") == 2);

58 
	}
}

	@gnulib-tests/uniwidth/test-uc_width2.c

21 #include 
	~<config.h
>

23 #include 
	~"uniwidth.h
"

25 #include 
	~<stdio.h
>

27 #include 
	~"macros.h
"

30 static char 
	gcurrent_width
;

32 static 
ucs4_t
 
	gcurrent_start
;

33 static 
ucs4_t
 
	gcurrent_end
;

36 
	$finish_interval
 (void)

38 if (
current_width
 != 0)

40 if (
current_start
 == 
current_end
)

41 
	`printf
 ("%04X\t\t%c\n", (unsigned) 
current_start
, 
current_width
);

43 
	`printf
 ("%04X..%04X\t%c\n", (unsigned) 
current_start
,

44 (unsigned) 
current_end
, 
current_width
);

45 
current_width
 = 0;

47 
	}
}

50 
	$add_to_interval
 (
ucs4_t
 
uc
, char 
width
)

52 if (
current_width
 == 
width
 && 
uc
 == 
current_end
 + 1)

53 
current_end
 = 
uc
;

56 
	`finish_interval
 ();

57 
current_width
 = 
width
;

58 
current_start
 = 
current_end
 = 
uc
;

60 
	}
}

63 
	$main
 ()

65 
ucs4_t
 
uc
;

67 for (
uc
 = 0; uc < 0x110000; uc++)

69 int 
w1
 = 
	`uc_width
 (
uc
, "UTF-8");

70 int 
w2
 = 
	`uc_width
 (
uc
, "GBK");

71 char 
width
 =

72 (
w1
 == 0 && 
w2
 == 0 ? '0' :

73 
w1
 == 1 && 
w2
 == 1 ? '1' :

74 
w1
 == 1 && 
w2
 == 2 ? 'A' :

75 
w1
 == 2 && 
w2
 == 2 ? '2' :

77 if (
width
 == 0)

80 
	`ASSERT
 (
w1
 < 0 && 
w2
 < 0);

83 
	`add_to_interval
 (
uc
, 
width
);

85 
	`finish_interval
 ();

88 
	}
}

	@gnulib-tests/unsetenv.c

19 #include 
	~<config.h
>

23 #define 
	#_GL_ARG_NONNULL
(
params
)

	)

26 #include 
	~<stdlib.h
>

28 #include 
	~<errno.h
>

29 #if !
_LIBC


30 #define 
	#__set_errno
(
ev
) ((
errno
) = (ev))

	)

33 #include 
	~<string.h
>

34 #include 
	~<unistd.h
>

36 #if !
_LIBC


37 #define 
	#__environ
 
environ


	)

40 #if 
_LIBC


42 #include 
	~<bits/libc-lock.h
>

43 
	$__libc_lock_define_initialized
 (static, 
envlock
)

44 #define 
	#LOCK
 
	`__libc_lock_lock
 (
envlock
)

	)

45 #define 
	#UNLOCK
 
	`__libc_lock_unlock
 (
envlock
)

	)

47 #define 
	#LOCK


	)

48 #define 
	#UNLOCK


	)

52 #ifdef 
_LIBC


53 #define 
	#unsetenv
 
__unsetenv


	)

56 #if 
_LIBC
 || !
HAVE_UNSETENV


59 
	$unsetenv
 (const char *
name
)

61 
size_t
 
len
;

62 char **
ep
;

64 if (
name
 == 
NULL
 || *name == '\0' || 
	`strchr
 (name, '=') != NULL)

66 
	`__set_errno
 (
EINVAL
);

70 
len
 = 
	`strlen
 (
name
);

72 
LOCK
;

74 
ep
 = 
__environ
;

75 while (*
ep
 != 
NULL
)

76 if (!
	`strncmp
 (*
ep
, 
name
, 
len
) && (*ep)[len] == '=')

79 char **
dp
 = 
ep
;

82 
dp
[0] = dp[1];

83 while (*
dp
++);

87 ++
ep
;

89 
UNLOCK
;

92 
	}
}

94 #ifdef 
_LIBC


95 #undef 
unsetenv


96 
	$weak_alias
 (
__unsetenv
, 
unsetenv
)

101 #undef 
unsetenv


102 #if !
HAVE_DECL_UNSETENV


103 #if 
VOID_UNSETENV


104 extern void 
	`unsetenv
 (const char *);

106 extern int 
	`unsetenv
 (const char *);

113 
	$rpl_unsetenv
 (const char *
name
)

115 int 
result
 = 0;

116 if (!
name
 || !*name || 
	`strchr
 (name, '='))

118 
errno
 = 
EINVAL
;

121 while (
	`getenv
 (
name
))

122 #if !
VOID_UNSETENV


123 
result
 =

125 
	`unsetenv
 (
name
);

126 return 
result
;

127 
	}
}

	@gnulib-tests/vasnprintf.c

52 #ifndef 
_GNU_SOURCE


53 #define 
	#_GNU_SOURCE
 1

	)

56 #ifndef 
VASNPRINTF


57 #include 
	~<config.h
>

59 #ifndef 
IN_LIBINTL


60 #include 
	~<alloca.h
>

64 #ifndef 
VASNPRINTF


65 #if 
WIDE_CHAR_VERSION


66 #include 
	~"vasnwprintf.h
"

68 #include 
	~"vasnprintf.h
"

72 #include 
	~<locale.h
>

73 #include 
	~<stdio.h
>

74 #include 
	~<stdlib.h
>

75 #include 
	~<string.h
>

76 #include 
	~<errno.h
>

77 #include 
	~<limits.h
>

78 #include 
	~<float.h
>

79 #if 
HAVE_NL_LANGINFO


80 #include 
	~<langinfo.h
>

82 #ifndef 
VASNPRINTF


83 #if 
WIDE_CHAR_VERSION


84 #include 
	~"wprintf-parse.h
"

86 #include 
	~"printf-parse.h
"

91 #include 
	~"xsize.h
"

93 #include 
	~"verify.h
"

95 #if (
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_LONG_DOUBLE
) && !
defined
 
IN_LIBINTL


96 #include 
	~<math.h
>

97 #include 
	~"float+.h
"

100 #if (
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_DOUBLE
) && !
defined
 
IN_LIBINTL


101 #include 
	~<math.h
>

102 #include 
	~"isnand-nolibm.h
"

105 #if (
NEED_PRINTF_LONG_DOUBLE
 || 
NEED_PRINTF_INFINITE_LONG_DOUBLE
) && !
defined
 
IN_LIBINTL


106 #include 
	~<math.h
>

107 #include 
	~"isnanl-nolibm.h
"

108 #include 
	~"fpucw.h
"

111 #if (
NEED_PRINTF_DIRECTIVE_A
 || 
NEED_PRINTF_DOUBLE
) && !
defined
 
IN_LIBINTL


112 #include 
	~<math.h
>

113 #include 
	~"isnand-nolibm.h
"

114 #include 
	~"printf-frexp.h
"

117 #if (
NEED_PRINTF_DIRECTIVE_A
 || 
NEED_PRINTF_LONG_DOUBLE
) && !
defined
 
IN_LIBINTL


118 #include 
	~<math.h
>

119 #include 
	~"isnanl-nolibm.h
"

120 #include 
	~"printf-frexpl.h
"

121 #include 
	~"fpucw.h
"

125 #ifndef 
VASNPRINTF


126 #if 
WIDE_CHAR_VERSION


127 #define 
	#VASNPRINTF
 
vasnwprintf


	)

128 #define 
	#FCHAR_T
 
wchar_t


	)

129 #define 
	#DCHAR_T
 
wchar_t


	)

130 #define 
	#TCHAR_T
 
wchar_t


	)

131 #define 
	#DCHAR_IS_TCHAR
 1

	)

132 #define 
	#DIRECTIVE
 
wchar_t_directive


	)

133 #define 
	#DIRECTIVES
 
wchar_t_directives


	)

134 #define 
	#PRINTF_PARSE
 
wprintf_parse


	)

135 #define 
	#DCHAR_CPY
 
wmemcpy


	)

136 #define 
	#DCHAR_SET
 
wmemset


	)

138 #define 
	#VASNPRINTF
 
vasnprintf


	)

139 #define 
	#FCHAR_T
 char

	)

140 #define 
	#DCHAR_T
 char

	)

141 #define 
	#TCHAR_T
 char

	)

142 #define 
	#DCHAR_IS_TCHAR
 1

	)

143 #define 
	#DIRECTIVE
 
char_directive


	)

144 #define 
	#DIRECTIVES
 
char_directives


	)

145 #define 
	#PRINTF_PARSE
 
printf_parse


	)

146 #define 
	#DCHAR_CPY
 
memcpy


	)

147 #define 
	#DCHAR_SET
 
memset


	)

150 #if 
WIDE_CHAR_VERSION


152 #define 
	#USE_SNPRINTF
 1

	)

153 #if 
HAVE_DECL__SNWPRINTF


158 #if 
defined
 
__MINGW32__


159 #define 
	#SNPRINTF
 
snwprintf


	)

161 #define 
	#SNPRINTF
 
_snwprintf


	)

165 #define 
	#SNPRINTF
 
swprintf


	)

174 #if (
HAVE_DECL__SNPRINTF
 || 
HAVE_SNPRINTF
) && !
defined
 
__BEOS__
 && !(
__GNU_LIBRARY__
 == 1)

175 #define 
	#USE_SNPRINTF
 1

	)

177 #define 
	#USE_SNPRINTF
 0

	)

179 #if 
HAVE_DECL__SNPRINTF


182 #if 
defined
 
__MINGW32__


183 #define 
	#SNPRINTF
 
snprintf


	)

185 #undef 
snprintf


187 #define 
	#SNPRINTF
 
_snprintf


	)

191 #define 
	#SNPRINTF
 
snprintf


	)

193 #undef 
snprintf


197 #undef 
sprintf


201 #ifdef 
lint


202 #define 
	#IF_LINT
(
Code
) 
	)
Code

204 #define 
	#IF_LINT
(
Code
)

	)

209 #undef 
exp


210 #define 
	#exp
 
expo


	)

211 #undef 
remainder


212 #define 
	#remainder
 
rem


	)

214 #if (!
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
) && !
WIDE_CHAR_VERSION


215 #if (
HAVE_STRNLEN
 && !
defined
 
_AIX
)

216 #define 
	#local_strnlen
 
strnlen


	)

218 #ifndef 
local_strnlen_defined


219 #define 
	#local_strnlen_defined
 1

	)

220 static 
size_t


221 
	$local_strnlen
 (const char *
string
, 
size_t
 
maxlen
)

223 const char *
end
 = 
	`memchr
 (
string
, '\0', 
maxlen
);

224 return 
end
 ? (
size_t
) (end - 
string
) : 
maxlen
;

225 
	}
}

230 #if (((!
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
) && 
WIDE_CHAR_VERSION
) || ((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || (
NEED_PRINTF_DIRECTIVE_LS
 && !
defined
 
IN_LIBINTL
)) && !WIDE_CHAR_VERSION && 
DCHAR_IS_TCHAR
)) && 
HAVE_WCHAR_T


231 #if 
HAVE_WCSLEN


232 #define 
	#local_wcslen
 
wcslen


	)

238 #ifndef 
local_wcslen_defined


239 #define 
	#local_wcslen_defined
 1

	)

240 static 
size_t


241 
	$local_wcslen
 (const 
wchar_t
 *
s
)

243 const 
wchar_t
 *
ptr
;

245 for (
ptr
 = 
s
; *ptr != (
wchar_t
) 0; ptr++)

247 return 
ptr
 - 
s
;

248 
	}
}

253 #if (!
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
) && 
HAVE_WCHAR_T
 && 
WIDE_CHAR_VERSION


254 #if 
HAVE_WCSNLEN


255 #define 
	#local_wcsnlen
 
wcsnlen


	)

257 #ifndef 
local_wcsnlen_defined


258 #define 
	#local_wcsnlen_defined
 1

	)

259 static 
size_t


260 
	$local_wcsnlen
 (const 
wchar_t
 *
s
, 
size_t
 
maxlen
)

262 const 
wchar_t
 *
ptr
;

264 for (
ptr
 = 
s
; 
maxlen
 > 0 && *ptr != (
wchar_t
) 0; ptr++, maxlen--)

266 return 
ptr
 - 
s
;

267 
	}
}

272 #if (
NEED_PRINTF_DIRECTIVE_A
 || 
NEED_PRINTF_LONG_DOUBLE
 || 
NEED_PRINTF_INFINITE_LONG_DOUBLE
 || 
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_DOUBLE
) && !
defined
 
IN_LIBINTL


274 #ifndef 
decimal_point_char_defined


275 #define 
	#decimal_point_char_defined
 1

	)

277 
	$decimal_point_char
 (void)

279 const char *
point
;

284 #if 
HAVE_NL_LANGINFO
 && (
__GLIBC__
 || 
defined
 
__UCLIBC__
 || (defined 
__APPLE__
 && defined 
__MACH__
))

285 
point
 = 
	`nl_langinfo
 (
RADIXCHAR
);

287 char 
pointbuf
[5];

288 
	`sprintf
 (
pointbuf
, "%#.0f", 1.0);

289 
point
 = &
pointbuf
[1];

291 
point
 = 
	`localeconv
 () -> 
decimal_point
;

294 return (
point
[0] != '\0' ? point[0] : '.');

295 
	}
}

299 #if 
NEED_PRINTF_INFINITE_DOUBLE
 && !
NEED_PRINTF_DOUBLE
 && !
defined
 
IN_LIBINTL


303 
	$is_infinite_or_zero
 (double 
x
)

305 return 
	`isnand
 (
x
) || x + x == x;

306 
	}
}

310 #if 
NEED_PRINTF_INFINITE_LONG_DOUBLE
 && !
NEED_PRINTF_LONG_DOUBLE
 && !
defined
 
IN_LIBINTL


314 
	$is_infinite_or_zerol
 (long double 
x
)

316 return 
	`isnanl
 (
x
) || x + x == x;

317 
	}
}

321 #if (
NEED_PRINTF_LONG_DOUBLE
 || 
NEED_PRINTF_DOUBLE
) && !
defined
 
IN_LIBINTL


327 typedef unsigned int 
	tmp_limb_t
;

328 #define 
	#GMP_LIMB_BITS
 32

	)

329 
verify
 (sizeof (
mp_limb_t
) * 
CHAR_BIT
 == 
GMP_LIMB_BITS
);

331 typedef unsigned long long 
	tmp_twolimb_t
;

332 #define 
	#GMP_TWOLIMB_BITS
 64

	)

333 
verify
 (sizeof (
mp_twolimb_t
) * 
CHAR_BIT
 == 
GMP_TWOLIMB_BITS
);

338 
size_t
 
	mnlimbs
;

339 
mp_limb_t
 *
	mlimbs
;

340 } 
	tmpn_t
;

346 
	$multiply
 (
mpn_t
 
src1
, mpn_t 
src2
, mpn_t *
dest
)

348 const 
mp_limb_t
 *
p1
;

349 const 
mp_limb_t
 *
p2
;

350 
size_t
 
len1
;

351 
size_t
 
len2
;

353 if (
src1
.
nlimbs
 <= 
src2
.nlimbs)

355 
len1
 = 
src1
.
nlimbs
;

356 
p1
 = 
src1
.
limbs
;

357 
len2
 = 
src2
.
nlimbs
;

358 
p2
 = 
src2
.
limbs
;

362 
len1
 = 
src2
.
nlimbs
;

363 
p1
 = 
src2
.
limbs
;

364 
len2
 = 
src1
.
nlimbs
;

365 
p2
 = 
src1
.
limbs
;

368 if (
len1
 == 0)

371 
dest
->
nlimbs
 = 0;

372 
dest
->
limbs
 = (
mp_limb_t
 *) 
	`malloc
 (1);

377 
size_t
 
dlen
;

378 
mp_limb_t
 *
dp
;

379 
size_t
 
k
, 
i
, 
j
;

381 
dlen
 = 
len1
 + 
len2
;

382 
dp
 = (
mp_limb_t
 *) 
	`malloc
 (
dlen
 * sizeof (mp_limb_t));

383 if (
dp
 == 
NULL
)

384 return 
NULL
;

385 for (
k
 = 
len2
; k > 0; )

386 
dp
[--
k
] = 0;

387 for (
i
 = 0; i < 
len1
; i++)

389 
mp_limb_t
 
digit1
 = 
p1
[
i
];

390 
mp_twolimb_t
 
carry
 = 0;

391 for (
j
 = 0; j < 
len2
; j++)

393 
mp_limb_t
 
digit2
 = 
p2
[
j
];

394 
carry
 += (
mp_twolimb_t
) 
digit1
 * (mp_twolimb_t) 
digit2
;

395 
carry
 += 
dp
[
i
 + 
j
];

396 
dp
[
i
 + 
j
] = (
mp_limb_t
) 
carry
;

397 
carry
 = carry >> 
GMP_LIMB_BITS
;

399 
dp
[
i
 + 
len2
] = (
mp_limb_t
) 
carry
;

402 while (
dlen
 > 0 && 
dp
[dlen - 1] == 0)

403 
dlen
--;

404 
dest
->
nlimbs
 = 
dlen
;

405 
dest
->
limbs
 = 
dp
;

407 return 
dest
->
limbs
;

408 
	}
}

418 
	$divide
 (
mpn_t
 
a
, mpn_t 
b
, mpn_t *
q
)

471 const 
mp_limb_t
 *
a_ptr
 = 
a
.
limbs
;

472 
size_t
 
a_len
 = 
a
.
nlimbs
;

473 const 
mp_limb_t
 *
b_ptr
 = 
b
.
limbs
;

474 
size_t
 
b_len
 = 
b
.
nlimbs
;

475 
mp_limb_t
 *
roomptr
;

476 
mp_limb_t
 *
tmp_roomptr
 = 
NULL
;

477 
mp_limb_t
 *
q_ptr
;

478 
size_t
 
q_len
;

479 
mp_limb_t
 *
r_ptr
;

480 
size_t
 
r_len
;

485 
roomptr
 = (
mp_limb_t
 *) 
	`malloc
 ((
a_len
 + 2) * sizeof (mp_limb_t));

486 if (
roomptr
 == 
NULL
)

487 return 
NULL
;

490 while (
a_len
 > 0 && 
a_ptr
[a_len - 1] == 0)

491 
a_len
--;

496 if (
b_len
 == 0)

498 
	`abort
 ();

499 if (
b_ptr
[
b_len
 - 1] == 0)

500 
b_len
--;

507 if (
a_len
 < 
b_len
)

510 
r_ptr
 = 
roomptr
;

511 
r_len
 = 
a_len
;

512 
	`memcpy
 (
r_ptr
, 
a_ptr
, 
a_len
 * sizeof (
mp_limb_t
));

513 
q_ptr
 = 
roomptr
 + 
a_len
;

514 
q_len
 = 0;

516 else if (
b_len
 == 1)

520 
r_ptr
 = 
roomptr
;

521 
q_ptr
 = 
roomptr
 + 1;

523 
mp_limb_t
 
den
 = 
b_ptr
[0];

524 
mp_limb_t
 
remainder
 = 0;

525 const 
mp_limb_t
 *
sourceptr
 = 
a_ptr
 + 
a_len
;

526 
mp_limb_t
 *
destptr
 = 
q_ptr
 + 
a_len
;

527 
size_t
 
count
;

528 for (
count
 = 
a_len
; count > 0; count--)

530 
mp_twolimb_t
 
num
 =

531 ((
mp_twolimb_t
) 
remainder
 << 
GMP_LIMB_BITS
) | *--
sourceptr
;

532 *--
destptr
 = 
num
 / 
den
;

533 
remainder
 = 
num
 % 
den
;

536 if (
remainder
 > 0)

538 
r_ptr
[0] = 
remainder
;

539 
r_len
 = 1;

542 
r_len
 = 0;

544 
q_len
 = 
a_len
;

545 if (
q_ptr
[
q_len
 - 1] == 0)

546 
q_len
--;

555 
size_t
 
s
;

557 
mp_limb_t
 
msd
 = 
b_ptr
[
b_len
 - 1];

560 #if 
__GNUC__
 > 3 || (__GNUC__ == 3 && 
__GNUC_MINOR__
 >= 4)

561 
s
 = 
	`__builtin_clz
 (
msd
);

563 #if 
defined
 
DBL_EXPBIT0_WORD
 && defined 
DBL_EXPBIT0_BIT


564 if (
GMP_LIMB_BITS
 <= 
DBL_MANT_BIT
)

568 #define 
	#DBL_EXP_MASK
 ((
DBL_MAX_EXP
 - 
DBL_MIN_EXP
) | 7)

	)

569 #define 
	#DBL_EXP_BIAS
 (
DBL_EXP_MASK
 / 2 - 1)

	)

570 #define 
	#NWORDS
 \

571 ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))

	)

572 union { double 
value
; unsigned int 
word
[
NWORDS
]; } 
m
;

575 
m
.
value
 = 
msd
;

577 
s
 = 
GMP_LIMB_BITS


578 - (((
m
.
word
[
DBL_EXPBIT0_WORD
] >> 
DBL_EXPBIT0_BIT
) & 
DBL_EXP_MASK
)

579 - 
DBL_EXP_BIAS
);

582 #undef 
NWORDS


585 
s
 = 31;

586 if (
msd
 >= 0x10000)

588 
msd
 = msd >> 16;

589 
s
 -= 16;

591 if (
msd
 >= 0x100)

593 
msd
 = msd >> 8;

594 
s
 -= 8;

596 if (
msd
 >= 0x10)

598 
msd
 = msd >> 4;

599 
s
 -= 4;

601 if (
msd
 >= 0x4)

603 
msd
 = msd >> 2;

604 
s
 -= 2;

606 if (
msd
 >= 0x2)

608 
msd
 = msd >> 1;

609 
s
 -= 1;

616 if (
s
 > 0)

618 
tmp_roomptr
 = (
mp_limb_t
 *) 
	`malloc
 (
b_len
 * sizeof (mp_limb_t));

619 if (
tmp_roomptr
 == 
NULL
)

621 
	`free
 (
roomptr
);

622 return 
NULL
;

625 const 
mp_limb_t
 *
sourceptr
 = 
b_ptr
;

626 
mp_limb_t
 *
destptr
 = 
tmp_roomptr
;

627 
mp_twolimb_t
 
accu
 = 0;

628 
size_t
 
count
;

629 for (
count
 = 
b_len
; count > 0; count--)

631 
accu
 += (
mp_twolimb_t
) *
sourceptr
++ << 
s
;

632 *
destptr
++ = (
mp_limb_t
) 
accu
;

633 
accu
 = accu >> 
GMP_LIMB_BITS
;

636 if (
accu
 != 0)

637 
	`abort
 ();

639 
b_ptr
 = 
tmp_roomptr
;

645 
r_ptr
 = 
roomptr
;

646 if (
s
 == 0)

648 
	`memcpy
 (
r_ptr
, 
a_ptr
, 
a_len
 * sizeof (
mp_limb_t
));

649 
r_ptr
[
a_len
] = 0;

653 const 
mp_limb_t
 *
sourceptr
 = 
a_ptr
;

654 
mp_limb_t
 *
destptr
 = 
r_ptr
;

655 
mp_twolimb_t
 
accu
 = 0;

656 
size_t
 
count
;

657 for (
count
 = 
a_len
; count > 0; count--)

659 
accu
 += (
mp_twolimb_t
) *
sourceptr
++ << 
s
;

660 *
destptr
++ = (
mp_limb_t
) 
accu
;

661 
accu
 = accu >> 
GMP_LIMB_BITS
;

663 *
destptr
++ = (
mp_limb_t
) 
accu
;

665 
q_ptr
 = 
roomptr
 + 
b_len
;

666 
q_len
 = 
a_len
 - 
b_len
 + 1;

668 
size_t
 
j
 = 
a_len
 - 
b_len
;

669 
mp_limb_t
 
b_msd
 = 
b_ptr
[
b_len
 - 1];

670 
mp_limb_t
 
b_2msd
 = 
b_ptr
[
b_len
 - 2];

671 
mp_twolimb_t
 
b_msdd
 =

672 ((
mp_twolimb_t
) 
b_msd
 << 
GMP_LIMB_BITS
) | 
b_2msd
;

677 
mp_limb_t
 
q_star
;

678 
mp_limb_t
 
c1
;

679 if (
r_ptr
[
j
 + 
b_len
] < 
b_msd
)

682 
mp_twolimb_t
 
num
 =

683 ((
mp_twolimb_t
) 
r_ptr
[
j
 + 
b_len
] << 
GMP_LIMB_BITS
)

684 | 
r_ptr
[
j
 + 
b_len
 - 1];

685 
q_star
 = 
num
 / 
b_msd
;

686 
c1
 = 
num
 % 
b_msd
;

691 
q_star
 = (
mp_limb_t
)~(mp_limb_t)0;

699 if (
r_ptr
[
j
 + 
b_len
] > 
b_msd


700 || (
c1
 = 
r_ptr
[
j
 + 
b_len
 - 1] + 
b_msd
) < b_msd)

704 goto 
subtract
;

709 
mp_twolimb_t
 
c2
 =

710 ((
mp_twolimb_t
) 
c1
 << 
GMP_LIMB_BITS
) | 
r_ptr
[
j
 + 
b_len
 - 2];

711 
mp_twolimb_t
 
c3
 =

712 (
mp_twolimb_t
) 
b_2msd
 * (mp_twolimb_t) 
q_star
;

717 if (
c3
 > 
c2
)

719 
q_star
 = q_star - 1;

720 if (
c3
 - 
c2
 > 
b_msdd
)

721 
q_star
 = q_star - 1;

724 if (
q_star
 > 0)

725 
subtract
:

728 
mp_limb_t
 
cr
;

730 const 
mp_limb_t
 *
sourceptr
 = 
b_ptr
;

731 
mp_limb_t
 *
destptr
 = 
r_ptr
 + 
j
;

732 
mp_twolimb_t
 
carry
 = 0;

733 
size_t
 
count
;

734 for (
count
 = 
b_len
; count > 0; count--)

737 
carry
 =

738 
carry


739 + (
mp_twolimb_t
) 
q_star
 * (mp_twolimb_t) *
sourceptr
++

740 + (
mp_limb_t
) ~(*
destptr
);

742 *
destptr
++ = ~(
mp_limb_t
) 
carry
;

743 
carry
 = carry >> 
GMP_LIMB_BITS
;

745 
cr
 = (
mp_limb_t
) 
carry
;

749 if (
cr
 > 
r_ptr
[
j
 + 
b_len
])

752 
q_star
 = q_star - 1;

755 const 
mp_limb_t
 *
sourceptr
 = 
b_ptr
;

756 
mp_limb_t
 *
destptr
 = 
r_ptr
 + 
j
;

757 
mp_limb_t
 
carry
 = 0;

758 
size_t
 
count
;

759 for (
count
 = 
b_len
; count > 0; count--)

761 
mp_limb_t
 
source1
 = *
sourceptr
++;

762 
mp_limb_t
 
source2
 = *
destptr
;

763 *
destptr
++ = 
source1
 + 
source2
 + 
carry
;

764 
carry
 =

765 (
carry


766 ? 
source1
 >= (
mp_limb_t
) ~
source2


767 : 
source1
 > (
mp_limb_t
) ~
source2
);

774 
q_ptr
[
j
] = 
q_star
;

775 if (
j
 == 0)

777 
j
--;

780 
r_len
 = 
b_len
;

782 if (
q_ptr
[
q_len
 - 1] == 0)

783 
q_len
--;

787 if (
s
 > 0)

789 
mp_limb_t
 
ptr
 = 
r_ptr
 + 
r_len
;

790 
mp_twolimb_t
 
accu
 = 0;

791 
size_t
 
count
;

792 for (
count
 = 
r_len
; count > 0; count--)

794 
accu
 = (
mp_twolimb_t
) (
mp_limb_t
) accu << 
GMP_LIMB_BITS
;

795 
accu
 += (
mp_twolimb_t
) *--
ptr
 << (
GMP_LIMB_BITS
 - 
s
);

796 *
ptr
 = (
mp_limb_t
) (
accu
 >> 
GMP_LIMB_BITS
);

801 while (
r_len
 > 0 && 
r_ptr
[r_len - 1] == 0)

802 
r_len
--;

805 if (
r_len
 > 
b_len
)

806 goto 
increment_q
;

808 
size_t
 
i
;

809 for (
i
 = 
b_len
;;)

811 
mp_limb_t
 
r_i
 =

812 (
i
 <= 
r_len
 && i > 0 ? 
r_ptr
[i - 1] >> (
GMP_LIMB_BITS
 - 1) : 0)

813 | (
i
 < 
r_len
 ? 
r_ptr
[i] << 1 : 0);

814 
mp_limb_t
 
b_i
 = (
i
 < 
b_len
 ? 
b_ptr
[i] : 0);

815 if (
r_i
 > 
b_i
)

816 goto 
increment_q
;

817 if (
r_i
 < 
b_i
)

818 goto 
keep_q
;

819 if (
i
 == 0)

821 
i
--;

824 if (
q_len
 > 0 && ((
q_ptr
[0] & 1) != 0))

826 
increment_q
:

828 
size_t
 
i
;

829 for (
i
 = 0; i < 
q_len
; i++)

830 if (++(
q_ptr
[
i
]) != 0)

831 goto 
keep_q
;

832 
q_ptr
[
q_len
++] = 1;

834 
keep_q
:

835 if (
tmp_roomptr
 != 
NULL
)

836 
	`free
 (
tmp_roomptr
);

837 
q
->
limbs
 = 
q_ptr
;

838 
q
->
nlimbs
 = 
q_len
;

839 return 
roomptr
;

840 
	}
}

849 
	$convert_to_decimal
 (
mpn_t
 
a
, 
size_t
 
extra_zeroes
)

851 
mp_limb_t
 *
a_ptr
 = 
a
.
limbs
;

852 
size_t
 
a_len
 = 
a
.
nlimbs
;

854 
size_t
 
c_len
 = 9 * ((size_t)(
a_len
 * (
GMP_LIMB_BITS
 * 0.03345f)) + 1);

855 char *
c_ptr
 = (char *) 
	`malloc
 (
	`xsum
 (
c_len
, 
extra_zeroes
));

856 if (
c_ptr
 != 
NULL
)

858 char *
d_ptr
 = 
c_ptr
;

859 for (; 
extra_zeroes
 > 0; extra_zeroes--)

860 *
d_ptr
++ = '0';

861 while (
a_len
 > 0)

864 
mp_limb_t
 
remainder
 = 0;

865 
mp_limb_t
 *
ptr
 = 
a_ptr
 + 
a_len
;

866 
size_t
 
count
;

867 for (
count
 = 
a_len
; count > 0; count--)

869 
mp_twolimb_t
 
num
 =

870 ((
mp_twolimb_t
) 
remainder
 << 
GMP_LIMB_BITS
) | *--
ptr
;

871 *
ptr
 = 
num
 / 1000000000;

872 
remainder
 = 
num
 % 1000000000;

875 for (
count
 = 9; count > 0; count--)

877 *
d_ptr
++ = '0' + (
remainder
 % 10);

878 
remainder
 = remainder / 10;

881 if (
a_ptr
[
a_len
 - 1] == 0)

882 
a_len
--;

885 while (
d_ptr
 > 
c_ptr
 && d_ptr[-1] == '0')

886 
d_ptr
--;

888 if (
d_ptr
 == 
c_ptr
)

889 *
d_ptr
++ = '0';

891 *
d_ptr
 = '\0';

893 return 
c_ptr
;

894 
	}
}

896 #if 
NEED_PRINTF_LONG_DOUBLE


903 
	$decode_long_double
 (long double 
x
, int *
ep
, 
mpn_t
 *
mp
)

905 
mpn_t
 
m
;

906 int 
exp
;

907 long double 
y
;

908 
size_t
 
i
;

911 
m
.
nlimbs
 = (
LDBL_MANT_BIT
 + 
GMP_LIMB_BITS
 - 1) / GMP_LIMB_BITS;

912 
m
.
limbs
 = (
mp_limb_t
 *) 
	`malloc
 (m.
nlimbs
 * sizeof (mp_limb_t));

913 if (
m
.
limbs
 == 
NULL
)

914 return 
NULL
;

916 
y
 = 
	`frexpl
 (
x
, &
exp
);

917 if (!(
y
 >= 0.0L && y < 1.0L))

918 
	`abort
 ();

926 #if (
LDBL_MANT_BIT
 % 
GMP_LIMB_BITS
) != 0

927 #if (
LDBL_MANT_BIT
 % 
GMP_LIMB_BITS
) > GMP_LIMB_BITS / 2

929 
mp_limb_t
 
hi
, 
lo
;

930 
y
 *= (
mp_limb_t
) 1 << (
LDBL_MANT_BIT
 % (
GMP_LIMB_BITS
 / 2));

931 
hi
 = (int) 
y
;

932 
y
 -= 
hi
;

933 if (!(
y
 >= 0.0L && y < 1.0L))

934 
	`abort
 ();

935 
y
 *= (
mp_limb_t
) 1 << (
GMP_LIMB_BITS
 / 2);

936 
lo
 = (int) 
y
;

937 
y
 -= 
lo
;

938 if (!(
y
 >= 0.0L && y < 1.0L))

939 
	`abort
 ();

940 
m
.
limbs
[
LDBL_MANT_BIT
 / 
GMP_LIMB_BITS
] = (
hi
 << (GMP_LIMB_BITS / 2)) | 
lo
;

944 
mp_limb_t
 
d
;

945 
y
 *= (
mp_limb_t
) 1 << (
LDBL_MANT_BIT
 % 
GMP_LIMB_BITS
);

946 
d
 = (int) 
y
;

947 
y
 -= 
d
;

948 if (!(
y
 >= 0.0L && y < 1.0L))

949 
	`abort
 ();

950 
m
.
limbs
[
LDBL_MANT_BIT
 / 
GMP_LIMB_BITS
] = 
d
;

954 for (
i
 = 
LDBL_MANT_BIT
 / 
GMP_LIMB_BITS
; i > 0; )

956 
mp_limb_t
 
hi
, 
lo
;

957 
y
 *= (
mp_limb_t
) 1 << (
GMP_LIMB_BITS
 / 2);

958 
hi
 = (int) 
y
;

959 
y
 -= 
hi
;

960 if (!(
y
 >= 0.0L && y < 1.0L))

961 
	`abort
 ();

962 
y
 *= (
mp_limb_t
) 1 << (
GMP_LIMB_BITS
 / 2);

963 
lo
 = (int) 
y
;

964 
y
 -= 
lo
;

965 if (!(
y
 >= 0.0L && y < 1.0L))

966 
	`abort
 ();

967 
m
.
limbs
[--
i
] = (
hi
 << (
GMP_LIMB_BITS
 / 2)) | 
lo
;

971 if (!(
y
 == 0.0L))

972 
	`abort
 ();

975 while (
m
.
nlimbs
 > 0 && m.
limbs
[m.nlimbs - 1] == 0)

976 
m
.
nlimbs
--;

977 *
mp
 = 
m
;

978 *
ep
 = 
exp
 - 
LDBL_MANT_BIT
;

979 return 
m
.
limbs
;

980 
	}
}

984 #if 
NEED_PRINTF_DOUBLE


991 
	$decode_double
 (double 
x
, int *
ep
, 
mpn_t
 *
mp
)

993 
mpn_t
 
m
;

994 int 
exp
;

995 double 
y
;

996 
size_t
 
i
;

999 
m
.
nlimbs
 = (
DBL_MANT_BIT
 + 
GMP_LIMB_BITS
 - 1) / GMP_LIMB_BITS;

1000 
m
.
limbs
 = (
mp_limb_t
 *) 
	`malloc
 (m.
nlimbs
 * sizeof (mp_limb_t));

1001 if (
m
.
limbs
 == 
NULL
)

1002 return 
NULL
;

1004 
y
 = 
	`frexp
 (
x
, &
exp
);

1005 if (!(
y
 >= 0.0 && y < 1.0))

1006 
	`abort
 ();

1014 #if (
DBL_MANT_BIT
 % 
GMP_LIMB_BITS
) != 0

1015 #if (
DBL_MANT_BIT
 % 
GMP_LIMB_BITS
) > GMP_LIMB_BITS / 2

1017 
mp_limb_t
 
hi
, 
lo
;

1018 
y
 *= (
mp_limb_t
) 1 << (
DBL_MANT_BIT
 % (
GMP_LIMB_BITS
 / 2));

1019 
hi
 = (int) 
y
;

1020 
y
 -= 
hi
;

1021 if (!(
y
 >= 0.0 && y < 1.0))

1022 
	`abort
 ();

1023 
y
 *= (
mp_limb_t
) 1 << (
GMP_LIMB_BITS
 / 2);

1024 
lo
 = (int) 
y
;

1025 
y
 -= 
lo
;

1026 if (!(
y
 >= 0.0 && y < 1.0))

1027 
	`abort
 ();

1028 
m
.
limbs
[
DBL_MANT_BIT
 / 
GMP_LIMB_BITS
] = (
hi
 << (GMP_LIMB_BITS / 2)) | 
lo
;

1032 
mp_limb_t
 
d
;

1033 
y
 *= (
mp_limb_t
) 1 << (
DBL_MANT_BIT
 % 
GMP_LIMB_BITS
);

1034 
d
 = (int) 
y
;

1035 
y
 -= 
d
;

1036 if (!(
y
 >= 0.0 && y < 1.0))

1037 
	`abort
 ();

1038 
m
.
limbs
[
DBL_MANT_BIT
 / 
GMP_LIMB_BITS
] = 
d
;

1042 for (
i
 = 
DBL_MANT_BIT
 / 
GMP_LIMB_BITS
; i > 0; )

1044 
mp_limb_t
 
hi
, 
lo
;

1045 
y
 *= (
mp_limb_t
) 1 << (
GMP_LIMB_BITS
 / 2);

1046 
hi
 = (int) 
y
;

1047 
y
 -= 
hi
;

1048 if (!(
y
 >= 0.0 && y < 1.0))

1049 
	`abort
 ();

1050 
y
 *= (
mp_limb_t
) 1 << (
GMP_LIMB_BITS
 / 2);

1051 
lo
 = (int) 
y
;

1052 
y
 -= 
lo
;

1053 if (!(
y
 >= 0.0 && y < 1.0))

1054 
	`abort
 ();

1055 
m
.
limbs
[--
i
] = (
hi
 << (
GMP_LIMB_BITS
 / 2)) | 
lo
;

1057 if (!(
y
 == 0.0))

1058 
	`abort
 ();

1060 while (
m
.
nlimbs
 > 0 && m.
limbs
[m.nlimbs - 1] == 0)

1061 
m
.
nlimbs
--;

1062 *
mp
 = 
m
;

1063 *
ep
 = 
exp
 - 
DBL_MANT_BIT
;

1064 return 
m
.
limbs
;

1065 
	}
}

1075 
	$scale10_round_decimal_decoded
 (int 
e
, 
mpn_t
 
m
, void *
memory
, int 
n
)

1077 int 
s
;

1078 
size_t
 
extra_zeroes
;

1079 unsigned int 
abs_n
;

1080 unsigned int 
abs_s
;

1081 
mp_limb_t
 *
pow5_ptr
;

1082 
size_t
 
pow5_len
;

1083 unsigned int 
s_limbs
;

1084 unsigned int 
s_bits
;

1085 
mpn_t
 
pow5
;

1086 
mpn_t
 
z
;

1087 void *
z_memory
;

1088 char *
digits
;

1090 if (
memory
 == 
NULL
)

1091 return 
NULL
;

1095 
s
 = 
e
 + 
n
;

1096 
extra_zeroes
 = 0;

1098 if (
s
 > 0 && 
n
 > 0)

1100 
extra_zeroes
 = (
s
 < 
n
 ? s : n);

1101 
s
 -= 
extra_zeroes
;

1102 
n
 -= 
extra_zeroes
;

1109 
abs_n
 = (
n
 >= 0 ? n : -n);

1110 
abs_s
 = (
s
 >= 0 ? s : -s);

1111 
pow5_ptr
 = (
mp_limb_t
 *) 
	`malloc
 (((int)(
abs_n
 * (2.322f / 
GMP_LIMB_BITS
)) + 1

1112 + 
abs_s
 / 
GMP_LIMB_BITS
 + 1)

1113 * sizeof (
mp_limb_t
));

1114 if (
pow5_ptr
 == 
NULL
)

1116 
	`free
 (
memory
);

1117 return 
NULL
;

1120 
pow5_ptr
[0] = 1;

1121 
pow5_len
 = 1;

1123 if (
abs_n
 > 0)

1125 static 
mp_limb_t
 const 
small_pow5
[13 + 1] =

1130 unsigned int 
n13
;

1131 for (
n13
 = 0; n13 <= 
abs_n
; n13 += 13)

1133 
mp_limb_t
 
digit1
 = 
small_pow5
[
n13
 + 13 <= 
abs_n
 ? 13 : abs_n - n13];

1134 
size_t
 
j
;

1135 
mp_twolimb_t
 
carry
 = 0;

1136 for (
j
 = 0; j < 
pow5_len
; j++)

1138 
mp_limb_t
 
digit2
 = 
pow5_ptr
[
j
];

1139 
carry
 += (
mp_twolimb_t
) 
digit1
 * (mp_twolimb_t) 
digit2
;

1140 
pow5_ptr
[
j
] = (
mp_limb_t
) 
carry
;

1141 
carry
 = carry >> 
GMP_LIMB_BITS
;

1143 if (
carry
 > 0)

1144 
pow5_ptr
[
pow5_len
++] = (
mp_limb_t
) 
carry
;

1147 
s_limbs
 = 
abs_s
 / 
GMP_LIMB_BITS
;

1148 
s_bits
 = 
abs_s
 % 
GMP_LIMB_BITS
;

1149 if (
n
 >= 0 ? 
s
 >= 0 : s <= 0)

1152 if (
s_bits
 > 0)

1154 
mp_limb_t
 *
ptr
 = 
pow5_ptr
;

1155 
mp_twolimb_t
 
accu
 = 0;

1156 
size_t
 
count
;

1157 for (
count
 = 
pow5_len
; count > 0; count--)

1159 
accu
 += (
mp_twolimb_t
) *
ptr
 << 
s_bits
;

1160 *
ptr
++ = (
mp_limb_t
) 
accu
;

1161 
accu
 = accu >> 
GMP_LIMB_BITS
;

1163 if (
accu
 > 0)

1165 *
ptr
 = (
mp_limb_t
) 
accu
;

1166 
pow5_len
++;

1169 if (
s_limbs
 > 0)

1171 
size_t
 
count
;

1172 for (
count
 = 
pow5_len
; count > 0;)

1174 
count
--;

1175 
pow5_ptr
[
s_limbs
 + 
count
] = pow5_ptr[count];

1177 for (
count
 = 
s_limbs
; count > 0;)

1179 
count
--;

1180 
pow5_ptr
[
count
] = 0;

1182 
pow5_len
 += 
s_limbs
;

1184 
pow5
.
limbs
 = 
pow5_ptr
;

1185 
pow5
.
nlimbs
 = 
pow5_len
;

1186 if (
n
 >= 0)

1189 
z_memory
 = 
	`multiply
 (
m
, 
pow5
, &
z
);

1194 
z_memory
 = 
	`divide
 (
m
, 
pow5
, &
z
);

1199 
pow5
.
limbs
 = 
pow5_ptr
;

1200 
pow5
.
nlimbs
 = 
pow5_len
;

1201 if (
n
 >= 0)

1205 
mpn_t
 
numerator
;

1206 
mpn_t
 
denominator
;

1207 void *
tmp_memory
;

1208 
tmp_memory
 = 
	`multiply
 (
m
, 
pow5
, &
numerator
);

1209 if (
tmp_memory
 == 
NULL
)

1211 
	`free
 (
pow5_ptr
);

1212 
	`free
 (
memory
);

1213 return 
NULL
;

1217 
mp_limb_t
 *
ptr
 = 
pow5_ptr
 + 
pow5_len
;

1218 
size_t
 
i
;

1219 for (
i
 = 0; i < 
s_limbs
; i++)

1220 
ptr
[
i
] = 0;

1221 
ptr
[
s_limbs
] = (
mp_limb_t
) 1 << 
s_bits
;

1222 
denominator
.
limbs
 = 
ptr
;

1223 
denominator
.
nlimbs
 = 
s_limbs
 + 1;

1225 
z_memory
 = 
	`divide
 (
numerator
, 
denominator
, &
z
);

1226 
	`free
 (
tmp_memory
);

1232 
mpn_t
 
numerator
;

1233 
mp_limb_t
 *
num_ptr
;

1234 
num_ptr
 = (
mp_limb_t
 *) 
	`malloc
 ((
m
.
nlimbs
 + 
s_limbs
 + 1)

1235 * sizeof (
mp_limb_t
));

1236 if (
num_ptr
 == 
NULL
)

1238 
	`free
 (
pow5_ptr
);

1239 
	`free
 (
memory
);

1240 return 
NULL
;

1243 
mp_limb_t
 *
destptr
 = 
num_ptr
;

1245 
size_t
 
i
;

1246 for (
i
 = 0; i < 
s_limbs
; i++)

1247 *
destptr
++ = 0;

1249 if (
s_bits
 > 0)

1251 const 
mp_limb_t
 *
sourceptr
 = 
m
.
limbs
;

1252 
mp_twolimb_t
 
accu
 = 0;

1253 
size_t
 
count
;

1254 for (
count
 = 
m
.
nlimbs
; count > 0; count--)

1256 
accu
 += (
mp_twolimb_t
) *
sourceptr
++ << 
s_bits
;

1257 *
destptr
++ = (
mp_limb_t
) 
accu
;

1258 
accu
 = accu >> 
GMP_LIMB_BITS
;

1260 if (
accu
 > 0)

1261 *
destptr
++ = (
mp_limb_t
) 
accu
;

1265 const 
mp_limb_t
 *
sourceptr
 = 
m
.
limbs
;

1266 
size_t
 
count
;

1267 for (
count
 = 
m
.
nlimbs
; count > 0; count--)

1268 *
destptr
++ = *
sourceptr
++;

1270 
numerator
.
limbs
 = 
num_ptr
;

1271 
numerator
.
nlimbs
 = 
destptr
 - 
num_ptr
;

1273 
z_memory
 = 
	`divide
 (
numerator
, 
pow5
, &
z
);

1274 
	`free
 (
num_ptr
);

1277 
	`free
 (
pow5_ptr
);

1278 
	`free
 (
memory
);

1282 if (
z_memory
 == 
NULL
)

1283 return 
NULL
;

1284 
digits
 = 
	`convert_to_decimal
 (
z
, 
extra_zeroes
);

1285 
	`free
 (
z_memory
);

1286 return 
digits
;

1287 
	}
}

1289 #if 
NEED_PRINTF_LONG_DOUBLE


1297 
	$scale10_round_decimal_long_double
 (long double 
x
, int 
n
)

1299 int 
e
 
	`IF_LINT
(= 0);

1300 
mpn_t
 
m
;

1301 void *
memory
 = 
	`decode_long_double
 (
x
, &
e
, &
m
);

1302 return 
	`scale10_round_decimal_decoded
 (
e
, 
m
, 
memory
, 
n
);

1303 
	}
}

1307 #if 
NEED_PRINTF_DOUBLE


1315 
	$scale10_round_decimal_double
 (double 
x
, int 
n
)

1317 int 
e
 
	`IF_LINT
(= 0);

1318 
mpn_t
 
m
;

1319 void *
memory
 = 
	`decode_double
 (
x
, &
e
, &
m
);

1320 return 
	`scale10_round_decimal_decoded
 (
e
, 
m
, 
memory
, 
n
);

1321 
	}
}

1325 #if 
NEED_PRINTF_LONG_DOUBLE


1331 
	$floorlog10l
 (long double 
x
)

1333 int 
exp
;

1334 long double 
y
;

1335 double 
z
;

1336 double 
l
;

1339 
y
 = 
	`frexpl
 (
x
, &
exp
);

1340 if (!(
y
 >= 0.0L && y < 1.0L))

1341 
	`abort
 ();

1342 if (
y
 == 0.0L)

1343 return 
INT_MIN
;

1344 if (
y
 < 0.5L)

1346 while (
y
 < (1.0L / (1 << (
GMP_LIMB_BITS
 / 2)) / (1 << (GMP_LIMB_BITS / 2))))

1348 
y
 *= 1.0L * (1 << (
GMP_LIMB_BITS
 / 2)) * (1 << (GMP_LIMB_BITS / 2));

1349 
exp
 -= 
GMP_LIMB_BITS
;

1351 if (
y
 < (1.0L / (1 << 16)))

1353 
y
 *= 1.0L * (1 << 16);

1354 
exp
 -= 16;

1356 if (
y
 < (1.0L / (1 << 8)))

1358 
y
 *= 1.0L * (1 << 8);

1359 
exp
 -= 8;

1361 if (
y
 < (1.0L / (1 << 4)))

1363 
y
 *= 1.0L * (1 << 4);

1364 
exp
 -= 4;

1366 if (
y
 < (1.0L / (1 << 2)))

1368 
y
 *= 1.0L * (1 << 2);

1369 
exp
 -= 2;

1371 if (
y
 < (1.0L / (1 << 1)))

1373 
y
 *= 1.0L * (1 << 1);

1374 
exp
 -= 1;

1377 if (!(
y
 >= 0.5L && y < 1.0L))

1378 
	`abort
 ();

1380 
l
 = 
exp
;

1381 
z
 = 
y
;

1382 if (
z
 < 0.70710678118654752444)

1384 
z
 *= 1.4142135623730950488;

1385 
l
 -= 0.5;

1387 if (
z
 < 0.8408964152537145431)

1389 
z
 *= 1.1892071150027210667;

1390 
l
 -= 0.25;

1392 if (
z
 < 0.91700404320467123175)

1394 
z
 *= 1.0905077326652576592;

1395 
l
 -= 0.125;

1397 if (
z
 < 0.9576032806985736469)

1399 
z
 *= 1.0442737824274138403;

1400 
l
 -= 0.0625;

1403 
z
 = 1 - z;

1406 
l
 -= 1.4426950408889634074 * 
z
 * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));

1409 
l
 *= 0.30102999566398119523;

1411 return (int) 
l
 + (l < 0 ? -1 : 0);

1412 
	}
}

1416 #if 
NEED_PRINTF_DOUBLE


1422 
	$floorlog10
 (double 
x
)

1424 int 
exp
;

1425 double 
y
;

1426 double 
z
;

1427 double 
l
;

1430 
y
 = 
	`frexp
 (
x
, &
exp
);

1431 if (!(
y
 >= 0.0 && y < 1.0))

1432 
	`abort
 ();

1433 if (
y
 == 0.0)

1434 return 
INT_MIN
;

1435 if (
y
 < 0.5)

1437 while (
y
 < (1.0 / (1 << (
GMP_LIMB_BITS
 / 2)) / (1 << (GMP_LIMB_BITS / 2))))

1439 
y
 *= 1.0 * (1 << (
GMP_LIMB_BITS
 / 2)) * (1 << (GMP_LIMB_BITS / 2));

1440 
exp
 -= 
GMP_LIMB_BITS
;

1442 if (
y
 < (1.0 / (1 << 16)))

1444 
y
 *= 1.0 * (1 << 16);

1445 
exp
 -= 16;

1447 if (
y
 < (1.0 / (1 << 8)))

1449 
y
 *= 1.0 * (1 << 8);

1450 
exp
 -= 8;

1452 if (
y
 < (1.0 / (1 << 4)))

1454 
y
 *= 1.0 * (1 << 4);

1455 
exp
 -= 4;

1457 if (
y
 < (1.0 / (1 << 2)))

1459 
y
 *= 1.0 * (1 << 2);

1460 
exp
 -= 2;

1462 if (
y
 < (1.0 / (1 << 1)))

1464 
y
 *= 1.0 * (1 << 1);

1465 
exp
 -= 1;

1468 if (!(
y
 >= 0.5 && y < 1.0))

1469 
	`abort
 ();

1471 
l
 = 
exp
;

1472 
z
 = 
y
;

1473 if (
z
 < 0.70710678118654752444)

1475 
z
 *= 1.4142135623730950488;

1476 
l
 -= 0.5;

1478 if (
z
 < 0.8408964152537145431)

1480 
z
 *= 1.1892071150027210667;

1481 
l
 -= 0.25;

1483 if (
z
 < 0.91700404320467123175)

1485 
z
 *= 1.0905077326652576592;

1486 
l
 -= 0.125;

1488 if (
z
 < 0.9576032806985736469)

1490 
z
 *= 1.0442737824274138403;

1491 
l
 -= 0.0625;

1494 
z
 = 1 - z;

1497 
l
 -= 1.4426950408889634074 * 
z
 * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));

1500 
l
 *= 0.30102999566398119523;

1502 return (int) 
l
 + (l < 0 ? -1 : 0);

1503 
	}
}

1510 
	$is_borderline
 (const char *
digits
, 
size_t
 
precision
)

1512 for (; 
precision
 > 0; precision--, 
digits
++)

1513 if (*
digits
 != '0')

1515 if (*
digits
 != '1')

1517 
digits
++;

1518 return *
digits
 == '\0';

1519 
	}
}

1523 #if !
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99


1528 #if 
WIDE_CHAR_VERSION


1529 #define 
	#MAX_ROOM_NEEDED
 
wmax_room_needed


	)

1531 #define 
	#MAX_ROOM_NEEDED
 
max_room_needed


	)

1536 static 
inline
 
size_t


1537 
	$MAX_ROOM_NEEDED
 (const 
arguments
 *
ap
, 
size_t
 
arg_index
, 
FCHAR_T
 
conversion
,

1538 
arg_type
 
type
, int 
flags
, 
size_t
 
width
, int 
has_precision
,

1539 
size_t
 
precision
, int 
pad_ourselves
)

1541 
size_t
 
tmp_length
;

1543 switch (
conversion
)

1546 #if 
HAVE_LONG_LONG_INT


1547 if (
type
 == 
TYPE_LONGLONGINT
 || type == 
TYPE_ULONGLONGINT
)

1548 
tmp_length
 =

1549 (unsigned int) (sizeof (unsigned long long) * 
CHAR_BIT


1555 if (
type
 == 
TYPE_LONGINT
 || type == 
TYPE_ULONGINT
)

1556 
tmp_length
 =

1557 (unsigned int) (sizeof (unsigned long) * 
CHAR_BIT


1562 
tmp_length
 =

1563 (unsigned int) (sizeof (unsigned int) * 
CHAR_BIT


1567 if (
tmp_length
 < 
precision
)

1568 
tmp_length
 = 
precision
;

1570 
tmp_length
 = 
	`xsum
 (tmp_length, tmp_length);

1572 
tmp_length
 = 
	`xsum
 (tmp_length, 1);

1576 #if 
HAVE_LONG_LONG_INT


1577 if (
type
 == 
TYPE_LONGLONGINT
 || type == 
TYPE_ULONGLONGINT
)

1578 
tmp_length
 =

1579 (unsigned int) (sizeof (unsigned long long) * 
CHAR_BIT


1585 if (
type
 == 
TYPE_LONGINT
 || type == 
TYPE_ULONGINT
)

1586 
tmp_length
 =

1587 (unsigned int) (sizeof (unsigned long) * 
CHAR_BIT


1592 
tmp_length
 =

1593 (unsigned int) (sizeof (unsigned int) * 
CHAR_BIT


1597 if (
tmp_length
 < 
precision
)

1598 
tmp_length
 = 
precision
;

1600 
tmp_length
 = 
	`xsum
 (tmp_length, 1);

1604 #if 
HAVE_LONG_LONG_INT


1605 if (
type
 == 
TYPE_LONGLONGINT
 || type == 
TYPE_ULONGLONGINT
)

1606 
tmp_length
 =

1607 (unsigned int) (sizeof (unsigned long long) * 
CHAR_BIT


1613 if (
type
 == 
TYPE_LONGINT
 || type == 
TYPE_ULONGINT
)

1614 
tmp_length
 =

1615 (unsigned int) (sizeof (unsigned long) * 
CHAR_BIT


1620 
tmp_length
 =

1621 (unsigned int) (sizeof (unsigned int) * 
CHAR_BIT


1625 if (
tmp_length
 < 
precision
)

1626 
tmp_length
 = 
precision
;

1628 
tmp_length
 = 
	`xsum
 (tmp_length, 2);

1632 if (
type
 == 
TYPE_LONGDOUBLE
)

1633 
tmp_length
 =

1634 (unsigned int) (
LDBL_MAX_EXP


1641 
tmp_length
 =

1642 (unsigned int) (
DBL_MAX_EXP


1648 
tmp_length
 = 
	`xsum
 (tmp_length, 
precision
);

1652 
tmp_length
 =

1654 
tmp_length
 = 
	`xsum
 (tmp_length, 
precision
);

1658 if (
type
 == 
TYPE_LONGDOUBLE
)

1659 
tmp_length
 =

1660 (unsigned int) (
LDBL_DIG


1665 
tmp_length
 =

1666 (unsigned int) (
DBL_DIG


1670 if (
tmp_length
 < 
precision
)

1671 
tmp_length
 = 
precision
;

1673 
tmp_length
 = 
	`xsum
 (tmp_length, 12);

1677 #if 
HAVE_WINT_T
 && !
WIDE_CHAR_VERSION


1678 if (
type
 == 
TYPE_WIDE_CHAR
)

1679 
tmp_length
 = 
MB_CUR_MAX
;

1682 
tmp_length
 = 1;

1686 #if 
HAVE_WCHAR_T


1687 if (
type
 == 
TYPE_WIDE_STRING
)

1689 #if 
WIDE_CHAR_VERSION


1694 const 
wchar_t
 *
arg
 = 
ap
->arg[
arg_index
].
a
.
a_wide_string
;

1696 if (
has_precision
)

1697 
tmp_length
 = 
	`local_wcsnlen
 (
arg
, 
precision
);

1699 
tmp_length
 = 
	`local_wcslen
 (
arg
);

1710 
	`abort
 ();

1716 #if 
WIDE_CHAR_VERSION


1723 
	`abort
 ();

1729 const char *
arg
 = 
ap
->arg[
arg_index
].
a
.
a_string
;

1731 if (
has_precision
)

1732 
tmp_length
 = 
	`local_strnlen
 (
arg
, 
precision
);

1734 
tmp_length
 = 
	`strlen
 (
arg
);

1740 
tmp_length
 =

1741 (unsigned int) (sizeof (void *) * 
CHAR_BIT


1749 
	`abort
 ();

1752 if (!
pad_ourselves
)

1754 #if 
ENABLE_UNISTDIO


1760 
tmp_length
 = 
	`xsum
 (tmp_length, 
width
);

1763 if (
tmp_length
 < 
width
)

1764 
tmp_length
 = 
width
;

1768 
tmp_length
 = 
	`xsum
 (tmp_length, 1);

1770 return 
tmp_length
;

1771 
	}
}

1775 
DCHAR_T
 *

1776 
	$VASNPRINTF
 (
DCHAR_T
 *
resultbuf
, 
size_t
 *
lengthp
,

1777 const 
FCHAR_T
 *
format
, 
va_list
 
args
)

1779 
DIRECTIVES
 
d
;

1780 
arguments
 
a
;

1782 if (
	`PRINTF_PARSE
 (
format
, &
d
, &
a
) < 0)

1784 return 
NULL
;

1786 #define 
	#CLEANUP
() \

1787 if (
d
.
dir
 != d.
direct_alloc_dir
) \

1788 
	`free
 (
d
.
dir
); \

1789 if (
a
.
arg
 != a.
direct_alloc_arg
) \

1790 
	`free
 (
a
.
arg
);

	)

1792 if (
	`PRINTF_FETCHARGS
 (
args
, &
a
) < 0)

1794 
	`CLEANUP
 ();

1795 
errno
 = 
EINVAL
;

1796 return 
NULL
;

1800 
size_t
 
buf_neededlength
;

1801 
TCHAR_T
 *
buf
;

1802 
TCHAR_T
 *
buf_malloced
;

1803 const 
FCHAR_T
 *
cp
;

1804 
size_t
 
i
;

1805 
DIRECTIVE
 *
dp
;

1807 
DCHAR_T
 *
result
;

1808 
size_t
 
allocated
;

1809 
size_t
 
length
;

1813 
buf_neededlength
 =

1814 
	`xsum4
 (7, 
d
.
max_width_length
, d.
max_precision_length
, 6);

1815 #if 
HAVE_ALLOCA


1816 if (
buf_neededlength
 < 4000 / sizeof (
TCHAR_T
))

1818 
buf
 = (
TCHAR_T
 *) 
	`alloca
 (
buf_neededlength
 * sizeof (TCHAR_T));

1819 
buf_malloced
 = 
NULL
;

1824 
size_t
 
buf_memsize
 = 
	`xtimes
 (
buf_neededlength
, sizeof (
TCHAR_T
));

1825 if (
	`size_overflow_p
 (
buf_memsize
))

1826 goto 
out_of_memory_1
;

1827 
buf
 = (
TCHAR_T
 *) 
	`malloc
 (
buf_memsize
);

1828 if (
buf
 == 
NULL
)

1829 goto 
out_of_memory_1
;

1830 
buf_malloced
 = 
buf
;

1833 if (
resultbuf
 != 
NULL
)

1835 
result
 = 
resultbuf
;

1836 
allocated
 = *
lengthp
;

1840 
result
 = 
NULL
;

1841 
allocated
 = 0;

1843 
length
 = 0;

1850 #define 
	#ENSURE_ALLOCATION
(
needed
) \

1851 if ((
needed
) > 
allocated
) \

1853 
size_t
 
memory_size
; \

1854 
DCHAR_T
 *
memory
; \

1856 
allocated
 = (allocated > 0 ? 
	`xtimes
 (allocated, 2) : 12); \

1857 if ((
needed
) > 
allocated
) \

1858 
allocated
 = (
needed
); \

1859 
memory_size
 = 
	`xtimes
 (
allocated
, sizeof (
DCHAR_T
)); \

1860 if (
	`size_overflow_p
 (
memory_size
)) \

1861 goto 
out_of_memory
; \

1862 if (
result
 == 
resultbuf
 || result == 
NULL
) \

1863 
memory
 = (
DCHAR_T
 *) 
	`malloc
 (
memory_size
); \

1865 
memory
 = (
DCHAR_T
 *) 
	`realloc
 (
result
, 
memory_size
); \

1866 if (
memory
 == 
NULL
) \

1867 goto 
out_of_memory
; \

1868 if (
result
 == 
resultbuf
 && 
length
 > 0) \

1869 
	`DCHAR_CPY
 (
memory
, 
result
, 
length
); \

1870 
result
 = 
memory
; \

1871 }

	)

1873 for (
cp
 = 
format
, 
i
 = 0, 
dp
 = &
d
.
dir
[0]; ; cp = dp->
dir_end
, i++, dp++)

1875 if (
cp
 != 
dp
->
dir_start
)

1877 
size_t
 
n
 = 
dp
->
dir_start
 - 
cp
;

1878 
size_t
 
augmented_length
 = 
	`xsum
 (
length
, 
n
);

1880 
	`ENSURE_ALLOCATION
 (
augmented_length
);

1884 if (sizeof (
FCHAR_T
) == sizeof (
DCHAR_T
))

1886 
	`DCHAR_CPY
 (
result
 + 
length
, (const 
DCHAR_T
 *) 
cp
, 
n
);

1887 
length
 = 
augmented_length
;

1892 
result
[
length
++] = (unsigned char) *
cp
++;

1893 while (--
n
 > 0);

1896 if (
i
 == 
d
.
count
)

1900 if (
dp
->
conversion
 == '%')

1902 
size_t
 
augmented_length
;

1904 if (!(
dp
->
arg_index
 == 
ARG_NONE
))

1905 
	`abort
 ();

1906 
augmented_length
 = 
	`xsum
 (
length
, 1);

1907 
	`ENSURE_ALLOCATION
 (
augmented_length
);

1908 
result
[
length
] = '%';

1909 
length
 = 
augmented_length
;

1913 if (!(
dp
->
arg_index
 != 
ARG_NONE
))

1914 
	`abort
 ();

1916 if (
dp
->
conversion
 == 'n')

1918 switch (
a
.
arg
[
dp
->
arg_index
].
type
)

1920 case 
TYPE_COUNT_SCHAR_POINTER
:

1921 *
a
.
arg
[
dp
->
arg_index
].a.
a_count_schar_pointer
 = 
length
;

1923 case 
TYPE_COUNT_SHORT_POINTER
:

1924 *
a
.
arg
[
dp
->
arg_index
].a.
a_count_short_pointer
 = 
length
;

1926 case 
TYPE_COUNT_INT_POINTER
:

1927 *
a
.
arg
[
dp
->
arg_index
].a.
a_count_int_pointer
 = 
length
;

1929 case 
TYPE_COUNT_LONGINT_POINTER
:

1930 *
a
.
arg
[
dp
->
arg_index
].a.
a_count_longint_pointer
 = 
length
;

1932 #if 
HAVE_LONG_LONG_INT


1933 case 
TYPE_COUNT_LONGLONGINT_POINTER
:

1934 *
a
.
arg
[
dp
->
arg_index
].a.
a_count_longlongint_pointer
 = 
length
;

1938 
	`abort
 ();

1941 #if 
ENABLE_UNISTDIO


1943 else if (
dp
->
conversion
 == 'U')

1945 
arg_type
 
type
 = 
a
.
arg
[
dp
->
arg_index
].type;

1946 int 
flags
 = 
dp
->flags;

1947 int 
has_width
;

1948 
size_t
 
width
;

1949 int 
has_precision
;

1950 
size_t
 
precision
;

1952 
has_width
 = 0;

1953 
width
 = 0;

1954 if (
dp
->
width_start
 != dp->
width_end
)

1956 if (
dp
->
width_arg_index
 != 
ARG_NONE
)

1958 int 
arg
;

1960 if (!(
a
.
arg
[
dp
->
width_arg_index
].
type
 == 
TYPE_INT
))

1961 
	`abort
 ();

1962 
arg
 = 
a
.arg[
dp
->
width_arg_index
].a.
a_int
;

1963 if (
arg
 < 0)

1967 
flags
 |= 
FLAG_LEFT
;

1968 
width
 = (unsigned int) (-
arg
);

1971 
width
 = 
arg
;

1975 const 
FCHAR_T
 *
digitp
 = 
dp
->
width_start
;

1978 
width
 = 
	`xsum
 (
	`xtimes
 (width, 10), *
digitp
++ - '0');

1979 while (
digitp
 != 
dp
->
width_end
);

1981 
has_width
 = 1;

1984 
has_precision
 = 0;

1985 
precision
 = 0;

1986 if (
dp
->
precision_start
 != dp->
precision_end
)

1988 if (
dp
->
precision_arg_index
 != 
ARG_NONE
)

1990 int 
arg
;

1992 if (!(
a
.
arg
[
dp
->
precision_arg_index
].
type
 == 
TYPE_INT
))

1993 
	`abort
 ();

1994 
arg
 = 
a
.arg[
dp
->
precision_arg_index
].a.
a_int
;

1997 if (
arg
 >= 0)

1999 
precision
 = 
arg
;

2000 
has_precision
 = 1;

2005 const 
FCHAR_T
 *
digitp
 = 
dp
->
precision_start
 + 1;

2007 
precision
 = 0;

2008 while (
digitp
 != 
dp
->
precision_end
)

2009 
precision
 = 
	`xsum
 (
	`xtimes
 (precision, 10), *
digitp
++ - '0');

2010 
has_precision
 = 1;

2014 switch (
type
)

2016 case 
TYPE_U8_STRING
:

2018 const 
uint8_t
 *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_u8_string
;

2019 const 
uint8_t
 *
arg_end
;

2020 
size_t
 
characters
;

2022 if (
has_precision
)

2025 
arg_end
 = 
arg
;

2026 
characters
 = 0;

2027 for (; 
precision
 > 0; precision--)

2029 int 
count
 = 
	`u8_strmblen
 (
arg_end
);

2030 if (
count
 == 0)

2032 if (
count
 < 0)

2034 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2035 
	`free
 (
result
);

2036 if (
buf_malloced
 != 
NULL
)

2037 
	`free
 (
buf_malloced
);

2038 
	`CLEANUP
 ();

2039 
errno
 = 
EILSEQ
;

2040 return 
NULL
;

2042 
arg_end
 += 
count
;

2043 
characters
++;

2046 else if (
has_width
)

2050 
arg_end
 = 
arg
;

2051 
characters
 = 0;

2054 int 
count
 = 
	`u8_strmblen
 (
arg_end
);

2055 if (
count
 == 0)

2057 if (
count
 < 0)

2059 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2060 
	`free
 (
result
);

2061 if (
buf_malloced
 != 
NULL
)

2062 
	`free
 (
buf_malloced
);

2063 
	`CLEANUP
 ();

2064 
errno
 = 
EILSEQ
;

2065 return 
NULL
;

2067 
arg_end
 += 
count
;

2068 
characters
++;

2074 
arg_end
 = 
arg
 + 
	`u8_strlen
 (arg);

2076 
characters
 = 0;

2079 if (
has_width
 && 
width
 > 
characters


2080 && !(
dp
->
flags
 & 
FLAG_LEFT
))

2082 
size_t
 
n
 = 
width
 - 
characters
;

2083 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2084 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2085 
length
 += 
n
;

2088 #if 
DCHAR_IS_UINT8_T


2090 
size_t
 
n
 = 
arg_end
 - 
arg
;

2091 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2092 
	`DCHAR_CPY
 (
result
 + 
length
, 
arg
, 
n
);

2093 
length
 += 
n
;

2097 
DCHAR_T
 *
converted
 = 
result
 + 
length
;

2098 
size_t
 
converted_len
 = 
allocated
 - 
length
;

2099 #if 
DCHAR_IS_TCHAR


2101 
converted
 =

2102 
	`u8_conv_to_encoding
 (
	`locale_charset
 (),

2103 
iconveh_question_mark
,

2104 
arg
, 
arg_end
 - arg, 
NULL
,

2105 
converted
, &
converted_len
);

2108 
converted
 =

2109 
	`U8_TO_DCHAR
 (
arg
, 
arg_end
 - arg,

2110 
converted
, &
converted_len
);

2112 if (
converted
 == 
NULL
)

2114 int 
saved_errno
 = 
errno
;

2115 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2116 
	`free
 (
result
);

2117 if (
buf_malloced
 != 
NULL
)

2118 
	`free
 (
buf_malloced
);

2119 
	`CLEANUP
 ();

2120 
errno
 = 
saved_errno
;

2121 return 
NULL
;

2123 if (
converted
 != 
result
 + 
length
)

2125 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
converted_len
));

2126 
	`DCHAR_CPY
 (
result
 + 
length
, 
converted
, 
converted_len
);

2127 
	`free
 (
converted
);

2129 
length
 += 
converted_len
;

2133 if (
has_width
 && 
width
 > 
characters


2134 && (
dp
->
flags
 & 
FLAG_LEFT
))

2136 
size_t
 
n
 = 
width
 - 
characters
;

2137 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2138 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2139 
length
 += 
n
;

2144 case 
TYPE_U16_STRING
:

2146 const 
uint16_t
 *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_u16_string
;

2147 const 
uint16_t
 *
arg_end
;

2148 
size_t
 
characters
;

2150 if (
has_precision
)

2153 
arg_end
 = 
arg
;

2154 
characters
 = 0;

2155 for (; 
precision
 > 0; precision--)

2157 int 
count
 = 
	`u16_strmblen
 (
arg_end
);

2158 if (
count
 == 0)

2160 if (
count
 < 0)

2162 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2163 
	`free
 (
result
);

2164 if (
buf_malloced
 != 
NULL
)

2165 
	`free
 (
buf_malloced
);

2166 
	`CLEANUP
 ();

2167 
errno
 = 
EILSEQ
;

2168 return 
NULL
;

2170 
arg_end
 += 
count
;

2171 
characters
++;

2174 else if (
has_width
)

2178 
arg_end
 = 
arg
;

2179 
characters
 = 0;

2182 int 
count
 = 
	`u16_strmblen
 (
arg_end
);

2183 if (
count
 == 0)

2185 if (
count
 < 0)

2187 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2188 
	`free
 (
result
);

2189 if (
buf_malloced
 != 
NULL
)

2190 
	`free
 (
buf_malloced
);

2191 
	`CLEANUP
 ();

2192 
errno
 = 
EILSEQ
;

2193 return 
NULL
;

2195 
arg_end
 += 
count
;

2196 
characters
++;

2202 
arg_end
 = 
arg
 + 
	`u16_strlen
 (arg);

2204 
characters
 = 0;

2207 if (
has_width
 && 
width
 > 
characters


2208 && !(
dp
->
flags
 & 
FLAG_LEFT
))

2210 
size_t
 
n
 = 
width
 - 
characters
;

2211 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2212 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2213 
length
 += 
n
;

2216 #if 
DCHAR_IS_UINT16_T


2218 
size_t
 
n
 = 
arg_end
 - 
arg
;

2219 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2220 
	`DCHAR_CPY
 (
result
 + 
length
, 
arg
, 
n
);

2221 
length
 += 
n
;

2225 
DCHAR_T
 *
converted
 = 
result
 + 
length
;

2226 
size_t
 
converted_len
 = 
allocated
 - 
length
;

2227 #if 
DCHAR_IS_TCHAR


2229 
converted
 =

2230 
	`u16_conv_to_encoding
 (
	`locale_charset
 (),

2231 
iconveh_question_mark
,

2232 
arg
, 
arg_end
 - arg, 
NULL
,

2233 
converted
, &
converted_len
);

2236 
converted
 =

2237 
	`U16_TO_DCHAR
 (
arg
, 
arg_end
 - arg,

2238 
converted
, &
converted_len
);

2240 if (
converted
 == 
NULL
)

2242 int 
saved_errno
 = 
errno
;

2243 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2244 
	`free
 (
result
);

2245 if (
buf_malloced
 != 
NULL
)

2246 
	`free
 (
buf_malloced
);

2247 
	`CLEANUP
 ();

2248 
errno
 = 
saved_errno
;

2249 return 
NULL
;

2251 if (
converted
 != 
result
 + 
length
)

2253 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
converted_len
));

2254 
	`DCHAR_CPY
 (
result
 + 
length
, 
converted
, 
converted_len
);

2255 
	`free
 (
converted
);

2257 
length
 += 
converted_len
;

2261 if (
has_width
 && 
width
 > 
characters


2262 && (
dp
->
flags
 & 
FLAG_LEFT
))

2264 
size_t
 
n
 = 
width
 - 
characters
;

2265 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2266 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2267 
length
 += 
n
;

2272 case 
TYPE_U32_STRING
:

2274 const 
uint32_t
 *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_u32_string
;

2275 const 
uint32_t
 *
arg_end
;

2276 
size_t
 
characters
;

2278 if (
has_precision
)

2281 
arg_end
 = 
arg
;

2282 
characters
 = 0;

2283 for (; 
precision
 > 0; precision--)

2285 int 
count
 = 
	`u32_strmblen
 (
arg_end
);

2286 if (
count
 == 0)

2288 if (
count
 < 0)

2290 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2291 
	`free
 (
result
);

2292 if (
buf_malloced
 != 
NULL
)

2293 
	`free
 (
buf_malloced
);

2294 
	`CLEANUP
 ();

2295 
errno
 = 
EILSEQ
;

2296 return 
NULL
;

2298 
arg_end
 += 
count
;

2299 
characters
++;

2302 else if (
has_width
)

2306 
arg_end
 = 
arg
;

2307 
characters
 = 0;

2310 int 
count
 = 
	`u32_strmblen
 (
arg_end
);

2311 if (
count
 == 0)

2313 if (
count
 < 0)

2315 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2316 
	`free
 (
result
);

2317 if (
buf_malloced
 != 
NULL
)

2318 
	`free
 (
buf_malloced
);

2319 
	`CLEANUP
 ();

2320 
errno
 = 
EILSEQ
;

2321 return 
NULL
;

2323 
arg_end
 += 
count
;

2324 
characters
++;

2330 
arg_end
 = 
arg
 + 
	`u32_strlen
 (arg);

2332 
characters
 = 0;

2335 if (
has_width
 && 
width
 > 
characters


2336 && !(
dp
->
flags
 & 
FLAG_LEFT
))

2338 
size_t
 
n
 = 
width
 - 
characters
;

2339 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2340 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2341 
length
 += 
n
;

2344 #if 
DCHAR_IS_UINT32_T


2346 
size_t
 
n
 = 
arg_end
 - 
arg
;

2347 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2348 
	`DCHAR_CPY
 (
result
 + 
length
, 
arg
, 
n
);

2349 
length
 += 
n
;

2353 
DCHAR_T
 *
converted
 = 
result
 + 
length
;

2354 
size_t
 
converted_len
 = 
allocated
 - 
length
;

2355 #if 
DCHAR_IS_TCHAR


2357 
converted
 =

2358 
	`u32_conv_to_encoding
 (
	`locale_charset
 (),

2359 
iconveh_question_mark
,

2360 
arg
, 
arg_end
 - arg, 
NULL
,

2361 
converted
, &
converted_len
);

2364 
converted
 =

2365 
	`U32_TO_DCHAR
 (
arg
, 
arg_end
 - arg,

2366 
converted
, &
converted_len
);

2368 if (
converted
 == 
NULL
)

2370 int 
saved_errno
 = 
errno
;

2371 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2372 
	`free
 (
result
);

2373 if (
buf_malloced
 != 
NULL
)

2374 
	`free
 (
buf_malloced
);

2375 
	`CLEANUP
 ();

2376 
errno
 = 
saved_errno
;

2377 return 
NULL
;

2379 if (
converted
 != 
result
 + 
length
)

2381 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
converted_len
));

2382 
	`DCHAR_CPY
 (
result
 + 
length
, 
converted
, 
converted_len
);

2383 
	`free
 (
converted
);

2385 
length
 += 
converted_len
;

2389 if (
has_width
 && 
width
 > 
characters


2390 && (
dp
->
flags
 & 
FLAG_LEFT
))

2392 
size_t
 
n
 = 
width
 - 
characters
;

2393 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2394 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2395 
length
 += 
n
;

2401 
	`abort
 ();

2405 #if (!
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
 || (
NEED_PRINTF_DIRECTIVE_LS
 && !
defined
 
IN_LIBINTL
)) && 
HAVE_WCHAR_T


2406 else if (
dp
->
conversion
 == 's'

2407 #if 
WIDE_CHAR_VERSION


2408 && 
a
.
arg
[
dp
->
arg_index
].
type
 != 
TYPE_WIDE_STRING


2410 && 
a
.
arg
[
dp
->
arg_index
].
type
 == 
TYPE_WIDE_STRING


2424 int 
flags
 = 
dp
->flags;

2425 int 
has_width
;

2426 
size_t
 
width
;

2427 int 
has_precision
;

2428 
size_t
 
precision
;

2430 
has_width
 = 0;

2431 
width
 = 0;

2432 if (
dp
->
width_start
 != dp->
width_end
)

2434 if (
dp
->
width_arg_index
 != 
ARG_NONE
)

2436 int 
arg
;

2438 if (!(
a
.
arg
[
dp
->
width_arg_index
].
type
 == 
TYPE_INT
))

2439 
	`abort
 ();

2440 
arg
 = 
a
.arg[
dp
->
width_arg_index
].a.
a_int
;

2441 if (
arg
 < 0)

2445 
flags
 |= 
FLAG_LEFT
;

2446 
width
 = (unsigned int) (-
arg
);

2449 
width
 = 
arg
;

2453 const 
FCHAR_T
 *
digitp
 = 
dp
->
width_start
;

2456 
width
 = 
	`xsum
 (
	`xtimes
 (width, 10), *
digitp
++ - '0');

2457 while (
digitp
 != 
dp
->
width_end
);

2459 
has_width
 = 1;

2462 
has_precision
 = 0;

2463 
precision
 = 6;

2464 if (
dp
->
precision_start
 != dp->
precision_end
)

2466 if (
dp
->
precision_arg_index
 != 
ARG_NONE
)

2468 int 
arg
;

2470 if (!(
a
.
arg
[
dp
->
precision_arg_index
].
type
 == 
TYPE_INT
))

2471 
	`abort
 ();

2472 
arg
 = 
a
.arg[
dp
->
precision_arg_index
].a.
a_int
;

2475 if (
arg
 >= 0)

2477 
precision
 = 
arg
;

2478 
has_precision
 = 1;

2483 const 
FCHAR_T
 *
digitp
 = 
dp
->
precision_start
 + 1;

2485 
precision
 = 0;

2486 while (
digitp
 != 
dp
->
precision_end
)

2487 
precision
 = 
	`xsum
 (
	`xtimes
 (precision, 10), *
digitp
++ - '0');

2488 
has_precision
 = 1;

2492 #if 
WIDE_CHAR_VERSION


2495 const char *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_string
;

2496 const char *
arg_end
;

2497 
size_t
 
characters
;

2499 if (
has_precision
)

2503 #if 
HAVE_MBRTOWC


2504 
mbstate_t
 
state
;

2505 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2507 
arg_end
 = 
arg
;

2508 
characters
 = 0;

2509 for (; 
precision
 > 0; precision--)

2511 int 
count
;

2512 #if 
HAVE_MBRTOWC


2513 
count
 = 
	`mbrlen
 (
arg_end
, 
MB_CUR_MAX
, &
state
);

2515 
count
 = 
	`mblen
 (
arg_end
, 
MB_CUR_MAX
);

2517 if (
count
 == 0)

2520 if (
count
 < 0)

2523 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2524 
	`free
 (
result
);

2525 if (
buf_malloced
 != 
NULL
)

2526 
	`free
 (
buf_malloced
);

2527 
	`CLEANUP
 ();

2528 
errno
 = 
EILSEQ
;

2529 return 
NULL
;

2531 
arg_end
 += 
count
;

2532 
characters
++;

2535 else if (
has_width
)

2539 #if 
HAVE_MBRTOWC


2540 
mbstate_t
 
state
;

2541 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2543 
arg_end
 = 
arg
;

2544 
characters
 = 0;

2547 int 
count
;

2548 #if 
HAVE_MBRTOWC


2549 
count
 = 
	`mbrlen
 (
arg_end
, 
MB_CUR_MAX
, &
state
);

2551 
count
 = 
	`mblen
 (
arg_end
, 
MB_CUR_MAX
);

2553 if (
count
 == 0)

2556 if (
count
 < 0)

2559 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2560 
	`free
 (
result
);

2561 if (
buf_malloced
 != 
NULL
)

2562 
	`free
 (
buf_malloced
);

2563 
	`CLEANUP
 ();

2564 
errno
 = 
EILSEQ
;

2565 return 
NULL
;

2567 
arg_end
 += 
count
;

2568 
characters
++;

2574 
arg_end
 = 
arg
 + 
	`strlen
 (arg);

2576 
characters
 = 0;

2579 if (
has_width
 && 
width
 > 
characters


2580 && !(
dp
->
flags
 & 
FLAG_LEFT
))

2582 
size_t
 
n
 = 
width
 - 
characters
;

2583 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2584 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2585 
length
 += 
n
;

2588 if (
has_precision
 || 
has_width
)

2591 
size_t
 
remaining
;

2592 #if 
HAVE_MBRTOWC


2593 
mbstate_t
 
state
;

2594 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2596 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
characters
));

2597 for (
remaining
 = 
characters
; remaining > 0; remaining--)

2599 
wchar_t
 
wc
;

2600 int 
count
;

2601 #if 
HAVE_MBRTOWC


2602 
count
 = 
	`mbrtowc
 (&
wc
, 
arg
, 
arg_end
 - arg, &
state
);

2604 
count
 = 
	`mbtowc
 (&
wc
, 
arg
, 
arg_end
 - arg);

2606 if (
count
 <= 0)

2609 
	`abort
 ();

2610 
result
[
length
++] = 
wc
;

2611 
arg
 += 
count
;

2613 if (!(
arg
 == 
arg_end
))

2614 
	`abort
 ();

2618 #if 
HAVE_MBRTOWC


2619 
mbstate_t
 
state
;

2620 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2622 while (
arg
 < 
arg_end
)

2624 
wchar_t
 
wc
;

2625 int 
count
;

2626 #if 
HAVE_MBRTOWC


2627 
count
 = 
	`mbrtowc
 (&
wc
, 
arg
, 
arg_end
 - arg, &
state
);

2629 
count
 = 
	`mbtowc
 (&
wc
, 
arg
, 
arg_end
 - arg);

2631 if (
count
 <= 0)

2634 
	`abort
 ();

2635 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 1));

2636 
result
[
length
++] = 
wc
;

2637 
arg
 += 
count
;

2641 if (
has_width
 && 
width
 > 
characters


2642 && (
dp
->
flags
 & 
FLAG_LEFT
))

2644 
size_t
 
n
 = 
width
 - 
characters
;

2645 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2646 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2647 
length
 += 
n
;

2653 const 
wchar_t
 *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_wide_string
;

2654 const 
wchar_t
 *
arg_end
;

2655 
size_t
 
characters
;

2656 #if !
DCHAR_IS_TCHAR


2658 
	`verify
 (sizeof (
TCHAR_T
) == 1);

2659 
TCHAR_T
 *
tmpsrc
;

2660 
DCHAR_T
 *
tmpdst
;

2661 
size_t
 
tmpdst_len
;

2663 
size_t
 
w
;

2665 if (
has_precision
)

2669 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2670 
mbstate_t
 
state
;

2671 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2673 
arg_end
 = 
arg
;

2674 
characters
 = 0;

2675 while (
precision
 > 0)

2677 char 
cbuf
[64];

2678 int 
count
;

2680 if (*
arg_end
 == 0)

2683 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2684 
count
 = 
	`wcrtomb
 (
cbuf
, *
arg_end
, &
state
);

2686 
count
 = 
	`wctomb
 (
cbuf
, *
arg_end
);

2688 if (
count
 < 0)

2691 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2692 
	`free
 (
result
);

2693 if (
buf_malloced
 != 
NULL
)

2694 
	`free
 (
buf_malloced
);

2695 
	`CLEANUP
 ();

2696 
errno
 = 
EILSEQ
;

2697 return 
NULL
;

2699 if (
precision
 < 
count
)

2701 
arg_end
++;

2702 
characters
 += 
count
;

2703 
precision
 -= 
count
;

2706 #if 
DCHAR_IS_TCHAR


2707 else if (
has_width
)

2714 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2715 
mbstate_t
 
state
;

2716 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2718 
arg_end
 = 
arg
;

2719 
characters
 = 0;

2722 char 
cbuf
[64];

2723 int 
count
;

2725 if (*
arg_end
 == 0)

2728 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2729 
count
 = 
	`wcrtomb
 (
cbuf
, *
arg_end
, &
state
);

2731 
count
 = 
	`wctomb
 (
cbuf
, *
arg_end
);

2733 if (
count
 < 0)

2736 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2737 
	`free
 (
result
);

2738 if (
buf_malloced
 != 
NULL
)

2739 
	`free
 (
buf_malloced
);

2740 
	`CLEANUP
 ();

2741 
errno
 = 
EILSEQ
;

2742 return 
NULL
;

2744 
arg_end
++;

2745 
characters
 += 
count
;

2748 #if 
DCHAR_IS_TCHAR


2752 
arg_end
 = 
arg
 + 
	`local_wcslen
 (arg);

2754 
characters
 = 0;

2758 #if !
DCHAR_IS_TCHAR


2760 
tmpsrc
 = (
TCHAR_T
 *) 
	`malloc
 (
characters
 * sizeof (TCHAR_T));

2761 if (
tmpsrc
 == 
NULL
)

2762 goto 
out_of_memory
;

2764 
TCHAR_T
 *
tmpptr
 = 
tmpsrc
;

2765 
size_t
 
remaining
;

2766 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2767 
mbstate_t
 
state
;

2768 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2770 for (
remaining
 = 
characters
; remaining > 0; )

2772 char 
cbuf
[64];

2773 int 
count
;

2775 if (*
arg
 == 0)

2776 
	`abort
 ();

2777 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2778 
count
 = 
	`wcrtomb
 (
cbuf
, *
arg
, &
state
);

2780 
count
 = 
	`wctomb
 (
cbuf
, *
arg
);

2782 if (
count
 <= 0)

2784 
	`abort
 ();

2785 
	`memcpy
 (
tmpptr
, 
cbuf
, 
count
);

2786 
tmpptr
 += 
count
;

2787 
arg
++;

2788 
remaining
 -= 
count
;

2790 if (!(
arg
 == 
arg_end
))

2791 
	`abort
 ();

2795 
tmpdst
 =

2796 
	`DCHAR_CONV_FROM_ENCODING
 (
	`locale_charset
 (),

2797 
iconveh_question_mark
,

2798 
tmpsrc
, 
characters
,

2799 
NULL
,

2800 
NULL
, &
tmpdst_len
);

2801 if (
tmpdst
 == 
NULL
)

2803 int 
saved_errno
 = 
errno
;

2804 
	`free
 (
tmpsrc
);

2805 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2806 
	`free
 (
result
);

2807 if (
buf_malloced
 != 
NULL
)

2808 
	`free
 (
buf_malloced
);

2809 
	`CLEANUP
 ();

2810 
errno
 = 
saved_errno
;

2811 return 
NULL
;

2813 
	`free
 (
tmpsrc
);

2816 if (
has_width
)

2818 #if 
ENABLE_UNISTDIO


2822 
w
 = 
	`DCHAR_MBSNLEN
 (
result
 + 
length
, 
characters
);

2826 
w
 = 
characters
;

2831 
w
 = 0;

2833 if (
has_width
 && 
width
 > 
w


2834 && !(
dp
->
flags
 & 
FLAG_LEFT
))

2836 
size_t
 
n
 = 
width
 - 
w
;

2837 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2838 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2839 
length
 += 
n
;

2842 #if 
DCHAR_IS_TCHAR


2843 if (
has_precision
 || 
has_width
)

2846 
size_t
 
remaining
;

2847 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2848 
mbstate_t
 
state
;

2849 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2851 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
characters
));

2852 for (
remaining
 = 
characters
; remaining > 0; )

2854 char 
cbuf
[64];

2855 int 
count
;

2857 if (*
arg
 == 0)

2858 
	`abort
 ();

2859 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2860 
count
 = 
	`wcrtomb
 (
cbuf
, *
arg
, &
state
);

2862 
count
 = 
	`wctomb
 (
cbuf
, *
arg
);

2864 if (
count
 <= 0)

2866 
	`abort
 ();

2867 
	`memcpy
 (
result
 + 
length
, 
cbuf
, 
count
);

2868 
length
 += 
count
;

2869 
arg
++;

2870 
remaining
 -= 
count
;

2872 if (!(
arg
 == 
arg_end
))

2873 
	`abort
 ();

2877 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2878 
mbstate_t
 
state
;

2879 
	`memset
 (&
state
, '\0', sizeof (
mbstate_t
));

2881 while (
arg
 < 
arg_end
)

2883 char 
cbuf
[64];

2884 int 
count
;

2886 if (*
arg
 == 0)

2887 
	`abort
 ();

2888 #if 
HAVE_WCRTOMB
 && !
defined
 
GNULIB_defined_mbstate_t


2889 
count
 = 
	`wcrtomb
 (
cbuf
, *
arg
, &
state
);

2891 
count
 = 
	`wctomb
 (
cbuf
, *
arg
);

2893 if (
count
 <= 0)

2896 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

2897 
	`free
 (
result
);

2898 if (
buf_malloced
 != 
NULL
)

2899 
	`free
 (
buf_malloced
);

2900 
	`CLEANUP
 ();

2901 
errno
 = 
EILSEQ
;

2902 return 
NULL
;

2904 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
count
));

2905 
	`memcpy
 (
result
 + 
length
, 
cbuf
, 
count
);

2906 
length
 += 
count
;

2907 
arg
++;

2911 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
tmpdst_len
));

2912 
	`DCHAR_CPY
 (
result
 + 
length
, 
tmpdst
, 
tmpdst_len
);

2913 
	`free
 (
tmpdst
);

2914 
length
 += 
tmpdst_len
;

2917 if (
has_width
 && 
width
 > 
w


2918 && (
dp
->
flags
 & 
FLAG_LEFT
))

2920 
size_t
 
n
 = 
width
 - 
w
;

2921 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
n
));

2922 
	`DCHAR_SET
 (
result
 + 
length
, ' ', 
n
);

2923 
length
 += 
n
;

2929 #if (
NEED_PRINTF_DIRECTIVE_A
 || 
NEED_PRINTF_LONG_DOUBLE
 || 
NEED_PRINTF_DOUBLE
) && !
defined
 
IN_LIBINTL


2930 else if ((
dp
->
conversion
 == 'a' || dp->conversion == 'A')

2931 #if !(
NEED_PRINTF_DIRECTIVE_A
 || (
NEED_PRINTF_LONG_DOUBLE
 && 
NEED_PRINTF_DOUBLE
))

2933 #if 
NEED_PRINTF_DOUBLE


2934 || 
a
.
arg
[
dp
->
arg_index
].
type
 == 
TYPE_DOUBLE


2936 #if 
NEED_PRINTF_LONG_DOUBLE


2937 || 
a
.
arg
[
dp
->
arg_index
].
type
 == 
TYPE_LONGDOUBLE


2943 
arg_type
 
type
 = 
a
.
arg
[
dp
->
arg_index
].type;

2944 int 
flags
 = 
dp
->flags;

2945 int 
has_width
;

2946 
size_t
 
width
;

2947 int 
has_precision
;

2948 
size_t
 
precision
;

2949 
size_t
 
tmp_length
;

2950 
DCHAR_T
 
tmpbuf
[700];

2951 
DCHAR_T
 *
tmp
;

2952 
DCHAR_T
 *
pad_ptr
;

2953 
DCHAR_T
 *
p
;

2955 
has_width
 = 0;

2956 
width
 = 0;

2957 if (
dp
->
width_start
 != dp->
width_end
)

2959 if (
dp
->
width_arg_index
 != 
ARG_NONE
)

2961 int 
arg
;

2963 if (!(
a
.
arg
[
dp
->
width_arg_index
].
type
 == 
TYPE_INT
))

2964 
	`abort
 ();

2965 
arg
 = 
a
.arg[
dp
->
width_arg_index
].a.
a_int
;

2966 if (
arg
 < 0)

2970 
flags
 |= 
FLAG_LEFT
;

2971 
width
 = (unsigned int) (-
arg
);

2974 
width
 = 
arg
;

2978 const 
FCHAR_T
 *
digitp
 = 
dp
->
width_start
;

2981 
width
 = 
	`xsum
 (
	`xtimes
 (width, 10), *
digitp
++ - '0');

2982 while (
digitp
 != 
dp
->
width_end
);

2984 
has_width
 = 1;

2987 
has_precision
 = 0;

2988 
precision
 = 0;

2989 if (
dp
->
precision_start
 != dp->
precision_end
)

2991 if (
dp
->
precision_arg_index
 != 
ARG_NONE
)

2993 int 
arg
;

2995 if (!(
a
.
arg
[
dp
->
precision_arg_index
].
type
 == 
TYPE_INT
))

2996 
	`abort
 ();

2997 
arg
 = 
a
.arg[
dp
->
precision_arg_index
].a.
a_int
;

3000 if (
arg
 >= 0)

3002 
precision
 = 
arg
;

3003 
has_precision
 = 1;

3008 const 
FCHAR_T
 *
digitp
 = 
dp
->
precision_start
 + 1;

3010 
precision
 = 0;

3011 while (
digitp
 != 
dp
->
precision_end
)

3012 
precision
 = 
	`xsum
 (
	`xtimes
 (precision, 10), *
digitp
++ - '0');

3013 
has_precision
 = 1;

3018 if (
type
 == 
TYPE_LONGDOUBLE
)

3019 
tmp_length
 =

3020 (unsigned int) ((
LDBL_DIG
 + 1)

3025 
tmp_length
 =

3026 (unsigned int) ((
DBL_DIG
 + 1)

3030 if (
tmp_length
 < 
precision
)

3031 
tmp_length
 = 
precision
;

3033 
tmp_length
 = 
	`xsum
 (tmp_length, 12);

3035 if (
tmp_length
 < 
width
)

3036 
tmp_length
 = 
width
;

3038 
tmp_length
 = 
	`xsum
 (tmp_length, 1);

3040 if (
tmp_length
 <= sizeof (
tmpbuf
) / sizeof (
DCHAR_T
))

3041 
tmp
 = 
tmpbuf
;

3044 
size_t
 
tmp_memsize
 = 
	`xtimes
 (
tmp_length
, sizeof (
DCHAR_T
));

3046 if (
	`size_overflow_p
 (
tmp_memsize
))

3048 goto 
out_of_memory
;

3049 
tmp
 = (
DCHAR_T
 *) 
	`malloc
 (
tmp_memsize
);

3050 if (
tmp
 == 
NULL
)

3052 goto 
out_of_memory
;

3055 
pad_ptr
 = 
NULL
;

3056 
p
 = 
tmp
;

3057 if (
type
 == 
TYPE_LONGDOUBLE
)

3059 #if 
NEED_PRINTF_DIRECTIVE_A
 || 
NEED_PRINTF_LONG_DOUBLE


3060 long double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_longdouble
;

3062 if (
	`isnanl
 (
arg
))

3064 if (
dp
->
conversion
 == 'A')

3066 *
p
++ = 'N'; *p++ = 'A'; *p++ = 'N';

3070 *
p
++ = 'n'; *p++ = 'a'; *p++ = 'n';

3075 int 
sign
 = 0;

3076 
DECL_LONG_DOUBLE_ROUNDING


3078 
	`BEGIN_LONG_DOUBLE_ROUNDING
 ();

3080 if (
	`signbit
 (
arg
))

3082 
sign
 = -1;

3083 
arg
 = -arg;

3086 if (
sign
 < 0)

3087 *
p
++ = '-';

3088 else if (
flags
 & 
FLAG_SHOWSIGN
)

3089 *
p
++ = '+';

3090 else if (
flags
 & 
FLAG_SPACE
)

3091 *
p
++ = ' ';

3093 if (
arg
 > 0.0L && arg + arg == arg)

3095 if (
dp
->
conversion
 == 'A')

3097 *
p
++ = 'I'; *p++ = 'N'; *p++ = 'F';

3101 *
p
++ = 'i'; *p++ = 'n'; *p++ = 'f';

3106 int 
exponent
;

3107 long double 
mantissa
;

3109 if (
arg
 > 0.0L)

3110 
mantissa
 = 
	`printf_frexpl
 (
arg
, &
exponent
);

3113 
exponent
 = 0;

3114 
mantissa
 = 0.0L;

3117 if (
has_precision


3118 && 
precision
 < (unsigned int) ((
LDBL_DIG
 + 1) * 0.831) + 1)

3121 long double 
tail
 = 
mantissa
;

3122 
size_t
 
q
;

3124 for (
q
 = 
precision
; ; q--)

3126 int 
digit
 = (int) 
tail
;

3127 
tail
 -= 
digit
;

3128 if (
q
 == 0)

3130 if (
digit
 & 1 ? 
tail
 >= 0.5L : tail > 0.5L)

3131 
tail
 = 1 - tail;

3133 
tail
 = - tail;

3136 
tail
 *= 16.0L;

3138 if (
tail
 != 0.0L)

3139 for (
q
 = 
precision
; q > 0; q--)

3140 
tail
 *= 0.0625L;

3141 
mantissa
 += 
tail
;

3144 *
p
++ = '0';

3145 *
p
++ = 
dp
->
conversion
 - 'A' + 'X';

3146 
pad_ptr
 = 
p
;

3148 int 
digit
;

3150 
digit
 = (int) 
mantissa
;

3151 
mantissa
 -= 
digit
;

3152 *
p
++ = '0' + 
digit
;

3153 if ((
flags
 & 
FLAG_ALT
)

3154 || 
mantissa
 > 0.0L || 
precision
 > 0)

3156 *
p
++ = 
	`decimal_point_char
 ();

3159 while (
mantissa
 > 0.0L)

3161 
mantissa
 *= 16.0L;

3162 
digit
 = (int) 
mantissa
;

3163 
mantissa
 -= 
digit
;

3164 *
p
++ = 
digit


3165 + (
digit
 < 10

3167 : 
dp
->
conversion
 - 10);

3168 if (
precision
 > 0)

3169 
precision
--;

3171 while (
precision
 > 0)

3173 *
p
++ = '0';

3174 
precision
--;

3178 *
p
++ = 
dp
->
conversion
 - 'A' + 'P';

3179 #if 
WIDE_CHAR_VERSION


3181 static const 
wchar_t
 
decimal_format
[] =

3183 
	`SNPRINTF
 (
p
, 6 + 1, 
decimal_format
, 
exponent
);

3185 while (*
p
 != '\0')

3186 
p
++;

3188 if (sizeof (
DCHAR_T
) == 1)

3190 
	`sprintf
 ((char *) 
p
, "%+d", 
exponent
);

3191 while (*
p
 != '\0')

3192 
p
++;

3196 char 
expbuf
[6 + 1];

3197 const char *
ep
;

3198 
	`sprintf
 (
expbuf
, "%+d", 
exponent
);

3199 for (
ep
 = 
expbuf
; (*
p
 = *ep) != '\0'; ep++)

3200 
p
++;

3205 
	`END_LONG_DOUBLE_ROUNDING
 ();

3208 
	`abort
 ();

3213 #if 
NEED_PRINTF_DIRECTIVE_A
 || 
NEED_PRINTF_DOUBLE


3214 double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_double
;

3216 if (
	`isnand
 (
arg
))

3218 if (
dp
->
conversion
 == 'A')

3220 *
p
++ = 'N'; *p++ = 'A'; *p++ = 'N';

3224 *
p
++ = 'n'; *p++ = 'a'; *p++ = 'n';

3229 int 
sign
 = 0;

3231 if (
	`signbit
 (
arg
))

3233 
sign
 = -1;

3234 
arg
 = -arg;

3237 if (
sign
 < 0)

3238 *
p
++ = '-';

3239 else if (
flags
 & 
FLAG_SHOWSIGN
)

3240 *
p
++ = '+';

3241 else if (
flags
 & 
FLAG_SPACE
)

3242 *
p
++ = ' ';

3244 if (
arg
 > 0.0 && arg + arg == arg)

3246 if (
dp
->
conversion
 == 'A')

3248 *
p
++ = 'I'; *p++ = 'N'; *p++ = 'F';

3252 *
p
++ = 'i'; *p++ = 'n'; *p++ = 'f';

3257 int 
exponent
;

3258 double 
mantissa
;

3260 if (
arg
 > 0.0)

3261 
mantissa
 = 
	`printf_frexp
 (
arg
, &
exponent
);

3264 
exponent
 = 0;

3265 
mantissa
 = 0.0;

3268 if (
has_precision


3269 && 
precision
 < (unsigned int) ((
DBL_DIG
 + 1) * 0.831) + 1)

3272 double 
tail
 = 
mantissa
;

3273 
size_t
 
q
;

3275 for (
q
 = 
precision
; ; q--)

3277 int 
digit
 = (int) 
tail
;

3278 
tail
 -= 
digit
;

3279 if (
q
 == 0)

3281 if (
digit
 & 1 ? 
tail
 >= 0.5 : tail > 0.5)

3282 
tail
 = 1 - tail;

3284 
tail
 = - tail;

3287 
tail
 *= 16.0;

3289 if (
tail
 != 0.0)

3290 for (
q
 = 
precision
; q > 0; q--)

3291 
tail
 *= 0.0625;

3292 
mantissa
 += 
tail
;

3295 *
p
++ = '0';

3296 *
p
++ = 
dp
->
conversion
 - 'A' + 'X';

3297 
pad_ptr
 = 
p
;

3299 int 
digit
;

3301 
digit
 = (int) 
mantissa
;

3302 
mantissa
 -= 
digit
;

3303 *
p
++ = '0' + 
digit
;

3304 if ((
flags
 & 
FLAG_ALT
)

3305 || 
mantissa
 > 0.0 || 
precision
 > 0)

3307 *
p
++ = 
	`decimal_point_char
 ();

3310 while (
mantissa
 > 0.0)

3312 
mantissa
 *= 16.0;

3313 
digit
 = (int) 
mantissa
;

3314 
mantissa
 -= 
digit
;

3315 *
p
++ = 
digit


3316 + (
digit
 < 10

3318 : 
dp
->
conversion
 - 10);

3319 if (
precision
 > 0)

3320 
precision
--;

3322 while (
precision
 > 0)

3324 *
p
++ = '0';

3325 
precision
--;

3329 *
p
++ = 
dp
->
conversion
 - 'A' + 'P';

3330 #if 
WIDE_CHAR_VERSION


3332 static const 
wchar_t
 
decimal_format
[] =

3334 
	`SNPRINTF
 (
p
, 6 + 1, 
decimal_format
, 
exponent
);

3336 while (*
p
 != '\0')

3337 
p
++;

3339 if (sizeof (
DCHAR_T
) == 1)

3341 
	`sprintf
 ((char *) 
p
, "%+d", 
exponent
);

3342 while (*
p
 != '\0')

3343 
p
++;

3347 char 
expbuf
[6 + 1];

3348 const char *
ep
;

3349 
	`sprintf
 (
expbuf
, "%+d", 
exponent
);

3350 for (
ep
 = 
expbuf
; (*
p
 = *ep) != '\0'; ep++)

3351 
p
++;

3357 
	`abort
 ();

3362 if (
has_width
 && 
p
 - 
tmp
 < 
width
)

3364 
size_t
 
pad
 = 
width
 - (
p
 - 
tmp
);

3365 
DCHAR_T
 *
end
 = 
p
 + 
pad
;

3367 if (
flags
 & 
FLAG_LEFT
)

3370 for (; 
pad
 > 0; pad--)

3371 *
p
++ = ' ';

3373 else if ((
flags
 & 
FLAG_ZERO
) && 
pad_ptr
 != 
NULL
)

3376 
DCHAR_T
 *
q
 = 
end
;

3378 while (
p
 > 
pad_ptr
)

3379 *--
q
 = *--
p
;

3380 for (; 
pad
 > 0; pad--)

3381 *
p
++ = '0';

3386 
DCHAR_T
 *
q
 = 
end
;

3388 while (
p
 > 
tmp
)

3389 *--
q
 = *--
p
;

3390 for (; 
pad
 > 0; pad--)

3391 *
p
++ = ' ';

3394 
p
 = 
end
;

3398 
size_t
 
count
 = 
p
 - 
tmp
;

3400 if (
count
 >= 
tmp_length
)

3403 
	`abort
 ();

3406 if (
count
 >= 
allocated
 - 
length
)

3408 
size_t
 
n
 = 
	`xsum
 (
length
, 
count
);

3410 
	`ENSURE_ALLOCATION
 (
n
);

3414 
	`memcpy
 (
result
 + 
length
, 
tmp
, 
count
 * sizeof (
DCHAR_T
));

3415 if (
tmp
 != 
tmpbuf
)

3416 
	`free
 (
tmp
);

3417 
length
 += 
count
;

3421 #if (
NEED_PRINTF_INFINITE_DOUBLE
 || 
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_LONG_DOUBLE
 || 
NEED_PRINTF_LONG_DOUBLE
) && !
defined
 
IN_LIBINTL


3422 else if ((
dp
->
conversion
 == 'f' || dp->conversion == 'F'

3423 || 
dp
->
conversion
 == 'e' || dp->conversion == 'E'

3424 || 
dp
->
conversion
 == 'g' || dp->conversion == 'G'

3425 || 
dp
->
conversion
 == 'a' || dp->conversion == 'A')

3427 #if 
NEED_PRINTF_DOUBLE


3428 || 
a
.
arg
[
dp
->
arg_index
].
type
 == 
TYPE_DOUBLE


3429 #elif 
NEED_PRINTF_INFINITE_DOUBLE


3430 || (
a
.
arg
[
dp
->
arg_index
].
type
 == 
TYPE_DOUBLE


3434 && 
	`is_infinite_or_zero
 (
a
.
arg
[
dp
->
arg_index
].a.
a_double
))

3436 #if 
NEED_PRINTF_LONG_DOUBLE


3437 || 
a
.
arg
[
dp
->
arg_index
].
type
 == 
TYPE_LONGDOUBLE


3438 #elif 
NEED_PRINTF_INFINITE_LONG_DOUBLE


3439 || (
a
.
arg
[
dp
->
arg_index
].
type
 == 
TYPE_LONGDOUBLE


3444 && 
	`is_infinite_or_zerol
 (
a
.
arg
[
dp
->
arg_index
].a.
a_longdouble
))

3448 #if (
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_DOUBLE
) && (
NEED_PRINTF_LONG_DOUBLE
 || 
NEED_PRINTF_INFINITE_LONG_DOUBLE
)

3449 
arg_type
 
type
 = 
a
.
arg
[
dp
->
arg_index
].type;

3451 int 
flags
 = 
dp
->flags;

3452 int 
has_width
;

3453 
size_t
 
width
;

3454 int 
has_precision
;

3455 
size_t
 
precision
;

3456 
size_t
 
tmp_length
;

3457 
DCHAR_T
 
tmpbuf
[700];

3458 
DCHAR_T
 *
tmp
;

3459 
DCHAR_T
 *
pad_ptr
;

3460 
DCHAR_T
 *
p
;

3462 
has_width
 = 0;

3463 
width
 = 0;

3464 if (
dp
->
width_start
 != dp->
width_end
)

3466 if (
dp
->
width_arg_index
 != 
ARG_NONE
)

3468 int 
arg
;

3470 if (!(
a
.
arg
[
dp
->
width_arg_index
].
type
 == 
TYPE_INT
))

3471 
	`abort
 ();

3472 
arg
 = 
a
.arg[
dp
->
width_arg_index
].a.
a_int
;

3473 if (
arg
 < 0)

3477 
flags
 |= 
FLAG_LEFT
;

3478 
width
 = (unsigned int) (-
arg
);

3481 
width
 = 
arg
;

3485 const 
FCHAR_T
 *
digitp
 = 
dp
->
width_start
;

3488 
width
 = 
	`xsum
 (
	`xtimes
 (width, 10), *
digitp
++ - '0');

3489 while (
digitp
 != 
dp
->
width_end
);

3491 
has_width
 = 1;

3494 
has_precision
 = 0;

3495 
precision
 = 0;

3496 if (
dp
->
precision_start
 != dp->
precision_end
)

3498 if (
dp
->
precision_arg_index
 != 
ARG_NONE
)

3500 int 
arg
;

3502 if (!(
a
.
arg
[
dp
->
precision_arg_index
].
type
 == 
TYPE_INT
))

3503 
	`abort
 ();

3504 
arg
 = 
a
.arg[
dp
->
precision_arg_index
].a.
a_int
;

3507 if (
arg
 >= 0)

3509 
precision
 = 
arg
;

3510 
has_precision
 = 1;

3515 const 
FCHAR_T
 *
digitp
 = 
dp
->
precision_start
 + 1;

3517 
precision
 = 0;

3518 while (
digitp
 != 
dp
->
precision_end
)

3519 
precision
 = 
	`xsum
 (
	`xtimes
 (precision, 10), *
digitp
++ - '0');

3520 
has_precision
 = 1;

3528 if (!
has_precision
)

3529 if (!(
dp
->
conversion
 == 'a' || dp->conversion == 'A'))

3530 
precision
 = 6;

3533 #if 
NEED_PRINTF_DOUBLE
 && 
NEED_PRINTF_LONG_DOUBLE


3534 
tmp_length
 = (
type
 == 
TYPE_LONGDOUBLE
 ? 
LDBL_DIG
 + 1 : 
DBL_DIG
 + 1);

3535 #elif 
NEED_PRINTF_INFINITE_DOUBLE
 && 
NEED_PRINTF_LONG_DOUBLE


3536 
tmp_length
 = (
type
 == 
TYPE_LONGDOUBLE
 ? 
LDBL_DIG
 + 1 : 0);

3537 #elif 
NEED_PRINTF_LONG_DOUBLE


3538 
tmp_length
 = 
LDBL_DIG
 + 1;

3539 #elif 
NEED_PRINTF_DOUBLE


3540 
tmp_length
 = 
DBL_DIG
 + 1;

3542 
tmp_length
 = 0;

3544 if (
tmp_length
 < 
precision
)

3545 
tmp_length
 = 
precision
;

3546 #if 
NEED_PRINTF_LONG_DOUBLE


3547 #if 
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_DOUBLE


3548 if (
type
 == 
TYPE_LONGDOUBLE
)

3550 if (
dp
->
conversion
 == 'f' || dp->conversion == 'F')

3552 long double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_longdouble
;

3553 if (!(
	`isnanl
 (
arg
) || arg + arg == arg))

3556 int 
exponent
 = 
	`floorlog10l
 (
arg
 < 0 ? -arg : arg);

3557 if (
exponent
 >= 0 && 
tmp_length
 < exponent + 
precision
)

3558 
tmp_length
 = 
exponent
 + 
precision
;

3562 #if 
NEED_PRINTF_DOUBLE


3563 #if 
NEED_PRINTF_LONG_DOUBLE
 || 
NEED_PRINTF_INFINITE_LONG_DOUBLE


3564 if (
type
 == 
TYPE_DOUBLE
)

3566 if (
dp
->
conversion
 == 'f' || dp->conversion == 'F')

3568 double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_double
;

3569 if (!(
	`isnand
 (
arg
) || arg + arg == arg))

3572 int 
exponent
 = 
	`floorlog10
 (
arg
 < 0 ? -arg : arg);

3573 if (
exponent
 >= 0 && 
tmp_length
 < exponent + 
precision
)

3574 
tmp_length
 = 
exponent
 + 
precision
;

3579 
tmp_length
 = 
	`xsum
 (tmp_length, 12);

3581 if (
tmp_length
 < 
width
)

3582 
tmp_length
 = 
width
;

3584 
tmp_length
 = 
	`xsum
 (tmp_length, 1);

3586 if (
tmp_length
 <= sizeof (
tmpbuf
) / sizeof (
DCHAR_T
))

3587 
tmp
 = 
tmpbuf
;

3590 
size_t
 
tmp_memsize
 = 
	`xtimes
 (
tmp_length
, sizeof (
DCHAR_T
));

3592 if (
	`size_overflow_p
 (
tmp_memsize
))

3594 goto 
out_of_memory
;

3595 
tmp
 = (
DCHAR_T
 *) 
	`malloc
 (
tmp_memsize
);

3596 if (
tmp
 == 
NULL
)

3598 goto 
out_of_memory
;

3601 
pad_ptr
 = 
NULL
;

3602 
p
 = 
tmp
;

3604 #if 
NEED_PRINTF_LONG_DOUBLE
 || 
NEED_PRINTF_INFINITE_LONG_DOUBLE


3605 #if 
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_DOUBLE


3606 if (
type
 == 
TYPE_LONGDOUBLE
)

3609 long double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_longdouble
;

3611 if (
	`isnanl
 (
arg
))

3613 if (
dp
->
conversion
 >= 'A' && dp->conversion <= 'Z')

3615 *
p
++ = 'N'; *p++ = 'A'; *p++ = 'N';

3619 *
p
++ = 'n'; *p++ = 'a'; *p++ = 'n';

3624 int 
sign
 = 0;

3625 
DECL_LONG_DOUBLE_ROUNDING


3627 
	`BEGIN_LONG_DOUBLE_ROUNDING
 ();

3629 if (
	`signbit
 (
arg
))

3631 
sign
 = -1;

3632 
arg
 = -arg;

3635 if (
sign
 < 0)

3636 *
p
++ = '-';

3637 else if (
flags
 & 
FLAG_SHOWSIGN
)

3638 *
p
++ = '+';

3639 else if (
flags
 & 
FLAG_SPACE
)

3640 *
p
++ = ' ';

3642 if (
arg
 > 0.0L && arg + arg == arg)

3644 if (
dp
->
conversion
 >= 'A' && dp->conversion <= 'Z')

3646 *
p
++ = 'I'; *p++ = 'N'; *p++ = 'F';

3650 *
p
++ = 'i'; *p++ = 'n'; *p++ = 'f';

3655 #if 
NEED_PRINTF_LONG_DOUBLE


3656 
pad_ptr
 = 
p
;

3658 if (
dp
->
conversion
 == 'f' || dp->conversion == 'F')

3660 char *
digits
;

3661 
size_t
 
ndigits
;

3663 
digits
 =

3664 
	`scale10_round_decimal_long_double
 (
arg
, 
precision
);

3665 if (
digits
 == 
NULL
)

3667 
	`END_LONG_DOUBLE_ROUNDING
 ();

3668 goto 
out_of_memory
;

3670 
ndigits
 = 
	`strlen
 (
digits
);

3672 if (
ndigits
 > 
precision
)

3675 --
ndigits
;

3676 *
p
++ = 
digits
[
ndigits
];

3678 while (
ndigits
 > 
precision
);

3680 *
p
++ = '0';

3682 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

3684 *
p
++ = 
	`decimal_point_char
 ();

3685 for (; 
precision
 > 
ndigits
; precision--)

3686 *
p
++ = '0';

3687 while (
ndigits
 > 0)

3689 --
ndigits
;

3690 *
p
++ = 
digits
[
ndigits
];

3694 
	`free
 (
digits
);

3696 else if (
dp
->
conversion
 == 'e' || dp->conversion == 'E')

3698 int 
exponent
;

3700 if (
arg
 == 0.0L)

3702 
exponent
 = 0;

3703 *
p
++ = '0';

3704 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

3706 *
p
++ = 
	`decimal_point_char
 ();

3707 for (; 
precision
 > 0; precision--)

3708 *
p
++ = '0';

3714 int 
adjusted
;

3715 char *
digits
;

3716 
size_t
 
ndigits
;

3718 
exponent
 = 
	`floorlog10l
 (
arg
);

3719 
adjusted
 = 0;

3722 
digits
 =

3723 
	`scale10_round_decimal_long_double
 (
arg
,

3724 (int)
precision
 - 
exponent
);

3725 if (
digits
 == 
NULL
)

3727 
	`END_LONG_DOUBLE_ROUNDING
 ();

3728 goto 
out_of_memory
;

3730 
ndigits
 = 
	`strlen
 (
digits
);

3732 if (
ndigits
 == 
precision
 + 1)

3734 if (
ndigits
 < 
precision


3735 || 
ndigits
 > 
precision
 + 2)

3738 
	`abort
 ();

3739 if (
adjusted
)

3743 
	`abort
 ();

3744 
	`free
 (
digits
);

3745 if (
ndigits
 == 
precision
)

3746 
exponent
 -= 1;

3748 
exponent
 += 1;

3749 
adjusted
 = 1;

3752 if (
	`is_borderline
 (
digits
, 
precision
))

3757 char *
digits2
 =

3758 
	`scale10_round_decimal_long_double
 (
arg
,

3759 (int)
precision
 - 
exponent
 + 1);

3760 if (
digits2
 == 
NULL
)

3762 
	`free
 (
digits
);

3763 
	`END_LONG_DOUBLE_ROUNDING
 ();

3764 goto 
out_of_memory
;

3766 if (
	`strlen
 (
digits2
) == 
precision
 + 1)

3768 
	`free
 (
digits
);

3769 
digits
 = 
digits2
;

3770 
exponent
 -= 1;

3773 
	`free
 (
digits2
);

3777 *
p
++ = 
digits
[--
ndigits
];

3778 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

3780 *
p
++ = 
	`decimal_point_char
 ();

3781 while (
ndigits
 > 0)

3783 --
ndigits
;

3784 *
p
++ = 
digits
[
ndigits
];

3788 
	`free
 (
digits
);

3791 *
p
++ = 
dp
->
conversion
;

3792 #if 
WIDE_CHAR_VERSION


3794 static const 
wchar_t
 
decimal_format
[] =

3796 
	`SNPRINTF
 (
p
, 6 + 1, 
decimal_format
, 
exponent
);

3798 while (*
p
 != '\0')

3799 
p
++;

3801 if (sizeof (
DCHAR_T
) == 1)

3803 
	`sprintf
 ((char *) 
p
, "%+.2d", 
exponent
);

3804 while (*
p
 != '\0')

3805 
p
++;

3809 char 
expbuf
[6 + 1];

3810 const char *
ep
;

3811 
	`sprintf
 (
expbuf
, "%+.2d", 
exponent
);

3812 for (
ep
 = 
expbuf
; (*
p
 = *ep) != '\0'; ep++)

3813 
p
++;

3817 else if (
dp
->
conversion
 == 'g' || dp->conversion == 'G')

3819 if (
precision
 == 0)

3820 
precision
 = 1;

3823 if (
arg
 == 0.0L)

3827 
size_t
 
ndigits
 = 
precision
;

3830 
size_t
 
nzeroes
 =

3831 (
flags
 & 
FLAG_ALT
 ? 0 : 
precision
 - 1);

3833 --
ndigits
;

3834 *
p
++ = '0';

3835 if ((
flags
 & 
FLAG_ALT
) || 
ndigits
 > 
nzeroes
)

3837 *
p
++ = 
	`decimal_point_char
 ();

3838 while (
ndigits
 > 
nzeroes
)

3840 --
ndigits
;

3841 *
p
++ = '0';

3848 int 
exponent
;

3849 int 
adjusted
;

3850 char *
digits
;

3851 
size_t
 
ndigits
;

3852 
size_t
 
nzeroes
;

3854 
exponent
 = 
	`floorlog10l
 (
arg
);

3855 
adjusted
 = 0;

3858 
digits
 =

3859 
	`scale10_round_decimal_long_double
 (
arg
,

3860 (int)(
precision
 - 1) - 
exponent
);

3861 if (
digits
 == 
NULL
)

3863 
	`END_LONG_DOUBLE_ROUNDING
 ();

3864 goto 
out_of_memory
;

3866 
ndigits
 = 
	`strlen
 (
digits
);

3868 if (
ndigits
 == 
precision
)

3870 if (
ndigits
 < 
precision
 - 1

3871 || 
ndigits
 > 
precision
 + 1)

3874 
	`abort
 ();

3875 if (
adjusted
)

3879 
	`abort
 ();

3880 
	`free
 (
digits
);

3881 if (
ndigits
 < 
precision
)

3882 
exponent
 -= 1;

3884 
exponent
 += 1;

3885 
adjusted
 = 1;

3888 if (
	`is_borderline
 (
digits
, 
precision
 - 1))

3893 char *
digits2
 =

3894 
	`scale10_round_decimal_long_double
 (
arg
,

3895 (int)(
precision
 - 1) - 
exponent
 + 1);

3896 if (
digits2
 == 
NULL
)

3898 
	`free
 (
digits
);

3899 
	`END_LONG_DOUBLE_ROUNDING
 ();

3900 goto 
out_of_memory
;

3902 if (
	`strlen
 (
digits2
) == 
precision
)

3904 
	`free
 (
digits
);

3905 
digits
 = 
digits2
;

3906 
exponent
 -= 1;

3909 
	`free
 (
digits2
);

3915 
nzeroes
 = 0;

3916 if ((
flags
 & 
FLAG_ALT
) == 0)

3917 while (
nzeroes
 < 
ndigits


3918 && 
digits
[
nzeroes
] == '0')

3919 
nzeroes
++;

3922 if (
exponent
 >= -4

3923 && 
exponent
 < (long)
precision
)

3929 if (
exponent
 >= 0)

3931 
size_t
 
count
 = 
exponent
 + 1;

3933 for (; 
count
 > 0; count--)

3934 *
p
++ = 
digits
[--
ndigits
];

3935 if ((
flags
 & 
FLAG_ALT
) || 
ndigits
 > 
nzeroes
)

3937 *
p
++ = 
	`decimal_point_char
 ();

3938 while (
ndigits
 > 
nzeroes
)

3940 --
ndigits
;

3941 *
p
++ = 
digits
[
ndigits
];

3947 
size_t
 
count
 = -
exponent
 - 1;

3948 *
p
++ = '0';

3949 *
p
++ = 
	`decimal_point_char
 ();

3950 for (; 
count
 > 0; count--)

3951 *
p
++ = '0';

3952 while (
ndigits
 > 
nzeroes
)

3954 --
ndigits
;

3955 *
p
++ = 
digits
[
ndigits
];

3962 *
p
++ = 
digits
[--
ndigits
];

3963 if ((
flags
 & 
FLAG_ALT
) || 
ndigits
 > 
nzeroes
)

3965 *
p
++ = 
	`decimal_point_char
 ();

3966 while (
ndigits
 > 
nzeroes
)

3968 --
ndigits
;

3969 *
p
++ = 
digits
[
ndigits
];

3972 *
p
++ = 
dp
->
conversion
 - 'G' + 'E';

3973 #if 
WIDE_CHAR_VERSION


3975 static const 
wchar_t
 
decimal_format
[] =

3977 
	`SNPRINTF
 (
p
, 6 + 1, 
decimal_format
, 
exponent
);

3979 while (*
p
 != '\0')

3980 
p
++;

3982 if (sizeof (
DCHAR_T
) == 1)

3984 
	`sprintf
 ((char *) 
p
, "%+.2d", 
exponent
);

3985 while (*
p
 != '\0')

3986 
p
++;

3990 char 
expbuf
[6 + 1];

3991 const char *
ep
;

3992 
	`sprintf
 (
expbuf
, "%+.2d", 
exponent
);

3993 for (
ep
 = 
expbuf
; (*
p
 = *ep) != '\0'; ep++)

3994 
p
++;

3999 
	`free
 (
digits
);

4003 
	`abort
 ();

4006 if (!(
arg
 == 0.0L))

4007 
	`abort
 ();

4009 
pad_ptr
 = 
p
;

4011 if (
dp
->
conversion
 == 'f' || dp->conversion == 'F')

4013 *
p
++ = '0';

4014 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4016 *
p
++ = 
	`decimal_point_char
 ();

4017 for (; 
precision
 > 0; precision--)

4018 *
p
++ = '0';

4021 else if (
dp
->
conversion
 == 'e' || dp->conversion == 'E')

4023 *
p
++ = '0';

4024 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4026 *
p
++ = 
	`decimal_point_char
 ();

4027 for (; 
precision
 > 0; precision--)

4028 *
p
++ = '0';

4030 *
p
++ = 
dp
->
conversion
;

4031 *
p
++ = '+';

4032 *
p
++ = '0';

4033 *
p
++ = '0';

4035 else if (
dp
->
conversion
 == 'g' || dp->conversion == 'G')

4037 *
p
++ = '0';

4038 if (
flags
 & 
FLAG_ALT
)

4040 
size_t
 
ndigits
 =

4041 (
precision
 > 0 ? precision - 1 : 0);

4042 *
p
++ = 
	`decimal_point_char
 ();

4043 for (; 
ndigits
 > 0; --ndigits)

4044 *
p
++ = '0';

4047 else if (
dp
->
conversion
 == 'a' || dp->conversion == 'A')

4049 *
p
++ = '0';

4050 *
p
++ = 
dp
->
conversion
 - 'A' + 'X';

4051 
pad_ptr
 = 
p
;

4052 *
p
++ = '0';

4053 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4055 *
p
++ = 
	`decimal_point_char
 ();

4056 for (; 
precision
 > 0; precision--)

4057 *
p
++ = '0';

4059 *
p
++ = 
dp
->
conversion
 - 'A' + 'P';

4060 *
p
++ = '+';

4061 *
p
++ = '0';

4064 
	`abort
 ();

4068 
	`END_LONG_DOUBLE_ROUNDING
 ();

4071 #if 
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_DOUBLE


4075 #if 
NEED_PRINTF_DOUBLE
 || 
NEED_PRINTF_INFINITE_DOUBLE


4077 double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_double
;

4079 if (
	`isnand
 (
arg
))

4081 if (
dp
->
conversion
 >= 'A' && dp->conversion <= 'Z')

4083 *
p
++ = 'N'; *p++ = 'A'; *p++ = 'N';

4087 *
p
++ = 'n'; *p++ = 'a'; *p++ = 'n';

4092 int 
sign
 = 0;

4094 if (
	`signbit
 (
arg
))

4096 
sign
 = -1;

4097 
arg
 = -arg;

4100 if (
sign
 < 0)

4101 *
p
++ = '-';

4102 else if (
flags
 & 
FLAG_SHOWSIGN
)

4103 *
p
++ = '+';

4104 else if (
flags
 & 
FLAG_SPACE
)

4105 *
p
++ = ' ';

4107 if (
arg
 > 0.0 && arg + arg == arg)

4109 if (
dp
->
conversion
 >= 'A' && dp->conversion <= 'Z')

4111 *
p
++ = 'I'; *p++ = 'N'; *p++ = 'F';

4115 *
p
++ = 'i'; *p++ = 'n'; *p++ = 'f';

4120 #if 
NEED_PRINTF_DOUBLE


4121 
pad_ptr
 = 
p
;

4123 if (
dp
->
conversion
 == 'f' || dp->conversion == 'F')

4125 char *
digits
;

4126 
size_t
 
ndigits
;

4128 
digits
 =

4129 
	`scale10_round_decimal_double
 (
arg
, 
precision
);

4130 if (
digits
 == 
NULL
)

4131 goto 
out_of_memory
;

4132 
ndigits
 = 
	`strlen
 (
digits
);

4134 if (
ndigits
 > 
precision
)

4137 --
ndigits
;

4138 *
p
++ = 
digits
[
ndigits
];

4140 while (
ndigits
 > 
precision
);

4142 *
p
++ = '0';

4144 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4146 *
p
++ = 
	`decimal_point_char
 ();

4147 for (; 
precision
 > 
ndigits
; precision--)

4148 *
p
++ = '0';

4149 while (
ndigits
 > 0)

4151 --
ndigits
;

4152 *
p
++ = 
digits
[
ndigits
];

4156 
	`free
 (
digits
);

4158 else if (
dp
->
conversion
 == 'e' || dp->conversion == 'E')

4160 int 
exponent
;

4162 if (
arg
 == 0.0)

4164 
exponent
 = 0;

4165 *
p
++ = '0';

4166 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4168 *
p
++ = 
	`decimal_point_char
 ();

4169 for (; 
precision
 > 0; precision--)

4170 *
p
++ = '0';

4176 int 
adjusted
;

4177 char *
digits
;

4178 
size_t
 
ndigits
;

4180 
exponent
 = 
	`floorlog10
 (
arg
);

4181 
adjusted
 = 0;

4184 
digits
 =

4185 
	`scale10_round_decimal_double
 (
arg
,

4186 (int)
precision
 - 
exponent
);

4187 if (
digits
 == 
NULL
)

4188 goto 
out_of_memory
;

4189 
ndigits
 = 
	`strlen
 (
digits
);

4191 if (
ndigits
 == 
precision
 + 1)

4193 if (
ndigits
 < 
precision


4194 || 
ndigits
 > 
precision
 + 2)

4197 
	`abort
 ();

4198 if (
adjusted
)

4202 
	`abort
 ();

4203 
	`free
 (
digits
);

4204 if (
ndigits
 == 
precision
)

4205 
exponent
 -= 1;

4207 
exponent
 += 1;

4208 
adjusted
 = 1;

4211 if (
	`is_borderline
 (
digits
, 
precision
))

4216 char *
digits2
 =

4217 
	`scale10_round_decimal_double
 (
arg
,

4218 (int)
precision
 - 
exponent
 + 1);

4219 if (
digits2
 == 
NULL
)

4221 
	`free
 (
digits
);

4222 goto 
out_of_memory
;

4224 if (
	`strlen
 (
digits2
) == 
precision
 + 1)

4226 
	`free
 (
digits
);

4227 
digits
 = 
digits2
;

4228 
exponent
 -= 1;

4231 
	`free
 (
digits2
);

4235 *
p
++ = 
digits
[--
ndigits
];

4236 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4238 *
p
++ = 
	`decimal_point_char
 ();

4239 while (
ndigits
 > 0)

4241 --
ndigits
;

4242 *
p
++ = 
digits
[
ndigits
];

4246 
	`free
 (
digits
);

4249 *
p
++ = 
dp
->
conversion
;

4250 #if 
WIDE_CHAR_VERSION


4252 static const 
wchar_t
 
decimal_format
[] =

4255 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


4260 
	`SNPRINTF
 (
p
, 6 + 1, 
decimal_format
, 
exponent
);

4262 while (*
p
 != '\0')

4263 
p
++;

4266 static const char 
decimal_format
[] =

4269 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


4274 if (sizeof (
DCHAR_T
) == 1)

4276 
	`sprintf
 ((char *) 
p
, 
decimal_format
, 
exponent
);

4277 while (*
p
 != '\0')

4278 
p
++;

4282 char 
expbuf
[6 + 1];

4283 const char *
ep
;

4284 
	`sprintf
 (
expbuf
, 
decimal_format
, 
exponent
);

4285 for (
ep
 = 
expbuf
; (*
p
 = *ep) != '\0'; ep++)

4286 
p
++;

4291 else if (
dp
->
conversion
 == 'g' || dp->conversion == 'G')

4293 if (
precision
 == 0)

4294 
precision
 = 1;

4297 if (
arg
 == 0.0)

4301 
size_t
 
ndigits
 = 
precision
;

4304 
size_t
 
nzeroes
 =

4305 (
flags
 & 
FLAG_ALT
 ? 0 : 
precision
 - 1);

4307 --
ndigits
;

4308 *
p
++ = '0';

4309 if ((
flags
 & 
FLAG_ALT
) || 
ndigits
 > 
nzeroes
)

4311 *
p
++ = 
	`decimal_point_char
 ();

4312 while (
ndigits
 > 
nzeroes
)

4314 --
ndigits
;

4315 *
p
++ = '0';

4322 int 
exponent
;

4323 int 
adjusted
;

4324 char *
digits
;

4325 
size_t
 
ndigits
;

4326 
size_t
 
nzeroes
;

4328 
exponent
 = 
	`floorlog10
 (
arg
);

4329 
adjusted
 = 0;

4332 
digits
 =

4333 
	`scale10_round_decimal_double
 (
arg
,

4334 (int)(
precision
 - 1) - 
exponent
);

4335 if (
digits
 == 
NULL
)

4336 goto 
out_of_memory
;

4337 
ndigits
 = 
	`strlen
 (
digits
);

4339 if (
ndigits
 == 
precision
)

4341 if (
ndigits
 < 
precision
 - 1

4342 || 
ndigits
 > 
precision
 + 1)

4345 
	`abort
 ();

4346 if (
adjusted
)

4350 
	`abort
 ();

4351 
	`free
 (
digits
);

4352 if (
ndigits
 < 
precision
)

4353 
exponent
 -= 1;

4355 
exponent
 += 1;

4356 
adjusted
 = 1;

4359 if (
	`is_borderline
 (
digits
, 
precision
 - 1))

4364 char *
digits2
 =

4365 
	`scale10_round_decimal_double
 (
arg
,

4366 (int)(
precision
 - 1) - 
exponent
 + 1);

4367 if (
digits2
 == 
NULL
)

4369 
	`free
 (
digits
);

4370 goto 
out_of_memory
;

4372 if (
	`strlen
 (
digits2
) == 
precision
)

4374 
	`free
 (
digits
);

4375 
digits
 = 
digits2
;

4376 
exponent
 -= 1;

4379 
	`free
 (
digits2
);

4385 
nzeroes
 = 0;

4386 if ((
flags
 & 
FLAG_ALT
) == 0)

4387 while (
nzeroes
 < 
ndigits


4388 && 
digits
[
nzeroes
] == '0')

4389 
nzeroes
++;

4392 if (
exponent
 >= -4

4393 && 
exponent
 < (long)
precision
)

4399 if (
exponent
 >= 0)

4401 
size_t
 
count
 = 
exponent
 + 1;

4403 for (; 
count
 > 0; count--)

4404 *
p
++ = 
digits
[--
ndigits
];

4405 if ((
flags
 & 
FLAG_ALT
) || 
ndigits
 > 
nzeroes
)

4407 *
p
++ = 
	`decimal_point_char
 ();

4408 while (
ndigits
 > 
nzeroes
)

4410 --
ndigits
;

4411 *
p
++ = 
digits
[
ndigits
];

4417 
size_t
 
count
 = -
exponent
 - 1;

4418 *
p
++ = '0';

4419 *
p
++ = 
	`decimal_point_char
 ();

4420 for (; 
count
 > 0; count--)

4421 *
p
++ = '0';

4422 while (
ndigits
 > 
nzeroes
)

4424 --
ndigits
;

4425 *
p
++ = 
digits
[
ndigits
];

4432 *
p
++ = 
digits
[--
ndigits
];

4433 if ((
flags
 & 
FLAG_ALT
) || 
ndigits
 > 
nzeroes
)

4435 *
p
++ = 
	`decimal_point_char
 ();

4436 while (
ndigits
 > 
nzeroes
)

4438 --
ndigits
;

4439 *
p
++ = 
digits
[
ndigits
];

4442 *
p
++ = 
dp
->
conversion
 - 'G' + 'E';

4443 #if 
WIDE_CHAR_VERSION


4445 static const 
wchar_t
 
decimal_format
[] =

4448 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


4453 
	`SNPRINTF
 (
p
, 6 + 1, 
decimal_format
, 
exponent
);

4455 while (*
p
 != '\0')

4456 
p
++;

4459 static const char 
decimal_format
[] =

4462 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


4467 if (sizeof (
DCHAR_T
) == 1)

4469 
	`sprintf
 ((char *) 
p
, 
decimal_format
, 
exponent
);

4470 while (*
p
 != '\0')

4471 
p
++;

4475 char 
expbuf
[6 + 1];

4476 const char *
ep
;

4477 
	`sprintf
 (
expbuf
, 
decimal_format
, 
exponent
);

4478 for (
ep
 = 
expbuf
; (*
p
 = *ep) != '\0'; ep++)

4479 
p
++;

4485 
	`free
 (
digits
);

4489 
	`abort
 ();

4492 if (!(
arg
 == 0.0))

4493 
	`abort
 ();

4495 
pad_ptr
 = 
p
;

4497 if (
dp
->
conversion
 == 'f' || dp->conversion == 'F')

4499 *
p
++ = '0';

4500 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4502 *
p
++ = 
	`decimal_point_char
 ();

4503 for (; 
precision
 > 0; precision--)

4504 *
p
++ = '0';

4507 else if (
dp
->
conversion
 == 'e' || dp->conversion == 'E')

4509 *
p
++ = '0';

4510 if ((
flags
 & 
FLAG_ALT
) || 
precision
 > 0)

4512 *
p
++ = 
	`decimal_point_char
 ();

4513 for (; 
precision
 > 0; precision--)

4514 *
p
++ = '0';

4516 *
p
++ = 
dp
->
conversion
;

4517 *
p
++ = '+';

4520 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


4521 *
p
++ = '0';

4523 *
p
++ = '0';

4524 *
p
++ = '0';

4526 else if (
dp
->
conversion
 == 'g' || dp->conversion == 'G')

4528 *
p
++ = '0';

4529 if (
flags
 & 
FLAG_ALT
)

4531 
size_t
 
ndigits
 =

4532 (
precision
 > 0 ? precision - 1 : 0);

4533 *
p
++ = 
	`decimal_point_char
 ();

4534 for (; 
ndigits
 > 0; --ndigits)

4535 *
p
++ = '0';

4539 
	`abort
 ();

4548 if (
has_width
 && 
p
 - 
tmp
 < 
width
)

4550 
size_t
 
pad
 = 
width
 - (
p
 - 
tmp
);

4551 
DCHAR_T
 *
end
 = 
p
 + 
pad
;

4553 if (
flags
 & 
FLAG_LEFT
)

4556 for (; 
pad
 > 0; pad--)

4557 *
p
++ = ' ';

4559 else if ((
flags
 & 
FLAG_ZERO
) && 
pad_ptr
 != 
NULL
)

4562 
DCHAR_T
 *
q
 = 
end
;

4564 while (
p
 > 
pad_ptr
)

4565 *--
q
 = *--
p
;

4566 for (; 
pad
 > 0; pad--)

4567 *
p
++ = '0';

4572 
DCHAR_T
 *
q
 = 
end
;

4574 while (
p
 > 
tmp
)

4575 *--
q
 = *--
p
;

4576 for (; 
pad
 > 0; pad--)

4577 *
p
++ = ' ';

4580 
p
 = 
end
;

4584 
size_t
 
count
 = 
p
 - 
tmp
;

4586 if (
count
 >= 
tmp_length
)

4589 
	`abort
 ();

4592 if (
count
 >= 
allocated
 - 
length
)

4594 
size_t
 
n
 = 
	`xsum
 (
length
, 
count
);

4596 
	`ENSURE_ALLOCATION
 (
n
);

4600 
	`memcpy
 (
result
 + 
length
, 
tmp
, 
count
 * sizeof (
DCHAR_T
));

4601 if (
tmp
 != 
tmpbuf
)

4602 
	`free
 (
tmp
);

4603 
length
 += 
count
;

4609 
arg_type
 
type
 = 
a
.
arg
[
dp
->
arg_index
].type;

4610 int 
flags
 = 
dp
->flags;

4611 #if !
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
 || !
DCHAR_IS_TCHAR
 || 
ENABLE_UNISTDIO
 || 
NEED_PRINTF_FLAG_LEFTADJUST
 || 
NEED_PRINTF_FLAG_ZERO
 || 
NEED_PRINTF_UNBOUNDED_PRECISION


4612 int 
has_width
;

4613 
size_t
 
width
;

4615 #if !
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
 || 
NEED_PRINTF_UNBOUNDED_PRECISION


4616 int 
has_precision
;

4617 
size_t
 
precision
;

4619 #if 
NEED_PRINTF_UNBOUNDED_PRECISION


4620 int 
prec_ourselves
;

4622 #define 
	#prec_ourselves
 0

	)

4624 #if 
NEED_PRINTF_FLAG_LEFTADJUST


4625 #define 
	#pad_ourselves
 1

	)

4626 #elif !
DCHAR_IS_TCHAR
 || 
ENABLE_UNISTDIO
 || 
NEED_PRINTF_FLAG_ZERO
 || 
NEED_PRINTF_UNBOUNDED_PRECISION


4627 int 
pad_ourselves
;

4629 #define 
	#pad_ourselves
 0

	)

4631 
TCHAR_T
 *
fbp
;

4632 unsigned int 
prefix_count
;

4633 int 
prefixes
[2] 
	`IF_LINT
 (= { 0 });

4634 int 
orig_errno
;

4635 #if !
USE_SNPRINTF


4636 
size_t
 
tmp_length
;

4637 
TCHAR_T
 
tmpbuf
[700];

4638 
TCHAR_T
 *
tmp
;

4641 #if !
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
 || !
DCHAR_IS_TCHAR
 || 
ENABLE_UNISTDIO
 || 
NEED_PRINTF_FLAG_LEFTADJUST
 || 
NEED_PRINTF_FLAG_ZERO
 || 
NEED_PRINTF_UNBOUNDED_PRECISION


4642 
has_width
 = 0;

4643 
width
 = 0;

4644 if (
dp
->
width_start
 != dp->
width_end
)

4646 if (
dp
->
width_arg_index
 != 
ARG_NONE
)

4648 int 
arg
;

4650 if (!(
a
.
arg
[
dp
->
width_arg_index
].
type
 == 
TYPE_INT
))

4651 
	`abort
 ();

4652 
arg
 = 
a
.arg[
dp
->
width_arg_index
].a.
a_int
;

4653 if (
arg
 < 0)

4657 
flags
 |= 
FLAG_LEFT
;

4658 
width
 = (unsigned int) (-
arg
);

4661 
width
 = 
arg
;

4665 const 
FCHAR_T
 *
digitp
 = 
dp
->
width_start
;

4668 
width
 = 
	`xsum
 (
	`xtimes
 (width, 10), *
digitp
++ - '0');

4669 while (
digitp
 != 
dp
->
width_end
);

4671 
has_width
 = 1;

4675 #if !
USE_SNPRINTF
 || !
HAVE_SNPRINTF_RETVAL_C99
 || 
NEED_PRINTF_UNBOUNDED_PRECISION


4676 
has_precision
 = 0;

4677 
precision
 = 6;

4678 if (
dp
->
precision_start
 != dp->
precision_end
)

4680 if (
dp
->
precision_arg_index
 != 
ARG_NONE
)

4682 int 
arg
;

4684 if (!(
a
.
arg
[
dp
->
precision_arg_index
].
type
 == 
TYPE_INT
))

4685 
	`abort
 ();

4686 
arg
 = 
a
.arg[
dp
->
precision_arg_index
].a.
a_int
;

4689 if (
arg
 >= 0)

4691 
precision
 = 
arg
;

4692 
has_precision
 = 1;

4697 const 
FCHAR_T
 *
digitp
 = 
dp
->
precision_start
 + 1;

4699 
precision
 = 0;

4700 while (
digitp
 != 
dp
->
precision_end
)

4701 
precision
 = 
	`xsum
 (
	`xtimes
 (precision, 10), *
digitp
++ - '0');

4702 
has_precision
 = 1;

4708 #if 
NEED_PRINTF_UNBOUNDED_PRECISION


4709 switch (
dp
->
conversion
)

4714 
prec_ourselves
 = 
has_precision
 && (
precision
 > 0);

4717 
prec_ourselves
 = 0;

4723 #if !
NEED_PRINTF_FLAG_LEFTADJUST
 && (!
DCHAR_IS_TCHAR
 || 
ENABLE_UNISTDIO
 || 
NEED_PRINTF_FLAG_ZERO
 || 
NEED_PRINTF_UNBOUNDED_PRECISION
)

4724 switch (
dp
->
conversion
)

4726 #if !
DCHAR_IS_TCHAR
 || 
ENABLE_UNISTDIO


4733 #if 
NEED_PRINTF_FLAG_ZERO


4737 
pad_ourselves
 = 1;

4740 
pad_ourselves
 = 
prec_ourselves
;

4745 #if !
USE_SNPRINTF


4748 
tmp_length
 =

4749 
	`MAX_ROOM_NEEDED
 (&
a
, 
dp
->
arg_index
, dp->
conversion
, 
type
,

4750 
flags
, 
width
, 
has_precision
, 
precision
,

4751 
pad_ourselves
);

4753 if (
tmp_length
 <= sizeof (
tmpbuf
) / sizeof (
TCHAR_T
))

4754 
tmp
 = 
tmpbuf
;

4757 
size_t
 
tmp_memsize
 = 
	`xtimes
 (
tmp_length
, sizeof (
TCHAR_T
));

4759 if (
	`size_overflow_p
 (
tmp_memsize
))

4761 goto 
out_of_memory
;

4762 
tmp
 = (
TCHAR_T
 *) 
	`malloc
 (
tmp_memsize
);

4763 if (
tmp
 == 
NULL
)

4765 goto 
out_of_memory
;

4771 
fbp
 = 
buf
;

4772 *
fbp
++ = '%';

4773 #if 
NEED_PRINTF_FLAG_GROUPING


4778 if (
flags
 & 
FLAG_GROUP
)

4779 *
fbp
++ = '\'';

4781 if (
flags
 & 
FLAG_LEFT
)

4782 *
fbp
++ = '-';

4783 if (
flags
 & 
FLAG_SHOWSIGN
)

4784 *
fbp
++ = '+';

4785 if (
flags
 & 
FLAG_SPACE
)

4786 *
fbp
++ = ' ';

4787 if (
flags
 & 
FLAG_ALT
)

4788 *
fbp
++ = '#';

4789 #if 
__GLIBC__
 >= 2 && !
defined
 
__UCLIBC__


4790 if (
flags
 & 
FLAG_LOCALIZED
)

4791 *
fbp
++ = 'I';

4793 if (!
pad_ourselves
)

4795 if (
flags
 & 
FLAG_ZERO
)

4796 *
fbp
++ = '0';

4797 if (
dp
->
width_start
 != dp->
width_end
)

4799 
size_t
 
n
 = 
dp
->
width_end
 - dp->
width_start
;

4802 if (sizeof (
FCHAR_T
) == sizeof (
TCHAR_T
))

4804 
	`memcpy
 (
fbp
, 
dp
->
width_start
, 
n
 * sizeof (
TCHAR_T
));

4805 
fbp
 += 
n
;

4809 const 
FCHAR_T
 *
mp
 = 
dp
->
width_start
;

4811 *
fbp
++ = (unsigned char) *
mp
++;

4812 while (--
n
 > 0);

4816 if (!
prec_ourselves
)

4818 if (
dp
->
precision_start
 != dp->
precision_end
)

4820 
size_t
 
n
 = 
dp
->
precision_end
 - dp->
precision_start
;

4823 if (sizeof (
FCHAR_T
) == sizeof (
TCHAR_T
))

4825 
	`memcpy
 (
fbp
, 
dp
->
precision_start
, 
n
 * sizeof (
TCHAR_T
));

4826 
fbp
 += 
n
;

4830 const 
FCHAR_T
 *
mp
 = 
dp
->
precision_start
;

4832 *
fbp
++ = (unsigned char) *
mp
++;

4833 while (--
n
 > 0);

4838 switch (
type
)

4840 #if 
HAVE_LONG_LONG_INT


4841 case 
TYPE_LONGLONGINT
:

4842 case 
TYPE_ULONGLONGINT
:

4843 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


4844 *
fbp
++ = 'I';

4845 *
fbp
++ = '6';

4846 *
fbp
++ = '4';

4849 *
fbp
++ = 'l';

4853 case 
TYPE_LONGINT
:

4854 case 
TYPE_ULONGINT
:

4855 #if 
HAVE_WINT_T


4856 case 
TYPE_WIDE_CHAR
:

4858 #if 
HAVE_WCHAR_T


4859 case 
TYPE_WIDE_STRING
:

4861 *
fbp
++ = 'l';

4863 case 
TYPE_LONGDOUBLE
:

4864 *
fbp
++ = 'L';

4869 #if 
NEED_PRINTF_DIRECTIVE_F


4870 if (
dp
->
conversion
 == 'F')

4871 *
fbp
 = 'f';

4874 *
fbp
 = 
dp
->
conversion
;

4875 #if 
USE_SNPRINTF


4876 #if !(((
__GLIBC__
 > 2 || (__GLIBC__ == 2 && 
__GLIBC_MINOR__
 >= 3)) && !
defined
 
__UCLIBC__
) || ((defined 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__
))

4877 
fbp
[1] = '%';

4878 
fbp
[2] = 'n';

4879 
fbp
[3] = '\0';

4905 
fbp
[1] = '\0';

4908 
fbp
[1] = '\0';

4912 
prefix_count
 = 0;

4913 if (!
pad_ourselves
 && 
dp
->
width_arg_index
 != 
ARG_NONE
)

4915 if (!(
a
.
arg
[
dp
->
width_arg_index
].
type
 == 
TYPE_INT
))

4916 
	`abort
 ();

4917 
prefixes
[
prefix_count
++] = 
a
.
arg
[
dp
->
width_arg_index
].a.
a_int
;

4919 if (!
prec_ourselves
 && 
dp
->
precision_arg_index
 != 
ARG_NONE
)

4921 if (!(
a
.
arg
[
dp
->
precision_arg_index
].
type
 == 
TYPE_INT
))

4922 
	`abort
 ();

4923 
prefixes
[
prefix_count
++] = 
a
.
arg
[
dp
->
precision_arg_index
].a.
a_int
;

4926 #if 
USE_SNPRINTF


4932 #define 
	#TCHARS_PER_DCHAR
 (sizeof (
DCHAR_T
) / sizeof (
TCHAR_T
))

	)

4935 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
,

4936 (2 + 
TCHARS_PER_DCHAR
 - 1)

4937 / 
TCHARS_PER_DCHAR
));

4940 *(
TCHAR_T
 *) (
result
 + 
length
) = '\0';

4943 
orig_errno
 = 
errno
;

4947 int 
count
 = -1;

4949 #if 
USE_SNPRINTF


4950 int 
retcount
 = 0;

4951 
size_t
 
maxlen
 = 
allocated
 - 
length
;

4954 if (
maxlen
 > 
INT_MAX
 / 
TCHARS_PER_DCHAR
)

4955 
maxlen
 = 
INT_MAX
 / 
TCHARS_PER_DCHAR
;

4956 
maxlen
 = maxlen * 
TCHARS_PER_DCHAR
;

4957 #define 
	#SNPRINTF_BUF
(
arg
) \

4958 switch (
prefix_count
) \

4961 
retcount
 = 
	`SNPRINTF
 ((
TCHAR_T
 *) (
result
 + 
length
), \

4962 
maxlen
, 
buf
, \

4963 
arg
, &
count
); \

4966 
retcount
 = 
	`SNPRINTF
 ((
TCHAR_T
 *) (
result
 + 
length
), \

4967 
maxlen
, 
buf
, \

4968 
prefixes
[0], 
arg
, &
count
); \

4971 
retcount
 = 
	`SNPRINTF
 ((
TCHAR_T
 *) (
result
 + 
length
), \

4972 
maxlen
, 
buf
, \

4973 
prefixes
[0], prefixes[1], 
arg
, \

4974 &
count
); \

4977 
	`abort
 (); \

4978 }

	)

4980 #define 
	#SNPRINTF_BUF
(
arg
) \

4981 switch (
prefix_count
) \

4984 
count
 = 
	`sprintf
 (
tmp
, 
buf
, 
arg
); \

4987 
count
 = 
	`sprintf
 (
tmp
, 
buf
, 
prefixes
[0], 
arg
); \

4990 
count
 = 
	`sprintf
 (
tmp
, 
buf
, 
prefixes
[0], prefixes[1],\

4991 
arg
); \

4994 
	`abort
 (); \

4995 }

	)

4998 
errno
 = 0;

4999 switch (
type
)

5001 case 
TYPE_SCHAR
:

5003 int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_schar
;

5004 
	`SNPRINTF_BUF
 (
arg
);

5007 case 
TYPE_UCHAR
:

5009 unsigned int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_uchar
;

5010 
	`SNPRINTF_BUF
 (
arg
);

5013 case 
TYPE_SHORT
:

5015 int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_short
;

5016 
	`SNPRINTF_BUF
 (
arg
);

5019 case 
TYPE_USHORT
:

5021 unsigned int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_ushort
;

5022 
	`SNPRINTF_BUF
 (
arg
);

5025 case 
TYPE_INT
:

5027 int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_int
;

5028 
	`SNPRINTF_BUF
 (
arg
);

5031 case 
TYPE_UINT
:

5033 unsigned int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_uint
;

5034 
	`SNPRINTF_BUF
 (
arg
);

5037 case 
TYPE_LONGINT
:

5039 long int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_longint
;

5040 
	`SNPRINTF_BUF
 (
arg
);

5043 case 
TYPE_ULONGINT
:

5045 unsigned long int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_ulongint
;

5046 
	`SNPRINTF_BUF
 (
arg
);

5049 #if 
HAVE_LONG_LONG_INT


5050 case 
TYPE_LONGLONGINT
:

5052 long long int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_longlongint
;

5053 
	`SNPRINTF_BUF
 (
arg
);

5056 case 
TYPE_ULONGLONGINT
:

5058 unsigned long long int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_ulonglongint
;

5059 
	`SNPRINTF_BUF
 (
arg
);

5063 case 
TYPE_DOUBLE
:

5065 double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_double
;

5066 
	`SNPRINTF_BUF
 (
arg
);

5069 case 
TYPE_LONGDOUBLE
:

5071 long double 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_longdouble
;

5072 
	`SNPRINTF_BUF
 (
arg
);

5075 case 
TYPE_CHAR
:

5077 int 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_char
;

5078 
	`SNPRINTF_BUF
 (
arg
);

5081 #if 
HAVE_WINT_T


5082 case 
TYPE_WIDE_CHAR
:

5084 
wint_t
 
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_wide_char
;

5085 
	`SNPRINTF_BUF
 (
arg
);

5089 case 
TYPE_STRING
:

5091 const char *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_string
;

5092 
	`SNPRINTF_BUF
 (
arg
);

5095 #if 
HAVE_WCHAR_T


5096 case 
TYPE_WIDE_STRING
:

5098 const 
wchar_t
 *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_wide_string
;

5099 
	`SNPRINTF_BUF
 (
arg
);

5103 case 
TYPE_POINTER
:

5105 void *
arg
 = 
a
.arg[
dp
->
arg_index
].a.
a_pointer
;

5106 
	`SNPRINTF_BUF
 (
arg
);

5110 
	`abort
 ();

5113 #if 
USE_SNPRINTF


5118 if (
count
 >= 0)

5122 if (
count
 < 
maxlen


5123 && ((
TCHAR_T
 *) (
result
 + 
length
)) [
count
] != '\0')

5124 
	`abort
 ();

5126 if (
retcount
 > 
count
)

5127 
count
 = 
retcount
;

5133 if (
fbp
[1] != '\0')

5137 
fbp
[1] = '\0';

5143 if (
retcount
 < 0)

5145 #if !
HAVE_SNPRINTF_RETVAL_C99


5156 
size_t
 
tmp_length
 =

5157 
	`MAX_ROOM_NEEDED
 (&
a
, 
dp
->
arg_index
,

5158 
dp
->
conversion
, 
type
, 
flags
,

5159 
width
, 
has_precision
,

5160 
precision
, 
pad_ourselves
);

5162 if (
maxlen
 < 
tmp_length
)

5166 
size_t
 
bigger_need
 =

5167 
	`xsum
 (
length
,

5168 
	`xsum
 (
tmp_length
,

5169 
TCHARS_PER_DCHAR
 - 1)

5170 / 
TCHARS_PER_DCHAR
);

5175 
size_t
 
bigger_need2
 =

5176 
	`xsum
 (
	`xtimes
 (
allocated
, 2), 12);

5177 if (
bigger_need
 < 
bigger_need2
)

5178 
bigger_need
 = 
bigger_need2
;

5179 
	`ENSURE_ALLOCATION
 (
bigger_need
);

5185 
count
 = 
retcount
;

5191 if (
count
 < 0)

5195 int 
saved_errno
 = 
errno
;

5197 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

5198 
	`free
 (
result
);

5199 if (
buf_malloced
 != 
NULL
)

5200 
	`free
 (
buf_malloced
);

5201 
	`CLEANUP
 ();

5202 
errno
 =

5203 (
saved_errno
 != 0

5204 ? 
saved_errno


5205 : (
dp
->
conversion
 == 'c' || dp->conversion == 's'

5206 ? 
EILSEQ


5207 : 
EINVAL
));

5208 return 
NULL
;

5211 #if 
USE_SNPRINTF


5217 if ((unsigned int) 
count
 + 1 >= 
maxlen
)

5222 if (
maxlen
 == 
INT_MAX
 / 
TCHARS_PER_DCHAR
)

5223 goto 
overflow
;

5235 
size_t
 
n
 =

5236 
	`xmax
 (
	`xsum
 (
length
,

5237 ((unsigned int) 
count
 + 2

5238 + 
TCHARS_PER_DCHAR
 - 1)

5239 / 
TCHARS_PER_DCHAR
),

5240 
	`xtimes
 (
allocated
, 2));

5242 
	`ENSURE_ALLOCATION
 (
n
);

5248 #if 
NEED_PRINTF_UNBOUNDED_PRECISION


5249 if (
prec_ourselves
)

5252 
TCHAR_T
 *
prec_ptr
 =

5253 #if 
USE_SNPRINTF


5254 (
TCHAR_T
 *) (
result
 + 
length
);

5256 
tmp
;

5258 
size_t
 
prefix_count
;

5259 
size_t
 
move
;

5261 
prefix_count
 = 0;

5263 if (
count
 >= 1

5264 && (*
prec_ptr
 == '-' || *prec_ptr == '+'

5265 || *
prec_ptr
 == ' '))

5266 
prefix_count
 = 1;

5269 else if (
count
 >= 2

5270 && 
prec_ptr
[0] == '0'

5271 && (
prec_ptr
[1] == 'x' || prec_ptr[1] == 'X'))

5272 
prefix_count
 = 2;

5274 
move
 = 
count
 - 
prefix_count
;

5275 if (
precision
 > 
move
)

5278 
size_t
 
insert
 = 
precision
 - 
move
;

5279 
TCHAR_T
 *
prec_end
;

5281 #if 
USE_SNPRINTF


5282 
size_t
 
n
 =

5283 
	`xsum
 (
length
,

5284 (
count
 + 
insert
 + 
TCHARS_PER_DCHAR
 - 1)

5285 / 
TCHARS_PER_DCHAR
);

5286 
length
 += (
count
 + 
TCHARS_PER_DCHAR
 - 1) / TCHARS_PER_DCHAR;

5287 
	`ENSURE_ALLOCATION
 (
n
);

5288 
length
 -= (
count
 + 
TCHARS_PER_DCHAR
 - 1) / TCHARS_PER_DCHAR;

5289 
prec_ptr
 = (
TCHAR_T
 *) (
result
 + 
length
);

5292 
prec_end
 = 
prec_ptr
 + 
count
;

5293 
prec_ptr
 += 
prefix_count
;

5295 while (
prec_end
 > 
prec_ptr
)

5297 
prec_end
--;

5298 
prec_end
[
insert
] = prec_end[0];

5301 
prec_end
 += 
insert
;

5303 *--
prec_end
 = '0';

5304 while (
prec_end
 > 
prec_ptr
);

5306 
count
 += 
insert
;

5311 #if !
USE_SNPRINTF


5312 if (
count
 >= 
tmp_length
)

5315 
	`abort
 ();

5318 #if !
DCHAR_IS_TCHAR


5320 if (
dp
->
conversion
 == 'c' || dp->conversion == 's')

5325 const 
TCHAR_T
 *
tmpsrc
;

5326 
DCHAR_T
 *
tmpdst
;

5327 
size_t
 
tmpdst_len
;

5329 
	`verify
 (sizeof (
TCHAR_T
) == 1);

5330 #if 
USE_SNPRINTF


5331 
tmpsrc
 = (
TCHAR_T
 *) (
result
 + 
length
);

5333 
tmpsrc
 = 
tmp
;

5335 
tmpdst
 =

5336 
	`DCHAR_CONV_FROM_ENCODING
 (
	`locale_charset
 (),

5337 
iconveh_question_mark
,

5338 
tmpsrc
, 
count
,

5339 
NULL
,

5340 
NULL
, &
tmpdst_len
);

5341 if (
tmpdst
 == 
NULL
)

5343 int 
saved_errno
 = 
errno
;

5344 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

5345 
	`free
 (
result
);

5346 if (
buf_malloced
 != 
NULL
)

5347 
	`free
 (
buf_malloced
);

5348 
	`CLEANUP
 ();

5349 
errno
 = 
saved_errno
;

5350 return 
NULL
;

5352 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
tmpdst_len
));

5353 
	`DCHAR_CPY
 (
result
 + 
length
, 
tmpdst
, 
tmpdst_len
);

5354 
	`free
 (
tmpdst
);

5355 
count
 = 
tmpdst_len
;

5361 #if 
USE_SNPRINTF


5365 if (sizeof (
DCHAR_T
) != sizeof (
TCHAR_T
))

5368 const 
TCHAR_T
 *
tmpsrc
;

5369 
DCHAR_T
 *
tmpdst
;

5370 
size_t
 
n
;

5372 #if 
USE_SNPRINTF


5373 if (
result
 == 
resultbuf
)

5375 
tmpsrc
 = (
TCHAR_T
 *) (
result
 + 
length
);

5378 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
count
));

5384 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
count
));

5385 
tmpsrc
 = (
TCHAR_T
 *) (
result
 + 
length
);

5388 
tmpsrc
 = 
tmp
;

5389 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 
count
));

5391 
tmpdst
 = 
result
 + 
length
;

5393 
tmpsrc
 += 
count
;

5394 
tmpdst
 += 
count
;

5395 for (
n
 = 
count
; n > 0; n--)

5396 *--
tmpdst
 = (unsigned char) *--
tmpsrc
;

5401 #if 
DCHAR_IS_TCHAR
 && !
USE_SNPRINTF


5403 if (
count
 > 
allocated
 - 
length
)

5407 
size_t
 
n
 =

5408 
	`xmax
 (
	`xsum
 (
length
, 
count
), 
	`xtimes
 (
allocated
, 2));

5410 
	`ENSURE_ALLOCATION
 (
n
);

5417 #if !
DCHAR_IS_TCHAR
 || 
ENABLE_UNISTDIO
 || 
NEED_PRINTF_FLAG_LEFTADJUST
 || 
NEED_PRINTF_FLAG_ZERO
 || 
NEED_PRINTF_UNBOUNDED_PRECISION


5418 if (
pad_ourselves
 && 
has_width
)

5420 
size_t
 
w
;

5421 #if 
ENABLE_UNISTDIO


5425 
w
 = 
	`DCHAR_MBSNLEN
 (
result
 + 
length
, 
count
);

5429 
w
 = 
count
;

5431 if (
w
 < 
width
)

5433 
size_t
 
pad
 = 
width
 - 
w
;

5436 if (
	`xsum
 (
count
, 
pad
) > 
allocated
 - 
length
)

5440 
size_t
 
n
 =

5441 
	`xmax
 (
	`xsum3
 (
length
, 
count
, 
pad
),

5442 
	`xtimes
 (
allocated
, 2));

5444 #if 
USE_SNPRINTF


5445 
length
 += 
count
;

5446 
	`ENSURE_ALLOCATION
 (
n
);

5447 
length
 -= 
count
;

5449 
	`ENSURE_ALLOCATION
 (
n
);

5455 #if !
DCHAR_IS_TCHAR
 || 
USE_SNPRINTF


5456 
DCHAR_T
 * const 
rp
 = 
result
 + 
length
;

5458 
DCHAR_T
 * const 
rp
 = 
tmp
;

5460 
DCHAR_T
 *
p
 = 
rp
 + 
count
;

5461 
DCHAR_T
 *
end
 = 
p
 + 
pad
;

5462 
DCHAR_T
 *
pad_ptr
;

5463 #if !
DCHAR_IS_TCHAR
 || 
ENABLE_UNISTDIO


5464 if (
dp
->
conversion
 == 'c'

5465 || 
dp
->
conversion
 == 's')

5467 
pad_ptr
 = 
NULL
;

5471 
pad_ptr
 = (*
rp
 == '-' ? rp + 1 : rp);

5473 if ((*
pad_ptr
 >= 'A' && *pad_ptr <= 'Z')

5474 || (*
pad_ptr
 >= 'a' && *pad_ptr <= 'z'))

5475 
pad_ptr
 = 
NULL
;

5481 
count
 = count + 
pad
;

5483 if (
flags
 & 
FLAG_LEFT
)

5486 for (; 
pad
 > 0; pad--)

5487 *
p
++ = ' ';

5489 else if ((
flags
 & 
FLAG_ZERO
) && 
pad_ptr
 != 
NULL
)

5492 
DCHAR_T
 *
q
 = 
end
;

5494 while (
p
 > 
pad_ptr
)

5495 *--
q
 = *--
p
;

5496 for (; 
pad
 > 0; pad--)

5497 *
p
++ = '0';

5502 
DCHAR_T
 *
q
 = 
end
;

5504 while (
p
 > 
rp
)

5505 *--
q
 = *--
p
;

5506 for (; 
pad
 > 0; pad--)

5507 *
p
++ = ' ';

5516 #if !
DCHAR_IS_TCHAR
 || 
USE_SNPRINTF


5520 
	`memcpy
 (
result
 + 
length
, 
tmp
, 
count
 * sizeof (
DCHAR_T
));

5522 #if !
USE_SNPRINTF


5523 if (
tmp
 != 
tmpbuf
)

5524 
	`free
 (
tmp
);

5527 #if 
NEED_PRINTF_DIRECTIVE_F


5528 if (
dp
->
conversion
 == 'F')

5531 
DCHAR_T
 *
rp
 = 
result
 + 
length
;

5532 
size_t
 
rc
;

5533 for (
rc
 = 
count
; rc > 0; rc--, 
rp
++)

5534 if (*
rp
 >= 'a' && *rp <= 'z')

5535 *
rp
 = *rp - 'a' + 'A';

5539 
length
 += 
count
;

5542 
errno
 = 
orig_errno
;

5543 #undef 
pad_ourselves


5544 #undef 
prec_ourselves


5550 
	`ENSURE_ALLOCATION
 (
	`xsum
 (
length
, 1));

5551 
result
[
length
] = '\0';

5553 if (
result
 != 
resultbuf
 && 
length
 + 1 < 
allocated
)

5556 
DCHAR_T
 *
memory
;

5558 
memory
 = (
DCHAR_T
 *) 
	`realloc
 (
result
, (
length
 + 1) * sizeof (DCHAR_T));

5559 if (
memory
 != 
NULL
)

5560 
result
 = 
memory
;

5563 if (
buf_malloced
 != 
NULL
)

5564 
	`free
 (
buf_malloced
);

5565 
	`CLEANUP
 ();

5566 *
lengthp
 = 
length
;

5571 return 
result
;

5573 #if 
USE_SNPRINTF


5574 
overflow
:

5575 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

5576 
	`free
 (
result
);

5577 if (
buf_malloced
 != 
NULL
)

5578 
	`free
 (
buf_malloced
);

5579 
	`CLEANUP
 ();

5580 
errno
 = 
EOVERFLOW
;

5581 return 
NULL
;

5584 
out_of_memory
:

5585 if (!(
result
 == 
resultbuf
 || result == 
NULL
))

5586 
	`free
 (
result
);

5587 if (
buf_malloced
 != 
NULL
)

5588 
	`free
 (
buf_malloced
);

5589 
out_of_memory_1
:

5590 
	`CLEANUP
 ();

5591 
errno
 = 
ENOMEM
;

5592 return 
NULL
;

5594 
	}
}

5596 #undef 
MAX_ROOM_NEEDED


5597 #undef 
TCHARS_PER_DCHAR


5598 #undef 
SNPRINTF


5599 #undef 
USE_SNPRINTF


5600 #undef 
DCHAR_SET


5601 #undef 
DCHAR_CPY


5602 #undef 
PRINTF_PARSE


5603 #undef 
DIRECTIVES


5604 #undef 
DIRECTIVE


5605 #undef 
DCHAR_IS_TCHAR


5606 #undef 
TCHAR_T


5607 #undef 
DCHAR_T


5608 #undef 
FCHAR_T


5609 #undef 
VASNPRINTF


	@gnulib-tests/vasnprintf.h

20 #ifndef 
_VASNPRINTF_H


21 #define 
	#_VASNPRINTF_H


	)

24 #include 
	~<stdarg.h
>

27 #include 
	~<stddef.h
>

35 #if 
__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 7)

36 #define 
	#_GL_ATTRIBUTE_FORMAT
(
spec
) 
	`__attribute__
 ((
__format__
 spec))

	)

38 #define 
	#_GL_ATTRIBUTE_FORMAT
(
spec
)

	)

41 #ifdef 
__cplusplus


69 #if 
REPLACE_VASNPRINTF


70 #define 
	#asnprintf
 
rpl_asnprintf


	)

71 #define 
	#vasnprintf
 
rpl_vasnprintf


	)

73 extern char * 
asnprintf
 (char *
resultbuf
, 
size_t
 *
lengthp
, const char *
format
, ...)

74 
_GL_ATTRIBUTE_FORMAT
 ((
__printf__
, 3, 4));

75 extern char * 
vasnprintf
 (char *
resultbuf
, 
size_t
 *
lengthp
, const char *
format
, 
va_list
 
args
)

76 
_GL_ATTRIBUTE_FORMAT
 ((
__printf__
, 3, 0));

78 #ifdef 
__cplusplus


	@gnulib-tests/xsize.h

21 #ifndef 
_XSIZE_H


22 #define 
	#_XSIZE_H


	)

25 #include 
	~<stddef.h
>

28 #include 
	~<limits.h
>

29 #if 
HAVE_STDINT_H


30 #include 
	~<stdint.h
>

50 #define 
	#xcast_size_t
(
N
) \

51 ((
N
) <= 
SIZE_MAX
 ? (
size_t
) (N) : SIZE_MAX)

	)

54 static 
inline
 
	gsize_t


55 #if 
__GNUC__
 >= 3

56 
__attribute__
 ((
__pure__
))

58 
	$xsum
 (
size_t
 
size1
, size_t 
size2
)

60 
size_t
 
sum
 = 
size1
 + 
size2
;

61 return (
sum
 >= 
size1
 ? sum : 
SIZE_MAX
);

62 
	}
}

65 static 
inline
 
	gsize_t


66 #if 
__GNUC__
 >= 3

67 
__attribute__
 ((
__pure__
))

69 
	$xsum3
 (
size_t
 
size1
, size_t 
size2
, size_t 
size3
)

71 return 
	`xsum
 (xsum (
size1
, 
size2
), 
size3
);

72 
	}
}

75 static 
inline
 
	gsize_t


76 #if 
__GNUC__
 >= 3

77 
__attribute__
 ((
__pure__
))

79 
	$xsum4
 (
size_t
 
size1
, size_t 
size2
, size_t 
size3
, size_t 
size4
)

81 return 
	`xsum
 (xsum (xsum (
size1
, 
size2
), 
size3
), 
size4
);

82 
	}
}

85 static 
inline
 
	gsize_t


86 #if 
__GNUC__
 >= 3

87 
__attribute__
 ((
__pure__
))

89 
	$xmax
 (
size_t
 
size1
, size_t 
size2
)

93 return (
size1
 >= 
size2
 ? size1 : size2);

94 
	}
}

100 #define 
	#xtimes
(
N
, 
ELSIZE
) \

101 ((
N
) <= 
SIZE_MAX
 / (
ELSIZE
) ? (
size_t
) (N) * (ELSIZE) : SIZE_MAX)

	)

104 #define 
	#size_overflow_p
(
SIZE
) \

105 ((
SIZE
) == 
SIZE_MAX
)

	)

107 #define 
	#size_in_bounds_p
(
SIZE
) \

108 ((
SIZE
) != 
SIZE_MAX
)

	)

	@gnulib-tests/zerosize-ptr.h

23 #include 
	~<stdlib.h
>

29 #if 
HAVE_SYS_MMAN_H
 && 
HAVE_MPROTECT


30 #include 
	~<fcntl.h
>

31 #include 
	~<unistd.h
>

32 #include 
	~<sys/types.h
>

33 #include 
	~<sys/mman.h
>

35 #ifndef 
MAP_FILE


36 #define 
	#MAP_FILE
 0

	)

46 
	$zerosize_ptr
 (void)

50 #if 
HAVE_SYS_MMAN_H
 && 
HAVE_MPROTECT


51 #if 
HAVE_MAP_ANONYMOUS


52 const int 
flags
 = 
MAP_ANONYMOUS
 | 
MAP_PRIVATE
;

53 const int 
fd
 = -1;

55 const int 
flags
 = 
MAP_FILE
 | 
MAP_PRIVATE
;

56 int 
fd
 = 
	`open
 ("/dev/zero", 
O_RDONLY
, 0666);

57 if (
fd
 >= 0)

60 int 
pagesize
 = 
	`getpagesize
 ();

61 char *
two_pages
 =

62 (char *) 
	`mmap
 (
NULL
, 2 * 
pagesize
, 
PROT_READ
 | 
PROT_WRITE
,

63 
flags
, 
fd
, 0);

64 if (
two_pages
 != (char *)(-1)

65 && 
	`mprotect
 (
two_pages
 + 
pagesize
, pagesize, 
PROT_NONE
) == 0)

66 return 
two_pages
 + 
pagesize
;

69 return 
NULL
;

70 
	}
}

	@lib/alloca.c

26 #include 
	~<config.h
>

28 #include 
	~<alloca.h
>

30 #include 
	~<string.h
>

31 #include 
	~<stdlib.h
>

33 #ifdef 
emacs


34 #include 
	~"lisp.h
"

35 #include 
	~"blockinput.h
"

36 #ifdef 
EMACS_FREE


37 #undef 
free


38 #define 
	#free
 
EMACS_FREE


	)

41 #define 
	#memory_full
() 
	`abort
 ()

	)

45 #if !
defined
 (
__GNUC__
) || __GNUC__ < 2

49 #ifndef 
alloca


51 #ifdef 
emacs


57 #ifndef 
STACK_DIRECTION


58 
you


59 
	glose


60 -- 
must
 
know
 
STACK_DIRECTION
 
at
 
	gcompile
-
	gtime


70 #if 
defined
 (
CRAY
) && defined (
CRAY_STACKSEG_END
)

71 long 
i00afunc
 ();

72 #define 
	#ADDRESS_FUNCTION
(
arg
) (char *) 
	`i00afunc
 (&(arg))

	)

74 #define 
	#ADDRESS_FUNCTION
(
arg
) &(arg)

	)

85 #ifndef 
STACK_DIRECTION


86 #define 
	#STACK_DIRECTION
 0

	)

89 #if 
STACK_DIRECTION
 != 0

91 #define 
	#STACK_DIR
 
STACK_DIRECTION


	)

95 static int 
	gstack_dir
;

96 #define 
	#STACK_DIR
 
stack_dir


	)

99 
	$find_stack_direction
 (int *
addr
, int 
depth
)

101 int 
dir
, 
dummy
 = 0;

102 if (! 
addr
)

103 
addr
 = &
dummy
;

104 *
addr
 = addr < &
dummy
 ? 1 : addr == &dummy ? 0 : -1;

105 
dir
 = 
depth
 ? 
	`find_stack_direction
 (
addr
, depth - 1) : 0;

106 return 
dir
 + 
dummy
;

107 
	}
}

118 #ifndef 
ALIGN_SIZE


119 #define 
	#ALIGN_SIZE
 sizeof(double)

	)

122 typedef union 
	uhdr


124 char 
	malign
[
ALIGN_SIZE
];

127 union 
hdr
 *
	mnext
;

128 char *
	mdeep
;

129 } 
	mh
;

130 } 
	theader
;

132 static 
header
 *
	glast_alloca_header
 = 
NULL
;

142 
	$alloca
 (
size_t
 
size
)

144 auto char 
probe
;

145 register char *
depth
 = 
	`ADDRESS_FUNCTION
 (
probe
);

147 #if 
STACK_DIRECTION
 == 0

148 if (
STACK_DIR
 == 0)

149 
STACK_DIR
 = 
	`find_stack_direction
 (
NULL
, (
size
 & 1) + 20);

156 register 
header
 *
hp
;

158 #ifdef 
emacs


159 
BLOCK_INPUT
;

162 for (
hp
 = 
last_alloca_header
; hp != 
NULL
;)

163 if ((
STACK_DIR
 > 0 && 
hp
->
h
.
deep
 > 
depth
)

164 || (
STACK_DIR
 < 0 && 
hp
->
h
.
deep
 < 
depth
))

166 register 
header
 *
np
 = 
hp
->
h
.
next
;

168 
	`free
 (
hp
);

170 
hp
 = 
np
;

175 
last_alloca_header
 = 
hp
;

177 #ifdef 
emacs


178 
UNBLOCK_INPUT
;

182 if (
size
 == 0)

183 return 
NULL
;

189 register 
header
 *
new
;

191 
size_t
 
combined_size
 = sizeof (
header
) + 
size
;

192 if (
combined_size
 < sizeof (
header
))

193 
	`memory_full
 ();

195 
new
 = 
	`malloc
 (
combined_size
);

197 if (! 
new
)

198 
	`memory_full
 ();

200 
new
->
h
.
next
 = 
last_alloca_header
;

201 
new
->
h
.
deep
 = 
depth
;

203 
last_alloca_header
 = 
new
;

207 return (void *) (
new
 + 1);

209 
	}
}

211 #if 
defined
 (
CRAY
) && defined (
CRAY_STACKSEG_END
)

213 #ifdef 
DEBUG_I00AFUNC


214 #include 
	~<stdio.h
>

217 #ifndef 
CRAY_STACK


218 #define 
	#CRAY_STACK


	)

219 #ifndef 
CRAY2


221 struct 
	sstack_control_header


223 long 
	mshgrow
:32;

224 long 
	mshaseg
:32;

225 long 
	mshhwm
:32;

226 long 
	mshsize
:32;

236 struct 
	sstack_segment_linkage


238 long 
	mss
[0200];

239 long 
	msssize
:32;

240 long 
	mssbase
:32;

242 long 
	msspseg
:32;

245 long 
	msstcpt
:32;

246 long 
	msscsnm
;

248 long 
	mssusr1
;

249 long 
	mssusr2
;

250 long 
	msstpid
;

251 long 
	mssgvup
;

252 long 
	msscray
[7];

253 long 
	mssa0
;

254 long 
	mssa1
;

255 long 
	mssa2
;

256 long 
	mssa3
;

257 long 
	mssa4
;

258 long 
	mssa5
;

259 long 
	mssa6
;

260 long 
	mssa7
;

261 long 
	msss0
;

262 long 
	msss1
;

263 long 
	msss2
;

264 long 
	msss3
;

265 long 
	msss4
;

266 long 
	msss5
;

267 long 
	msss6
;

268 long 
	msss7
;

274 struct 
	sstk_stat


276 long 
	mnow
;

277 long 
	mmaxc
;

280 long 
	mhigh_water
;

281 long 
	moverflows
;

282 long 
	mhits
;

283 long 
	mextends
;

284 long 
	mstko_mallocs
;

285 long 
	munderflows
;

286 long 
	mstko_free
;

287 long 
	mstkm_free
;

288 long 
	msegments
;

289 long 
	mmaxs
;

290 long 
	mpad_size
;

291 long 
	mcurrent_address
;

292 long 
	mcurrent_size
;

295 long 
	minitial_address
;

296 long 
	minitial_size
;

303 struct 
	sstk_trailer


305 long 
	mthis_address
;

306 long 
	mthis_size
;

308 long 
	munknown2
;

309 long 
	munknown3
;

310 long 
	mlink
;

312 long 
	munknown5
;

313 long 
	munknown6
;

314 long 
	munknown7
;

315 long 
	munknown8
;

316 long 
	munknown9
;

317 long 
	munknown10
;

318 long 
	munknown11
;

319 long 
	munknown12
;

320 long 
	munknown13
;

321 long 
	munknown14
;

327 #ifdef 
CRAY2


332 
	$i00afunc
 (long *
address
)

334 struct 
stk_stat
 
status
;

335 struct 
stk_trailer
 *
trailer
;

336 long *
block
, 
size
;

337 long 
result
 = 0;

344 
	`STKSTAT
 (&
status
);

348 
trailer
 = (struct 
stk_trailer
 *) (
status
.
current_address


349 + 
status
.
current_size


355 if (
trailer
 == 0)

356 
	`abort
 ();

360 while (
trailer
 != 0)

362 
block
 = (long *) 
trailer
->
this_address
;

363 
size
 = 
trailer
->
this_size
;

364 if (
block
 == 0 || 
size
 == 0)

365 
	`abort
 ();

366 
trailer
 = (struct 
stk_trailer
 *) trailer->
link
;

367 if ((
block
 <= 
address
) && (address < (block + 
size
)))

374 
result
 = 
address
 - 
block
;

376 if (
trailer
 == 0)

378 return 
result
;

383 if (
trailer
->
this_size
 <= 0)

384 
	`abort
 ();

385 
result
 += 
trailer
->
this_size
;

386 
trailer
 = (struct 
stk_trailer
 *) trailer->
link
;

388 while (
trailer
 != 0);

395 return (
result
);

396 
	}
}

406 
	$i00afunc
 (long 
address
)

408 long 
stkl
 = 0;

410 long 
size
, 
pseg
, 
this_segment
, 
stack
;

411 long 
result
 = 0;

413 struct 
stack_segment_linkage
 *
ssptr
;

423 
stkl
 = 
	`CRAY_STACKSEG_END
 ();

424 
ssptr
 = (struct 
stack_segment_linkage
 *) 
stkl
;

432 
pseg
 = 
ssptr
->
sspseg
;

433 
size
 = 
ssptr
->
sssize
;

435 
this_segment
 = 
stkl
 - 
size
;

441 while (!(
this_segment
 <= 
address
 && address <= 
stkl
))

443 #ifdef 
DEBUG_I00AFUNC


444 
	`fprintf
 (
stderr
, "%011o %011o %011o\n", 
this_segment
, 
address
, 
stkl
);

446 if (
pseg
 == 0)

448 
stkl
 = stkl - 
pseg
;

449 
ssptr
 = (struct 
stack_segment_linkage
 *) 
stkl
;

450 
size
 = 
ssptr
->
sssize
;

451 
pseg
 = 
ssptr
->
sspseg
;

452 
this_segment
 = 
stkl
 - 
size
;

455 
result
 = 
address
 - 
this_segment
;

462 while (
pseg
 != 0)

464 #ifdef 
DEBUG_I00AFUNC


465 
	`fprintf
 (
stderr
, "%011o %011o\n", 
pseg
, 
size
);

467 
stkl
 = stkl - 
pseg
;

468 
ssptr
 = (struct 
stack_segment_linkage
 *) 
stkl
;

469 
size
 = 
ssptr
->
sssize
;

470 
pseg
 = 
ssptr
->
sspseg
;

471 
result
 += 
size
;

473 return (
result
);

474 
	}
}

	@lib/alloca.in.h

25 #ifndef 
_GL_ALLOCA_H


26 #define 
	#_GL_ALLOCA_H


	)

39 #ifndef 
alloca


40 #ifdef 
__GNUC__


41 #define 
	#alloca
 
__builtin_alloca


	)

42 #elif 
defined
 
_AIX


43 #define 
	#alloca
 
__alloca


	)

44 #elif 
defined
 
_MSC_VER


45 #include 
	~<malloc.h
>

46 #define 
	#alloca
 
_alloca


	)

47 #elif 
defined
 
__DECC
 && defined 
__VMS


48 #define 
	#alloca
 
__ALLOCA


	)

50 #include 
	~<stddef.h
>

51 #ifdef 
__cplusplus


54 void *
alloca
 (
size_t
);

	@lib/argmatch.c

22 #include 
	~<config.h
>

25 #include 
	~"argmatch.h
"

27 #include 
	~<stdbool.h
>

28 #include 
	~<stdio.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

32 #include 
	~"gettext.h
"

33 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

35 #include 
	~"error.h
"

36 #include 
	~"quotearg.h
"

37 #include 
	~"quote.h
"

39 #if 
USE_UNLOCKED_IO


40 #include 
	~"unlocked-io.h
"

46 #ifndef 
ARGMATCH_QUOTING_STYLE


47 #define 
	#ARGMATCH_QUOTING_STYLE
 
locale_quoting_style


	)

51 #ifndef 
ARGMATCH_DIE


52 #include 
	~"exitfail.h
"

53 #define 
	#ARGMATCH_DIE
 
	`exit
 (
exit_failure
)

	)

56 #ifdef 
ARGMATCH_DIE_DECL


57 
	gARGMATCH_DIE_DECL
;

61 
	$__argmatch_die
 (void)

63 
ARGMATCH_DIE
;

64 
	}
}

68 
argmatch_exit_fn
 
	gargmatch_die
 = 
__argmatch_die
;

82 
ptrdiff_t


83 
	$argmatch
 (const char *
arg
, const char *const *
arglist
,

84 const char *
vallist
, 
size_t
 
valsize
)

86 
size_t
 
i
;

87 
size_t
 
arglen
;

88 
ptrdiff_t
 
matchind
 = -1;

89 
bool
 
ambiguous
 = 
false
;

91 
arglen
 = 
	`strlen
 (
arg
);

94 for (
i
 = 0; 
arglist
[i]; i++)

96 if (!
	`strncmp
 (
arglist
[
i
], 
arg
, 
arglen
))

98 if (
	`strlen
 (
arglist
[
i
]) == 
arglen
)

100 return 
i
;

101 else if (
matchind
 == -1)

103 
matchind
 = 
i
;

107 if (
vallist
 == 
NULL


108 || 
	`memcmp
 (
vallist
 + 
valsize
 * 
matchind
,

109 
vallist
 + 
valsize
 * 
i
, valsize))

113 
ambiguous
 = 
true
;

118 if (
ambiguous
)

121 return 
matchind
;

122 
	}
}

130 
	$argmatch_invalid
 (const char *
context
, const char *
value
, 
ptrdiff_t
 
problem
)

132 char const *
format
 = (
problem
 == -1

133 ? 
	`_
("invalid argument %s for %s")

134 : 
	`_
("ambiguous argument %s for %s"));

136 
	`error
 (0, 0, 
format
, 
	`quotearg_n_style
 (0, 
ARGMATCH_QUOTING_STYLE
, 
value
),

137 
	`quote_n
 (1, 
context
));

138 
	}
}

145 
	$argmatch_valid
 (const char *const *
arglist
,

146 const char *
vallist
, 
size_t
 
valsize
)

148 
size_t
 
i
;

149 const char *
last_val
 = 
NULL
;

153 
	`fprintf
 (
stderr
, 
	`_
("Valid arguments are:"));

154 for (
i
 = 0; 
arglist
[i]; i++)

155 if ((
i
 == 0)

156 || 
	`memcmp
 (
last_val
, 
vallist
 + 
valsize
 * 
i
, valsize))

158 
	`fprintf
 (
stderr
, "\n - `%s'", 
arglist
[
i
]);

159 
last_val
 = 
vallist
 + 
valsize
 * 
i
;

163 
	`fprintf
 (
stderr
, ", `%s'", 
arglist
[
i
]);

165 
	`putc
 ('\n', 
stderr
);

166 
	}
}

174 
ptrdiff_t


175 
	$__xargmatch_internal
 (const char *
context
,

176 const char *
arg
, const char *const *
arglist
,

177 const char *
vallist
, 
size_t
 
valsize
,

178 
argmatch_exit_fn
 
exit_fn
)

180 
ptrdiff_t
 
res
 = 
	`argmatch
 (
arg
, 
arglist
, 
vallist
, 
valsize
);

181 if (
res
 >= 0)

183 return 
res
;

186 
	`argmatch_invalid
 (
context
, 
arg
, 
res
);

187 
	`argmatch_valid
 (
arglist
, 
vallist
, 
valsize
);

188 (*
exit_fn
) ();

191 
	}
}

196 
	$argmatch_to_argument
 (const char *
value
,

197 const char *const *
arglist
,

198 const char *
vallist
, 
size_t
 
valsize
)

200 
size_t
 
i
;

202 for (
i
 = 0; 
arglist
[i]; i++)

203 if (!
	`memcmp
 (
value
, 
vallist
 + 
valsize
 * 
i
, valsize))

204 return 
arglist
[
i
];

205 return 
NULL
;

206 
	}
}

208 #ifdef 
TEST


212 char *
	gprogram_name
;

215 enum 
	ebackup_type


218 
	mno_backups
,

221 
	msimple_backups
,

225 
	mnumbered_existing_backups
,

228 
	mnumbered_backups


233 static const char *const 
	gbackup_args
[] =

242 static const enum 
backup_type
 
	gbackup_vals
[] =

244 
no_backups
, no_backups, no_backups,

245 
simple_backups
, simple_backups,

246 
numbered_existing_backups
, numbered_existing_backups,

247 
numbered_backups
, numbered_backups

251 
	$main
 (int 
argc
, const char *const *
argv
)

253 const char *
cp
;

254 enum 
backup_type
 backup_type = 
no_backups
;

256 
program_name
 = (char *) 
argv
[0];

258 if (
argc
 > 2)

260 
	`fprintf
 (
stderr
, "Usage: %s [VERSION_CONTROL]\n", 
program_name
);

261 
	`exit
 (1);

264 if ((
cp
 = 
	`getenv
 ("VERSION_CONTROL")))

265 
backup_type
 = 
	`XARGMATCH
 ("$VERSION_CONTROL", 
cp
,

266 
backup_args
, 
backup_vals
);

268 if (
argc
 == 2)

269 
backup_type
 = 
	`XARGMATCH
 (
program_name
, 
argv
[1],

270 
backup_args
, 
backup_vals
);

272 
	`printf
 ("The version control is `%s'\n",

273 
	`ARGMATCH_TO_ARGUMENT
 (
backup_type
, 
backup_args
, 
backup_vals
));

276 
	}
}

	@lib/argmatch.h

22 #ifndef 
ARGMATCH_H_


23 #define 
	#ARGMATCH_H_
 1

	)

25 #include 
	~<stddef.h
>

27 #include 
	~"verify.h
"

29 #define 
	#ARRAY_CARDINALITY
(
Array
) (sizeof (Array) / sizeof *(Array))

	)

34 #define 
	#ARGMATCH_VERIFY
(
Arglist
, 
Vallist
) \

35 
	`verify
 (
	`ARRAY_CARDINALITY
 (
Arglist
) == ARRAY_CARDINALITY (
Vallist
) + 1)

	)

42 
ptrdiff_t
 
argmatch
 (char const *
arg
, char const *const *
arglist
,

43 char const *
vallist
, 
size_t
 
valsize
);

45 #define 
	#ARGMATCH
(
Arg
, 
Arglist
, 
Vallist
) \

46 
	`argmatch
 (
Arg
, 
Arglist
, (char const *) (
Vallist
), sizeof *(Vallist))

	)

51 typedef void (*
	targmatch_exit_fn
) (void);

52 extern 
argmatch_exit_fn
 
argmatch_die
;

56 void 
	`argmatch_invalid
 (char const *
context
, char const *
value
,

57 
ptrdiff_t
 
problem
);

61 #define 
	#invalid_arg
(
Context
, 
Value
, 
Problem
) \

62 
	`argmatch_invalid
 (
Context
, 
Value
, 
Problem
)

	)

68 void 
	`argmatch_valid
 (char const *const *
arglist
,

69 char const *
vallist
, 
size_t
 
valsize
);

71 #define 
	#ARGMATCH_VALID
(
Arglist
, 
Vallist
) \

72 
	`argmatch_valid
 (
Arglist
, (char const *) (
Vallist
), sizeof *(Vallist))

	)

79 
ptrdiff_t
 
	`__xargmatch_internal
 (char const *
context
,

80 char const *
arg
, char const *const *
arglist
,

81 char const *
vallist
, 
size_t
 
valsize
,

82 
argmatch_exit_fn
 
exit_fn
);

86 #define 
	#XARGMATCH
(
Context
, 
Arg
, 
Arglist
, 
Vallist
) \

87 ((
Vallist
) [
	`__xargmatch_internal
 (
Context
, 
Arg
, 
Arglist
, \

88 (char const *) (
Vallist
), \

89 sizeof *(
Vallist
), \

90 
argmatch_die
)])

	)

94 char const *
	`argmatch_to_argument
 (char const *
value
,

95 char const *const *
arglist
,

96 char const *
vallist
, 
size_t
 
valsize
);

98 #define 
	#ARGMATCH_TO_ARGUMENT
(
Value
, 
Arglist
, 
Vallist
) \

99 
	`argmatch_to_argument
 (
Value
, 
Arglist
, \

100 (char const *) (
Vallist
), sizeof *(Vallist))

	)

	@lib/basename-lgpl.c

19 #include 
	~<config.h
>

21 #include 
	~"dirname.h
"

23 #include 
	~<string.h
>

30 
	$last_component
 (char const *
name
)

32 char const *
base
 = 
name
 + 
	`FILE_SYSTEM_PREFIX_LEN
 (name);

33 char const *
p
;

34 
bool
 
saw_slash
 = 
false
;

36 while (
	`ISSLASH
 (*
base
))

37 
base
++;

39 for (
p
 = 
base
; *p; p++)

41 if (
	`ISSLASH
 (*
p
))

42 
saw_slash
 = 
true
;

43 else if (
saw_slash
)

45 
base
 = 
p
;

46 
saw_slash
 = 
false
;

50 return (char *) 
base
;

51 
	}
}

57 
size_t


58 
	$base_len
 (char const *
name
)

60 
size_t
 
len
;

61 
size_t
 
prefix_len
 = 
	`FILE_SYSTEM_PREFIX_LEN
 (
name
);

63 for (
len
 = 
	`strlen
 (
name
); 1 < len && 
	`ISSLASH
 (name[len - 1]); len--)

66 if (
DOUBLE_SLASH_IS_DISTINCT_ROOT
 && 
len
 == 1

67 && 
	`ISSLASH
 (
name
[0]) && ISSLASH (name[1]) && ! name[2])

70 if (
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
 && 
prefix_len


71 && 
len
 == 
prefix_len
 && 
	`ISSLASH
 (
name
[prefix_len]))

72 return 
prefix_len
 + 1;

74 return 
len
;

75 
	}
}

	@lib/basename.c

19 #include 
	~<config.h
>

21 #include 
	~"dirname.h
"

23 #include 
	~<string.h
>

24 #include 
	~"xalloc.h
"

25 #include 
	~"xstrndup.h
"

28 
	$base_name
 (char const *
name
)

30 char const *
base
 = 
	`last_component
 (
name
);

31 
size_t
 
length
;

35 if (! *
base
)

36 return 
	`xstrndup
 (
name
, 
	`base_len
 (name));

39 
length
 = 
	`base_len
 (
base
);

40 if (
	`ISSLASH
 (
base
[
length
]))

41 
length
++;

46 if (
	`FILE_SYSTEM_PREFIX_LEN
 (
base
))

48 char *
p
 = 
	`xmalloc
 (
length
 + 3);

49 
p
[0] = '.';

50 
p
[1] = '/';

51 
	`memcpy
 (
p
 + 2, 
base
, 
length
);

52 
p
[
length
 + 2] = '\0';

53 return 
p
;

57 return 
	`xstrndup
 (
base
, 
length
);

58 
	}
}

	@lib/binary-io.h

17 #ifndef 
_BINARY_H


18 #define 
	#_BINARY_H


	)

22 #include 
	~<fcntl.h
>

26 #include 
	~<stdio.h
>

30 #if 
O_BINARY


31 #if 
defined
 
__EMX__
 || defined 
__DJGPP__
 || defined 
__CYGWIN__


32 #include 
	~<io.h
>

34 #define 
	#setmode
 
_setmode


	)

35 #undef 
fileno


36 #define 
	#fileno
 
_fileno


	)

38 #ifdef 
__DJGPP__


39 #include 
	~<unistd.h
>

43 #define 
	#SET_BINARY
(
fd
) ((void) (!
	`isatty
 (fd) ? (
	`setmode
 (fd, 
O_BINARY
), 0) : 0))

	)

45 #define 
	#SET_BINARY
(
fd
) ((void) 
	`setmode
 (fd, 
O_BINARY
))

	)

49 #define 
	#SET_BINARY
(
fd
) ((void) 0)

	)

	@lib/bitrotate.h

19 #ifndef 
_GL_BITROTATE_H


20 #define 
	#_GL_BITROTATE_H


	)

22 #include 
	~<limits.h
>

23 #include 
	~<stdint.h
>

24 #include 
	~<sys/types.h
>

26 #ifdef 
UINT64_MAX


30 static 
inline
 
uint64_t


31 
	$rotl64
 (
uint64_t
 
x
, int 
n
)

33 return ((
x
 << 
n
) | (x >> (64 - n))) & 
UINT64_MAX
;

34 
	}
}

39 static 
inline
 
uint64_t


40 
	$rotr64
 (
uint64_t
 
x
, int 
n
)

42 return ((
x
 >> 
n
) | (x << (64 - n))) & 
UINT64_MAX
;

43 
	}
}

49 static 
inline
 
uint32_t


50 
	$rotl32
 (
uint32_t
 
x
, int 
n
)

52 return ((
x
 << 
n
) | (x >> (32 - n))) & 
UINT32_MAX
;

53 
	}
}

58 static 
inline
 
uint32_t


59 
	$rotr32
 (
uint32_t
 
x
, int 
n
)

61 return ((
x
 >> 
n
) | (x << (32 - n))) & 
UINT32_MAX
;

62 
	}
}

67 static 
inline
 
size_t


68 
	$rotl_sz
 (
size_t
 
x
, int 
n
)

70 return ((
x
 << 
n
) | (x >> ((
CHAR_BIT
 * sizeof x) - n))) & 
SIZE_MAX
;

71 
	}
}

76 static 
inline
 
size_t


77 
	$rotr_sz
 (
size_t
 
x
, int 
n
)

79 return ((
x
 >> 
n
) | (x << ((
CHAR_BIT
 * sizeof x) - n))) & 
SIZE_MAX
;

80 
	}
}

87 static 
inline
 
uint16_t


88 
	$rotl16
 (
uint16_t
 
x
, int 
n
)

90 return ((
x
 << 
n
) | (x >> (16 - n))) & 
UINT16_MAX
;

91 
	}
}

98 static 
inline
 
uint16_t


99 
	$rotr16
 (
uint16_t
 
x
, int 
n
)

101 return ((
x
 >> 
n
) | (x << (16 - n))) & 
UINT16_MAX
;

102 
	}
}

109 static 
inline
 
uint8_t


110 
	$rotl8
 (
uint8_t
 
x
, int 
n
)

112 return ((
x
 << 
n
) | (x >> (8 - n))) & 
UINT8_MAX
;

113 
	}
}

120 static 
inline
 
uint8_t


121 
	$rotr8
 (
uint8_t
 
x
, int 
n
)

123 return ((
x
 >> 
n
) | (x << (8 - n))) & 
UINT8_MAX
;

124 
	}
}

	@lib/btowc.c

18 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #include 
	~<stdio.h
>

24 #include 
	~<stdlib.h
>

26 
wint_t


27 
	$btowc
 (int 
c
)

29 if (
c
 != 
EOF
)

31 char 
buf
[1];

32 
wchar_t
 
wc
;

34 
buf
[0] = 
c
;

35 if (
	`mbtowc
 (&
wc
, 
buf
, 1) >= 0)

36 return 
wc
;

38 return 
WEOF
;

39 
	}
}

	@lib/c-ctype.c

21 #include 
	~<config.h
>

24 #define 
	#NO_C_CTYPE_MACROS


	)

25 #include 
	~"c-ctype.h
"

29 
bool


30 
	$c_isascii
 (int 
c
)

32 return (
c
 >= 0x00 && c <= 0x7f);

33 
	}
}

35 
bool


36 
	$c_isalnum
 (int 
c
)

38 #if 
C_CTYPE_CONSECUTIVE_DIGITS
 \

39 && 
C_CTYPE_CONSECUTIVE_UPPERCASE
 && 
C_CTYPE_CONSECUTIVE_LOWERCASE


40 #if 
C_CTYPE_ASCII


41 return ((
c
 >= '0' && c <= '9')

42 || ((
c
 & ~0x20) >= 'A' && (c & ~0x20) <= 'Z'));

44 return ((
c
 >= '0' && c <= '9')

45 || (
c
 >= 'A' && c <= 'Z')

46 || (
c
 >= 'a' && c <= 'z'));

49 switch (
c
)

68 
	}
}

70 
bool


71 
	$c_isalpha
 (int 
c
)

73 #if 
C_CTYPE_CONSECUTIVE_UPPERCASE
 && 
C_CTYPE_CONSECUTIVE_LOWERCASE


74 #if 
C_CTYPE_ASCII


75 return ((
c
 & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');

77 return ((
c
 >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));

80 switch (
c
)

97 
	}
}

99 
bool


100 
	$c_isblank
 (int 
c
)

102 return (
c
 == ' ' || c == '\t');

103 
	}
}

105 
bool


106 
	$c_iscntrl
 (int 
c
)

108 #if 
C_CTYPE_ASCII


109 return ((
c
 & ~0x1f) == 0 || c == 0x7f);

111 switch (
c
)

137 
	}
}

139 
bool


140 
	$c_isdigit
 (int 
c
)

142 #if 
C_CTYPE_CONSECUTIVE_DIGITS


143 return (
c
 >= '0' && c <= '9');

145 switch (
c
)

154 
	}
}

156 
bool


157 
	$c_islower
 (int 
c
)

159 #if 
C_CTYPE_CONSECUTIVE_LOWERCASE


160 return (
c
 >= 'a' && c <= 'z');

162 switch (
c
)

174 
	}
}

176 
bool


177 
	$c_isgraph
 (int 
c
)

179 #if 
C_CTYPE_ASCII


180 return (
c
 >= '!' && c <= '~');

182 switch (
c
)

208 
	}
}

210 
bool


211 
	$c_isprint
 (int 
c
)

213 #if 
C_CTYPE_ASCII


214 return (
c
 >= ' ' && c <= '~');

216 switch (
c
)

242 
	}
}

244 
bool


245 
	$c_ispunct
 (int 
c
)

247 #if 
C_CTYPE_ASCII


248 return ((
c
 >= '!' && c <= '~')

249 && !((
c
 >= '0' && c <= '9')

250 || ((
c
 & ~0x20) >= 'A' && (c & ~0x20) <= 'Z')));

252 switch (
c
)

266 
	}
}

268 
bool


269 
	$c_isspace
 (int 
c
)

271 return (
c
 == ' ' || c == '\t'

272 || 
c
 == '\n' || c == '\v' || c == '\f' || c == '\r');

273 
	}
}

275 
bool


276 
	$c_isupper
 (int 
c
)

278 #if 
C_CTYPE_CONSECUTIVE_UPPERCASE


279 return (
c
 >= 'A' && c <= 'Z');

281 switch (
c
)

293 
	}
}

295 
bool


296 
	$c_isxdigit
 (int 
c
)

298 #if 
C_CTYPE_CONSECUTIVE_DIGITS
 \

299 && 
C_CTYPE_CONSECUTIVE_UPPERCASE
 && 
C_CTYPE_CONSECUTIVE_LOWERCASE


300 #if 
C_CTYPE_ASCII


301 return ((
c
 >= '0' && c <= '9')

302 || ((
c
 & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));

304 return ((
c
 >= '0' && c <= '9')

305 || (
c
 >= 'A' && c <= 'F')

306 || (
c
 >= 'a' && c <= 'f'));

309 switch (
c
)

320 
	}
}

323 
	$c_tolower
 (int 
c
)

325 #if 
C_CTYPE_CONSECUTIVE_UPPERCASE
 && 
C_CTYPE_CONSECUTIVE_LOWERCASE


326 return (
c
 >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);

328 switch (
c
)

356 default: return 
c
;

359 
	}
}

362 
	$c_toupper
 (int 
c
)

364 #if 
C_CTYPE_CONSECUTIVE_UPPERCASE
 && 
C_CTYPE_CONSECUTIVE_LOWERCASE


365 return (
c
 >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);

367 switch (
c
)

395 default: return 
c
;

398 
	}
}

	@lib/c-ctype.h

26 #ifndef 
C_CTYPE_H


27 #define 
	#C_CTYPE_H


	)

29 #include 
	~<stdbool.h
>

32 #ifdef 
__cplusplus


49 #define 
	#C_CTYPE_CONSECUTIVE_DIGITS
 1

	)

61 #define 
	#C_CTYPE_CONSECUTIVE_UPPERCASE
 1

	)

74 #define 
	#C_CTYPE_CONSECUTIVE_LOWERCASE
 1

	)

102 #define 
	#C_CTYPE_ASCII
 1

	)

123 extern 
bool
 
c_isascii
 (int 
c
);

125 extern 
bool
 
c_isalnum
 (int 
c
);

126 extern 
bool
 
c_isalpha
 (int 
c
);

127 extern 
bool
 
c_isblank
 (int 
c
);

128 extern 
bool
 
c_iscntrl
 (int 
c
);

129 extern 
bool
 
c_isdigit
 (int 
c
);

130 extern 
bool
 
c_islower
 (int 
c
);

131 extern 
bool
 
c_isgraph
 (int 
c
);

132 extern 
bool
 
c_isprint
 (int 
c
);

133 extern 
bool
 
c_ispunct
 (int 
c
);

134 extern 
bool
 
c_isspace
 (int 
c
);

135 extern 
bool
 
c_isupper
 (int 
c
);

136 extern 
bool
 
c_isxdigit
 (int 
c
);

138 extern int 
c_tolower
 (int 
c
);

139 extern int 
c_toupper
 (int 
c
);

142 #if 
defined
 
__GNUC__
 && defined 
__OPTIMIZE__
 && !defined 
__OPTIMIZE_SIZE__
 && !defined 
NO_C_CTYPE_MACROS


146 #undef 
c_isascii


147 #define 
	#c_isascii
(
c
) \

148 ({ int 
__c
 = (
c
); \

149 (
__c
 >= 0x00 && __c <= 0x7f); \

150 })

	)

152 #if 
C_CTYPE_CONSECUTIVE_DIGITS
 \

153 && 
	gC_CTYPE_CONSECUTIVE_UPPERCASE
 && 
	gC_CTYPE_CONSECUTIVE_LOWERCASE


154 #if 
C_CTYPE_ASCII


155 #undef 
c_isalnum


156 #define 
	#c_isalnum
(
c
) \

157 ({ int 
__c
 = (
c
); \

158 ((
__c
 >= '0' && __c <= '9') \

159 || ((
__c
 & ~0x20) >= 'A' && (__c & ~0x20) <= 'Z')); \

160 })

	)

162 #undef 
c_isalnum


163 #define 
	#c_isalnum
(
c
) \

164 ({ int 
__c
 = (
c
); \

165 ((
__c
 >= '0' && __c <= '9') \

166 || (
__c
 >= 'A' && __c <= 'Z') \

167 || (
__c
 >= 'a' && __c <= 'z')); \

168 })

	)

172 #if 
C_CTYPE_CONSECUTIVE_UPPERCASE
 && 
C_CTYPE_CONSECUTIVE_LOWERCASE


173 #if 
C_CTYPE_ASCII


174 #undef 
c_isalpha


175 #define 
	#c_isalpha
(
c
) \

176 ({ int 
__c
 = (
c
); \

177 ((
__c
 & ~0x20) >= 'A' && (__c & ~0x20) <= 'Z'); \

178 })

	)

180 #undef 
c_isalpha


181 #define 
	#c_isalpha
(
c
) \

182 ({ int 
__c
 = (
c
); \

183 ((
__c
 >= 'A' && __c <= 'Z') || (__c >= 'a' && __c <= 'z')); \

184 })

	)

188 #undef 
c_isblank


189 #define 
	#c_isblank
(
c
) \

190 ({ int 
__c
 = (
c
); \

191 (
__c
 == ' ' || __c == '\t'); \

192 })

	)

194 #if 
C_CTYPE_ASCII


195 #undef 
c_iscntrl


196 #define 
	#c_iscntrl
(
c
) \

197 ({ int 
__c
 = (
c
); \

198 ((
__c
 & ~0x1f) == 0 || __c == 0x7f); \

199 })

	)

202 #if 
C_CTYPE_CONSECUTIVE_DIGITS


203 #undef 
c_isdigit


204 #define 
	#c_isdigit
(
c
) \

205 ({ int 
__c
 = (
c
); \

206 (
__c
 >= '0' && __c <= '9'); \

207 })

	)

210 #if 
C_CTYPE_CONSECUTIVE_LOWERCASE


211 #undef 
c_islower


212 #define 
	#c_islower
(
c
) \

213 ({ int 
__c
 = (
c
); \

214 (
__c
 >= 'a' && __c <= 'z'); \

215 })

	)

218 #if 
C_CTYPE_ASCII


219 #undef 
c_isgraph


220 #define 
	#c_isgraph
(
c
) \

221 ({ int 
__c
 = (
c
); \

222 (
__c
 >= '!' && __c <= '~'); \

223 })

	)

226 #if 
C_CTYPE_ASCII


227 #undef 
c_isprint


228 #define 
	#c_isprint
(
c
) \

229 ({ int 
__c
 = (
c
); \

230 (
__c
 >= ' ' && __c <= '~'); \

231 })

	)

234 #if 
C_CTYPE_ASCII


235 #undef 
c_ispunct


236 #define 
	#c_ispunct
(
c
) \

237 ({ int 
_c
 = (
c
); \

238 (
	`c_isgraph
 (
_c
) && ! 
	`c_isalnum
 (_c)); \

239 })

	)

242 #undef 
c_isspace


243 #define 
	#c_isspace
(
c
) \

244 ({ int 
__c
 = (
c
); \

245 (
__c
 == ' ' || __c == '\t' \

246 || 
__c
 == '\n' || __c == '\v' || __c == '\f' || __c == '\r'); \

247 })

	)

249 #if 
C_CTYPE_CONSECUTIVE_UPPERCASE


250 #undef 
c_isupper


251 #define 
	#c_isupper
(
c
) \

252 ({ int 
__c
 = (
c
); \

253 (
__c
 >= 'A' && __c <= 'Z'); \

254 })

	)

257 #if 
C_CTYPE_CONSECUTIVE_DIGITS
 \

258 && 
	gC_CTYPE_CONSECUTIVE_UPPERCASE
 && 
	gC_CTYPE_CONSECUTIVE_LOWERCASE


259 #if 
C_CTYPE_ASCII


260 #undef 
c_isxdigit


261 #define 
	#c_isxdigit
(
c
) \

262 ({ int 
__c
 = (
c
); \

263 ((
__c
 >= '0' && __c <= '9') \

264 || ((
__c
 & ~0x20) >= 'A' && (__c & ~0x20) <= 'F')); \

265 })

	)

267 #undef 
c_isxdigit


268 #define 
	#c_isxdigit
(
c
) \

269 ({ int 
__c
 = (
c
); \

270 ((
__c
 >= '0' && __c <= '9') \

271 || (
__c
 >= 'A' && __c <= 'F') \

272 || (
__c
 >= 'a' && __c <= 'f')); \

273 })

	)

277 #if 
C_CTYPE_CONSECUTIVE_UPPERCASE
 && 
C_CTYPE_CONSECUTIVE_LOWERCASE


278 #undef 
c_tolower


279 #define 
	#c_tolower
(
c
) \

280 ({ int 
__c
 = (
c
); \

281 (
__c
 >= 'A' && __c <= 'Z' ? __c - 'A' + 'a' : __c); \

282 })

	)

283 #undef 
c_toupper


284 #define 
	#c_toupper
(
c
) \

285 ({ int 
__c
 = (
c
); \

286 (
__c
 >= 'a' && __c <= 'z' ? __c - 'a' + 'A' : __c); \

287 })

	)

293 #ifdef 
__cplusplus


	@lib/c-strcase.h

21 #ifndef 
C_STRCASE_H


22 #define 
	#C_STRCASE_H


	)

24 #include 
	~<stddef.h
>

37 #ifdef 
__cplusplus


45 extern int 
c_strcasecmp
 (const char *
s1
, const char *
s2
);

50 extern int 
c_strncasecmp
 (const char *
s1
, const char *
s2
, 
size_t
 
n
);

53 #ifdef 
__cplusplus


	@lib/c-strcasecmp.c

20 #include 
	~<config.h
>

23 #include 
	~"c-strcase.h
"

25 #include 
	~<limits.h
>

27 #include 
	~"c-ctype.h
"

30 
	$c_strcasecmp
 (const char *
s1
, const char *
s2
)

32 register const unsigned char *
p1
 = (const unsigned char *) 
s1
;

33 register const unsigned char *
p2
 = (const unsigned char *) 
s2
;

34 unsigned char 
c1
, 
c2
;

36 if (
p1
 == 
p2
)

41 
c1
 = 
	`c_tolower
 (*
p1
);

42 
c2
 = 
	`c_tolower
 (*
p2
);

44 if (
c1
 == '\0')

47 ++
p1
;

48 ++
p2
;

50 while (
c1
 == 
c2
);

52 if (
UCHAR_MAX
 <= 
INT_MAX
)

53 return 
c1
 - 
c2
;

58 return (
c1
 > 
c2
 ? 1 : c1 < c2 ? -1 : 0);

59 
	}
}

	@lib/c-strncasecmp.c

20 #include 
	~<config.h
>

23 #include 
	~"c-strcase.h
"

25 #include 
	~<limits.h
>

27 #include 
	~"c-ctype.h
"

30 
	$c_strncasecmp
 (const char *
s1
, const char *
s2
, 
size_t
 
n
)

32 register const unsigned char *
p1
 = (const unsigned char *) 
s1
;

33 register const unsigned char *
p2
 = (const unsigned char *) 
s2
;

34 unsigned char 
c1
, 
c2
;

36 if (
p1
 == 
p2
 || 
n
 == 0)

41 
c1
 = 
	`c_tolower
 (*
p1
);

42 
c2
 = 
	`c_tolower
 (*
p2
);

44 if (--
n
 == 0 || 
c1
 == '\0')

47 ++
p1
;

48 ++
p2
;

50 while (
c1
 == 
c2
);

52 if (
UCHAR_MAX
 <= 
INT_MAX
)

53 return 
c1
 - 
c2
;

58 return (
c1
 > 
c2
 ? 1 : c1 < c2 ? -1 : 0);

59 
	}
}

	@lib/close-stream.c

18 #include 
	~<config.h
>

20 #include 
	~"close-stream.h
"

22 #include 
	~<errno.h
>

23 #include 
	~<stdbool.h
>

25 #include 
	~"fpending.h
"

27 #if 
USE_UNLOCKED_IO


28 #include 
	~"unlocked-io.h
"

56 
	$close_stream
 (
FILE
 *
stream
)

58 const 
bool
 
some_pending
 = (
	`__fpending
 (
stream
) != 0);

59 const 
bool
 
prev_fail
 = (
	`ferror
 (
stream
) != 0);

60 const 
bool
 
fclose_fail
 = (
	`fclose
 (
stream
) != 0);

70 if (
prev_fail
 || (
fclose_fail
 && (
some_pending
 || 
errno
 != 
EBADF
)))

72 if (! 
fclose_fail
)

73 
errno
 = 0;

74 return 
EOF
;

78 
	}
}

	@lib/close-stream.h

1 #include 
	~<stdio.h
>

2 int 
close_stream
 (
FILE
 *
stream
);

	@lib/closeout.c

19 #include 
	~<config.h
>

21 #include 
	~"closeout.h
"

23 #include 
	~<errno.h
>

24 #include 
	~<stdbool.h
>

25 #include 
	~<stdio.h
>

26 #include 
	~<unistd.h
>

28 #include 
	~"gettext.h
"

29 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

31 #include 
	~"close-stream.h
"

32 #include 
	~"error.h
"

33 #include 
	~"exitfail.h
"

34 #include 
	~"quotearg.h
"

36 static const char *
	gfile_name
;

41 
	$close_stdout_set_file_name
 (const char *
file
)

43 
file_name
 = 
file
;

44 
	}
}

46 static 
bool
 
	gignore_EPIPE
 ;

78 
	$close_stdout_set_ignore_EPIPE
 (
bool
 
ignore
)

80 
ignore_EPIPE
 = 
ignore
;

81 
	}
}

107 
	$close_stdout
 (void)

109 if (
	`close_stream
 (
stdout
) != 0

110 && !(
ignore_EPIPE
 && 
errno
 == 
EPIPE
))

112 char const *
write_error
 = 
	`_
("write error");

113 if (
file_name
)

114 
	`error
 (0, 
errno
, "%s: %s", 
	`quotearg_colon
 (
file_name
),

115 
write_error
);

117 
	`error
 (0, 
errno
, "%s", 
write_error
);

119 
	`_exit
 (
exit_failure
);

122 if (
	`close_stream
 (
stderr
) != 0)

123 
	`_exit
 (
exit_failure
);

124 
	}
}

	@lib/closeout.h

19 #ifndef 
CLOSEOUT_H


20 #define 
	#CLOSEOUT_H
 1

	)

22 #include 
	~<stdbool.h
>

24 #ifdef 
__cplusplus


28 void 
close_stdout_set_file_name
 (const char *
file
);

29 void 
close_stdout_set_ignore_EPIPE
 (
bool
 
ignore
);

30 void 
close_stdout
 (void);

32 #ifdef 
__cplusplus


	@lib/ctype.in.h

28 #ifndef 
_
@
GUARD_PREFIX
@
_CTYPE_H


30 #if 
__GNUC__
 >= 3

31 @
	gPRAGMA_SYSTEM_HEADER
@

33 @
	gPRAGMA_COLUMNS
@

37 #@
INCLUDE_NEXT
@ @
NEXT_CTYPE_H
@

39 #ifndef 
_
@
GUARD_PREFIX
@
_CTYPE_H


40 #define 
	#_
@
GUARD_PREFIX
@
_CTYPE_H


	)

47 #if @
GNULIB_ISBLANK
@

48 #if !@
HAVE_ISBLANK
@

49 
_GL_EXTERN_C
 int 
isblank
 (int 
c
);

51 #elif 
defined
 
GNULIB_POSIXCHECK


52 #undef 
isblank


53 #if 
HAVE_RAW_DECL_ISBLANK


54 
_GL_WARN_ON_USE
 (
isblank
, "isblank is unportable - "

	@lib/dirent.in.h

17 #ifndef 
_
@
GUARD_PREFIX
@
_DIRENT_H


19 #if 
__GNUC__
 >= 3

20 @
	gPRAGMA_SYSTEM_HEADER
@

22 @
	gPRAGMA_COLUMNS
@

25 #if @
HAVE_DIRENT_H
@

26 #@
INCLUDE_NEXT
@ @
NEXT_DIRENT_H
@

29 #ifndef 
_
@
GUARD_PREFIX
@
_DIRENT_H


30 #define 
	#_
@
GUARD_PREFIX
@
_DIRENT_H


	)

33 #include 
	~<sys/types.h
>

35 #if !@
HAVE_DIRENT_H
@

37 #if !
GNULIB_defined_struct_dirent


38 struct 
	sdirent


40 char 
	md_type
;

41 char 
	md_name
[1];

44 #define 
	#DT_UNKNOWN
 0

	)

45 #define 
	#DT_FIFO
 1

	)

46 #define 
	#DT_CHR
 2

	)

47 #define 
	#DT_DIR
 4

	)

48 #define 
	#DT_BLK
 6

	)

49 #define 
	#DT_REG
 8

	)

50 #define 
	#DT_LNK
 10

	)

51 #define 
	#DT_SOCK
 12

	)

52 #define 
	#DT_WHT
 14

	)

53 typedef struct 
gl_directory
 
	tDIR
;

54 #define 
	#GNULIB_defined_struct_dirent
 1

	)

67 #if @
GNULIB_OPENDIR
@

68 #if @
REPLACE_OPENDIR
@

69 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

70 #undef 
opendir


71 #define 
	#opendir
 
rpl_opendir


	)

73 
_GL_FUNCDECL_RPL
 (
opendir
, 
DIR
 *, (const char *
dir_name
) 
_GL_ARG_NONNULL
 ((1)));

74 
_GL_CXXALIAS_RPL
 (
opendir
, 
DIR
 *, (const char *
dir_name
));

76 #if !@
HAVE_OPENDIR
@

77 
_GL_FUNCDECL_SYS
 (
opendir
, 
DIR
 *, (const char *
dir_name
) 
_GL_ARG_NONNULL
 ((1)));

79 
_GL_CXXALIAS_SYS
 (
opendir
, 
DIR
 *, (const char *
dir_name
));

81 
_GL_CXXALIASWARN
 (
opendir
);

82 #elif 
defined
 
GNULIB_POSIXCHECK


83 #undef 
opendir


84 #if 
HAVE_RAW_DECL_OPENDIR


85 
_GL_WARN_ON_USE
 (
opendir
, "opendir is not portable - "

90 #if @
GNULIB_READDIR
@

91 #if !@
HAVE_READDIR
@

92 
_GL_FUNCDECL_SYS
 (
readdir
, struct 
dirent
 *, (
DIR
 *
dirp
) 
_GL_ARG_NONNULL
 ((1)));

94 
_GL_CXXALIAS_SYS
 (
readdir
, struct 
dirent
 *, (
DIR
 *
dirp
));

95 
_GL_CXXALIASWARN
 (
readdir
);

96 #elif 
defined
 
GNULIB_POSIXCHECK


97 #undef 
readdir


98 #if 
HAVE_RAW_DECL_READDIR


99 
_GL_WARN_ON_USE
 (
readdir
, "readdir is not portable - "

104 #if @
GNULIB_REWINDDIR
@

105 #if !@
HAVE_REWINDDIR
@

106 
_GL_FUNCDECL_SYS
 (
rewinddir
, void, (
DIR
 *
dirp
) 
_GL_ARG_NONNULL
 ((1)));

108 
_GL_CXXALIAS_SYS
 (
rewinddir
, void, (
DIR
 *
dirp
));

109 
_GL_CXXALIASWARN
 (
rewinddir
);

110 #elif 
defined
 
GNULIB_POSIXCHECK


111 #undef 
rewinddir


112 #if 
HAVE_RAW_DECL_REWINDDIR


113 
_GL_WARN_ON_USE
 (
rewinddir
, "rewinddir is not portable - "

118 #if @
GNULIB_CLOSEDIR
@

119 #if @
REPLACE_CLOSEDIR
@

120 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

121 #undef 
closedir


122 #define 
	#closedir
 
rpl_closedir


	)

124 
_GL_FUNCDECL_RPL
 (
closedir
, int, (
DIR
 *
dirp
) 
_GL_ARG_NONNULL
 ((1)));

125 
_GL_CXXALIAS_RPL
 (
closedir
, int, (
DIR
 *
dirp
));

127 #if !@
HAVE_CLOSEDIR
@

128 
_GL_FUNCDECL_SYS
 (
closedir
, int, (
DIR
 *
dirp
) 
_GL_ARG_NONNULL
 ((1)));

130 
_GL_CXXALIAS_SYS
 (
closedir
, int, (
DIR
 *
dirp
));

132 
_GL_CXXALIASWARN
 (
closedir
);

133 #elif 
defined
 
GNULIB_POSIXCHECK


134 #undef 
closedir


135 #if 
HAVE_RAW_DECL_CLOSEDIR


136 
_GL_WARN_ON_USE
 (
closedir
, "closedir is not portable - "

141 #if @
GNULIB_DIRFD
@

144 #if @
REPLACE_DIRFD
@

145 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

146 #undef 
dirfd


147 #define 
	#dirfd
 
rpl_dirfd


	)

149 
_GL_FUNCDECL_RPL
 (
dirfd
, int, (
DIR
 *) 
_GL_ARG_NONNULL
 ((1)));

150 
_GL_CXXALIAS_RPL
 (
dirfd
, int, (
DIR
 *));

152 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
 && defined 
dirfd


155 static 
inline
 int (
dirfd
) (
DIR
 *
dp
) { return 
	`dirfd
 (dp); 
	}
}

156 #undef 
dirfd


158 #if !(@
HAVE_DECL_DIRFD
@ || 
defined
 
dirfd
)

159 
_GL_FUNCDECL_SYS
 (
dirfd
, int, (
DIR
 *) 
_GL_ARG_NONNULL
 ((1)));

161 
_GL_CXXALIAS_SYS
 (
dirfd
, int, (
DIR
 *));

163 
_GL_CXXALIASWARN
 (
dirfd
);

164 #elif 
defined
 
GNULIB_POSIXCHECK


165 #undef 
dirfd


166 #if 
HAVE_RAW_DECL_DIRFD


167 
_GL_WARN_ON_USE
 (
dirfd
, "dirfd is unportable - "

172 #if @
GNULIB_FDOPENDIR
@

178 #if @
REPLACE_FDOPENDIR
@

179 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

180 #undef 
fdopendir


181 #define 
	#fdopendir
 
rpl_fdopendir


	)

183 
_GL_FUNCDECL_RPL
 (
fdopendir
, 
DIR
 *, (int 
fd
));

184 
_GL_CXXALIAS_RPL
 (
fdopendir
, 
DIR
 *, (int 
fd
));

186 #if !@
HAVE_FDOPENDIR
@ || !@
HAVE_DECL_FDOPENDIR
@

187 
_GL_FUNCDECL_SYS
 (
fdopendir
, 
DIR
 *, (int 
fd
));

189 
_GL_CXXALIAS_SYS
 (
fdopendir
, 
DIR
 *, (int 
fd
));

191 
_GL_CXXALIASWARN
 (
fdopendir
);

192 #elif 
defined
 
GNULIB_POSIXCHECK


193 #undef 
fdopendir


194 #if 
HAVE_RAW_DECL_FDOPENDIR


195 
_GL_WARN_ON_USE
 (
fdopendir
, "fdopendir is unportable - "

200 #if @
GNULIB_SCANDIR
@

205 #if !@
HAVE_SCANDIR
@

206 
_GL_FUNCDECL_SYS
 (
scandir
, int,

207 (const char *
dir
, struct 
dirent
 ***
namelist
,

208 int (*
filter
) (const struct 
dirent
 *),

209 int (*
cmp
) (const struct 
dirent
 **, const struct dirent **))

210 
	`_GL_ARG_NONNULL
 ((1, 2, 4)));

214 
	`_GL_CXXALIAS_SYS_CAST
 (
scandir
, int,

215 (const char *
dir
, struct 
dirent
 ***
namelist
,

216 int (*
filter
) (const struct 
dirent
 *),

217 int (*
cmp
) (const struct 
dirent
 **, const struct dirent **)));

218 
	`_GL_CXXALIASWARN
 (
scandir
);

219 #elif 
defined
 
GNULIB_POSIXCHECK


220 #undef 
scandir


221 #if 
HAVE_RAW_DECL_SCANDIR


222 
	`_GL_WARN_ON_USE
 (
scandir
, "scandir is unportable - "

227 #if @
GNULIB_ALPHASORT
@

229 #if !@
HAVE_ALPHASORT
@

230 
	`_GL_FUNCDECL_SYS
 (
alphasort
, int,

231 (const struct 
dirent
 **, const struct dirent **)

232 
	`_GL_ARG_NONNULL
 ((1, 2)));

236 
	`_GL_CXXALIAS_SYS_CAST
 (
alphasort
, int,

237 (const struct 
dirent
 **, const struct dirent **));

238 
	`_GL_CXXALIASWARN
 (
alphasort
);

239 #elif 
defined
 
GNULIB_POSIXCHECK


240 #undef 
alphasort


241 #if 
HAVE_RAW_DECL_ALPHASORT


242 
	`_GL_WARN_ON_USE
 (
alphasort
, "alphasort is unportable - "

	@lib/dirname-lgpl.c

19 #include 
	~<config.h
>

21 #include 
	~"dirname.h
"

23 #include 
	~<stdlib.h
>

24 #include 
	~<string.h
>

31 
size_t


32 
	$dir_len
 (char const *
file
)

34 
size_t
 
prefix_length
 = 
	`FILE_SYSTEM_PREFIX_LEN
 (
file
);

35 
size_t
 
length
;

38 
prefix_length
 += (prefix_length != 0

39 ? (
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE


40 && 
	`ISSLASH
 (
file
[
prefix_length
]))

41 : (
	`ISSLASH
 (
file
[0])

42 ? ((
DOUBLE_SLASH_IS_DISTINCT_ROOT


43 && 
	`ISSLASH
 (
file
[1]) && ! ISSLASH (file[2])

48 for (
length
 = 
	`last_component
 (
file
) - file;

49 
prefix_length
 < 
length
; length--)

50 if (! 
	`ISSLASH
 (
file
[
length
 - 1]))

52 return 
length
;

53 
	}
}

71 
	$mdir_name
 (char const *
file
)

73 
size_t
 
length
 = 
	`dir_len
 (
file
);

74 
bool
 
append_dot
 = (
length
 == 0

75 || (
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE


76 && 
length
 == 
	`FILE_SYSTEM_PREFIX_LEN
 (
file
)

77 && 
file
[2] != '\0' && ! 
	`ISSLASH
 (file[2])));

78 char *
dir
 = 
	`malloc
 (
length
 + 
append_dot
 + 1);

79 if (!
dir
)

80 return 
NULL
;

81 
	`memcpy
 (
dir
, 
file
, 
length
);

82 if (
append_dot
)

83 
dir
[
length
++] = '.';

84 
dir
[
length
] = '\0';

85 return 
dir
;

86 
	}
}

	@lib/dirname.c

19 #include 
	~<config.h
>

21 #include 
	~"dirname.h
"

23 #include 
	~<stdlib.h
>

24 #include 
	~<string.h
>

25 #include 
	~"xalloc.h
"

32 
	$dir_name
 (char const *
file
)

34 char *
result
 = 
	`mdir_name
 (
file
);

35 if (!
result
)

36 
	`xalloc_die
 ();

37 return 
result
;

38 
	}
}

	@lib/dirname.h

19 #ifndef 
DIRNAME_H_


20 #define 
	#DIRNAME_H_
 1

	)

22 #include 
	~<stdbool.h
>

23 #include 
	~<stddef.h
>

24 #include 
	~"dosname.h
"

26 #ifndef 
DIRECTORY_SEPARATOR


27 #define 
	#DIRECTORY_SEPARATOR
 '/'

	)

30 #ifndef 
DOUBLE_SLASH_IS_DISTINCT_ROOT


31 #define 
	#DOUBLE_SLASH_IS_DISTINCT_ROOT
 0

	)

34 #if 
GNULIB_DIRNAME


35 char *
base_name
 (char const *
file
);

36 char *
dir_name
 (char const *
file
);

39 char *
mdir_name
 (char const *
file
);

40 
size_t
 
base_len
 (char const *
file
);

41 
size_t
 
dir_len
 (char const *
file
);

42 char *
last_component
 (char const *
file
);

44 
bool
 
strip_trailing_slashes
 (char *
file
);

	@lib/dosname.h

20 #ifndef 
_DOSNAME_H


21 #define 
	#_DOSNAME_H


	)

23 #if (
defined
 
_WIN32
 || defined 
__WIN32__
 || \

24 
defined
 
	g__MSDOS__
 || defined 
	g__CYGWIN__
 || \

25 
defined
 
	g__EMX__
 || defined 
	g__DJGPP__
)

28 #define 
	#_IS_DRIVE_LETTER
(
C
) (((unsigned int) (C) | ('a' - 'A')) - 'a' \

29 <= 'z' - 'a')

	)

30 #define 
	#FILE_SYSTEM_PREFIX_LEN
(
Filename
) \

31 (
	`_IS_DRIVE_LETTER
 ((
Filename
)[0]) && (Filename)[1] == ':' ? 2 : 0)

	)

32 #ifndef 
__CYGWIN__


33 #define 
	#FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
 1

	)

35 #define 
	#ISSLASH
(
C
) ((C) == '/' || (C) == '\\')

	)

37 #define 
	#FILE_SYSTEM_PREFIX_LEN
(
Filename
) 0

	)

38 #define 
	#ISSLASH
(
C
) ((C) == '/')

	)

41 #ifndef 
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE


42 #define 
	#FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
 0

	)

45 #if 
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE


46 #define 
	#IS_ABSOLUTE_FILE_NAME
(
F
) 
	`ISSLASH
 ((F)[
	`FILE_SYSTEM_PREFIX_LEN
 (F)])

	)

48 #define 
	#IS_ABSOLUTE_FILE_NAME
(
F
) \

49 (
	`ISSLASH
 ((
F
)[0]) || 
	`FILE_SYSTEM_PREFIX_LEN
 (F) != 0)

	)

51 #define 
	#IS_RELATIVE_FILE_NAME
(
F
) (! 
	`IS_ABSOLUTE_FILE_NAME
 (F))

	)

	@lib/errno.in.h

21 #ifndef 
_
@
GUARD_PREFIX
@
_ERRNO_H


23 #if 
__GNUC__
 >= 3

24 @
	gPRAGMA_SYSTEM_HEADER
@

26 @
	gPRAGMA_COLUMNS
@

29 #@
INCLUDE_NEXT
@ @
NEXT_ERRNO_H
@

31 #ifndef 
_
@
GUARD_PREFIX
@
_ERRNO_H


32 #define 
	#_
@
GUARD_PREFIX
@
_ERRNO_H


	)

36 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


40 #ifndef 
ENOMSG


41 #define 
	#ENOMSG
 122

	)

42 #define 
	#GNULIB_defined_ENOMSG
 1

	)

45 #ifndef 
EIDRM


46 #define 
	#EIDRM
 111

	)

47 #define 
	#GNULIB_defined_EIDRM
 1

	)

50 #ifndef 
ENOLINK


51 #define 
	#ENOLINK
 121

	)

52 #define 
	#GNULIB_defined_ENOLINK
 1

	)

55 #ifndef 
EPROTO


56 #define 
	#EPROTO
 134

	)

57 #define 
	#GNULIB_defined_EPROTO
 1

	)

60 #ifndef 
EBADMSG


61 #define 
	#EBADMSG
 104

	)

62 #define 
	#GNULIB_defined_EBADMSG
 1

	)

65 #ifndef 
EOVERFLOW


66 #define 
	#EOVERFLOW
 132

	)

67 #define 
	#GNULIB_defined_EOVERFLOW
 1

	)

70 #ifndef 
ENOTSUP


71 #define 
	#ENOTSUP
 129

	)

72 #define 
	#GNULIB_defined_ENOTSUP
 1

	)

75 #ifndef 
ENETRESET


76 #define 
	#ENETRESET
 117

	)

77 #define 
	#GNULIB_defined_ENETRESET
 1

	)

80 #ifndef 
ECONNABORTED


81 #define 
	#ECONNABORTED
 106

	)

82 #define 
	#GNULIB_defined_ECONNABORTED
 1

	)

85 #ifndef 
ECANCELED


86 #define 
	#ECANCELED
 105

	)

87 #define 
	#GNULIB_defined_ECANCELED
 1

	)

90 #ifndef 
EINPROGRESS


91 #define 
	#EINPROGRESS
 112

	)

92 #define 
	#EALREADY
 103

	)

93 #define 
	#ENOTSOCK
 128

	)

94 #define 
	#EDESTADDRREQ
 109

	)

95 #define 
	#EMSGSIZE
 115

	)

96 #define 
	#EPROTOTYPE
 136

	)

97 #define 
	#ENOPROTOOPT
 123

	)

98 #define 
	#EPROTONOSUPPORT
 135

	)

99 #define 
	#EOPNOTSUPP
 130

	)

100 #define 
	#EAFNOSUPPORT
 102

	)

101 #define 
	#EADDRINUSE
 100

	)

102 #define 
	#EADDRNOTAVAIL
 101

	)

103 #define 
	#ENETDOWN
 116

	)

104 #define 
	#ENETUNREACH
 118

	)

105 #define 
	#ECONNRESET
 108

	)

106 #define 
	#ENOBUFS
 119

	)

107 #define 
	#EISCONN
 113

	)

108 #define 
	#ENOTCONN
 126

	)

109 #define 
	#ETIMEDOUT
 138

	)

110 #define 
	#ECONNREFUSED
 107

	)

111 #define 
	#ELOOP
 114

	)

112 #define 
	#EHOSTUNREACH
 110

	)

113 #define 
	#EWOULDBLOCK
 140

	)

114 #define 
	#ETXTBSY
 139

	)

115 #define 
	#ENODATA
 120

	)

116 #define 
	#ENOSR
 124

	)

117 #define 
	#ENOSTR
 125

	)

118 #define 
	#ENOTRECOVERABLE
 127

	)

119 #define 
	#EOWNERDEAD
 133

	)

120 #define 
	#ETIME
 137

	)

121 #define 
	#EOTHER
 131

	)

122 #define 
	#GNULIB_defined_ESOCK
 1

	)

127 #define 
	#ESOCKTNOSUPPORT
 10044

	)

128 #define 
	#EPFNOSUPPORT
 10046

	)

129 #define 
	#ESHUTDOWN
 10058

	)

130 #define 
	#ETOOMANYREFS
 10059

	)

131 #define 
	#EHOSTDOWN
 10064

	)

132 #define 
	#EPROCLIM
 10067

	)

133 #define 
	#EUSERS
 10068

	)

134 #define 
	#EDQUOT
 10069

	)

135 #define 
	#ESTALE
 10070

	)

136 #define 
	#EREMOTE
 10071

	)

137 #define 
	#GNULIB_defined_EWINSOCK
 1

	)

144 #if @
EMULTIHOP_HIDDEN
@

145 #define 
	#EMULTIHOP
 @
EMULTIHOP_VALUE
@

	)

146 #define 
	#GNULIB_defined_EMULTIHOP
 1

	)

148 #if @
ENOLINK_HIDDEN
@

149 #define 
	#ENOLINK
 @
ENOLINK_VALUE
@

	)

150 #define 
	#GNULIB_defined_ENOLINK
 1

	)

152 #if @
EOVERFLOW_HIDDEN
@

153 #define 
	#EOVERFLOW
 @
EOVERFLOW_VALUE
@

	)

154 #define 
	#GNULIB_defined_EOVERFLOW
 1

	)

168 #ifndef 
ENOMSG


169 #define 
	#ENOMSG
 2000

	)

170 #define 
	#GNULIB_defined_ENOMSG
 1

	)

173 #ifndef 
EIDRM


174 #define 
	#EIDRM
 2001

	)

175 #define 
	#GNULIB_defined_EIDRM
 1

	)

178 #ifndef 
ENOLINK


179 #define 
	#ENOLINK
 2002

	)

180 #define 
	#GNULIB_defined_ENOLINK
 1

	)

183 #ifndef 
EPROTO


184 #define 
	#EPROTO
 2003

	)

185 #define 
	#GNULIB_defined_EPROTO
 1

	)

188 #ifndef 
EMULTIHOP


189 #define 
	#EMULTIHOP
 2004

	)

190 #define 
	#GNULIB_defined_EMULTIHOP
 1

	)

193 #ifndef 
EBADMSG


194 #define 
	#EBADMSG
 2005

	)

195 #define 
	#GNULIB_defined_EBADMSG
 1

	)

198 #ifndef 
EOVERFLOW


199 #define 
	#EOVERFLOW
 2006

	)

200 #define 
	#GNULIB_defined_EOVERFLOW
 1

	)

203 #ifndef 
ENOTSUP


204 #define 
	#ENOTSUP
 2007

	)

205 #define 
	#GNULIB_defined_ENOTSUP
 1

	)

208 #ifndef 
ENETRESET


209 #define 
	#ENETRESET
 2011

	)

210 #define 
	#GNULIB_defined_ENETRESET
 1

	)

213 #ifndef 
ECONNABORTED


214 #define 
	#ECONNABORTED
 2012

	)

215 #define 
	#GNULIB_defined_ECONNABORTED
 1

	)

218 #ifndef 
ESTALE


219 #define 
	#ESTALE
 2009

	)

220 #define 
	#GNULIB_defined_ESTALE
 1

	)

223 #ifndef 
EDQUOT


224 #define 
	#EDQUOT
 2010

	)

225 #define 
	#GNULIB_defined_EDQUOT
 1

	)

228 #ifndef 
ECANCELED


229 #define 
	#ECANCELED
 2008

	)

230 #define 
	#GNULIB_defined_ECANCELED
 1

	)

	@lib/error.c

20 #if !
_LIBC


21 #include 
	~<config.h
>

24 #include 
	~"error.h
"

26 #include 
	~<stdarg.h
>

27 #include 
	~<stdio.h
>

28 #include 
	~<stdlib.h
>

29 #include 
	~<string.h
>

31 #if !
_LIBC
 && 
ENABLE_NLS


32 #include 
	~"gettext.h
"

33 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

36 #ifdef 
_LIBC


37 #include 
	~<libintl.h
>

38 #include 
	~<stdbool.h
>

39 #include 
	~<stdint.h
>

40 #include 
	~<wchar.h
>

41 #define 
	#mbsrtowcs
 
__mbsrtowcs


	)

44 #if 
USE_UNLOCKED_IO


45 #include 
	~"unlocked-io.h
"

48 #ifndef 
_


49 #define 
	#_
(
String
) 
	)
String

55 void (*
error_print_progname
) (void);

58 unsigned int 
error_message_count
;

60 #ifdef 
_LIBC


63 #define 
	#program_name
 
program_invocation_name


	)

64 #include 
	~<errno.h
>

65 #include 
	~<limits.h
>

66 #include 
	~<libio/libioP.h
>

70 extern void 
	$__error
 (int 
status
, int 
errnum
, const char *
message
, ...)

71 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

72 extern void 
	$__error_at_line
 (int 
status
, int 
errnum
, const char *
file_name
,

73 unsigned int 
line_number
, const char *
message
,

75 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 5, 6)));;

76 #define 
	#error
 
__error


	)

77 #define 
	#error_at_line
 
__error_at_line


	)

79 #include 
	~<libio/iolibio.h
>

80 #define 
	#fflush
(
s
) 
	`INTUSE
(
_IO_fflush
) (s)

	)

81 #undef 
putc


82 #define 
	#putc
(
c
, 
fp
) 
	`INTUSE
(
_IO_putc
) (c, fp)

	)

84 #include 
	~<bits/libc-lock.h
>

88 #include 
	~<fcntl.h
>

89 #include 
	~<unistd.h
>

91 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


93 #define 
	#WIN32_LEAN_AND_MEAN


	)

94 #include 
	~<windows.h
>

96 #include 
	~"msvc-nothrow.h
"

100 #undef 
fcntl


102 #if !
HAVE_DECL_STRERROR_R


103 #ifndef 
HAVE_DECL_STRERROR_R


106 #if 
STRERROR_R_CHAR_P


107 char *
	`strerror_r
 ();

109 int 
	`strerror_r
 ();

115 extern char *
program_name
;

117 #if 
HAVE_STRERROR_R
 || 
defined
 
strerror_r


118 #define 
	#__strerror_r
 
strerror_r


	)

122 #if !
_LIBC


124 static 
inline
 int

125 
	$is_open
 (int 
fd
)

127 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


131 return (
HANDLE
) 
	`_get_osfhandle
 (
fd
) != 
INVALID_HANDLE_VALUE
;

133 #ifndef 
F_GETFL


134 #error 
Please
 
port
 
fcntl
 
to
 
your
 
platform


136 return 0 <= 
	`fcntl
 (
fd
, 
F_GETFL
);

138 
	}
}

141 static 
inline
 void

142 
	$flush_stdout
 (void)

144 #if !
_LIBC


145 int 
stdout_fd
;

147 #if 
GNULIB_FREOPEN_SAFER


151 
stdout_fd
 = 
STDOUT_FILENO
;

156 
stdout_fd
 = 
	`fileno
 (
stdout
);

161 if (0 <= 
stdout_fd
 && 
	`is_open
 (stdout_fd))

163 
	`fflush
 (
stdout
);

164 
	}
}

167 
	$print_errno_message
 (int 
errnum
)

169 char const *
s
;

171 #if 
defined
 
HAVE_STRERROR_R
 || 
_LIBC


172 char 
errbuf
[1024];

173 #if 
STRERROR_R_CHAR_P
 || 
_LIBC


174 
s
 = 
	`__strerror_r
 (
errnum
, 
errbuf
, sizeof errbuf);

176 if (
	`__strerror_r
 (
errnum
, 
errbuf
, sizeof errbuf) == 0)

177 
s
 = 
errbuf
;

179 
s
 = 0;

182 
s
 = 
	`strerror
 (
errnum
);

185 #if !
_LIBC


186 if (! 
s
)

187 
s
 = 
	`_
("Unknown system error");

190 #if 
_LIBC


191 
	`__fxprintf
 (
NULL
, ": %s", 
s
);

193 
	`fprintf
 (
stderr
, ": %s", 
s
);

195 
	}
}

198 
	$error_tail
 (int 
status
, int 
errnum
, const char *
message
, 
va_list
 
args
)

200 #if 
_LIBC


201 if (
	`_IO_fwide
 (
stderr
, 0) > 0)

203 #define 
	#ALLOCA_LIMIT
 2000

	)

204 
size_t
 
len
 = 
	`strlen
 (
message
) + 1;

205 
wchar_t
 *
wmessage
 = 
NULL
;

206 
mbstate_t
 
st
;

207 
size_t
 
res
;

208 const char *
tmp
;

209 
bool
 
use_malloc
 = 
false
;

213 if (
	`__libc_use_alloca
 (
len
 * sizeof (
wchar_t
)))

214 
wmessage
 = (
wchar_t
 *) 
	`alloca
 (
len
 * sizeof (wchar_t));

217 if (!
use_malloc
)

218 
wmessage
 = 
NULL
;

220 
wchar_t
 *
p
 = (wchar_t *) 
	`realloc
 (
wmessage
,

221 
len
 * sizeof (
wchar_t
));

222 if (
p
 == 
NULL
)

224 
	`free
 (
wmessage
);

225 
	`fputws_unlocked
 (
L
"out of memory\n", 
stderr
);

228 
wmessage
 = 
p
;

229 
use_malloc
 = 
true
;

232 
	`memset
 (&
st
, '\0', sizeof (st));

233 
tmp
 = 
message
;

235 
res
 = 
	`mbsrtowcs
 (
wmessage
, &
tmp
, 
len
, &
st
);

236 if (
res
 != 
len
)

239 if (
	`__builtin_expect
 (
len
 >= 
SIZE_MAX
 / 2, 0))

242 
res
 = (
size_t
) -1;

246 
len
 *= 2;

249 if (
res
 == (
size_t
) -1)

252 if (
use_malloc
)

254 
	`free
 (
wmessage
);

255 
use_malloc
 = 
false
;

257 
wmessage
 = (
wchar_t
 *) 
L
"???";

260 
	`__vfwprintf
 (
stderr
, 
wmessage
, 
args
);

262 if (
use_malloc
)

263 
	`free
 (
wmessage
);

267 
	`vfprintf
 (
stderr
, 
message
, 
args
);

268 
	`va_end
 (
args
);

270 ++
error_message_count
;

271 if (
errnum
)

272 
	`print_errno_message
 (
errnum
);

273 #if 
_LIBC


274 
	`__fxprintf
 (
NULL
, "\n");

276 
	`putc
 ('\n', 
stderr
);

278 
	`fflush
 (
stderr
);

279 if (
status
)

280 
	`exit
 (
status
);

281 
	}
}

289 
	$error
 (int 
status
, int 
errnum
, const char *
message
, ...)

291 
va_list
 
args
;

293 #if 
defined
 
_LIBC
 && defined 
__libc_ptf_call


296 int 
state
 = 
PTHREAD_CANCEL_ENABLE
;

297 
	`__libc_ptf_call
 (
pthread_setcancelstate
, (
PTHREAD_CANCEL_DISABLE
, &
state
),

301 
	`flush_stdout
 ();

302 #ifdef 
_LIBC


303 
	`_IO_flockfile
 (
stderr
);

305 if (
error_print_progname
)

306 (*
error_print_progname
) ();

309 #if 
_LIBC


310 
	`__fxprintf
 (
NULL
, "%s: ", 
program_name
);

312 
	`fprintf
 (
stderr
, "%s: ", 
program_name
);

316 
	`va_start
 (
args
, 
message
);

317 
	`error_tail
 (
status
, 
errnum
, 
message
, 
args
);

319 #ifdef 
_LIBC


320 
	`_IO_funlockfile
 (
stderr
);

321 #ifdef 
__libc_ptf_call


322 
	`__libc_ptf_call
 (
pthread_setcancelstate
, (
state
, 
NULL
), 0);

325 
	}
}

329 int 
	gerror_one_per_line
;

332 
	$error_at_line
 (int 
status
, int 
errnum
, const char *
file_name
,

333 unsigned int 
line_number
, const char *
message
, ...)

335 
va_list
 
args
;

337 if (
error_one_per_line
)

339 static const char *
old_file_name
;

340 static unsigned int 
old_line_number
;

342 if (
old_line_number
 == 
line_number


343 && (
file_name
 == 
old_file_name


344 || 
	`strcmp
 (
old_file_name
, 
file_name
) == 0))

348 
old_file_name
 = 
file_name
;

349 
old_line_number
 = 
line_number
;

352 #if 
defined
 
_LIBC
 && defined 
__libc_ptf_call


355 int 
state
 = 
PTHREAD_CANCEL_ENABLE
;

356 
	`__libc_ptf_call
 (
pthread_setcancelstate
, (
PTHREAD_CANCEL_DISABLE
, &
state
),

360 
	`flush_stdout
 ();

361 #ifdef 
_LIBC


362 
	`_IO_flockfile
 (
stderr
);

364 if (
error_print_progname
)

365 (*
error_print_progname
) ();

368 #if 
_LIBC


369 
	`__fxprintf
 (
NULL
, "%s:", 
program_name
);

371 
	`fprintf
 (
stderr
, "%s:", 
program_name
);

375 #if 
_LIBC


376 
	`__fxprintf
 (
NULL
, 
file_name
 != NULL ? "%s:%d: " : " ",

377 
file_name
, 
line_number
);

379 
	`fprintf
 (
stderr
, 
file_name
 != 
NULL
 ? "%s:%d: " : " ",

380 
file_name
, 
line_number
);

383 
	`va_start
 (
args
, 
message
);

384 
	`error_tail
 (
status
, 
errnum
, 
message
, 
args
);

386 #ifdef 
_LIBC


387 
	`_IO_funlockfile
 (
stderr
);

388 #ifdef 
__libc_ptf_call


389 
	`__libc_ptf_call
 (
pthread_setcancelstate
, (
state
, 
NULL
), 0);

392 
	}
}

394 #ifdef 
_LIBC


396 #undef 
error


397 #undef 
error_at_line


398 
	$weak_alias
 (
__error
, 
error
)

399 
	$weak_alias
 (
__error_at_line
, 
error_at_line
)

	@lib/error.h

19 #ifndef 
_ERROR_H


20 #define 
	#_ERROR_H
 1

	)

28 #if 
__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 7)

29 #define 
	#_GL_ATTRIBUTE_FORMAT
(
spec
) 
	`__attribute__
 ((
__format__
 spec))

	)

31 #define 
	#_GL_ATTRIBUTE_FORMAT
(
spec
)

	)

34 #ifdef 
__cplusplus


42 extern void 
error
 (int 
__status
, int 
__errnum
, const char *
__format
, ...)

43 
_GL_ATTRIBUTE_FORMAT
 ((
__printf__
, 3, 4));

45 extern void 
error_at_line
 (int 
__status
, int 
__errnum
, const char *
__fname
,

46 unsigned int 
__lineno
, const char *
__format
, ...)

47 
_GL_ATTRIBUTE_FORMAT
 ((
__printf__
, 5, 6));

52 extern void (*
error_print_progname
) (void);

55 extern unsigned int 
error_message_count
;

59 extern int 
error_one_per_line
;

61 #ifdef 
__cplusplus


	@lib/exclude.c

24 #include 
	~<config.h
>

26 #include 
	~<stdbool.h
>

28 #include 
	~<ctype.h
>

29 #include 
	~<errno.h
>

30 #include 
	~<stddef.h
>

31 #include 
	~<stdio.h
>

32 #include 
	~<stdlib.h
>

33 #include 
	~<string.h
>

34 #include 
	~<wctype.h
>

36 #include 
	~"exclude.h
"

37 #include 
	~"hash.h
"

38 #include 
	~"mbuiter.h
"

39 #include 
	~"fnmatch.h
"

40 #include 
	~"xalloc.h
"

41 #include 
	~"verify.h
"

43 #if 
USE_UNLOCKED_IO


44 #include 
	~"unlocked-io.h
"

48 #ifndef 
FNM_CASEFOLD


49 #define 
	#FNM_CASEFOLD
 0

	)

51 #ifndef 
FNM_EXTMATCH


52 #define 
	#FNM_EXTMATCH
 0

	)

54 #ifndef 
FNM_LEADING_DIR


55 #define 
	#FNM_LEADING_DIR
 0

	)

58 
verify
 (((
EXCLUDE_ANCHORED
 | 
EXCLUDE_INCLUDE
 | 
EXCLUDE_WILDCARDS
)

59 & (
FNM_PATHNAME
 | 
FNM_NOESCAPE
 | 
FNM_PERIOD
 | 
FNM_LEADING_DIR


60 | 
FNM_CASEFOLD
 | 
FNM_EXTMATCH
))

74 struct 
	spatopts


76 char const *
	mpattern
;

77 int 
	moptions
;

82 struct 
	sexclude_pattern


84 struct 
patopts
 *
	mexclude
;

85 
size_t
 
	mexclude_alloc
;

86 
size_t
 
	mexclude_count
;

89 enum 
	eexclude_type


91 
	mexclude_hash
,

92 
	mexclude_pattern


95 struct 
	sexclude_segment


97 struct 
exclude_segment
 *
	mnext
;

98 enum 
exclude_type
 
	mtype
;

99 int 
	moptions
;

102 
Hash_table
 *
	mtable
;

103 struct 
exclude_pattern
 
	mpat
;

104 } 
	mv
;

108 struct 
	sexclude


110 struct 
exclude_segment
 *
	mhead
, *
	mtail
;

114 
bool


115 
	$fnmatch_pattern_has_wildcards
 (const char *
str
, int 
options
)

117 const char *
cset
 = "\\?*[]";

118 if (
options
 & 
FNM_NOESCAPE
)

119 
cset
++;

120 while (*
str
)

122 
size_t
 
n
 = 
	`strcspn
 (
str
, 
cset
);

123 if (
str
[
n
] == 0)

125 else if (
str
[
n
] == '\\')

127 
str
 += 
n
 + 1;

128 if (*
str
)

129 
str
++;

132 return 
true
;

134 return 
false
;

135 
	}
}

138 
	$unescape_pattern
 (char *
str
)

140 int 
inset
 = 0;

141 char *
q
 = 
str
;

144 if (
inset
)

146 if (*
q
 == ']')

147 
inset
 = 0;

149 else if (*
q
 == '[')

150 
inset
 = 1;

151 else if (*
q
 == '\\')

152 
q
++;

154 while ((*
str
++ = *
q
++));

155 
	}
}

159 struct 
exclude
 *

160 
	$new_exclude
 (void)

162 return 
	`xzalloc
 (sizeof *
	`new_exclude
 ());

163 
	}
}

166 static 
size_t


167 
	$string_hasher
 (void const *
data
, 
size_t
 
n_buckets
)

169 char const *
p
 = 
data
;

170 return 
	`hash_string
 (
p
, 
n_buckets
);

171 
	}
}

174 static 
size_t


175 
	$string_hasher_ci
 (void const *
data
, 
size_t
 
n_buckets
)

177 char const *
p
 = 
data
;

178 
mbui_iterator_t
 
iter
;

179 
size_t
 
value
 = 0;

181 for (
	`mbui_init
 (
iter
, 
p
); 
	`mbui_avail
 (iter); 
	`mbui_advance
 (iter))

183 
mbchar_t
 
m
 = 
	`mbui_cur
 (
iter
);

184 
wchar_t
 
wc
;

186 if (
m
.
wc_valid
)

187 
wc
 = 
	`towlower
 (
m
.wc);

189 
wc
 = *
m
.
ptr
;

191 
value
 = (value * 31 + 
wc
) % 
n_buckets
;

194 return 
value
;

195 
	}
}

198 static 
bool


199 
	$string_compare
 (void const *
data1
, void const *
data2
)

201 char const *
p1
 = 
data1
;

202 char const *
p2
 = 
data2
;

203 return 
	`strcmp
 (
p1
, 
p2
) == 0;

204 
	}
}

207 static 
bool


208 
	$string_compare_ci
 (void const *
data1
, void const *
data2
)

210 char const *
p1
 = 
data1
;

211 char const *
p2
 = 
data2
;

212 return 
	`mbscasecmp
 (
p1
, 
p2
) == 0;

213 
	}
}

216 
	$string_free
 (void *
data
)

218 
	`free
 (
data
);

219 
	}
}

223 static struct 
exclude_segment
 *

224 
	$new_exclude_segment
 (struct 
exclude
 *
ex
, enum 
exclude_type
 
type
, int 
options
)

226 struct 
exclude_segment
 *
sp
 = 
	`xzalloc
 (sizeof (struct exclude_segment));

227 
sp
->
type
 = type;

228 
sp
->
options
 = options;

229 switch (
type
)

231 case 
exclude_pattern
:

234 case 
exclude_hash
:

235 
sp
->
v
.
table
 = 
	`hash_initialize
 (0, 
NULL
,

236 (
options
 & 
FNM_CASEFOLD
) ?

237 
string_hasher_ci


238 : 
string_hasher
,

239 (
options
 & 
FNM_CASEFOLD
) ?

240 
string_compare_ci


241 : 
string_compare
,

242 
string_free
);

245 if (
ex
->
tail
)

246 
ex
->
tail
->
next
 = 
sp
;

248 
ex
->
head
 = 
sp
;

249 
ex
->
tail
 = 
sp
;

250 return 
sp
;

251 
	}
}

255 
	$free_exclude_segment
 (struct 
exclude_segment
 *
seg
)

257 switch (
seg
->
type
)

259 case 
exclude_pattern
:

260 
	`free
 (
seg
->
v
.
pat
.
exclude
);

263 case 
exclude_hash
:

264 
	`hash_free
 (
seg
->
v
.
table
);

267 
	`free
 (
seg
);

268 
	}
}

272 
	$free_exclude
 (struct 
exclude
 *
ex
)

274 struct 
exclude_segment
 *
seg
;

275 for (
seg
 = 
ex
->
head
; seg; )

277 struct 
exclude_segment
 *
next
 = 
seg
->next;

278 
	`free_exclude_segment
 (
seg
);

279 
seg
 = 
next
;

281 
	`free
 (
ex
);

282 
	}
}

288 
	$fnmatch_no_wildcards
 (char const *
pattern
, char const *
f
, int 
options
)

290 if (! (
options
 & 
FNM_LEADING_DIR
))

291 return ((
options
 & 
FNM_CASEFOLD
)

292 ? 
	`mbscasecmp
 (
pattern
, 
f
)

293 : 
	`strcmp
 (
pattern
, 
f
));

294 else if (! (
options
 & 
FNM_CASEFOLD
))

296 
size_t
 
patlen
 = 
	`strlen
 (
pattern
);

297 int 
r
 = 
	`strncmp
 (
pattern
, 
f
, 
patlen
);

298 if (! 
r
)

300 
r
 = 
f
[
patlen
];

301 if (
r
 == '/')

302 
r
 = 0;

304 return 
r
;

315 char *
fcopy
 = 
	`xstrdup
 (
f
);

316 char *
p
;

317 int 
r
;

318 for (
p
 = 
fcopy
; ; *p++ = '/')

320 
p
 = 
	`strchr
 (p, '/');

321 if (
p
)

322 *
p
 = '\0';

323 
r
 = 
	`mbscasecmp
 (
pattern
, 
fcopy
);

324 if (!
p
 || 
r
 <= 0)

327 
	`free
 (
fcopy
);

328 return 
r
;

330 
	}
}

332 
bool


333 
	$exclude_fnmatch
 (char const *
pattern
, char const *
f
, int 
options
)

335 int (*
matcher
) (char const *, char const *, int) =

336 (
options
 & 
EXCLUDE_WILDCARDS


337 ? 
fnmatch


338 : 
fnmatch_no_wildcards
);

339 
bool
 
matched
 = ((*
matcher
) (
pattern
, 
f
, 
options
) == 0);

340 char const *
p
;

342 if (! (
options
 & 
EXCLUDE_ANCHORED
))

343 for (
p
 = 
f
; *p && ! 
matched
; p++)

344 if (*
p
 == '/' && p[1] != '/')

345 
matched
 = ((*
matcher
) (
pattern
, 
p
 + 1, 
options
) == 0);

347 return 
matched
;

348 
	}
}

352 static 
bool


353 
	$excluded_file_pattern_p
 (struct 
exclude_segment
 const *
seg
, char const *
f
)

355 
size_t
 
exclude_count
 = 
seg
->
v
.
pat
.exclude_count;

356 struct 
patopts
 const *
exclude
 = 
seg
->
v
.
pat
.exclude;

357 
size_t
 
i
;

358 
bool
 
excluded
 = !! (
exclude
[0].
options
 & 
EXCLUDE_INCLUDE
);

361 for (
i
 = 0; i < 
exclude_count
; i++)

363 char const *
pattern
 = 
exclude
[
i
].pattern;

364 int 
options
 = 
exclude
[
i
].options;

365 if (
	`exclude_fnmatch
 (
pattern
, 
f
, 
options
))

366 return !
excluded
;

368 return 
excluded
;

369 
	}
}

374 static 
bool


375 
	$excluded_file_name_p
 (struct 
exclude_segment
 const *
seg
, char const *
f
,

376 char *
buffer
)

378 int 
options
 = 
seg
->options;

379 
bool
 
excluded
 = !! (
options
 & 
EXCLUDE_INCLUDE
);

380 
Hash_table
 *
table
 = 
seg
->
v
.table;

385 
	`strcpy
 (
buffer
, 
f
);

389 if (
	`hash_lookup
 (
table
, 
buffer
))

390 return !
excluded
;

391 if (
options
 & 
FNM_LEADING_DIR
)

393 char *
p
 = 
	`strrchr
 (
buffer
, '/');

394 if (
p
)

396 *
p
 = 0;

403 if (!(
options
 & 
EXCLUDE_ANCHORED
))

405 
f
 = 
	`strchr
 (f, '/');

406 if (
f
)

407 
f
++;

412 while (
f
);

413 return 
excluded
;

414 
	}
}

418 
bool


419 
	$excluded_file_name
 (struct 
exclude
 const *
ex
, char const *
f
)

421 struct 
exclude_segment
 *
seg
;

422 
bool
 
excluded
;

423 char *
filename
 = 
NULL
;

426 if (!
ex
->
head
)

427 return 
false
;

430 
excluded
 = !! (
ex
->
head
->
options
 & 
EXCLUDE_INCLUDE
);

433 for (
seg
 = 
ex
->
head
; seg; seg = seg->
next
)

435 
bool
 
rc
;

437 switch (
seg
->
type
)

439 case 
exclude_pattern
:

440 
rc
 = 
	`excluded_file_pattern_p
 (
seg
, 
f
);

443 case 
exclude_hash
:

444 if (!
filename
)

445 
filename
 = 
	`xmalloc
 (
	`strlen
 (
f
) + 1);

446 
rc
 = 
	`excluded_file_name_p
 (
seg
, 
f
, 
filename
);

450 
	`abort
 ();

452 if (
rc
 != 
excluded
)

454 
excluded
 = 
rc
;

458 
	`free
 (
filename
);

459 return 
excluded
;

460 
	}
}

465 
	$add_exclude
 (struct 
exclude
 *
ex
, char const *
pattern
, int 
options
)

467 struct 
exclude_segment
 *
seg
;

469 if ((
options
 & 
EXCLUDE_WILDCARDS
)

470 && 
	`fnmatch_pattern_has_wildcards
 (
pattern
, 
options
))

472 struct 
exclude_pattern
 *
pat
;

473 struct 
patopts
 *patopts;

475 if (
ex
->
tail
 && ex->tail->
type
 == 
exclude_pattern


476 && ((
ex
->
tail
->
options
 & 
EXCLUDE_INCLUDE
) ==

477 (
options
 & 
EXCLUDE_INCLUDE
)))

478 
seg
 = 
ex
->
tail
;

480 
seg
 = 
	`new_exclude_segment
 (
ex
, 
exclude_pattern
, 
options
);

482 
pat
 = &
seg
->
v
.pat;

483 if (
pat
->
exclude_count
 == pat->
exclude_alloc
)

484 
pat
->
exclude
 = 
	`x2nrealloc
 (pat->exclude, &pat->
exclude_alloc
,

485 sizeof *
pat
->
exclude
);

486 
patopts
 = &
pat
->
exclude
[pat->
exclude_count
++];

487 
patopts
->
pattern
 = pattern;

488 
patopts
->
options
 = options;

492 char *
str
, *
p
;

493 #define 
	#EXCLUDE_HASH_FLAGS
 (
EXCLUDE_INCLUDE
|
EXCLUDE_ANCHORED
|\

494 
FNM_LEADING_DIR
|
FNM_CASEFOLD
)

	)

495 if (
ex
->
tail
 && ex->tail->
type
 == 
exclude_hash


496 && ((
ex
->
tail
->
options
 & 
EXCLUDE_HASH_FLAGS
) ==

497 (
options
 & 
EXCLUDE_HASH_FLAGS
)))

498 
seg
 = 
ex
->
tail
;

500 
seg
 = 
	`new_exclude_segment
 (
ex
, 
exclude_hash
, 
options
);

502 
str
 = 
	`xstrdup
 (
pattern
);

503 if (
options
 & 
EXCLUDE_WILDCARDS
)

504 
	`unescape_pattern
 (
str
);

505 
p
 = 
	`hash_insert
 (
seg
->
v
.
table
, 
str
);

506 if (
p
 != 
str
)

507 
	`free
 (
str
);

509 
	}
}

517 
add_exclude_file
 (void (*
add_func
) (struct 
exclude
 *, char const *, int),

518 struct 
exclude
 *
ex
, char const *
file_name
, int 
options
,

519 char 
line_end
)

521 
bool
 
use_stdin
 = 
file_name
[0] == '-' && !file_name[1];

522 
FILE
 *
in
;

523 char *
buf
 = 
NULL
;

524 char *
p
;

525 char const *
pattern
;

526 char const *
lim
;

527 
size_t
 
buf_alloc
 = 0;

528 
size_t
 
buf_count
 = 0;

529 int 
c
;

530 int 
e
 = 0;

532 if (
use_stdin
)

533 
in
 = 
stdin
;

534 else if (! (
in
 = 
	`fopen
 (
file_name
, "r")))

537 while ((
c
 = 
	`getc
 (
in
)) != 
EOF
)

539 if (
buf_count
 == 
buf_alloc
)

540 
buf
 = 
	`x2realloc
 (buf, &
buf_alloc
);

541 
buf
[
buf_count
++] = 
c
;

544 if (
	`ferror
 (
in
))

545 
e
 = 
errno
;

547 if (!
use_stdin
 && 
	`fclose
 (
in
) != 0)

548 
e
 = 
errno
;

550 
buf
 = 
	`xrealloc
 (buf, 
buf_count
 + 1);

551 
buf
[
buf_count
] = 
line_end
;

552 
lim
 = 
buf
 + 
buf_count
 + ! (buf_count == 0 || buf[buf_count - 1] == 
line_end
);

553 
pattern
 = 
buf
;

555 for (
p
 = 
buf
; p < 
lim
; p++)

556 if (*
p
 == 
line_end
)

558 char *
pattern_end
 = 
p
;

560 if (
	`isspace
 ((unsigned char) 
line_end
))

562 for (; ; 
pattern_end
--)

563 if (
pattern_end
 == 
pattern
)

564 goto 
next_pattern
;

565 else if (! 
	`isspace
 ((unsigned char) 
pattern_end
[-1]))

569 *
pattern_end
 = '\0';

570 (*
add_func
) (
ex
, 
pattern
, 
options
);

572 
next_pattern
:

573 
pattern
 = 
p
 + 1;

576 
errno
 = 
e
;

577 return 
e
 ? -1 : 0;

578 
	}
}

	@lib/exclude.h

19 #ifndef 
_GL_EXCLUDE_H


20 #define 
	#_GL_EXCLUDE_H
 1

	)

22 #include 
	~<stdbool.h
>

31 #define 
	#EXCLUDE_ANCHORED
 (1 << 30)

	)

34 #define 
	#EXCLUDE_INCLUDE
 (1 << 29)

	)

38 #define 
	#EXCLUDE_WILDCARDS
 (1 << 28)

	)

40 struct 
	gexclude
;

42 
bool
 
fnmatch_pattern_has_wildcards
 (const char *, int);

44 struct 
exclude
 *
new_exclude
 (void);

45 void 
free_exclude
 (struct 
exclude
 *);

46 void 
add_exclude
 (struct 
exclude
 *, char const *, int);

47 int 
add_exclude_file
 (void (*) (struct 
exclude
 *, char const *, int),

48 struct 
exclude
 *, char const *, int, char);

49 
bool
 
	`excluded_file_name
 (struct 
exclude
 const *, char const *);

50 
bool
 
	`exclude_fnmatch
 (char const *
pattern
, char const *
f
, int 
options
);

	@lib/exitfail.c

18 #include 
	~<config.h
>

20 #include 
	~"exitfail.h
"

22 #include 
	~<stdlib.h
>

24 int volatile 
	gexit_failure
 = 
EXIT_FAILURE
;

	@lib/exitfail.h

18 extern int volatile 
exit_failure
;

	@lib/fcntl.in.h

20 #if 
__GNUC__
 >= 3

21 @
	gPRAGMA_SYSTEM_HEADER
@

23 @
	gPRAGMA_COLUMNS
@

25 #if 
defined
 
__need_system_fcntl_h


28 #include 
	~<sys/types.h
>

35 #if !(
defined
 
__GLIBC__
 || defined 
__UCLIBC__
) || (defined 
__cplusplus
 && defined 
GNULIB_NAMESPACE
 && !(
__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 3)))

36 #include 
	~<sys/stat.h
>

38 #@
INCLUDE_NEXT
@ @
NEXT_FCNTL_H
@

43 #ifndef 
_
@
GUARD_PREFIX
@
_FCNTL_H


45 #include 
	~<sys/types.h
>

52 #if !(
defined
 
__GLIBC__
 || defined 
__UCLIBC__
) || (defined 
__cplusplus
 && defined 
GNULIB_NAMESPACE
 && !(
__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 3)))

53 #include 
	~<sys/stat.h
>

56 #@
INCLUDE_NEXT
@ @
NEXT_FCNTL_H
@

58 #ifndef 
_
@
GUARD_PREFIX
@
_FCNTL_H


59 #define 
	#_
@
GUARD_PREFIX
@
_FCNTL_H


	)

61 #ifndef 
__GLIBC__


62 #include 
	~<unistd.h
>

75 #if @
GNULIB_FCNTL
@

76 #if @
REPLACE_FCNTL
@

77 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

78 #undef 
fcntl


79 #define 
	#fcntl
 
rpl_fcntl


	)

81 
_GL_FUNCDECL_RPL
 (
fcntl
, int, (int 
fd
, int 
action
, ...));

82 
_GL_CXXALIAS_RPL
 (
fcntl
, int, (int 
fd
, int 
action
, ...));

84 #if !@
HAVE_FCNTL
@

85 
_GL_FUNCDECL_SYS
 (
fcntl
, int, (int 
fd
, int 
action
, ...));

87 
_GL_CXXALIAS_SYS
 (
fcntl
, int, (int 
fd
, int 
action
, ...));

89 
_GL_CXXALIASWARN
 (
fcntl
);

90 #elif 
defined
 
GNULIB_POSIXCHECK


91 #undef 
fcntl


92 #if 
HAVE_RAW_DECL_FCNTL


93 
_GL_WARN_ON_USE
 (
fcntl
, "fcntl is not always POSIX compliant - "

98 #if @
GNULIB_OPEN
@

99 #if @
REPLACE_OPEN
@

100 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

101 #undef 
open


102 #define 
	#open
 
rpl_open


	)

104 
_GL_FUNCDECL_RPL
 (
open
, int, (const char *
filename
, int 
flags
, ...)

105 
_GL_ARG_NONNULL
 ((1)));

106 
_GL_CXXALIAS_RPL
 (
open
, int, (const char *
filename
, int 
flags
, ...));

108 
_GL_CXXALIAS_SYS
 (
open
, int, (const char *
filename
, int 
flags
, ...));

112 #if !
defined
 
__hpux


113 
_GL_CXXALIASWARN
 (
open
);

115 #elif 
defined
 
GNULIB_POSIXCHECK


116 #undef 
open


118 
_GL_WARN_ON_USE
 (
open
, "open is not always POSIX compliant - "

122 #if @
GNULIB_OPENAT
@

123 #if @
REPLACE_OPENAT
@

124 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

125 #undef 
openat


126 #define 
	#openat
 
rpl_openat


	)

128 
_GL_FUNCDECL_RPL
 (
openat
, int,

129 (int 
fd
, char const *
file
, int 
flags
, ...)

130 
_GL_ARG_NONNULL
 ((2)));

131 
_GL_CXXALIAS_RPL
 (
openat
, int,

132 (int 
fd
, char const *
file
, int 
flags
, ...));

134 #if !@
HAVE_OPENAT
@

135 
_GL_FUNCDECL_SYS
 (
openat
, int,

136 (int 
fd
, char const *
file
, int 
flags
, ...)

137 
_GL_ARG_NONNULL
 ((2)));

139 
_GL_CXXALIAS_SYS
 (
openat
, int,

140 (int 
fd
, char const *
file
, int 
flags
, ...));

142 
_GL_CXXALIASWARN
 (
openat
);

143 #elif 
defined
 
GNULIB_POSIXCHECK


144 #undef 
openat


145 #if 
HAVE_RAW_DECL_OPENAT


146 
_GL_WARN_ON_USE
 (
openat
, "openat is not portable - "

154 #ifndef 
FD_CLOEXEC


155 #define 
	#FD_CLOEXEC
 1

	)

161 #ifndef 
F_DUPFD_CLOEXEC


162 #define 
	#F_DUPFD_CLOEXEC
 0x40000000

	)

164 #define 
	#GNULIB_defined_F_DUPFD_CLOEXEC
 1

	)

166 #define 
	#GNULIB_defined_F_DUPFD_CLOEXEC
 0

	)

169 #ifndef 
F_DUPFD


170 #define 
	#F_DUPFD
 1

	)

173 #ifndef 
F_GETFD


174 #define 
	#F_GETFD
 2

	)

179 #if !
defined
 
O_DIRECT
 && defined 
O_DIRECTIO


181 #define 
	#O_DIRECT
 
O_DIRECTIO


	)

184 #if !
defined
 
O_CLOEXEC
 && defined 
O_NOINHERIT


186 #define 
	#O_CLOEXEC
 
O_NOINHERIT


	)

189 #ifndef 
O_CLOEXEC


190 #define 
	#O_CLOEXEC
 0

	)

193 #ifndef 
O_DIRECT


194 #define 
	#O_DIRECT
 0

	)

197 #ifndef 
O_DIRECTORY


198 #define 
	#O_DIRECTORY
 0

	)

201 #ifndef 
O_DSYNC


202 #define 
	#O_DSYNC
 0

	)

205 #ifndef 
O_EXEC


206 #define 
	#O_EXEC
 
O_RDONLY


	)

209 #ifndef 
O_NDELAY


210 #define 
	#O_NDELAY
 0

	)

213 #ifndef 
O_NOATIME


214 #define 
	#O_NOATIME
 0

	)

217 #ifndef 
O_NONBLOCK


218 #define 
	#O_NONBLOCK
 
O_NDELAY


	)

224 #if @
GNULIB_NONBLOCKING
@

225 #if 
O_NONBLOCK


226 #define 
	#GNULIB_defined_O_NONBLOCK
 0

	)

228 #define 
	#GNULIB_defined_O_NONBLOCK
 1

	)

229 #undef 
O_NONBLOCK


230 #define 
	#O_NONBLOCK
 0x40000000

	)

234 #ifndef 
O_NOCTTY


235 #define 
	#O_NOCTTY
 0

	)

238 #ifndef 
O_NOFOLLOW


239 #define 
	#O_NOFOLLOW
 0

	)

242 #ifndef 
O_NOLINKS


243 #define 
	#O_NOLINKS
 0

	)

246 #ifndef 
O_RSYNC


247 #define 
	#O_RSYNC
 0

	)

250 #ifndef 
O_SEARCH


251 #define 
	#O_SEARCH
 
O_RDONLY


	)

254 #ifndef 
O_SYNC


255 #define 
	#O_SYNC
 0

	)

258 #ifndef 
O_TTY_INIT


259 #define 
	#O_TTY_INIT
 0

	)

262 #if 
O_ACCMODE
 != (
O_RDONLY
 | 
O_WRONLY
 | 
O_RDWR
 | 
O_EXEC
 | 
O_SEARCH
)

263 #undef 
O_ACCMODE


264 #define 
	#O_ACCMODE
 (
O_RDONLY
 | 
O_WRONLY
 | 
O_RDWR
 | 
O_EXEC
 | 
O_SEARCH
)

	)

269 #if !
defined
 
O_BINARY
 && defined 
_O_BINARY


271 #define 
	#O_BINARY
 
_O_BINARY


	)

272 #define 
	#O_TEXT
 
_O_TEXT


	)

275 #if 
defined
 
__BEOS__
 || defined 
__HAIKU__


277 #undef 
O_BINARY


278 #undef 
O_TEXT


281 #ifndef 
O_BINARY


282 #define 
	#O_BINARY
 0

	)

283 #define 
	#O_TEXT
 0

	)

292 #if 0 < 
AT_FDCWD
 && AT_FDCWD == 0xffd19553

293 #undef 
AT_FDCWD


299 #ifndef 
AT_FDCWD


300 #define 
	#AT_FDCWD
 (-3041965)

	)

305 #ifndef 
AT_SYMLINK_NOFOLLOW


306 #define 
	#AT_SYMLINK_NOFOLLOW
 4096

	)

309 #ifndef 
AT_REMOVEDIR


310 #define 
	#AT_REMOVEDIR
 1

	)

314 #ifndef 
AT_SYMLINK_FOLLOW


315 #define 
	#AT_SYMLINK_FOLLOW
 2

	)

318 #ifndef 
AT_EACCESS


319 #define 
	#AT_EACCESS
 4

	)

	@lib/fnmatch.c

19 #ifndef 
_LIBC


20 #include 
	~<config.h
>

24 #ifndef 
_GNU_SOURCE


25 #define 
	#_GNU_SOURCE
 1

	)

28 #if ! 
defined
 
__builtin_expect
 && 
__GNUC__
 < 3

29 #define 
	#__builtin_expect
(
expr
, 
expected
) (expr)

	)

32 #include 
	~<fnmatch.h
>

34 #include 
	~<alloca.h
>

35 #include 
	~<assert.h
>

36 #include 
	~<ctype.h
>

37 #include 
	~<errno.h
>

38 #include 
	~<stddef.h
>

39 #include 
	~<stdbool.h
>

40 #include 
	~<stdlib.h
>

41 #include 
	~<string.h
>

43 #define 
	#WIDE_CHAR_SUPPORT
 \

44 (
HAVE_WCTYPE_H
 && 
HAVE_BTOWC
 && 
HAVE_ISWCTYPE
 \

45 && 
HAVE_WMEMCHR
 && (
HAVE_WMEMCPY
 || 
HAVE_WMEMPCPY
))

	)

49 #if 
defined
 
_LIBC
 || 
WIDE_CHAR_SUPPORT


50 #include 
	~<wctype.h
>

51 #include 
	~<wchar.h
>

57 #ifdef 
_LIBC


58 #include 
	~"../locale/localeinfo.h
"

59 #include 
	~"../locale/elem-hash.h
"

60 #include 
	~"../locale/coll-lookup.h
"

61 #include 
	~<shlib-compat.h
>

63 #define 
	#CONCAT
(
a
,
b
) 
	`__CONCAT
(a,b)

	)

64 #define 
	#mbsrtowcs
 
__mbsrtowcs


	)

65 #define 
	#fnmatch
 
__fnmatch


	)

66 extern int 
fnmatch
 (const char *
pattern
, const char *
string
, int 
flags
);

69 #ifndef 
SIZE_MAX


70 #define 
	#SIZE_MAX
 ((
size_t
) -1)

	)

74 #define 
	#NO_LEADING_PERIOD
(
flags
) \

75 ((
flags
 & (
FNM_FILE_NAME
 | 
FNM_PERIOD
)) == (FNM_FILE_NAME | FNM_PERIOD))

	)

86 #if 
defined
 
_LIBC
 || !defined 
__GNU_LIBRARY__
 || !
HAVE_FNMATCH_GNU


89 #if ! (
defined
 
isblank
 || (
HAVE_ISBLANK
 && 
HAVE_DECL_ISBLANK
))

90 #define 
	#isblank
(
c
) ((c) == ' ' || (c) == '\t')

	)

93 #define 
	#STREQ
(
s1
, 
s2
) (
	`strcmp
 (s1, s2) == 0)

	)

95 #if 
defined
 
_LIBC
 || 
WIDE_CHAR_SUPPORT


98 #ifdef 
CHARCLASS_NAME_MAX


99 #define 
	#CHAR_CLASS_MAX_LENGTH
 
CHARCLASS_NAME_MAX


	)

103 #define 
	#CHAR_CLASS_MAX_LENGTH
 256

	)

106 #ifdef 
_LIBC


107 #define 
	#IS_CHAR_CLASS
(
string
) 
	`__wctype
 (string)

	)

109 #define 
	#IS_CHAR_CLASS
(
string
) 
	`wctype
 (string)

	)

112 #ifdef 
_LIBC


113 #define 
	#ISWCTYPE
(
WC
, 
WT
) 
	`__iswctype
 (WC, WT)

	)

115 #define 
	#ISWCTYPE
(
WC
, 
WT
) 
	`iswctype
 (WC, WT)

	)

118 #if (
HAVE_MBSTATE_T
 && 
HAVE_MBSRTOWCS
) || 
_LIBC


120 #define 
	#HANDLE_MULTIBYTE
 1

	)

124 #define 
	#CHAR_CLASS_MAX_LENGTH
 6

	)

126 #define 
	#IS_CHAR_CLASS
(
string
) \

127 (
	`STREQ
 (
string
, "alpha") || STREQ (string, "upper") \

128 || 
	`STREQ
 (
string
, "lower") || STREQ (string, "digit") \

129 || 
	`STREQ
 (
string
, "alnum") || STREQ (string, "xdigit") \

130 || 
	`STREQ
 (
string
, "space") || STREQ (string, "print") \

131 || 
	`STREQ
 (
string
, "punct") || STREQ (string, "graph") \

132 || 
	`STREQ
 (
string
, "cntrl") || STREQ (string, "blank"))

	)

139 static int 
	gposixly_correct
;

141 #ifndef 
internal_function


144 #define 
	#internal_function


	)

148 #define 
	#FOLD
(
c
) ((
flags
 & 
FNM_CASEFOLD
) ? 
	`tolower
 (c) : (c))

	)

149 #define 
	#CHAR
 char

	)

150 #define 
	#UCHAR
 unsigned char

	)

151 #define 
	#INT
 int

	)

152 #define 
	#FCT
 
internal_fnmatch


	)

153 #define 
	#EXT
 
ext_match


	)

154 #define 
	#END
 
end_pattern


	)

155 #define 
	#L_
(
CS
) 
	)
CS

156 #ifdef 
_LIBC


157 #define 
	#BTOWC
(
C
) 
	`__btowc
 (C)

	)

159 #define 
	#BTOWC
(
C
) 
	`btowc
 (C)

	)

161 #define 
	#STRLEN
(
S
) 
	`strlen
 (S)

	)

162 #define 
	#STRCAT
(
D
, 
S
) 
	`strcat
 (D, S)

	)

163 #ifdef 
_LIBC


164 #define 
	#MEMPCPY
(
D
, 
S
, 
N
) 
	`__mempcpy
 (D, S, N)

	)

166 #if 
HAVE_MEMPCPY


167 #define 
	#MEMPCPY
(
D
, 
S
, 
N
) 
	`mempcpy
 (D, S, N)

	)

169 #define 
	#MEMPCPY
(
D
, 
S
, 
N
) ((void *) ((char *) 
	`memcpy
 (D, S, N) + (N)))

	)

172 #define 
	#MEMCHR
(
S
, 
C
, 
N
) 
	`memchr
 (S, C, N)

	)

173 #define 
	#STRCOLL
(
S1
, 
S2
) 
	`strcoll
 (S1, S2)

	)

174 #include 
	~"fnmatch_loop.c
"

177 #if 
HANDLE_MULTIBYTE


178 #define 
	#FOLD
(
c
) ((
flags
 & 
FNM_CASEFOLD
) ? 
	`towlower
 (c) : (c))

	)

179 #define 
	#CHAR
 
wchar_t


	)

180 #define 
	#UCHAR
 
wint_t


	)

181 #define 
	#INT
 
wint_t


	)

182 #define 
	#FCT
 
internal_fnwmatch


	)

183 #define 
	#EXT
 
ext_wmatch


	)

184 #define 
	#END
 
end_wpattern


	)

185 #define 
	#L_
(
CS
) 
L
##
	)
CS

186 #define 
	#BTOWC
(
C
) (C)

	)

187 #ifdef 
_LIBC


188 #define 
	#STRLEN
(
S
) 
	`__wcslen
 (S)

	)

189 #define 
	#STRCAT
(
D
, 
S
) 
	`__wcscat
 (D, S)

	)

190 #define 
	#MEMPCPY
(
D
, 
S
, 
N
) 
	`__wmempcpy
 (D, S, N)

	)

192 #define 
	#STRLEN
(
S
) 
	`wcslen
 (S)

	)

193 #define 
	#STRCAT
(
D
, 
S
) 
	`wcscat
 (D, S)

	)

194 #if 
HAVE_WMEMPCPY


195 #define 
	#MEMPCPY
(
D
, 
S
, 
N
) 
	`wmempcpy
 (D, S, N)

	)

197 #define 
	#MEMPCPY
(
D
, 
S
, 
N
) (
	`wmemcpy
 (D, S, N) + (N))

	)

200 #define 
	#MEMCHR
(
S
, 
C
, 
N
) 
	`wmemchr
 (S, C, N)

	)

201 #define 
	#STRCOLL
(
S1
, 
S2
) 
	`wcscoll
 (S1, S2)

	)

202 #define 
	#WIDE_CHAR_VERSION
 1

	)

204 #undef 
IS_CHAR_CLASS


211 static 
wctype_t


212 
	$is_char_class
 (const 
wchar_t
 *
wcs
)

214 char 
s
[
CHAR_CLASS_MAX_LENGTH
 + 1];

215 char *
cp
 = 
s
;

220 #ifdef 
_LIBC


221 if (*
wcs
 < 0x20 || *wcs > 0x7e

222 || *
wcs
 == 0x24 || *wcs == 0x40 || *wcs == 0x60)

223 return (
wctype_t
) 0;

225 switch (*
wcs
)

227 case 
L
' ': case L'!': case L'"': case L'#': case L'%':

228 case 
L
'&': case L'\'': case L'(': case L')': case L'*':

229 case 
L
'+': case L',': case L'-': case L'.': case L'/':

230 case 
L
'0': case L'1': case L'2': case L'3': case L'4':

231 case 
L
'5': case L'6': case L'7': case L'8': case L'9':

232 case 
L
':': case L';': case L'<': case L'=': case L'>':

233 case 
L
'?':

234 case 
L
'A': case L'B': case L'C': case L'D': case L'E':

235 case 
L
'F': case L'G': case L'H': case L'I': case L'J':

236 case 
L
'K': case L'L': case L'M': case L'N': case L'O':

237 case 
L
'P': case L'Q': case L'R': case L'S': case L'T':

238 case 
L
'U': case L'V': case L'W': case L'X': case L'Y':

239 case 
L
'Z':

240 case 
L
'[': case L'\\': case L']': case L'^': case L'_':

241 case 
L
'a': case L'b': case L'c': case L'd': case L'e':

242 case 
L
'f': case L'g': case L'h': case L'i': case L'j':

243 case 
L
'k': case L'l': case L'm': case L'n': case L'o':

244 case 
L
'p': case L'q': case L'r': case L's': case L't':

245 case 
L
'u': case L'v': case L'w': case L'x': case L'y':

246 case 
L
'z': case L'{': case L'|': case L'}': case L'~':

249 return (
wctype_t
) 0;

254 if (
cp
 == 
s
 + 
CHAR_CLASS_MAX_LENGTH
)

255 return (
wctype_t
) 0;

257 *
cp
++ = (char) *
wcs
++;

259 while (*
wcs
 != 
L
'\0');

261 *
cp
 = '\0';

263 #ifdef 
_LIBC


264 return 
	`__wctype
 (
s
);

266 return 
	`wctype
 (
s
);

268 
	}
}

269 #define 
	#IS_CHAR_CLASS
(
string
) 
	`is_char_class
 (string)

	)

271 #include 
	~"fnmatch_loop.c
"

276 
	$fnmatch
 (const char *
pattern
, const char *
string
, int 
flags
)

278 #if 
HANDLE_MULTIBYTE


279 #define 
	#ALLOCA_LIMIT
 2000

	)

280 if (
	`__builtin_expect
 (
MB_CUR_MAX
, 1) != 1)

282 
mbstate_t
 
ps
;

283 
size_t
 
patsize
;

284 
size_t
 
strsize
;

285 
size_t
 
totsize
;

286 
wchar_t
 *
wpattern
;

287 
wchar_t
 *
wstring
;

288 int 
res
;

292 
	`memset
 (&
ps
, '\0', sizeof (ps));

293 
patsize
 = 
	`mbsrtowcs
 (
NULL
, &
pattern
, 0, &
ps
) + 1;

294 if (
	`__builtin_expect
 (
patsize
 != 0, 1))

296 
	`assert
 (
	`mbsinit
 (&
ps
));

297 
strsize
 = 
	`mbsrtowcs
 (
NULL
, &
string
, 0, &
ps
) + 1;

298 if (
	`__builtin_expect
 (
strsize
 != 0, 1))

300 
	`assert
 (
	`mbsinit
 (&
ps
));

301 
totsize
 = 
patsize
 + 
strsize
;

302 if (
	`__builtin_expect
 (! (
patsize
 <= 
totsize


303 && 
totsize
 <= 
SIZE_MAX
 / sizeof (
wchar_t
)),

306 
errno
 = 
ENOMEM
;

311 if (
	`__builtin_expect
 (
totsize
 < 
ALLOCA_LIMIT
, 1))

312 
wpattern
 = (
wchar_t
 *) 
	`alloca
 (
totsize
 * sizeof (wchar_t));

315 
wpattern
 = 
	`malloc
 (
totsize
 * sizeof (
wchar_t
));

316 if (
	`__builtin_expect
 (! 
wpattern
, 0))

318 
errno
 = 
ENOMEM
;

322 
wstring
 = 
wpattern
 + 
patsize
;

325 
	`mbsrtowcs
 (
wpattern
, &
pattern
, 
patsize
, &
ps
);

326 
	`assert
 (
	`mbsinit
 (&
ps
));

327 
	`mbsrtowcs
 (
wstring
, &
string
, 
strsize
, &
ps
);

329 
res
 = 
	`internal_fnwmatch
 (
wpattern
, 
wstring
, wstring + 
strsize
 - 1,

330 
flags
 & 
FNM_PERIOD
, flags);

332 if (
	`__builtin_expect
 (! (
totsize
 < 
ALLOCA_LIMIT
), 0))

333 
	`free
 (
wpattern
);

334 return 
res
;

341 return 
	`internal_fnmatch
 (
pattern
, 
string
, string + 
	`strlen
 (string),

342 
flags
 & 
FNM_PERIOD
, flags);

343 
	}
}

345 #ifdef 
_LIBC


346 #undef 
fnmatch


347 
versioned_symbol
 (
libc
, 
__fnmatch
, 
fnmatch
, 
GLIBC_2_2_3
);

348 #if 
SHLIB_COMPAT
(
libc
, 
GLIBC_2_0
, 
GLIBC_2_2_3
)

349 
	$strong_alias
 (
__fnmatch
, 
__fnmatch_old
)

350 
	`compat_symbol
 (
libc
, 
__fnmatch_old
, 
fnmatch
, 
GLIBC_2_0
);

352 
	$libc_hidden_ver
 (
__fnmatch
, 
fnmatch
)

	@lib/fnmatch.in.h

22 #ifndef 
_FNMATCH_H


23 #define 
	#_FNMATCH_H
 1

	)

27 #ifdef 
__cplusplus


33 #undef 
FNM_PATHNAME


34 #undef 
FNM_NOESCAPE


35 #undef 
FNM_PERIOD


38 #define 
	#FNM_PATHNAME
 (1 << 0)

	)

39 #define 
	#FNM_NOESCAPE
 (1 << 1)

	)

40 #define 
	#FNM_PERIOD
 (1 << 2)

	)

42 #if !
defined
 
_POSIX_C_SOURCE
 || _POSIX_C_SOURCE < 2 || defined 
_GNU_SOURCE


43 #define 
	#FNM_FILE_NAME
 
FNM_PATHNAME


	)

44 #define 
	#FNM_LEADING_DIR
 (1 << 3)

	)

45 #define 
	#FNM_CASEFOLD
 (1 << 4)

	)

46 #define 
	#FNM_EXTMATCH
 (1 << 5)

	)

50 #define 
	#FNM_NOMATCH
 1

	)

56 #ifdef 
_XOPEN_SOURCE


57 #define 
	#FNM_NOSYS
 (-1)

	)

62 extern int 
fnmatch
 (const char *
__pattern
, const char *
__name
,

63 int 
__flags
)

64 
_GL_ARG_NONNULL
 ((1, 2));

66 #ifdef 
__cplusplus


	@lib/fnmatch_loop.c

22 static int 
	$EXT
 (
INT
 
opt
, const 
CHAR
 *
pattern
, const CHAR *
string
,

23 const 
CHAR
 *
string_end
, 
bool
 
no_leading_period
, int 
flags
)

24 
internal_function
;

25 static const 
CHAR
 *
	$END
 (const 
CHAR
 *
patternp
) 
internal_function
;

28 
internal_function


29 
	$FCT
 (const 
CHAR
 *
pattern
, const CHAR *
string
, const CHAR *
string_end
,

30 
bool
 
no_leading_period
, int 
flags
)

32 register const 
CHAR
 *
p
 = 
pattern
, *
n
 = 
string
;

33 register 
UCHAR
 
c
;

34 #ifdef 
_LIBC


35 #if 
WIDE_CHAR_VERSION


36 const char *
collseq
 = (const char *)

37 
	`_NL_CURRENT
(
LC_COLLATE
, 
_NL_COLLATE_COLLSEQWC
);

39 const 
UCHAR
 *
collseq
 = (const UCHAR *)

40 
	`_NL_CURRENT
(
LC_COLLATE
, 
_NL_COLLATE_COLLSEQMB
);

44 while ((
c
 = *
p
++) != 
	`L_
('\0'))

46 
bool
 
new_no_leading_period
 = 
false
;

47 
c
 = 
	`FOLD
 (c);

49 switch (
c
)

51 case 
	`L_
('?'):

52 if (
	`__builtin_expect
 (
flags
 & 
FNM_EXTMATCH
, 0) && *
p
 == '(')

54 int 
res
;

56 
res
 = 
	`EXT
 (
c
, 
p
, 
n
, 
string_end
, 
no_leading_period
,

57 
flags
);

58 if (
res
 != -1)

59 return 
res
;

62 if (
n
 == 
string_end
)

63 return 
FNM_NOMATCH
;

64 else if (*
n
 == 
	`L_
('/') && (
flags
 & 
FNM_FILE_NAME
))

65 return 
FNM_NOMATCH
;

66 else if (*
n
 == 
	`L_
('.') && 
no_leading_period
)

67 return 
FNM_NOMATCH
;

70 case 
	`L_
('\\'):

71 if (!(
flags
 & 
FNM_NOESCAPE
))

73 
c
 = *
p
++;

74 if (
c
 == 
	`L_
('\0'))

76 return 
FNM_NOMATCH
;

77 
c
 = 
	`FOLD
 (c);

79 if (
n
 == 
string_end
 || 
	`FOLD
 ((
UCHAR
) *n) != 
c
)

80 return 
FNM_NOMATCH
;

83 case 
	`L_
('*'):

84 if (
	`__builtin_expect
 (
flags
 & 
FNM_EXTMATCH
, 0) && *
p
 == '(')

86 int 
res
;

88 
res
 = 
	`EXT
 (
c
, 
p
, 
n
, 
string_end
, 
no_leading_period
,

89 
flags
);

90 if (
res
 != -1)

91 return 
res
;

94 if (
n
 != 
string_end
 && *n == 
	`L_
('.') && 
no_leading_period
)

95 return 
FNM_NOMATCH
;

97 for (
c
 = *
p
++; c == 
	`L_
('?') || c == L_('*'); c = *p++)

99 if (*
p
 == 
	`L_
('(') && (
flags
 & 
FNM_EXTMATCH
) != 0)

101 const 
CHAR
 *
endp
 = 
	`END
 (
p
);

102 if (
endp
 != 
p
)

105 
p
 = 
endp
;

110 if (
c
 == 
	`L_
('?'))

113 if (
n
 == 
string_end
)

115 return 
FNM_NOMATCH
;

116 else if (*
n
 == 
	`L_
('/')

117 && 
	`__builtin_expect
 (
flags
 & 
FNM_FILE_NAME
, 0))

120 return 
FNM_NOMATCH
;

125 ++
n
;

129 if (
c
 == 
	`L_
('\0'))

135 int 
result
 = (
flags
 & 
FNM_FILE_NAME
) == 0 ? 0 : 
FNM_NOMATCH
;

137 if (
flags
 & 
FNM_FILE_NAME
)

139 if (
flags
 & 
FNM_LEADING_DIR
)

140 
result
 = 0;

143 if (
	`MEMCHR
 (
n
, 
	`L_
('/'), 
string_end
 - n) == 
NULL
)

144 
result
 = 0;

148 return 
result
;

152 const 
CHAR
 *
endp
;

154 
endp
 = 
	`MEMCHR
 (
n
, (
flags
 & 
FNM_FILE_NAME
) ? 
	`L_
('/') : L_('\0'),

155 
string_end
 - 
n
);

156 if (
endp
 == 
NULL
)

157 
endp
 = 
string_end
;

159 if (
c
 == 
	`L_
('[')

160 || (
	`__builtin_expect
 (
flags
 & 
FNM_EXTMATCH
, 0) != 0

161 && (
c
 == 
	`L_
('@') || c == L_('+') || c == L_('!'))

162 && *
p
 == 
	`L_
('(')))

164 int 
flags2
 = ((
flags
 & 
FNM_FILE_NAME
)

165 ? 
flags
 : (flags & ~
FNM_PERIOD
));

166 
bool
 
no_leading_period2
 = 
no_leading_period
;

168 for (--
p
; 
n
 < 
endp
; ++n, 
no_leading_period2
 = 
false
)

169 if (
	`FCT
 (
p
, 
n
, 
string_end
, 
no_leading_period2
, 
flags2
)

173 else if (
c
 == 
	`L_
('/') && (
flags
 & 
FNM_FILE_NAME
))

175 while (
n
 < 
string_end
 && *n != 
	`L_
('/'))

176 ++
n
;

177 if (
n
 < 
string_end
 && *n == 
	`L_
('/')

178 && (
	`FCT
 (
p
, 
n
 + 1, 
string_end
, 
flags
 & 
FNM_PERIOD
, flags)

184 int 
flags2
 = ((
flags
 & 
FNM_FILE_NAME
)

185 ? 
flags
 : (flags & ~
FNM_PERIOD
));

186 int 
no_leading_period2
 = 
no_leading_period
;

188 if (
c
 == 
	`L_
('\\') && !(
flags
 & 
FNM_NOESCAPE
))

189 
c
 = *
p
;

190 
c
 = 
	`FOLD
 (c);

191 for (--
p
; 
n
 < 
endp
; ++n, 
no_leading_period2
 = 
false
)

192 if (
	`FOLD
 ((
UCHAR
) *
n
) == 
c


193 && (
	`FCT
 (
p
, 
n
, 
string_end
, 
no_leading_period2
, 
flags2
)

200 return 
FNM_NOMATCH
;

202 case 
	`L_
('['):

205 const 
CHAR
 *
p_init
 = 
p
;

206 const 
CHAR
 *
n_init
 = 
n
;

207 register 
bool
 
not
;

208 
CHAR
 
cold
;

209 
UCHAR
 
fn
;

211 if (
posixly_correct
 == 0)

212 
posixly_correct
 = 
	`getenv
 ("POSIXLY_CORRECT") != 
NULL
 ? 1 : -1;

214 if (
n
 == 
string_end
)

215 return 
FNM_NOMATCH
;

217 if (*
n
 == 
	`L_
('.') && 
no_leading_period
)

218 return 
FNM_NOMATCH
;

220 if (*
n
 == 
	`L_
('/') && (
flags
 & 
FNM_FILE_NAME
))

222 return 
FNM_NOMATCH
;

224 
not
 = (*
p
 == 
	`L_
('!') || (
posixly_correct
 < 0 && *p == L_('^')));

225 if (
not
)

226 ++
p
;

228 
fn
 = 
	`FOLD
 ((
UCHAR
) *
n
);

230 
c
 = *
p
++;

233 if (!(
flags
 & 
FNM_NOESCAPE
) && 
c
 == 
	`L_
('\\'))

235 if (*
p
 == 
	`L_
('\0'))

236 return 
FNM_NOMATCH
;

237 
c
 = 
	`FOLD
 ((
UCHAR
) *
p
);

238 ++
p
;

240 goto 
normal_bracket
;

242 else if (
c
 == 
	`L_
('[') && *
p
 == L_(':'))

245 
CHAR
 
str
[
CHAR_CLASS_MAX_LENGTH
 + 1];

246 
size_t
 
c1
 = 0;

247 #if 
defined
 
_LIBC
 || 
WIDE_CHAR_SUPPORT


248 
wctype_t
 
wt
;

250 const 
CHAR
 *
startp
 = 
p
;

254 if (
c1
 == 
CHAR_CLASS_MAX_LENGTH
)

257 return 
FNM_NOMATCH
;

259 
c
 = *++
p
;

260 if (
c
 == 
	`L_
(':') && 
p
[1] == L_(']'))

262 
p
 += 2;

265 if (
c
 < 
	`L_
('a') || c >= L_('z'))

269 
p
 = 
startp
;

270 
c
 = 
	`L_
('[');

271 goto 
normal_bracket
;

273 
str
[
c1
++] = 
c
;

275 
str
[
c1
] = 
	`L_
('\0');

277 #if 
defined
 
_LIBC
 || 
WIDE_CHAR_SUPPORT


278 
wt
 = 
	`IS_CHAR_CLASS
 (
str
);

279 if (
wt
 == 0)

281 return 
FNM_NOMATCH
;

283 #if 
defined
 
_LIBC
 && ! 
WIDE_CHAR_VERSION


287 if (
	`_ISCTYPE
 ((
UCHAR
) *
n
, 
wt
))

288 goto 
matched
;

290 if (
	`ISWCTYPE
 (
	`BTOWC
 ((
UCHAR
) *
n
), 
wt
))

291 goto 
matched
;

294 if ((
	`STREQ
 (
str
, 
	`L_
("alnum")) && 
	`isalnum
 ((
UCHAR
) *
n
))

295 || (
	`STREQ
 (
str
, 
	`L_
("alpha")) && 
	`isalpha
 ((
UCHAR
) *
n
))

296 || (
	`STREQ
 (
str
, 
	`L_
("blank")) && 
	`isblank
 ((
UCHAR
) *
n
))

297 || (
	`STREQ
 (
str
, 
	`L_
("cntrl")) && 
	`iscntrl
 ((
UCHAR
) *
n
))

298 || (
	`STREQ
 (
str
, 
	`L_
("digit")) && 
	`isdigit
 ((
UCHAR
) *
n
))

299 || (
	`STREQ
 (
str
, 
	`L_
("graph")) && 
	`isgraph
 ((
UCHAR
) *
n
))

300 || (
	`STREQ
 (
str
, 
	`L_
("lower")) && 
	`islower
 ((
UCHAR
) *
n
))

301 || (
	`STREQ
 (
str
, 
	`L_
("print")) && 
	`isprint
 ((
UCHAR
) *
n
))

302 || (
	`STREQ
 (
str
, 
	`L_
("punct")) && 
	`ispunct
 ((
UCHAR
) *
n
))

303 || (
	`STREQ
 (
str
, 
	`L_
("space")) && 
	`isspace
 ((
UCHAR
) *
n
))

304 || (
	`STREQ
 (
str
, 
	`L_
("upper")) && 
	`isupper
 ((
UCHAR
) *
n
))

305 || (
	`STREQ
 (
str
, 
	`L_
("xdigit")) && 
	`isxdigit
 ((
UCHAR
) *
n
)))

306 goto 
matched
;

308 
c
 = *
p
++;

310 #ifdef 
_LIBC


311 else if (
c
 == 
	`L_
('[') && *
p
 == L_('='))

313 
UCHAR
 
str
[1];

314 
uint32_t
 
nrules
 =

315 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
);

316 const 
CHAR
 *
startp
 = 
p
;

318 
c
 = *++
p
;

319 if (
c
 == 
	`L_
('\0'))

321 
p
 = 
startp
;

322 
c
 = 
	`L_
('[');

323 goto 
normal_bracket
;

325 
str
[0] = 
c
;

327 
c
 = *++
p
;

328 if (
c
 != 
	`L_
('=') || 
p
[1] != L_(']'))

330 
p
 = 
startp
;

331 
c
 = 
	`L_
('[');

332 goto 
normal_bracket
;

334 
p
 += 2;

336 if (
nrules
 == 0)

338 if ((
UCHAR
) *
n
 == 
str
[0])

339 goto 
matched
;

343 const 
int32_t
 *
table
;

344 #if 
WIDE_CHAR_VERSION


345 const 
int32_t
 *
weights
;

346 const 
int32_t
 *
extra
;

348 const unsigned char *
weights
;

349 const unsigned char *
extra
;

351 const 
int32_t
 *
indirect
;

352 
int32_t
 
idx
;

353 const 
UCHAR
 *
cp
 = (const UCHAR *) 
str
;

356 #if 
WIDE_CHAR_VERSION


357 #include 
	~<locale/weightwc.h
>

359 #include 
	~<locale/weight.h
>

362 #if 
WIDE_CHAR_VERSION


363 
table
 = (const 
int32_t
 *)

364 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_TABLEWC
);

365 
weights
 = (const 
int32_t
 *)

366 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_WEIGHTWC
);

367 
extra
 = (const 
int32_t
 *)

368 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_EXTRAWC
);

369 
indirect
 = (const 
int32_t
 *)

370 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_INDIRECTWC
);

372 
table
 = (const 
int32_t
 *)

373 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_TABLEMB
);

374 
weights
 = (const unsigned char *)

375 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_WEIGHTMB
);

376 
extra
 = (const unsigned char *)

377 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_EXTRAMB
);

378 
indirect
 = (const 
int32_t
 *)

379 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_INDIRECTMB
);

382 
idx
 = 
	`findidx
 (&
cp
);

383 if (
idx
 != 0)

388 int 
len
 = 
weights
[
idx
 & 0xffffff];

389 
int32_t
 
idx2
;

390 const 
UCHAR
 *
np
 = (const UCHAR *) 
n
;

392 
idx2
 = 
	`findidx
 (&
np
);

393 if (
idx2
 != 0

394 && (
idx
 >> 24) == (
idx2
 >> 24)

395 && 
len
 == 
weights
[
idx2
 & 0xffffff])

397 int 
cnt
 = 0;

399 
idx
 &= 0xffffff;

400 
idx2
 &= 0xffffff;

402 while (
cnt
 < 
len


403 && (
weights
[
idx
 + 1 + 
cnt
]

404 == 
weights
[
idx2
 + 1 + 
cnt
]))

405 ++
cnt
;

407 if (
cnt
 == 
len
)

408 goto 
matched
;

413 
c
 = *
p
++;

416 else if (
c
 == 
	`L_
('\0'))

419 
p
 = 
p_init
;

420 
n
 = 
n_init
;

421 
c
 = 
	`L_
('[');

422 goto 
normal_match
;

426 
bool
 
is_range
 = 
false
;

428 #ifdef 
_LIBC


429 
bool
 
is_seqval
 = 
false
;

431 if (
c
 == 
	`L_
('[') && *
p
 == L_('.'))

433 
uint32_t
 
nrules
 =

434 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
);

435 const 
CHAR
 *
startp
 = 
p
;

436 
size_t
 
c1
 = 0;

440 
c
 = *++
p
;

441 if (
c
 == 
	`L_
('.') && 
p
[1] == L_(']'))

443 
p
 += 2;

446 if (
c
 == '\0')

447 return 
FNM_NOMATCH
;

448 ++
c1
;

454 
is_range
 = *
p
 == 
	`L_
('-') && p[1] != L_('\0');

456 if (
nrules
 == 0)

461 if (
c1
 != 1)

462 return 
FNM_NOMATCH
;

464 if (!
is_range
 && *
n
 == 
startp
[1])

465 goto 
matched
;

467 
cold
 = 
startp
[1];

468 
c
 = *
p
++;

472 
int32_t
 
table_size
;

473 const 
int32_t
 *
symb_table
;

474 #ifdef 
WIDE_CHAR_VERSION


475 char 
str
[
c1
];

476 
size_t
 
strcnt
;

478 #define 
	#str
 (
startp
 + 1)

	)

480 const unsigned char *
extra
;

481 
int32_t
 
idx
;

482 
int32_t
 
elem
;

483 
int32_t
 
second
;

484 
int32_t
 
hash
;

486 #ifdef 
WIDE_CHAR_VERSION


491 for (
strcnt
 = 0; strcnt < 
c1
; ++strcnt)

492 
str
[
strcnt
] = 
startp
[1 + strcnt];

495 
table_size
 =

496 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
,

497 
_NL_COLLATE_SYMB_HASH_SIZEMB
);

498 
symb_table
 = (const 
int32_t
 *)

499 
	`_NL_CURRENT
 (
LC_COLLATE
,

500 
_NL_COLLATE_SYMB_TABLEMB
);

501 
extra
 = (const unsigned char *)

502 
	`_NL_CURRENT
 (
LC_COLLATE
,

503 
_NL_COLLATE_SYMB_EXTRAMB
);

506 
hash
 = 
	`elem_hash
 (
str
, 
c1
);

508 
idx
 = 0;

509 
elem
 = 
hash
 % 
table_size
;

510 if (
symb_table
[2 * 
elem
] != 0)

512 
second
 = 
hash
 % (
table_size
 - 2) + 1;

517 if (
symb_table
[2 * 
elem
] == 
hash


518 && (
c1


519 == 
extra
[
symb_table
[2 * 
elem
 + 1]])

520 && 
	`memcmp
 (
str
,

521 &
extra
[
symb_table
[2 * 
elem


523 + 1], 
c1
) == 0)

526 
idx
 = 
symb_table
[2 * 
elem
 + 1];

527 
idx
 += 1 + 
extra
[idx];

532 
elem
 += 
second
;

534 while (
symb_table
[2 * 
elem
] != 0);

537 if (
symb_table
[2 * 
elem
] != 0)

541 #ifdef 
WIDE_CHAR_VERSION


542 
int32_t
 *
wextra
;

544 
idx
 += 1 + 
extra
[idx];

546 
idx
 = (idx + 3) & ~3;

548 
wextra
 = (
int32_t
 *) &
extra
[
idx
 + 4];

551 if (! 
is_range
)

553 #ifdef 
WIDE_CHAR_VERSION


554 for (
c1
 = 0;

555 (
int32_t
) 
c1
 < 
wextra
[
idx
];

556 ++
c1
)

557 if (
n
[
c1
] != 
wextra
[1 + c1])

560 if ((
int32_t
) 
c1
 == 
wextra
[
idx
])

561 goto 
matched
;

563 for (
c1
 = 0; c1 < 
extra
[
idx
]; ++c1)

564 if (
n
[
c1
] != 
extra
[1 + c1])

567 if (
c1
 == 
extra
[
idx
])

568 goto 
matched
;

573 
is_seqval
 = 
true
;

574 #ifdef 
WIDE_CHAR_VERSION


575 
cold
 = 
wextra
[1 + wextra[
idx
]];

578 
idx
 += 1 + 
extra
[idx];

579 
idx
 = (idx + 3) & ~4;

580 
cold
 = *((
int32_t
 *) &
extra
[
idx
]);

583 
c
 = *
p
++;

585 else if (
c1
 == 1)

589 if (!
is_range
 && *
n
 == 
str
[0])

590 goto 
matched
;

592 
cold
 = 
str
[0];

593 
c
 = *
p
++;

596 return 
FNM_NOMATCH
;

600 #undef 
str


603 
c
 = 
	`FOLD
 (c);

604 
normal_bracket
:

609 
is_range
 = (*
p
 == 
	`L_
('-') && p[1] != L_('\0')

610 && 
p
[1] != 
	`L_
(']'));

612 if (!
is_range
 && 
c
 == 
fn
)

613 goto 
matched
;

615 #if 
_LIBC


618 
is_seqval
 = 
false
;

621 
cold
 = 
c
;

622 
c
 = *
p
++;

625 if (
c
 == 
	`L_
('-') && *
p
 != L_(']'))

627 #if 
_LIBC


636 
uint32_t
 
fcollseq
;

637 
uint32_t
 
lcollseq
;

638 
UCHAR
 
cend
 = *
p
++;

640 #ifdef 
WIDE_CHAR_VERSION


642 
fcollseq
 = 
	`__collseq_table_lookup
 (
collseq
, 
fn
);

643 if (
fcollseq
 == ~((
uint32_t
) 0))

647 goto 
range_not_matched
;

649 if (
is_seqval
)

650 
lcollseq
 = 
cold
;

652 
lcollseq
 = 
	`__collseq_table_lookup
 (
collseq
, 
cold
);

654 
fcollseq
 = 
collseq
[
fn
];

655 
lcollseq
 = 
is_seqval
 ? 
cold
 : 
collseq
[(
UCHAR
) cold];

658 
is_seqval
 = 
false
;

659 if (
cend
 == 
	`L_
('[') && *
p
 == L_('.'))

661 
uint32_t
 
nrules
 =

662 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
,

663 
_NL_COLLATE_NRULES
);

664 const 
CHAR
 *
startp
 = 
p
;

665 
size_t
 
c1
 = 0;

669 
c
 = *++
p
;

670 if (
c
 == 
	`L_
('.') && 
p
[1] == L_(']'))

672 
p
 += 2;

675 if (
c
 == '\0')

676 return 
FNM_NOMATCH
;

677 ++
c1
;

680 if (
nrules
 == 0)

686 if (
c1
 != 1)

687 return 
FNM_NOMATCH
;

689 
cend
 = 
startp
[1];

693 
int32_t
 
table_size
;

694 const 
int32_t
 *
symb_table
;

695 #ifdef 
WIDE_CHAR_VERSION


696 char 
str
[
c1
];

697 
size_t
 
strcnt
;

699 #define 
	#str
 (
startp
 + 1)

	)

701 const unsigned char *
extra
;

702 
int32_t
 
idx
;

703 
int32_t
 
elem
;

704 
int32_t
 
second
;

705 
int32_t
 
hash
;

707 #ifdef 
WIDE_CHAR_VERSION


712 for (
strcnt
 = 0; strcnt < 
c1
; ++strcnt)

713 
str
[
strcnt
] = 
startp
[1 + strcnt];

716 
table_size
 =

717 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
,

718 
_NL_COLLATE_SYMB_HASH_SIZEMB
);

719 
symb_table
 = (const 
int32_t
 *)

720 
	`_NL_CURRENT
 (
LC_COLLATE
,

721 
_NL_COLLATE_SYMB_TABLEMB
);

722 
extra
 = (const unsigned char *)

723 
	`_NL_CURRENT
 (
LC_COLLATE
,

724 
_NL_COLLATE_SYMB_EXTRAMB
);

728 
hash
 = 
	`elem_hash
 (
str
, 
c1
);

730 
idx
 = 0;

731 
elem
 = 
hash
 % 
table_size
;

732 if (
symb_table
[2 * 
elem
] != 0)

734 
second
 = 
hash
 % (
table_size
 - 2) + 1;

739 if (
symb_table
[2 * 
elem
] == 
hash


740 && (
c1


741 == 
extra
[
symb_table
[2 * 
elem
 + 1]])

742 && 
	`memcmp
 (
str
,

743 &
extra
[
symb_table
[2 * 
elem
 + 1]

744 + 1], 
c1
) == 0)

747 
idx
 = 
symb_table
[2 * 
elem
 + 1];

748 
idx
 += 1 + 
extra
[idx];

753 
elem
 += 
second
;

755 while (
symb_table
[2 * 
elem
] != 0);

758 if (
symb_table
[2 * 
elem
] != 0)

762 #ifdef 
WIDE_CHAR_VERSION


763 
int32_t
 *
wextra
;

765 
idx
 += 1 + 
extra
[idx];

767 
idx
 = (idx + 3) & ~4;

769 
wextra
 = (
int32_t
 *) &
extra
[
idx
 + 4];

772 
is_seqval
 = 
true
;

773 #ifdef 
WIDE_CHAR_VERSION


774 
cend
 = 
wextra
[1 + wextra[
idx
]];

777 
idx
 += 1 + 
extra
[idx];

778 
idx
 = (idx + 3) & ~4;

779 
cend
 = *((
int32_t
 *) &
extra
[
idx
]);

782 else if (
symb_table
[2 * 
elem
] != 0 && 
c1
 == 1)

784 
cend
 = 
str
[0];

785 
c
 = *
p
++;

788 return 
FNM_NOMATCH
;

790 #undef 
str


794 if (!(
flags
 & 
FNM_NOESCAPE
) && 
cend
 == 
	`L_
('\\'))

795 
cend
 = *
p
++;

796 if (
cend
 == 
	`L_
('\0'))

797 return 
FNM_NOMATCH
;

798 
cend
 = 
	`FOLD
 (cend);

805 #ifdef 
WIDE_CHAR_VERSION


806 
lcollseq
 == 0xffffffff ||

808 
lcollseq
 <= 
fcollseq
)

811 
uint32_t
 
hcollseq
;

813 if (
is_seqval
)

814 
hcollseq
 = 
cend
;

817 #ifdef 
WIDE_CHAR_VERSION


818 
hcollseq
 =

819 
	`__collseq_table_lookup
 (
collseq
, 
cend
);

820 if (
hcollseq
 == ~((
uint32_t
) 0))

825 if (
lcollseq
 != 
fcollseq
)

826 goto 
range_not_matched
;

828 goto 
matched
;

831 
hcollseq
 = 
collseq
[
cend
];

835 if (
lcollseq
 <= 
hcollseq
 && 
fcollseq
 <= hcollseq)

836 goto 
matched
;

838 #ifdef 
WIDE_CHAR_VERSION


839 
range_not_matched
:

846 
UCHAR
 
cend
 = *
p
++;

848 if (!(
flags
 & 
FNM_NOESCAPE
) && 
cend
 == 
	`L_
('\\'))

849 
cend
 = *
p
++;

850 if (
cend
 == 
	`L_
('\0'))

851 return 
FNM_NOMATCH
;

854 if (
cold
 <= 
fn
 && fn <= 
cend
)

855 goto 
matched
;

858 
c
 = *
p
++;

862 if (
c
 == 
	`L_
(']'))

866 if (!
not
)

867 return 
FNM_NOMATCH
;

870 
matched
:

874 
ignore_next
:

875 
c
 = *
p
++;

877 if (
c
 == 
	`L_
('\0'))

879 return 
FNM_NOMATCH
;

881 if (!(
flags
 & 
FNM_NOESCAPE
) && 
c
 == 
	`L_
('\\'))

883 if (*
p
 == 
	`L_
('\0'))

884 return 
FNM_NOMATCH
;

886 ++
p
;

888 else if (
c
 == 
	`L_
('[') && *
p
 == L_(':'))

890 int 
c1
 = 0;

891 const 
CHAR
 *
startp
 = 
p
;

895 
c
 = *++
p
;

896 if (++
c1
 == 
CHAR_CLASS_MAX_LENGTH
)

897 return 
FNM_NOMATCH
;

899 if (*
p
 == 
	`L_
(':') && p[1] == L_(']'))

902 if (
c
 < 
	`L_
('a') || c >= L_('z'))

904 
p
 = 
startp
;

905 goto 
ignore_next
;

908 
p
 += 2;

909 
c
 = *
p
++;

911 else if (
c
 == 
	`L_
('[') && *
p
 == L_('='))

913 
c
 = *++
p
;

914 if (
c
 == 
	`L_
('\0'))

915 return 
FNM_NOMATCH
;

916 
c
 = *++
p
;

917 if (
c
 != 
	`L_
('=') || 
p
[1] != L_(']'))

918 return 
FNM_NOMATCH
;

919 
p
 += 2;

920 
c
 = *
p
++;

922 else if (
c
 == 
	`L_
('[') && *
p
 == L_('.'))

924 ++
p
;

927 
c
 = *++
p
;

928 if (
c
 == '\0')

929 return 
FNM_NOMATCH
;

931 if (*
p
 == 
	`L_
('.') && p[1] == L_(']'))

934 
p
 += 2;

935 
c
 = *
p
++;

938 while (
c
 != 
	`L_
(']'));

939 if (
not
)

940 return 
FNM_NOMATCH
;

944 case 
	`L_
('+'):

945 case 
	`L_
('@'):

946 case 
	`L_
('!'):

947 if (
	`__builtin_expect
 (
flags
 & 
FNM_EXTMATCH
, 0) && *
p
 == '(')

949 int 
res
;

951 
res
 = 
	`EXT
 (
c
, 
p
, 
n
, 
string_end
, 
no_leading_period
, 
flags
);

952 if (
res
 != -1)

953 return 
res
;

955 goto 
normal_match
;

957 case 
	`L_
('/'):

958 if (
	`NO_LEADING_PERIOD
 (
flags
))

960 if (
n
 == 
string_end
 || 
c
 != (
UCHAR
) *n)

961 return 
FNM_NOMATCH
;

963 
new_no_leading_period
 = 
true
;

968 
normal_match
:

969 if (
n
 == 
string_end
 || 
c
 != 
	`FOLD
 ((
UCHAR
) *n))

970 return 
FNM_NOMATCH
;

973 
no_leading_period
 = 
new_no_leading_period
;

974 ++
n
;

977 if (
n
 == 
string_end
)

980 if ((
flags
 & 
FNM_LEADING_DIR
) && 
n
 != 
string_end
 && *n == 
	`L_
('/'))

984 return 
FNM_NOMATCH
;

985 
	}
}

988 static const 
CHAR
 *

989 
internal_function


990 
	$END
 (const 
CHAR
 *
pattern
)

992 const 
CHAR
 *
p
 = 
pattern
;

995 if (*++
p
 == 
	`L_
('\0'))

997 return 
pattern
;

998 else if (*
p
 == 
	`L_
('['))

1001 if (
posixly_correct
 == 0)

1002 
posixly_correct
 = 
	`getenv
 ("POSIXLY_CORRECT") != 
NULL
 ? 1 : -1;

1006 if (*++
p
 == 
	`L_
('!') || (
posixly_correct
 < 0 && *p == L_('^')))

1007 ++
p
;

1009 if (*
p
 == 
	`L_
(']'))

1010 ++
p
;

1012 while (*
p
 != 
	`L_
(']'))

1013 if (*
p
++ == 
	`L_
('\0'))

1015 return 
pattern
;

1017 else if ((*
p
 == 
	`L_
('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')

1018 || *
p
 == 
	`L_
('!')) && p[1] == L_('('))

1019 
p
 = 
	`END
 (p + 1);

1020 else if (*
p
 == 
	`L_
(')'))

1023 return 
p
 + 1;

1024 
	}
}

1028 
internal_function


1029 
	$EXT
 (
INT
 
opt
, const 
CHAR
 *
pattern
, const CHAR *
string
, const CHAR *
string_end
,

1030 
bool
 
no_leading_period
, int 
flags
)

1032 const 
CHAR
 *
startp
;

1033 
size_t
 
level
;

1034 struct 
	spatternlist


1036 struct 
patternlist
 *
next
;

1037 
CHAR
 
str
[1];

1038 } *
list
 = 
NULL
;

1039 struct 
patternlist
 **
lastp
 = &
list
;

1040 
size_t
 
pattern_len
 = 
	`STRLEN
 (
pattern
);

1041 const 
CHAR
 *
p
;

1042 const 
CHAR
 *
rs
;

1043 enum { 
ALLOCA_LIMIT
 = 8000 };

1046 
level
 = 0;

1047 for (
startp
 = 
p
 = 
pattern
 + 1; ; ++p)

1048 if (*
p
 == 
	`L_
('\0'))

1051 else if (*
p
 == 
	`L_
('['))

1054 if (
posixly_correct
 == 0)

1055 
posixly_correct
 = 
	`getenv
 ("POSIXLY_CORRECT") != 
NULL
 ? 1 : -1;

1059 if (*++
p
 == 
	`L_
('!') || (
posixly_correct
 < 0 && *p == L_('^')))

1060 ++
p
;

1062 if (*
p
 == 
	`L_
(']'))

1063 ++
p
;

1065 while (*
p
 != 
	`L_
(']'))

1066 if (*
p
++ == 
	`L_
('\0'))

1070 else if ((*
p
 == 
	`L_
('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')

1071 || *
p
 == 
	`L_
('!')) && p[1] == L_('('))

1073 ++
level
;

1074 else if (*
p
 == 
	`L_
(')'))

1076 if (
level
-- == 0)

1079 #define 
	#NEW_PATTERN
 \

1080 struct 
patternlist
 *
newp
; \

1081 
size_t
 
plen
; \

1082 
size_t
 
plensize
; \

1083 
size_t
 
newpsize
; \

1085 
plen
 = (
opt
 == 
	`L_
('?') || opt == L_('@') \

1086 ? 
pattern_len
 \

1087 : 
p
 - 
startp
 + 1UL); \

1088 
plensize
 = 
plen
 * sizeof (
CHAR
); \

1089 
newpsize
 = 
	`offsetof
 (struct 
patternlist
, 
str
) + 
plensize
; \

1090 if ((
size_t
) -1 / sizeof (
CHAR
) < 
plen
 \

1091 || 
newpsize
 < 
	`offsetof
 (struct 
patternlist
, 
str
) \

1092 || 
ALLOCA_LIMIT
 <= 
newpsize
) \

1094 
newp
 = (struct 
patternlist
 *) 
	`alloca
 (
newpsize
); \

1095 *((
CHAR
 *) 
	`MEMPCPY
 (
newp
->
str
, 
startp
, 
p
 - startp)) = 
	`L_
('\0'); \

1096 
newp
->
next
 = 
NULL
; \

1097 *
lastp
 = 
newp
; \

1098 
lastp
 = &
newp
->
next


	)

1099 
NEW_PATTERN
;

1103 else if (*
p
 == 
	`L_
('|'))

1105 if (
level
 == 0)

1107 
NEW_PATTERN
;

1108 
startp
 = 
p
 + 1;

1111 
	`assert
 (
list
 != 
NULL
);

1112 
	`assert
 (
p
[-1] == 
	`L_
(')'));

1113 #undef 
NEW_PATTERN


1115 switch (
opt
)

1117 case 
	`L_
('*'):

1118 if (
	`FCT
 (
p
, 
string
, 
string_end
, 
no_leading_period
, 
flags
) == 0)

1122 case 
	`L_
('+'):

1125 for (
rs
 = 
string
; rs <= 
string_end
; ++rs)

1128 if (
	`FCT
 (
list
->
str
, 
string
, 
rs
, 
no_leading_period
,

1129 
flags
 & 
FNM_FILE_NAME
 ? flags : flags & ~
FNM_PERIOD
) == 0

1132 && (
	`FCT
 (
p
, 
rs
, 
string_end
,

1133 
rs
 == 
string


1134 ? 
no_leading_period


1135 : 
rs
[-1] == '/' && 
	`NO_LEADING_PERIOD
 (
flags
),

1136 
flags
 & 
FNM_FILE_NAME


1137 ? 
flags
 : flags & ~
FNM_PERIOD
) == 0

1139 || (
rs
 != 
string


1140 && 
	`FCT
 (
pattern
 - 1, 
rs
, 
string_end
,

1141 
rs
 == 
string


1142 ? 
no_leading_period


1143 : 
rs
[-1] == '/' && 
	`NO_LEADING_PERIOD
 (
flags
),

1144 
flags
 & 
FNM_FILE_NAME


1145 ? 
flags
 : flags & ~
FNM_PERIOD
) == 0)))

1149 while ((
list
 = list->
next
) != 
NULL
);

1152 return 
FNM_NOMATCH
;

1154 case 
	`L_
('?'):

1155 if (
	`FCT
 (
p
, 
string
, 
string_end
, 
no_leading_period
, 
flags
) == 0)

1159 case 
	`L_
('@'):

1165 if (
	`FCT
 (
	`STRCAT
 (
list
->
str
, 
p
), 
string
, 
string_end
,

1166 
no_leading_period
,

1167 
flags
 & 
FNM_FILE_NAME
 ? flags : flags & ~
FNM_PERIOD
) == 0)

1170 while ((
list
 = list->
next
) != 
NULL
);

1173 return 
FNM_NOMATCH
;

1175 case 
	`L_
('!'):

1176 for (
rs
 = 
string
; rs <= 
string_end
; ++rs)

1178 struct 
patternlist
 *
runp
;

1180 for (
runp
 = 
list
; runp != 
NULL
; runp = runp->
next
)

1181 if (
	`FCT
 (
runp
->
str
, 
string
, 
rs
, 
no_leading_period
,

1182 
flags
 & 
FNM_FILE_NAME
 ? flags : flags & ~
FNM_PERIOD
) == 0)

1186 if (
runp
 == 
NULL


1187 && (
	`FCT
 (
p
, 
rs
, 
string_end
,

1188 
rs
 == 
string


1189 ? 
no_leading_period


1190 : 
rs
[-1] == '/' && 
	`NO_LEADING_PERIOD
 (
flags
),

1191 
flags
 & 
FNM_FILE_NAME
 ? flags : flags & ~
FNM_PERIOD
)

1199 return 
FNM_NOMATCH
;

1202 
	`assert
 (! "Invalid extended matching operator");

1207 
	}
}

1210 #undef 
FOLD


1211 #undef 
CHAR


1212 #undef 
UCHAR


1213 #undef 
INT


1214 #undef 
FCT


1215 #undef 
EXT


1216 #undef 
END


1217 #undef 
MEMPCPY


1218 #undef 
MEMCHR


1219 #undef 
STRCOLL


1220 #undef 
STRLEN


1221 #undef 
STRCAT


1222 #undef 
L_


1223 #undef 
BTOWC


	@lib/fpending.c

20 #include 
	~<config.h
>

22 #include 
	~"fpending.h
"

26 
size_t


27 
	$__fpending
 (
FILE
 *
fp
)

29 return 
PENDING_OUTPUT_N_BYTES
;

30 
	}
}

	@lib/fpending.h

21 #include 
	~<stddef.h
>

22 #include 
	~<stdio.h
>

24 #ifndef 
HAVE_DECL___FPENDING


28 #if 
HAVE_DECL___FPENDING


29 #if 
HAVE_STDIO_EXT_H


30 #include 
	~<stdio_ext.h
>

33 
size_t
 
__fpending
 (
FILE
 *);

	@lib/fstat.c

20 #define 
	#__need_system_sys_stat_h


	)

21 #include 
	~<config.h
>

24 #include 
	~<sys/types.h
>

25 #include 
	~<sys/stat.h
>

26 #undef 
__need_system_sys_stat_h


28 static 
inline
 int

29 
	$orig_fstat
 (int 
fd
, struct 
stat
 *
buf
)

31 return 
	`fstat
 (
fd
, 
buf
);

32 
	}
}

38 #include 
	~"sys/stat.h
"

40 #include 
	~<errno.h
>

41 #include 
	~<unistd.h
>

43 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER


44 #include 
	~"msvc-inval.h
"

47 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER


48 static 
inline
 int

49 
	$fstat_nothrow
 (int 
fd
, struct 
stat
 *
buf
)

51 int 
result
;

53 
TRY_MSVC_INVAL


55 
result
 = 
	`orig_fstat
 (
fd
, 
buf
);

57 
CATCH_MSVC_INVAL


59 
result
 = -1;

60 
errno
 = 
EBADF
;

62 
DONE_MSVC_INVAL
;

64 return 
result
;

65 
	}
}

67 #define 
	#fstat_nothrow
 
orig_fstat


	)

71 
	$rpl_fstat
 (int 
fd
, struct 
stat
 *
buf
)

73 #if 
REPLACE_FCHDIR
 && 
REPLACE_OPEN_DIRECTORY


76 const char *
name
 = 
	`_gl_directory_name
 (
fd
);

77 if (
name
 != 
NULL
)

78 return 
	`stat
 (
name
, 
buf
);

81 return 
	`fstat_nothrow
 (
fd
, 
buf
);

82 
	}
}

	@lib/getopt.c

22 #ifndef 
_LIBC


23 #include 
	~<config.h
>

26 #include 
	~"getopt.h
"

28 #include 
	~<stdio.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

31 #include 
	~<unistd.h
>

33 #ifdef 
_LIBC


34 #include 
	~<libintl.h
>

36 #include 
	~"gettext.h
"

37 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

40 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


41 #include 
	~<wchar.h
>

59 #include 
	~"getopt_int.h
"

67 char *
	goptarg
;

82 int 
	goptind
 = 1;

87 int 
	gopterr
 = 1;

93 int 
	goptopt
 = '?';

97 static struct 
_getopt_data
 
	ggetopt_data
;

100 #if 
defined
 
HAVE_DECL_GETENV
 && !HAVE_DECL_GETENV

101 extern char *
getenv
 ();

104 #ifdef 
_LIBC


108 extern int 
__libc_argc
;

109 extern char **
__libc_argv
;

114 #ifdef 
USE_NONOPTION_FLAGS


116 extern char *
__getopt_nonoption_flags
;

119 #ifdef 
USE_NONOPTION_FLAGS


120 #define 
	#SWAP_FLAGS
(
ch1
, 
ch2
) \

121 if (
d
->
__nonoption_flags_len
 > 0) \

123 char 
__tmp
 = 
__getopt_nonoption_flags
[
ch1
]; \

124 
__getopt_nonoption_flags
[
ch1
] = __getopt_nonoption_flags[
ch2
]; \

125 
__getopt_nonoption_flags
[
ch2
] = 
__tmp
; \

126 }

	)

128 #define 
	#SWAP_FLAGS
(
ch1
, 
ch2
)

	)

131 #define 
	#SWAP_FLAGS
(
ch1
, 
ch2
)

	)

144 
	$exchange
 (char **
argv
, struct 
_getopt_data
 *
d
)

146 int 
bottom
 = 
d
->
__first_nonopt
;

147 int 
middle
 = 
d
->
__last_nonopt
;

148 int 
top
 = 
d
->
optind
;

149 char *
tem
;

156 #if 
defined
 
_LIBC
 && defined 
USE_NONOPTION_FLAGS


160 if (
d
->
__nonoption_flags_len
 > 0 && 
top
 >= d->
__nonoption_flags_max_len
)

164 char *
new_str
 = 
	`malloc
 (
top
 + 1);

165 if (
new_str
 == 
NULL
)

166 
d
->
__nonoption_flags_len
 = d->
__nonoption_flags_max_len
 = 0;

169 
	`memset
 (
	`__mempcpy
 (
new_str
, 
__getopt_nonoption_flags
,

170 
d
->
__nonoption_flags_max_len
),

171 '\0', 
top
 + 1 - 
d
->
__nonoption_flags_max_len
);

172 
d
->
__nonoption_flags_max_len
 = 
top
 + 1;

173 
__getopt_nonoption_flags
 = 
new_str
;

178 while (
top
 > 
middle
 && middle > 
bottom
)

180 if (
top
 - 
middle
 > middle - 
bottom
)

183 int 
len
 = 
middle
 - 
bottom
;

184 register int 
i
;

187 for (
i
 = 0; i < 
len
; i++)

189 
tem
 = 
argv
[
bottom
 + 
i
];

190 
argv
[
bottom
 + 
i
] = argv[
top
 - (
middle
 - bottom) + i];

191 
argv
[
top
 - (
middle
 - 
bottom
) + 
i
] = 
tem
;

192 
	`SWAP_FLAGS
 (
bottom
 + 
i
, 
top
 - (
middle
 - bottom) + i);

195 
top
 -= 
len
;

200 int 
len
 = 
top
 - 
middle
;

201 register int 
i
;

204 for (
i
 = 0; i < 
len
; i++)

206 
tem
 = 
argv
[
bottom
 + 
i
];

207 
argv
[
bottom
 + 
i
] = argv[
middle
 + i];

208 
argv
[
middle
 + 
i
] = 
tem
;

209 
	`SWAP_FLAGS
 (
bottom
 + 
i
, 
middle
 + i);

212 
bottom
 += 
len
;

218 
d
->
__first_nonopt
 += (d->
optind
 - d->
__last_nonopt
);

219 
d
->
__last_nonopt
 = d->
optind
;

220 
	}
}

225 
	$_getopt_initialize
 (int 
argc
 
_GL_UNUSED
,

226 char **
argv
 
_GL_UNUSED
, const char *
optstring
,

227 struct 
_getopt_data
 *
d
, int 
posixly_correct
)

233 
d
->
__first_nonopt
 = d->
__last_nonopt
 = d->
optind
;

235 
d
->
__nextchar
 = 
NULL
;

237 
d
->
__posixly_correct
 = 
posixly_correct
 || !!
	`getenv
 ("POSIXLY_CORRECT");

241 if (
optstring
[0] == '-')

243 
d
->
__ordering
 = 
RETURN_IN_ORDER
;

244 ++
optstring
;

246 else if (
optstring
[0] == '+')

248 
d
->
__ordering
 = 
REQUIRE_ORDER
;

249 ++
optstring
;

251 else if (
d
->
__posixly_correct
)

252 
d
->
__ordering
 = 
REQUIRE_ORDER
;

254 
d
->
__ordering
 = 
PERMUTE
;

256 #if 
defined
 
_LIBC
 && defined 
USE_NONOPTION_FLAGS


257 if (!
d
->
__posixly_correct


258 && 
argc
 == 
__libc_argc
 && 
argv
 == 
__libc_argv
)

260 if (
d
->
__nonoption_flags_max_len
 == 0)

262 if (
__getopt_nonoption_flags
 == 
NULL


263 || 
__getopt_nonoption_flags
[0] == '\0')

264 
d
->
__nonoption_flags_max_len
 = -1;

267 const char *
orig_str
 = 
__getopt_nonoption_flags
;

268 int 
len
 = 
d
->
__nonoption_flags_max_len
 = 
	`strlen
 (
orig_str
);

269 if (
d
->
__nonoption_flags_max_len
 < 
argc
)

270 
d
->
__nonoption_flags_max_len
 = 
argc
;

271 
__getopt_nonoption_flags
 =

272 (char *) 
	`malloc
 (
d
->
__nonoption_flags_max_len
);

273 if (
__getopt_nonoption_flags
 == 
NULL
)

274 
d
->
__nonoption_flags_max_len
 = -1;

276 
	`memset
 (
	`__mempcpy
 (
__getopt_nonoption_flags
, 
orig_str
, 
len
),

277 '\0', 
d
->
__nonoption_flags_max_len
 - 
len
);

280 
d
->
__nonoption_flags_len
 = d->
__nonoption_flags_max_len
;

283 
d
->
__nonoption_flags_len
 = 0;

286 return 
optstring
;

287 
	}
}

346 
	$_getopt_internal_r
 (int 
argc
, char **
argv
, const char *
optstring
,

347 const struct 
option
 *
longopts
, int *
longind
,

348 int 
long_only
, struct 
_getopt_data
 *
d
, int 
posixly_correct
)

350 int 
print_errors
 = 
d
->
opterr
;

352 if (
argc
 < 1)

355 
d
->
optarg
 = 
NULL
;

357 if (
d
->
optind
 == 0 || !d->
__initialized
)

359 if (
d
->
optind
 == 0)

360 
d
->
optind
 = 1;

361 
optstring
 = 
	`_getopt_initialize
 (
argc
, 
argv
, optstring, 
d
,

362 
posixly_correct
);

363 
d
->
__initialized
 = 1;

365 else if (
optstring
[0] == '-' || optstring[0] == '+')

366 
optstring
++;

367 if (
optstring
[0] == ':')

368 
print_errors
 = 0;

374 #if 
defined
 
_LIBC
 && defined 
USE_NONOPTION_FLAGS


375 #define 
	#NONOPTION_P
 (
argv
[
d
->
optind
][0] != '-' || argv[d->optind][1] == '\0' \

376 || (
d
->
optind
 < d->
__nonoption_flags_len
 \

377 && 
__getopt_nonoption_flags
[
d
->
optind
] == '1'))

	)

379 #define 
	#NONOPTION_P
 (
argv
[
d
->
optind
][0] != '-' || argv[d->optind][1] == '\0')

	)

382 if (
d
->
__nextchar
 == 
NULL
 || *d->__nextchar == '\0')

388 if (
d
->
__last_nonopt
 > d->
optind
)

389 
d
->
__last_nonopt
 = d->
optind
;

390 if (
d
->
__first_nonopt
 > d->
optind
)

391 
d
->
__first_nonopt
 = d->
optind
;

393 if (
d
->
__ordering
 == 
PERMUTE
)

398 if (
d
->
__first_nonopt
 != d->
__last_nonopt


399 && 
d
->
__last_nonopt
 != d->
optind
)

400 
	`exchange
 ((char **) 
argv
, 
d
);

401 else if (
d
->
__last_nonopt
 != d->
optind
)

402 
d
->
__first_nonopt
 = d->
optind
;

407 while (
d
->
optind
 < 
argc
 && 
NONOPTION_P
)

408 
d
->
optind
++;

409 
d
->
__last_nonopt
 = d->
optind
;

417 if (
d
->
optind
 != 
argc
 && !
	`strcmp
 (
argv
[d->optind], "--"))

419 
d
->
optind
++;

421 if (
d
->
__first_nonopt
 != d->
__last_nonopt


422 && 
d
->
__last_nonopt
 != d->
optind
)

423 
	`exchange
 ((char **) 
argv
, 
d
);

424 else if (
d
->
__first_nonopt
 == d->
__last_nonopt
)

425 
d
->
__first_nonopt
 = d->
optind
;

426 
d
->
__last_nonopt
 = 
argc
;

428 
d
->
optind
 = 
argc
;

434 if (
d
->
optind
 == 
argc
)

438 if (
d
->
__first_nonopt
 != d->
__last_nonopt
)

439 
d
->
optind
 = d->
__first_nonopt
;

446 if (
NONOPTION_P
)

448 if (
d
->
__ordering
 == 
REQUIRE_ORDER
)

450 
d
->
optarg
 = 
argv
[d->
optind
++];

457 
d
->
__nextchar
 = (
argv
[d->
optind
] + 1

458 + (
longopts
 != 
NULL
 && 
argv
[
d
->
optind
][1] == '-'));

476 if (
longopts
 != 
NULL


477 && (
argv
[
d
->
optind
][1] == '-'

478 || (
long_only
 && (
argv
[
d
->
optind
][2]

479 || !
	`strchr
 (
optstring
, 
argv
[
d
->
optind
][1])))))

481 char *
nameend
;

482 unsigned int 
namelen
;

483 const struct 
option
 *
p
;

484 const struct 
option
 *
pfound
 = 
NULL
;

485 struct 
	soption_list


487 const struct 
option
 *
p
;

488 struct 
option_list
 *
next
;

489 } *
ambig_list
 = 
NULL
;

490 int 
exact
 = 0;

491 int 
indfound
 = -1;

492 int 
option_index
;

494 for (
nameend
 = 
d
->
__nextchar
; *nameend && *nameend != '='; nameend++)

496 
namelen
 = 
nameend
 - 
d
->
__nextchar
;

500 for (
p
 = 
longopts
, 
option_index
 = 0; p->
name
; p++, option_index++)

501 if (!
	`strncmp
 (
p
->
name
, 
d
->
__nextchar
, 
namelen
))

503 if (
namelen
 == (unsigned int) 
	`strlen
 (
p
->
name
))

506 
pfound
 = 
p
;

507 
indfound
 = 
option_index
;

508 
exact
 = 1;

511 else if (
pfound
 == 
NULL
)

514 
pfound
 = 
p
;

515 
indfound
 = 
option_index
;

517 else if (
long_only


518 || 
pfound
->
has_arg
 != 
p
->has_arg

519 || 
pfound
->
flag
 != 
p
->flag

520 || 
pfound
->
val
 != 
p
->val)

523 struct 
option_list
 *
newp
 = 
	`malloc
 (sizeof (*newp));

524 
newp
->
p
 = p;

525 
newp
->
next
 = 
ambig_list
;

526 
ambig_list
 = 
newp
;

530 if (
ambig_list
 != 
NULL
 && !
exact
)

532 if (
print_errors
)

534 struct 
option_list
 
first
;

535 
first
.
p
 = 
pfound
;

536 
first
.
next
 = 
ambig_list
;

537 
ambig_list
 = &
first
;

539 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


540 char *
buf
 = 
NULL
;

541 
size_t
 
buflen
 = 0;

543 
FILE
 *
fp
 = 
	`open_memstream
 (&
buf
, &
buflen
);

544 if (
fp
 != 
NULL
)

546 
	`fprintf
 (
fp
,

547 
	`_
("%s: option '%s' is ambiguous; possibilities:"),

548 
argv
[0], argv[
d
->
optind
]);

552 
	`fprintf
 (
fp
, " '--%s'", 
ambig_list
->
p
->
name
);

553 
ambig_list
 = ambig_list->
next
;

555 while (
ambig_list
 != 
NULL
);

557 
	`fputc_unlocked
 ('\n', 
fp
);

559 if (
	`__builtin_expect
 (
	`fclose
 (
fp
) != 
EOF
, 1))

561 
	`_IO_flockfile
 (
stderr
);

563 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

564 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 |= 
_IO_FLAGS2_NOTCANCEL
;

566 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

568 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

569 
	`_IO_funlockfile
 (
stderr
);

571 
	`free
 (
buf
);

575 
	`fprintf
 (
stderr
,

576 
	`_
("%s: option '%s' is ambiguous; possibilities:"),

577 
argv
[0], argv[
d
->
optind
]);

580 
	`fprintf
 (
stderr
, " '--%s'", 
ambig_list
->
p
->
name
);

581 
ambig_list
 = ambig_list->
next
;

583 while (
ambig_list
 != 
NULL
);

585 
	`fputc
 ('\n', 
stderr
);

588 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

589 
d
->
optind
++;

590 
d
->
optopt
 = 0;

594 while (
ambig_list
 != 
NULL
)

596 struct 
option_list
 *
pn
 = 
ambig_list
->
next
;

597 
	`free
 (
ambig_list
);

598 
ambig_list
 = 
pn
;

601 if (
pfound
 != 
NULL
)

603 
option_index
 = 
indfound
;

604 
d
->
optind
++;

605 if (*
nameend
)

609 if (
pfound
->
has_arg
)

610 
d
->
optarg
 = 
nameend
 + 1;

613 if (
print_errors
)

615 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


616 char *
buf
;

617 int 
n
;

620 if (
argv
[
d
->
optind
 - 1][1] == '-')

623 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


624 
n
 = 
	`__asprintf
 (&
buf
, 
	`_
("\
%s: option '--%s' doesn't allow an argument\n"),

626 
argv
[0], 
pfound
->
name
);

628 
	`fprintf
 (
stderr
, 
	`_
("\
%s: option '--%s' doesn't allow an argument\n"),

630 
argv
[0], 
pfound
->
name
);

636 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


637 
n
 = 
	`__asprintf
 (&
buf
, 
	`_
("\
%s: option '%c%s' doesn't allow an argument\n"),

639 
argv
[0], argv[
d
->
optind
 - 1][0],

640 
pfound
->
name
);

642 
	`fprintf
 (
stderr
, 
	`_
("\
%s: option '%c%s' doesn't allow an argument\n"),

644 
argv
[0], argv[
d
->
optind
 - 1][0],

645 
pfound
->
name
);

649 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


650 if (
n
 >= 0)

652 
	`_IO_flockfile
 (
stderr
);

654 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

655 ((
_IO_FILE
 *) 
stderr
)->
_flags2


656 |= 
_IO_FLAGS2_NOTCANCEL
;

658 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

660 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

661 
	`_IO_funlockfile
 (
stderr
);

663 
	`free
 (
buf
);

668 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

670 
d
->
optopt
 = 
pfound
->
val
;

674 else if (
pfound
->
has_arg
 == 1)

676 if (
d
->
optind
 < 
argc
)

677 
d
->
optarg
 = 
argv
[d->
optind
++];

680 if (
print_errors
)

682 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


683 char *
buf
;

685 if (
	`__asprintf
 (&
buf
, 
	`_
("\
%s: option '--%s' requires an argument\n"),

687 
argv
[0], 
pfound
->
name
) >= 0)

689 
	`_IO_flockfile
 (
stderr
);

691 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

692 ((
_IO_FILE
 *) 
stderr
)->
_flags2


693 |= 
_IO_FLAGS2_NOTCANCEL
;

695 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

697 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

698 
	`_IO_funlockfile
 (
stderr
);

700 
	`free
 (
buf
);

703 
	`fprintf
 (
stderr
,

704 
	`_
("%s: option '--%s' requires an argument\n"),

705 
argv
[0], 
pfound
->
name
);

708 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

709 
d
->
optopt
 = 
pfound
->
val
;

710 return 
optstring
[0] == ':' ? ':' : '?';

713 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

714 if (
longind
 != 
NULL
)

715 *
longind
 = 
option_index
;

716 if (
pfound
->
flag
)

718 *(
pfound
->
flag
) = pfound->
val
;

721 return 
pfound
->
val
;

728 if (!
long_only
 || 
argv
[
d
->
optind
][1] == '-'

729 || 
	`strchr
 (
optstring
, *
d
->
__nextchar
) == 
NULL
)

731 if (
print_errors
)

733 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


734 char *
buf
;

735 int 
n
;

738 if (
argv
[
d
->
optind
][1] == '-')

741 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


742 
n
 = 
	`__asprintf
 (&
buf
, 
	`_
("%s: unrecognized option '--%s'\n"),

743 
argv
[0], 
d
->
__nextchar
);

745 
	`fprintf
 (
stderr
, 
	`_
("%s: unrecognized option '--%s'\n"),

746 
argv
[0], 
d
->
__nextchar
);

752 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


753 
n
 = 
	`__asprintf
 (&
buf
, 
	`_
("%s: unrecognized option '%c%s'\n"),

754 
argv
[0], argv[
d
->
optind
][0], d->
__nextchar
);

756 
	`fprintf
 (
stderr
, 
	`_
("%s: unrecognized option '%c%s'\n"),

757 
argv
[0], argv[
d
->
optind
][0], d->
__nextchar
);

761 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


762 if (
n
 >= 0)

764 
	`_IO_flockfile
 (
stderr
);

766 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

767 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 |= 
_IO_FLAGS2_NOTCANCEL
;

769 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

771 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

772 
	`_IO_funlockfile
 (
stderr
);

774 
	`free
 (
buf
);

778 
d
->
__nextchar
 = (char *) "";

779 
d
->
optind
++;

780 
d
->
optopt
 = 0;

788 char 
c
 = *
d
->
__nextchar
++;

789 const char *
temp
 = 
	`strchr
 (
optstring
, 
c
);

792 if (*
d
->
__nextchar
 == '\0')

793 ++
d
->
optind
;

795 if (
temp
 == 
NULL
 || 
c
 == ':' || c == ';')

797 if (
print_errors
)

799 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


800 char *
buf
;

801 int 
n
;

804 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


805 
n
 = 
	`__asprintf
 (&
buf
, 
	`_
("%s: invalid option -- '%c'\n"),

806 
argv
[0], 
c
);

808 
	`fprintf
 (
stderr
, 
	`_
("%s: invalid option -- '%c'\n"), 
argv
[0], 
c
);

811 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


812 if (
n
 >= 0)

814 
	`_IO_flockfile
 (
stderr
);

816 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

817 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 |= 
_IO_FLAGS2_NOTCANCEL
;

819 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

821 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

822 
	`_IO_funlockfile
 (
stderr
);

824 
	`free
 (
buf
);

828 
d
->
optopt
 = 
c
;

832 if (
temp
[0] == 'W' && temp[1] == ';')

834 char *
nameend
;

835 const struct 
option
 *
p
;

836 const struct 
option
 *
pfound
 = 
NULL
;

837 int 
exact
 = 0;

838 int 
ambig
 = 0;

839 int 
indfound
 = 0;

840 int 
option_index
;

842 if (
longopts
 == 
NULL
)

843 goto 
no_longs
;

846 if (*
d
->
__nextchar
 != '\0')

848 
d
->
optarg
 = d->
__nextchar
;

851 
d
->
optind
++;

853 else if (
d
->
optind
 == 
argc
)

855 if (
print_errors
)

857 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


858 char *
buf
;

860 if (
	`__asprintf
 (&
buf
,

861 
	`_
("%s: option requires an argument -- '%c'\n"),

862 
argv
[0], 
c
) >= 0)

864 
	`_IO_flockfile
 (
stderr
);

866 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

867 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 |= 
_IO_FLAGS2_NOTCANCEL
;

869 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

871 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

872 
	`_IO_funlockfile
 (
stderr
);

874 
	`free
 (
buf
);

877 
	`fprintf
 (
stderr
,

878 
	`_
("%s: option requires an argument -- '%c'\n"),

879 
argv
[0], 
c
);

882 
d
->
optopt
 = 
c
;

883 if (
optstring
[0] == ':')

884 
c
 = ':';

886 
c
 = '?';

887 return 
c
;

892 
d
->
optarg
 = 
argv
[d->
optind
++];

897 for (
d
->
__nextchar
 = 
nameend
 = d->
optarg
; *nameend && *nameend != '=';

898 
nameend
++)

903 for (
p
 = 
longopts
, 
option_index
 = 0; p->
name
; p++, option_index++)

904 if (!
	`strncmp
 (
p
->
name
, 
d
->
__nextchar
, 
nameend
 - d->__nextchar))

906 if ((unsigned int) (
nameend
 - 
d
->
__nextchar
) == 
	`strlen
 (
p
->
name
))

909 
pfound
 = 
p
;

910 
indfound
 = 
option_index
;

911 
exact
 = 1;

914 else if (
pfound
 == 
NULL
)

917 
pfound
 = 
p
;

918 
indfound
 = 
option_index
;

920 else if (
long_only


921 || 
pfound
->
has_arg
 != 
p
->has_arg

922 || 
pfound
->
flag
 != 
p
->flag

923 || 
pfound
->
val
 != 
p
->val)

925 
ambig
 = 1;

927 if (
ambig
 && !
exact
)

929 if (
print_errors
)

931 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


932 char *
buf
;

934 if (
	`__asprintf
 (&
buf
, 
	`_
("%s: option '-W %s' is ambiguous\n"),

935 
argv
[0], 
d
->
optarg
) >= 0)

937 
	`_IO_flockfile
 (
stderr
);

939 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

940 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 |= 
_IO_FLAGS2_NOTCANCEL
;

942 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

944 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

945 
	`_IO_funlockfile
 (
stderr
);

947 
	`free
 (
buf
);

950 
	`fprintf
 (
stderr
, 
	`_
("%s: option '-W %s' is ambiguous\n"),

951 
argv
[0], 
d
->
optarg
);

954 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

955 
d
->
optind
++;

958 if (
pfound
 != 
NULL
)

960 
option_index
 = 
indfound
;

961 if (*
nameend
)

965 if (
pfound
->
has_arg
)

966 
d
->
optarg
 = 
nameend
 + 1;

969 if (
print_errors
)

971 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


972 char *
buf
;

974 if (
	`__asprintf
 (&
buf
, 
	`_
("\
%s: option '-W %s' doesn't allow an argument\n"),

976 
argv
[0], 
pfound
->
name
) >= 0)

978 
	`_IO_flockfile
 (
stderr
);

980 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

981 ((
_IO_FILE
 *) 
stderr
)->
_flags2


982 |= 
_IO_FLAGS2_NOTCANCEL
;

984 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

986 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

987 
	`_IO_funlockfile
 (
stderr
);

989 
	`free
 (
buf
);

992 
	`fprintf
 (
stderr
, 
	`_
("\
%s: option '-W %s' doesn't allow an argument\n"),

994 
argv
[0], 
pfound
->
name
);

998 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

1002 else if (
pfound
->
has_arg
 == 1)

1004 if (
d
->
optind
 < 
argc
)

1005 
d
->
optarg
 = 
argv
[d->
optind
++];

1008 if (
print_errors
)

1010 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


1011 char *
buf
;

1013 if (
	`__asprintf
 (&
buf
, 
	`_
("\
%s: option '-W %s' requires an argument\n"),

1015 
argv
[0], 
pfound
->
name
) >= 0)

1017 
	`_IO_flockfile
 (
stderr
);

1019 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

1020 ((
_IO_FILE
 *) 
stderr
)->
_flags2


1021 |= 
_IO_FLAGS2_NOTCANCEL
;

1023 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

1025 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

1026 
	`_IO_funlockfile
 (
stderr
);

1028 
	`free
 (
buf
);

1031 
	`fprintf
 (
stderr
, 
	`_
("\
%s: option '-W %s' requires an argument\n"),

1033 
argv
[0], 
pfound
->
name
);

1036 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

1037 return 
optstring
[0] == ':' ? ':' : '?';

1041 
d
->
optarg
 = 
NULL
;

1042 
d
->
__nextchar
 += 
	`strlen
 (d->__nextchar);

1043 if (
longind
 != 
NULL
)

1044 *
longind
 = 
option_index
;

1045 if (
pfound
->
flag
)

1047 *(
pfound
->
flag
) = pfound->
val
;

1050 return 
pfound
->
val
;

1053 
no_longs
:

1054 
d
->
__nextchar
 = 
NULL
;

1057 if (
temp
[1] == ':')

1059 if (
temp
[2] == ':')

1062 if (*
d
->
__nextchar
 != '\0')

1064 
d
->
optarg
 = d->
__nextchar
;

1065 
d
->
optind
++;

1068 
d
->
optarg
 = 
NULL
;

1069 
d
->
__nextchar
 = 
NULL
;

1074 if (*
d
->
__nextchar
 != '\0')

1076 
d
->
optarg
 = d->
__nextchar
;

1079 
d
->
optind
++;

1081 else if (
d
->
optind
 == 
argc
)

1083 if (
print_errors
)

1085 #if 
defined
 
_LIBC
 && defined 
USE_IN_LIBIO


1086 char *
buf
;

1088 if (
	`__asprintf
 (&
buf
, 
	`_
("\
%s: option requires an argument -- '%c'\n"),

1090 
argv
[0], 
c
) >= 0)

1092 
	`_IO_flockfile
 (
stderr
);

1094 int 
old_flags2
 = ((
_IO_FILE
 *) 
stderr
)->
_flags2
;

1095 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 |= 
_IO_FLAGS2_NOTCANCEL
;

1097 
	`__fxprintf
 (
NULL
, "%s", 
buf
);

1099 ((
_IO_FILE
 *) 
stderr
)->
_flags2
 = 
old_flags2
;

1100 
	`_IO_funlockfile
 (
stderr
);

1102 
	`free
 (
buf
);

1105 
	`fprintf
 (
stderr
,

1106 
	`_
("%s: option requires an argument -- '%c'\n"),

1107 
argv
[0], 
c
);

1110 
d
->
optopt
 = 
c
;

1111 if (
optstring
[0] == ':')

1112 
c
 = ':';

1114 
c
 = '?';

1119 
d
->
optarg
 = 
argv
[d->
optind
++];

1120 
d
->
__nextchar
 = 
NULL
;

1123 return 
c
;

1125 
	}
}

1128 
	$_getopt_internal
 (int 
argc
, char **
argv
, const char *
optstring
,

1129 const struct 
option
 *
longopts
, int *
longind
, int 
long_only
,

1130 int 
posixly_correct
)

1132 int 
result
;

1134 
getopt_data
.
optind
 = optind;

1135 
getopt_data
.
opterr
 = opterr;

1137 
result
 = 
	`_getopt_internal_r
 (
argc
, 
argv
, 
optstring
, 
longopts
,

1138 
longind
, 
long_only
, &
getopt_data
,

1139 
posixly_correct
);

1141 
optind
 = 
getopt_data
.optind;

1142 
optarg
 = 
getopt_data
.optarg;

1143 
optopt
 = 
getopt_data
.optopt;

1145 return 
result
;

1146 
	}
}

1150 #if 
_LIBC


1151 enum { 
	mPOSIXLY_CORRECT
 = 0 };

1153 enum { 
	mPOSIXLY_CORRECT
 = 1 };

1157 
	$getopt
 (int 
argc
, char *const *
argv
, const char *
optstring
)

1159 return 
	`_getopt_internal
 (
argc
, (char **) 
argv
, 
optstring
,

1160 (const struct 
option
 *) 0,

1162 0, 
POSIXLY_CORRECT
);

1163 
	}
}

1165 #ifdef 
_LIBC


1167 
	$__posix_getopt
 (int 
argc
, char *const *
argv
, const char *
optstring
)

1169 return 
	`_getopt_internal
 (
argc
, 
argv
, 
optstring
,

1170 (const struct 
option
 *) 0,

1173 
	}
}

1177 #ifdef 
TEST


1183 
	$main
 (int 
argc
, char **
argv
)

1185 int 
c
;

1186 int 
digit_optind
 = 0;

1190 int 
this_option_optind
 = 
optind
 ? optind : 1;

1192 
c
 = 
	`getopt
 (
argc
, 
argv
, "abc:d:0123456789");

1193 if (
c
 == -1)

1196 switch (
c
)

1208 if (
digit_optind
 != 0 && digit_optind != 
this_option_optind
)

1209 
	`printf
 ("digits occur in two different argv-elements.\n");

1210 
digit_optind
 = 
this_option_optind
;

1211 
	`printf
 ("option %c\n", 
c
);

1215 
	`printf
 ("option a\n");

1219 
	`printf
 ("option b\n");

1223 
	`printf
 ("option c with value '%s'\n", 
optarg
);

1230 
	`printf
 ("?? getopt returned character code 0%o ??\n", 
c
);

1234 if (
optind
 < 
argc
)

1236 
	`printf
 ("non-option ARGV-elements: ");

1237 while (
optind
 < 
argc
)

1238 
	`printf
 ("%s ", 
argv
[
optind
++]);

1239 
	`printf
 ("\n");

1242 
	`exit
 (0);

1243 
	}
}

	@lib/getopt.in.h

19 #ifndef 
_
@
GUARD_PREFIX
@
_GETOPT_H


21 #if 
__GNUC__
 >= 3

22 @
	gPRAGMA_SYSTEM_HEADER
@

24 @
	gPRAGMA_COLUMNS
@

29 #if @
HAVE_GETOPT_H
@

30 #define 
	#_GL_SYSTEM_GETOPT


	)

31 #@
INCLUDE_NEXT
@ @
NEXT_GETOPT_H
@

32 #undef 
_GL_SYSTEM_GETOPT


35 #ifndef 
_
@
GUARD_PREFIX
@
_GETOPT_H


37 #ifndef 
__need_getopt


38 #define 
	#_
@
GUARD_PREFIX
@
_GETOPT_H
 1

	)

50 #if 
defined
 
__GETOPT_PREFIX
 && !defined 
__need_getopt


51 #if !@
HAVE_GETOPT_H
@

52 #include 
	~<stdlib.h
>

53 #include 
	~<stdio.h
>

54 #include 
	~<unistd.h
>

56 #undef 
__need_getopt


57 #undef 
getopt


58 #undef 
getopt_long


59 #undef 
getopt_long_only


60 #undef 
optarg


61 #undef 
opterr


62 #undef 
optind


63 #undef 
optopt


64 #undef 
option


65 #define 
	#__GETOPT_CONCAT
(
x
, 
y
) x ## 
	)
y

66 #define 
	#__GETOPT_XCONCAT
(
x
, 
y
) 
	`__GETOPT_CONCAT
 (x, y)

	)

67 #define 
	#__GETOPT_ID
(
y
) 
	`__GETOPT_XCONCAT
 (
__GETOPT_PREFIX
, y)

	)

68 #define 
	#getopt
 
	`__GETOPT_ID
 (
getopt
)

	)

69 #define 
	#getopt_long
 
	`__GETOPT_ID
 (
getopt_long
)

	)

70 #define 
	#getopt_long_only
 
	`__GETOPT_ID
 (
getopt_long_only
)

	)

71 #define 
	#optarg
 
	`__GETOPT_ID
 (
optarg
)

	)

72 #define 
	#opterr
 
	`__GETOPT_ID
 (
opterr
)

	)

73 #define 
	#optind
 
	`__GETOPT_ID
 (
optind
)

	)

74 #define 
	#optopt
 
	`__GETOPT_ID
 (
optopt
)

	)

75 #define 
	#option
 
	`__GETOPT_ID
 (
option
)

	)

76 #define 
	#_getopt_internal
 
	`__GETOPT_ID
 (
getopt_internal
)

	)

95 #if !
defined
 
__need_getopt


96 #if 
defined
 
__GETOPT_PREFIX


97 #define 
	#__getopt_argv_const


	)

99 #define 
	#__getopt_argv_const
 const

	)

110 #if !
defined
 
__GNU_LIBRARY__


111 #include 
	~<ctype.h
>

114 #ifndef 
__THROW


115 #ifndef 
__GNUC_PREREQ


116 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) (0)

	)

118 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,8)

119 #define 
	#__THROW
 
	`throw
 ()

	)

121 #define 
	#__THROW


	)

127 #ifdef 
__cplusplus


137 extern char *
optarg
;

151 extern int 
optind
;

156 extern int 
opterr
;

160 extern int 
optopt
;

162 #ifndef 
__need_getopt


184 #if !
GNULIB_defined_struct_option


185 struct 
	soption


187 const char *
	gname
;

190 int 
	ghas_arg
;

191 int *
	gflag
;

192 int 
	gval
;

194 #define 
	#GNULIB_defined_struct_option
 1

	)

199 #define 
	#no_argument
 0

	)

200 #define 
	#required_argument
 1

	)

201 #define 
	#optional_argument
 2

	)

230 extern int 
getopt
 (int 
___argc
, char *const *
___argv
, const char *
__shortopts
)

231 
__THROW
 
_GL_ARG_NONNULL
 ((2, 3));

233 #ifndef 
__need_getopt


234 extern int 
getopt_long
 (int 
___argc
, char *
__getopt_argv_const
 *
___argv
,

235 const char *
__shortopts
,

236 const struct 
option
 *
__longopts
, int *
__longind
)

237 
__THROW
 
_GL_ARG_NONNULL
 ((2, 3));

238 extern int 
getopt_long_only
 (int 
___argc
, char *
__getopt_argv_const
 *
___argv
,

239 const char *
__shortopts
,

240 const struct 
option
 *
__longopts
, int *
__longind
)

241 
__THROW
 
_GL_ARG_NONNULL
 ((2, 3));

245 #ifdef 
__cplusplus


250 #undef 
__need_getopt


	@lib/getopt1.c

19 #ifdef 
_LIBC


20 #include 
	~<getopt.h
>

22 #include 
	~<config.h
>

23 #include 
	~"getopt.h
"

25 #include 
	~"getopt_int.h
"

27 #include 
	~<stdio.h
>

31 #ifdef 
__GNU_LIBRARY__


32 #include 
	~<stdlib.h
>

35 #ifndef 
NULL


36 #define 
	#NULL
 0

	)

40 
	$getopt_long
 (int 
argc
, char *
__getopt_argv_const
 *
argv
, const char *
options
,

41 const struct 
option
 *
long_options
, int *
opt_index
)

43 return 
	`_getopt_internal
 (
argc
, (char **) 
argv
, 
options
, 
long_options
,

44 
opt_index
, 0, 0);

45 
	}
}

48 
	$_getopt_long_r
 (int 
argc
, char **
argv
, const char *
options
,

49 const struct 
option
 *
long_options
, int *
opt_index
,

50 struct 
_getopt_data
 *
d
)

52 return 
	`_getopt_internal_r
 (
argc
, 
argv
, 
options
, 
long_options
, 
opt_index
,

53 0, 
d
, 0);

54 
	}
}

62 
	$getopt_long_only
 (int 
argc
, char *
__getopt_argv_const
 *
argv
,

63 const char *
options
,

64 const struct 
option
 *
long_options
, int *
opt_index
)

66 return 
	`_getopt_internal
 (
argc
, (char **) 
argv
, 
options
, 
long_options
,

67 
opt_index
, 1, 0);

68 
	}
}

71 
	$_getopt_long_only_r
 (int 
argc
, char **
argv
, const char *
options
,

72 const struct 
option
 *
long_options
, int *
opt_index
,

73 struct 
_getopt_data
 *
d
)

75 return 
	`_getopt_internal_r
 (
argc
, 
argv
, 
options
, 
long_options
, 
opt_index
,

76 1, 
d
, 0);

77 
	}
}

80 #ifdef 
TEST


82 #include 
	~<stdio.h
>

85 
	$main
 (int 
argc
, char **
argv
)

87 int 
c
;

88 int 
digit_optind
 = 0;

92 int 
this_option_optind
 = 
optind
 ? optind : 1;

93 int 
option_index
 = 0;

94 static const struct 
option
 
long_options
[] =

105 
c
 = 
	`getopt_long
 (
argc
, 
argv
, "abc:d:0123456789",

106 
long_options
, &
option_index
);

107 if (
c
 == -1)

110 switch (
c
)

113 
	`printf
 ("option %s", 
long_options
[
option_index
].
name
);

114 if (
optarg
)

115 
	`printf
 (" with arg %s", 
optarg
);

116 
	`printf
 ("\n");

129 if (
digit_optind
 != 0 && digit_optind != 
this_option_optind
)

130 
	`printf
 ("digits occur in two different argv-elements.\n");

131 
digit_optind
 = 
this_option_optind
;

132 
	`printf
 ("option %c\n", 
c
);

136 
	`printf
 ("option a\n");

140 
	`printf
 ("option b\n");

144 
	`printf
 ("option c with value `%s'\n", 
optarg
);

148 
	`printf
 ("option d with value `%s'\n", 
optarg
);

155 
	`printf
 ("?? getopt returned character code 0%o ??\n", 
c
);

159 if (
optind
 < 
argc
)

161 
	`printf
 ("non-option ARGV-elements: ");

162 while (
optind
 < 
argc
)

163 
	`printf
 ("%s ", 
argv
[
optind
++]);

164 
	`printf
 ("\n");

167 
	`exit
 (0);

168 
	}
}

	@lib/getopt_int.h

19 #ifndef 
_GETOPT_INT_H


20 #define 
	#_GETOPT_INT_H
 1

	)

22 #include 
	~<getopt.h
>

24 extern int 
_getopt_internal
 (int 
___argc
, char **
___argv
,

25 const char *
__shortopts
,

26 const struct 
option
 *
__longopts
, int *
__longind
,

27 int 
__long_only
, int 
__posixly_correct
);

62 enum 
	e__ord


64 
	mREQUIRE_ORDER
, 
	mPERMUTE
, 
	mRETURN_IN_ORDER


68 struct 
	s_getopt_data


73 int 
	moptind
;

74 int 
	mopterr
;

75 int 
	moptopt
;

76 char *
	moptarg
;

81 int 
	m__initialized
;

89 char *
	m__nextchar
;

92 enum 
__ord
 
	m__ordering
;

96 int 
	m__posixly_correct
;

105 int 
	m__first_nonopt
;

106 int 
	m__last_nonopt
;

108 #if 
defined
 
_LIBC
 && defined 
USE_NONOPTION_FLAGS


109 int 
	m__nonoption_flags_max_len
;

110 int 
	m__nonoption_flags_len
;

116 #define 
	#_GETOPT_DATA_INITIALIZER
 { 1, 1 }

	)

118 extern int 
_getopt_internal_r
 (int 
___argc
, char **
___argv
,

119 const char *
__shortopts
,

120 const struct 
option
 *
__longopts
, int *
__longind
,

121 int 
__long_only
, struct 
_getopt_data
 *
__data
,

122 int 
__posixly_correct
);

124 extern int 
_getopt_long_r
 (int 
___argc
, char **
___argv
,

125 const char *
__shortopts
,

126 const struct 
option
 *
__longopts
, int *
__longind
,

127 struct 
_getopt_data
 *
__data
);

129 extern int 
_getopt_long_only_r
 (int 
___argc
, char **
___argv
,

130 const char *
__shortopts
,

131 const struct 
option
 *
__longopts
,

132 int *
__longind
,

133 struct 
_getopt_data
 *
__data
);

	@lib/getpagesize.c

20 #include 
	~<config.h
>

23 #include 
	~<unistd.h
>

26 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


28 #define 
	#WIN32_LEAN_AND_MEAN


	)

29 #include 
	~<windows.h
>

32 
	$getpagesize
 (void)

34 
SYSTEM_INFO
 
system_info
;

35 
	`GetSystemInfo
 (&
system_info
);

36 return 
system_info
.
dwPageSize
;

37 
	}
}

	@lib/gettext.h

21 #ifndef 
_LIBGETTEXT_H


22 #define 
	#_LIBGETTEXT_H
 1

	)

25 #if 
ENABLE_NLS


28 #include 
	~<libintl.h
>

33 #ifdef 
DEFAULT_TEXT_DOMAIN


34 #undef 
gettext


35 #define 
	#gettext
(
Msgid
) \

36 
	`dgettext
 (
DEFAULT_TEXT_DOMAIN
, 
Msgid
)

	)

37 #undef 
ngettext


38 #define 
	#ngettext
(
Msgid1
, 
Msgid2
, 
N
) \

39 
	`dngettext
 (
DEFAULT_TEXT_DOMAIN
, 
Msgid1
, 
Msgid2
, 
N
)

	)

50 #if 
defined
(
__sun
)

51 #include 
	~<locale.h
>

57 #if 
defined
(
__cplusplus
) && defined(
__GNUG__
) && (
__GNUC__
 >= 3)

58 #include 
	~<cstdlib
>

59 #if (
__GLIBC__
 >= 2 && !
defined
 
__UCLIBC__
) || 
_GLIBCXX_HAVE_LIBINTL_H


60 #include 
	~<libintl.h
>

69 #undef 
gettext


70 #define 
	#gettext
(
Msgid
) ((const char *) (Msgid))

	)

71 #undef 
dgettext


72 #define 
	#dgettext
(
Domainname
, 
Msgid
) ((void) (Domainname), 
	`gettext
 (Msgid))

	)

73 #undef 
dcgettext


74 #define 
	#dcgettext
(
Domainname
, 
Msgid
, 
Category
) \

75 ((void) (
Category
), 
	`dgettext
 (
Domainname
, 
Msgid
))

	)

76 #undef 
ngettext


77 #define 
	#ngettext
(
Msgid1
, 
Msgid2
, 
N
) \

78 ((
N
) == 1 \

79 ? ((void) (
Msgid2
), (const char *) (
Msgid1
)) \

80 : ((void) (
Msgid1
), (const char *) (
Msgid2
)))

	)

81 #undef 
dngettext


82 #define 
	#dngettext
(
Domainname
, 
Msgid1
, 
Msgid2
, 
N
) \

83 ((void) (
Domainname
), 
	`ngettext
 (
Msgid1
, 
Msgid2
, 
N
))

	)

84 #undef 
dcngettext


85 #define 
	#dcngettext
(
Domainname
, 
Msgid1
, 
Msgid2
, 
N
, 
Category
) \

86 ((void) (
Category
), 
	`dngettext
 (
Domainname
, 
Msgid1
, 
Msgid2
, 
N
))

	)

87 #undef 
textdomain


88 #define 
	#textdomain
(
Domainname
) ((const char *) (Domainname))

	)

89 #undef 
bindtextdomain


90 #define 
	#bindtextdomain
(
Domainname
, 
Dirname
) \

91 ((void) (
Domainname
), (const char *) (
Dirname
))

	)

92 #undef 
bind_textdomain_codeset


93 #define 
	#bind_textdomain_codeset
(
Domainname
, 
Codeset
) \

94 ((void) (
Domainname
), (const char *) (
Codeset
))

	)

99 #ifdef 
GNULIB_defined_setlocale


100 #undef 
setlocale


101 #define 
	#setlocale
 
rpl_setlocale


	)

111 #define 
	#gettext_noop
(
String
) 
	)
String

114 #define 
	#GETTEXT_CONTEXT_GLUE
 "\004"

	)

120 #ifdef 
DEFAULT_TEXT_DOMAIN


121 #define 
	#pgettext
(
Msgctxt
, 
Msgid
) \

122 
	`pgettext_aux
 (
DEFAULT_TEXT_DOMAIN
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
LC_MESSAGES
)

	)

124 #define 
	#pgettext
(
Msgctxt
, 
Msgid
) \

125 
	`pgettext_aux
 (
NULL
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
LC_MESSAGES
)

	)

127 #define 
	#dpgettext
(
Domainname
, 
Msgctxt
, 
Msgid
) \

128 
	`pgettext_aux
 (
Domainname
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
LC_MESSAGES
)

	)

129 #define 
	#dcpgettext
(
Domainname
, 
Msgctxt
, 
Msgid
, 
Category
) \

130 
	`pgettext_aux
 (
Domainname
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
Category
)

	)

131 #ifdef 
DEFAULT_TEXT_DOMAIN


132 #define 
	#npgettext
(
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
) \

133 
	`npgettext_aux
 (
DEFAULT_TEXT_DOMAIN
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
MsgidPlural
, 
N
, 
LC_MESSAGES
)

	)

135 #define 
	#npgettext
(
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
) \

136 
	`npgettext_aux
 (
NULL
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
MsgidPlural
, 
N
, 
LC_MESSAGES
)

	)

138 #define 
	#dnpgettext
(
Domainname
, 
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
) \

139 
	`npgettext_aux
 (
Domainname
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
MsgidPlural
, 
N
, 
LC_MESSAGES
)

	)

140 #define 
	#dcnpgettext
(
Domainname
, 
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
, 
Category
) \

141 
	`npgettext_aux
 (
Domainname
, 
Msgctxt
 
GETTEXT_CONTEXT_GLUE
 
Msgid
, Msgid, 
MsgidPlural
, 
N
, 
Category
)

	)

143 #ifdef 
__GNUC__


144 
	g__inline


146 #ifdef 
__cplusplus


147 
	ginline


151 
	$pgettext_aux
 (const char *
domain
,

152 const char *
msg_ctxt_id
, const char *
msgid
,

153 int 
category
)

155 const char *
translation
 = 
	`dcgettext
 (
domain
, 
msg_ctxt_id
, 
category
);

156 if (
translation
 == 
msg_ctxt_id
)

157 return 
msgid
;

159 return 
translation
;

160 
	}
}

162 #ifdef 
__GNUC__


163 
	g__inline


165 #ifdef 
__cplusplus


166 
	ginline


170 
	$npgettext_aux
 (const char *
domain
,

171 const char *
msg_ctxt_id
, const char *
msgid
,

172 const char *
msgid_plural
, unsigned long int 
n
,

173 int 
category
)

175 const char *
translation
 =

176 
	`dcngettext
 (
domain
, 
msg_ctxt_id
, 
msgid_plural
, 
n
, 
category
);

177 if (
translation
 == 
msg_ctxt_id
 || translation == 
msgid_plural
)

178 return (
n
 == 1 ? 
msgid
 : 
msgid_plural
);

180 return 
translation
;

181 
	}
}

187 #include 
	~<string.h
>

189 #define 
	#_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
 \

190 (((
__GNUC__
 >= 3 || 
__GNUG__
 >= 2) && !
defined
 
__STRICT_ANSI__
) \

191  )

	)

193 #if !
_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS


194 #include 
	~<stdlib.h
>

197 #define 
	#pgettext_expr
(
Msgctxt
, 
Msgid
) \

198 
	`dcpgettext_expr
 (
NULL
, 
Msgctxt
, 
Msgid
, 
LC_MESSAGES
)

	)

199 #define 
	#dpgettext_expr
(
Domainname
, 
Msgctxt
, 
Msgid
) \

200 
	`dcpgettext_expr
 (
Domainname
, 
Msgctxt
, 
Msgid
, 
LC_MESSAGES
)

	)

202 #ifdef 
__GNUC__


203 
	g__inline


205 #ifdef 
__cplusplus


206 
	ginline


210 
	$dcpgettext_expr
 (const char *
domain
,

211 const char *
msgctxt
, const char *
msgid
,

212 int 
category
)

214 
size_t
 
msgctxt_len
 = 
	`strlen
 (
msgctxt
) + 1;

215 
size_t
 
msgid_len
 = 
	`strlen
 (
msgid
) + 1;

216 const char *
translation
;

217 #if 
_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS


218 char 
msg_ctxt_id
[
msgctxt_len
 + 
msgid_len
];

220 char 
buf
[1024];

221 char *
msg_ctxt_id
 =

222 (
msgctxt_len
 + 
msgid_len
 <= sizeof (
buf
)

223 ? 
buf


224 : (char *) 
	`malloc
 (
msgctxt_len
 + 
msgid_len
));

225 if (
msg_ctxt_id
 != 
NULL
)

228 
	`memcpy
 (
msg_ctxt_id
, 
msgctxt
, 
msgctxt_len
 - 1);

229 
msg_ctxt_id
[
msgctxt_len
 - 1] = '\004';

230 
	`memcpy
 (
msg_ctxt_id
 + 
msgctxt_len
, 
msgid
, 
msgid_len
);

231 
translation
 = 
	`dcgettext
 (
domain
, 
msg_ctxt_id
, 
category
);

232 #if !
_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS


233 if (
msg_ctxt_id
 != 
buf
)

234 
	`free
 (
msg_ctxt_id
);

236 if (
translation
 != 
msg_ctxt_id
)

237 return 
translation
;

239 return 
msgid
;

240 
	}
}

242 #define 
	#npgettext_expr
(
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
) \

243 
	`dcnpgettext_expr
 (
NULL
, 
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
, 
LC_MESSAGES
)

	)

244 #define 
	#dnpgettext_expr
(
Domainname
, 
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
) \

245 
	`dcnpgettext_expr
 (
Domainname
, 
Msgctxt
, 
Msgid
, 
MsgidPlural
, 
N
, 
LC_MESSAGES
)

	)

247 #ifdef 
__GNUC__


248 
	g__inline


250 #ifdef 
__cplusplus


251 
	ginline


255 
	$dcnpgettext_expr
 (const char *
domain
,

256 const char *
msgctxt
, const char *
msgid
,

257 const char *
msgid_plural
, unsigned long int 
n
,

258 int 
category
)

260 
size_t
 
msgctxt_len
 = 
	`strlen
 (
msgctxt
) + 1;

261 
size_t
 
msgid_len
 = 
	`strlen
 (
msgid
) + 1;

262 const char *
translation
;

263 #if 
_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS


264 char 
msg_ctxt_id
[
msgctxt_len
 + 
msgid_len
];

266 char 
buf
[1024];

267 char *
msg_ctxt_id
 =

268 (
msgctxt_len
 + 
msgid_len
 <= sizeof (
buf
)

269 ? 
buf


270 : (char *) 
	`malloc
 (
msgctxt_len
 + 
msgid_len
));

271 if (
msg_ctxt_id
 != 
NULL
)

274 
	`memcpy
 (
msg_ctxt_id
, 
msgctxt
, 
msgctxt_len
 - 1);

275 
msg_ctxt_id
[
msgctxt_len
 - 1] = '\004';

276 
	`memcpy
 (
msg_ctxt_id
 + 
msgctxt_len
, 
msgid
, 
msgid_len
);

277 
translation
 = 
	`dcngettext
 (
domain
, 
msg_ctxt_id
, 
msgid_plural
, 
n
, 
category
);

278 #if !
_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS


279 if (
msg_ctxt_id
 != 
buf
)

280 
	`free
 (
msg_ctxt_id
);

282 if (!(
translation
 == 
msg_ctxt_id
 || translation == 
msgid_plural
))

283 return 
translation
;

285 return (
n
 == 1 ? 
msgid
 : 
msgid_plural
);

286 
	}
}

	@lib/hard-locale.c

19 #include 
	~<config.h
>

21 #include 
	~"hard-locale.h
"

23 #include 
	~<locale.h
>

24 #include 
	~<stdlib.h
>

25 #include 
	~<string.h
>

27 #ifdef 
__GLIBC__


28 #define 
	#GLIBC_VERSION
 
__GLIBC__


	)

29 #elif 
defined
 
__UCLIBC__


30 #define 
	#GLIBC_VERSION
 2

	)

32 #define 
	#GLIBC_VERSION
 0

	)

37 
bool


38 
	$hard_locale
 (int 
category
)

40 
bool
 
hard
 = 
true
;

41 char const *
p
 = 
	`setlocale
 (
category
, 
NULL
);

43 if (
p
)

45 if (2 <= 
GLIBC_VERSION
)

47 if (
	`strcmp
 (
p
, "C") == 0 || strcmp (p, "POSIX") == 0)

48 
hard
 = 
false
;

52 char *
locale
 = 
	`strdup
 (
p
);

53 if (
locale
)

58 if (((
p
 = 
	`setlocale
 (
category
, "C"))

59 && 
	`strcmp
 (
p
, 
locale
) == 0)

60 || ((
p
 = 
	`setlocale
 (
category
, "POSIX"))

61 && 
	`strcmp
 (
p
, 
locale
) == 0))

62 
hard
 = 
false
;

65 
	`setlocale
 (
category
, 
locale
);

66 
	`free
 (
locale
);

71 return 
hard
;

72 
	}
}

	@lib/hard-locale.h

18 #ifndef 
HARD_LOCALE_H_


19 #define 
	#HARD_LOCALE_H_
 1

	)

21 #include 
	~<stdbool.h
>

23 
bool
 
hard_locale
 (int);

	@lib/hash.c

25 #include 
	~<config.h
>

27 #include 
	~"hash.h
"

29 #include 
	~"bitrotate.h
"

30 #include 
	~"xalloc-oversized.h
"

32 #include 
	~<stdint.h
>

33 #include 
	~<stdio.h
>

34 #include 
	~<stdlib.h
>

36 #if 
USE_OBSTACK


37 #include 
	~"obstack.h
"

38 #ifndef 
obstack_chunk_alloc


39 #define 
	#obstack_chunk_alloc
 
malloc


	)

41 #ifndef 
obstack_chunk_free


42 #define 
	#obstack_chunk_free
 
free


	)

46 struct 
	shash_entry


48 void *
	mdata
;

49 struct 
hash_entry
 *
	mnext
;

52 struct 
	shash_table


57 struct 
hash_entry
 *
	mbucket
;

58 struct 
hash_entry
 const *
	mbucket_limit
;

59 
size_t
 
	mn_buckets
;

60 
size_t
 
	mn_buckets_used
;

61 
size_t
 
	mn_entries
;

64 const 
Hash_tuning
 *
	mtuning
;

71 
Hash_hasher
 
	mhasher
;

72 
Hash_comparator
 
	mcomparator
;

73 
Hash_data_freer
 
	mdata_freer
;

76 struct 
hash_entry
 *
	mfree_entry_list
;

78 #if 
USE_OBSTACK


82 struct 
obstack
 
	mentry_stack
;

116 #define 
	#DEFAULT_GROWTH_THRESHOLD
 0.8

	)

117 #define 
	#DEFAULT_GROWTH_FACTOR
 1.414

	)

125 #define 
	#DEFAULT_SHRINK_THRESHOLD
 0.0

	)

126 #define 
	#DEFAULT_SHRINK_FACTOR
 1.0

	)

130 static const 
Hash_tuning
 
	gdefault_tuning
 =

132 
DEFAULT_SHRINK_THRESHOLD
,

133 
DEFAULT_SHRINK_FACTOR
,

134 
DEFAULT_GROWTH_THRESHOLD
,

135 
DEFAULT_GROWTH_FACTOR
,

136 
false


149 
size_t


150 
	$hash_get_n_buckets
 (const 
Hash_table
 *
table
)

152 return 
table
->
n_buckets
;

153 
	}
}

157 
size_t


158 
	$hash_get_n_buckets_used
 (const 
Hash_table
 *
table
)

160 return 
table
->
n_buckets_used
;

161 
	}
}

165 
size_t


166 
	$hash_get_n_entries
 (const 
Hash_table
 *
table
)

168 return 
table
->
n_entries
;

169 
	}
}

173 
size_t


174 
	$hash_get_max_bucket_length
 (const 
Hash_table
 *
table
)

176 struct 
hash_entry
 const *
bucket
;

177 
size_t
 
max_bucket_length
 = 0;

179 for (
bucket
 = 
table
->bucket; bucket < table->
bucket_limit
; bucket++)

181 if (
bucket
->
data
)

183 struct 
hash_entry
 const *
cursor
 = 
bucket
;

184 
size_t
 
bucket_length
 = 1;

186 while (
cursor
 = cursor->
next
, cursor)

187 
bucket_length
++;

189 if (
bucket_length
 > 
max_bucket_length
)

190 
max_bucket_length
 = 
bucket_length
;

194 return 
max_bucket_length
;

195 
	}
}

200 
bool


201 
	$hash_table_ok
 (const 
Hash_table
 *
table
)

203 struct 
hash_entry
 const *
bucket
;

204 
size_t
 
n_buckets_used
 = 0;

205 
size_t
 
n_entries
 = 0;

207 for (
bucket
 = 
table
->bucket; bucket < table->
bucket_limit
; bucket++)

209 if (
bucket
->
data
)

211 struct 
hash_entry
 const *
cursor
 = 
bucket
;

214 
n_buckets_used
++;

215 
n_entries
++;

218 while (
cursor
 = cursor->
next
, cursor)

219 
n_entries
++;

223 if (
n_buckets_used
 == 
table
->n_buckets_used && 
n_entries
 == table->n_entries)

224 return 
true
;

226 return 
false
;

227 
	}
}

230 
	$hash_print_statistics
 (const 
Hash_table
 *
table
, 
FILE
 *
stream
)

232 
size_t
 
n_entries
 = 
	`hash_get_n_entries
 (
table
);

233 
size_t
 
n_buckets
 = 
	`hash_get_n_buckets
 (
table
);

234 
size_t
 
n_buckets_used
 = 
	`hash_get_n_buckets_used
 (
table
);

235 
size_t
 
max_bucket_length
 = 
	`hash_get_max_bucket_length
 (
table
);

237 
	`fprintf
 (
stream
, "# entries: %lu\n", (unsigned long int) 
n_entries
);

238 
	`fprintf
 (
stream
, "# buckets: %lu\n", (unsigned long int) 
n_buckets
);

239 
	`fprintf
 (
stream
, "# buckets used: %lu (%.2f%%)\n",

240 (unsigned long int) 
n_buckets_used
,

241 (100.0 * 
n_buckets_used
) / 
n_buckets
);

242 
	`fprintf
 (
stream
, "max bucket length: %lu\n",

243 (unsigned long int) 
max_bucket_length
);

244 
	}
}

248 static struct 
hash_entry
 *

249 
	$safe_hasher
 (const 
Hash_table
 *
table
, const void *
key
)

251 
size_t
 
n
 = 
table
->
	`hasher
 (
key
, table->
n_buckets
);

252 if (! (
n
 < 
table
->
n_buckets
))

253 
	`abort
 ();

254 return 
table
->
bucket
 + 
n
;

255 
	}
}

261 
	$hash_lookup
 (const 
Hash_table
 *
table
, const void *
entry
)

263 struct 
hash_entry
 const *
bucket
 = 
	`safe_hasher
 (
table
, 
entry
);

264 struct 
hash_entry
 const *
cursor
;

266 if (
bucket
->
data
 == 
NULL
)

267 return 
NULL
;

269 for (
cursor
 = 
bucket
; cursor; cursor = cursor->
next
)

270 if (
entry
 == 
cursor
->
data
 || 
table
->
	`comparator
 (entry, cursor->data))

271 return 
cursor
->
data
;

273 return 
NULL
;

274 
	}
}

288 
	$hash_get_first
 (const 
Hash_table
 *
table
)

290 struct 
hash_entry
 const *
bucket
;

292 if (
table
->
n_entries
 == 0)

293 return 
NULL
;

295 for (
bucket
 = 
table
->bucket; ; bucket++)

296 if (! (
bucket
 < 
table
->
bucket_limit
))

297 
	`abort
 ();

298 else if (
bucket
->
data
)

299 return 
bucket
->
data
;

300 
	}
}

307 
	$hash_get_next
 (const 
Hash_table
 *
table
, const void *
entry
)

309 struct 
hash_entry
 const *
bucket
 = 
	`safe_hasher
 (
table
, 
entry
);

310 struct 
hash_entry
 const *
cursor
;

313 
cursor
 = 
bucket
;

316 if (
cursor
->
data
 == 
entry
 && cursor->
next
)

317 return 
cursor
->
next
->
data
;

318 
cursor
 = cursor->
next
;

320 while (
cursor
 != 
NULL
);

323 while (++
bucket
 < 
table
->
bucket_limit
)

324 if (
bucket
->
data
)

325 return 
bucket
->
data
;

328 return 
NULL
;

329 
	}
}

335 
size_t


336 
	$hash_get_entries
 (const 
Hash_table
 *
table
, void **
buffer
,

337 
size_t
 
buffer_size
)

339 
size_t
 
counter
 = 0;

340 struct 
hash_entry
 const *
bucket
;

341 struct 
hash_entry
 const *
cursor
;

343 for (
bucket
 = 
table
->bucket; bucket < table->
bucket_limit
; bucket++)

345 if (
bucket
->
data
)

347 for (
cursor
 = 
bucket
; cursor; cursor = cursor->
next
)

349 if (
counter
 >= 
buffer_size
)

350 return 
counter
;

351 
buffer
[
counter
++] = 
cursor
->
data
;

356 return 
counter
;

357 
	}
}

367 
size_t


368 
	$hash_do_for_each
 (const 
Hash_table
 *
table
, 
Hash_processor
 
processor
,

369 void *
processor_data
)

371 
size_t
 
counter
 = 0;

372 struct 
hash_entry
 const *
bucket
;

373 struct 
hash_entry
 const *
cursor
;

375 for (
bucket
 = 
table
->bucket; bucket < table->
bucket_limit
; bucket++)

377 if (
bucket
->
data
)

379 for (
cursor
 = 
bucket
; cursor; cursor = cursor->
next
)

381 if (! 
	`processor
 (
cursor
->
data
, 
processor_data
))

382 return 
counter
;

383 
counter
++;

388 return 
counter
;

389 
	}
}

396 #if 
USE_DIFF_HASH


404 
size_t


405 
	$hash_string
 (const char *
string
, 
size_t
 
n_buckets
)

407 #define 
	#HASH_ONE_CHAR
(
Value
, 
Byte
) \

408 ((
Byte
) + 
	`rotl_sz
 (
Value
, 7))

	)

410 
size_t
 
value
 = 0;

411 unsigned char 
ch
;

413 for (; (
ch
 = *
string
); string++)

414 
value
 = 
	`HASH_ONE_CHAR
 (value, 
ch
);

415 return 
value
 % 
n_buckets
;

417 #undef 
HASH_ONE_CHAR


418 
	}
}

427 
size_t


428 
	$hash_string
 (const char *
string
, 
size_t
 
n_buckets
)

430 
size_t
 
value
 = 0;

431 unsigned char 
ch
;

433 for (; (
ch
 = *
string
); string++)

434 
value
 = (value * 31 + 
ch
) % 
n_buckets
;

435 return 
value
;

436 
	}
}

443 static 
bool


444 
	$is_prime
 (
size_t
 
candidate
)

446 
size_t
 
divisor
 = 3;

447 
size_t
 
square
 = 
divisor
 * divisor;

449 while (
square
 < 
candidate
 && (candidate % 
divisor
))

451 
divisor
++;

452 
square
 += 4 * 
divisor
;

453 
divisor
++;

456 return (
candidate
 % 
divisor
 ? 
true
 : 
false
);

457 
	}
}

462 static 
size_t


463 
	$next_prime
 (
size_t
 
candidate
)

466 if (
candidate
 < 10)

467 
candidate
 = 10;

470 
candidate
 |= 1;

472 while (
SIZE_MAX
 != 
candidate
 && !
	`is_prime
 (candidate))

473 
candidate
 += 2;

475 return 
candidate
;

476 
	}
}

479 
	$hash_reset_tuning
 (
Hash_tuning
 *
tuning
)

481 *
tuning
 = 
default_tuning
;

482 
	}
}

485 static 
size_t


486 
	$raw_hasher
 (const void *
data
, 
size_t
 
n
)

493 
size_t
 
val
 = 
	`rotr_sz
 ((size_t) 
data
, 3);

494 return 
val
 % 
n
;

495 
	}
}

498 static 
bool


499 
	$raw_comparator
 (const void *
a
, const void *
b
)

501 return 
a
 == 
b
;

502 
	}
}

511 static 
bool


512 
	$check_tuning
 (
Hash_table
 *
table
)

514 const 
Hash_tuning
 *
tuning
 = 
table
->tuning;

515 float 
epsilon
;

516 if (
tuning
 == &
default_tuning
)

517 return 
true
;

524 
epsilon
 = 0.1f;

526 if (
epsilon
 < 
tuning
->
growth_threshold


527 && 
tuning
->
growth_threshold
 < 1 - 
epsilon


528 && 1 + 
epsilon
 < 
tuning
->
growth_factor


529 && 0 <= 
tuning
->
shrink_threshold


530 && 
tuning
->
shrink_threshold
 + 
epsilon
 < tuning->
shrink_factor


531 && 
tuning
->
shrink_factor
 <= 1

532 && 
tuning
->
shrink_threshold
 + 
epsilon
 < tuning->
growth_threshold
)

533 return 
true
;

535 
table
->
tuning
 = &
default_tuning
;

536 return 
false
;

537 
	}
}

543 static 
size_t


544 
	$compute_bucket_size
 (
size_t
 
candidate
, const 
Hash_tuning
 *
tuning
)

546 if (!
tuning
->
is_n_buckets
)

548 float 
new_candidate
 = 
candidate
 / 
tuning
->
growth_threshold
;

549 if (
SIZE_MAX
 <= 
new_candidate
)

551 
candidate
 = 
new_candidate
;

553 
candidate
 = 
	`next_prime
 (candidate);

554 if (
	`xalloc_oversized
 (
candidate
, sizeof (struct 
hash_entry
 *)))

556 return 
candidate
;

557 
	}
}

593 
Hash_table
 *

594 
	$hash_initialize
 (
size_t
 
candidate
, const 
Hash_tuning
 *
tuning
,

595 
Hash_hasher
 
hasher
, 
Hash_comparator
 
comparator
,

596 
Hash_data_freer
 
data_freer
)

598 
Hash_table
 *
table
;

600 if (
hasher
 == 
NULL
)

601 
hasher
 = 
raw_hasher
;

602 if (
comparator
 == 
NULL
)

603 
comparator
 = 
raw_comparator
;

605 
table
 = 
	`malloc
 (sizeof *table);

606 if (
table
 == 
NULL
)

607 return 
NULL
;

609 if (!
tuning
)

610 
tuning
 = &
default_tuning
;

611 
table
->
tuning
 = tuning;

612 if (!
	`check_tuning
 (
table
))

619 goto 
fail
;

622 
table
->
n_buckets
 = 
	`compute_bucket_size
 (
candidate
, 
tuning
);

623 if (!
table
->
n_buckets
)

624 goto 
fail
;

626 
table
->
bucket
 = 
	`calloc
 (table->
n_buckets
, sizeof *table->bucket);

627 if (
table
->
bucket
 == 
NULL
)

628 goto 
fail
;

629 
table
->
bucket_limit
 = table->
bucket
 + table->
n_buckets
;

630 
table
->
n_buckets_used
 = 0;

631 
table
->
n_entries
 = 0;

633 
table
->
hasher
 = hasher;

634 
table
->
comparator
 = comparator;

635 
table
->
data_freer
 = data_freer;

637 
table
->
free_entry_list
 = 
NULL
;

638 #if 
USE_OBSTACK


639 
	`obstack_init
 (&
table
->
entry_stack
);

641 return 
table
;

643 
fail
:

644 
	`free
 (
table
);

645 return 
NULL
;

646 
	}
}

653 
	$hash_clear
 (
Hash_table
 *
table
)

655 struct 
hash_entry
 *
bucket
;

657 for (
bucket
 = 
table
->bucket; bucket < table->
bucket_limit
; bucket++)

659 if (
bucket
->
data
)

661 struct 
hash_entry
 *
cursor
;

662 struct 
hash_entry
 *
next
;

665 for (
cursor
 = 
bucket
->
next
; cursor; cursor = next)

667 if (
table
->
data_freer
)

668 
table
->
	`data_freer
 (
cursor
->
data
);

669 
cursor
->
data
 = 
NULL
;

671 
next
 = 
cursor
->next;

674 
cursor
->
next
 = 
table
->
free_entry_list
;

675 
table
->
free_entry_list
 = 
cursor
;

679 if (
table
->
data_freer
)

680 
table
->
	`data_freer
 (
bucket
->
data
);

681 
bucket
->
data
 = 
NULL
;

682 
bucket
->
next
 = 
NULL
;

686 
table
->
n_buckets_used
 = 0;

687 
table
->
n_entries
 = 0;

688 
	}
}

696 
	$hash_free
 (
Hash_table
 *
table
)

698 struct 
hash_entry
 *
bucket
;

699 struct 
hash_entry
 *
cursor
;

700 struct 
hash_entry
 *
next
;

703 if (
table
->
data_freer
 && table->
n_entries
)

705 for (
bucket
 = 
table
->bucket; bucket < table->
bucket_limit
; bucket++)

707 if (
bucket
->
data
)

709 for (
cursor
 = 
bucket
; cursor; cursor = cursor->
next
)

710 
table
->
	`data_freer
 (
cursor
->
data
);

715 #if 
USE_OBSTACK


717 
	`obstack_free
 (&
table
->
entry_stack
, 
NULL
);

722 for (
bucket
 = 
table
->bucket; bucket < table->
bucket_limit
; bucket++)

724 for (
cursor
 = 
bucket
->
next
; cursor; cursor = next)

726 
next
 = 
cursor
->next;

727 
	`free
 (
cursor
);

732 for (
cursor
 = 
table
->
free_entry_list
; cursor; cursor = 
next
)

734 
next
 = 
cursor
->next;

735 
	`free
 (
cursor
);

741 
	`free
 (
table
->
bucket
);

742 
	`free
 (
table
);

743 
	}
}

750 static struct 
hash_entry
 *

751 
	$allocate_entry
 (
Hash_table
 *
table
)

753 struct 
hash_entry
 *
new
;

755 if (
table
->
free_entry_list
)

757 
new
 = 
table
->
free_entry_list
;

758 
table
->
free_entry_list
 = 
new
->
next
;

762 #if 
USE_OBSTACK


763 
new
 = 
	`obstack_alloc
 (&
table
->
entry_stack
, sizeof *new);

765 
new
 = 
	`malloc
 (sizeof *new);

769 return 
new
;

770 
	}
}

776 
	$free_entry
 (
Hash_table
 *
table
, struct 
hash_entry
 *
entry
)

778 
entry
->
data
 = 
NULL
;

779 
entry
->
next
 = 
table
->
free_entry_list
;

780 
table
->
free_entry_list
 = 
entry
;

781 
	}
}

790 
	$hash_find_entry
 (
Hash_table
 *
table
, const void *
entry
,

791 struct 
hash_entry
 **
bucket_head
, 
bool
 
delete
)

793 struct 
hash_entry
 *
bucket
 = 
	`safe_hasher
 (
table
, 
entry
);

794 struct 
hash_entry
 *
cursor
;

796 *
bucket_head
 = 
bucket
;

799 if (
bucket
->
data
 == 
NULL
)

800 return 
NULL
;

803 if (
entry
 == 
bucket
->
data
 || 
table
->
	`comparator
 (entry, bucket->data))

805 void *
data
 = 
bucket
->data;

807 if (
delete
)

809 if (
bucket
->
next
)

811 struct 
hash_entry
 *
next
 = 
bucket
->next;

815 *
bucket
 = *
next
;

816 
	`free_entry
 (
table
, 
next
);

820 
bucket
->
data
 = 
NULL
;

824 return 
data
;

828 for (
cursor
 = 
bucket
; cursor->
next
; cursor = cursor->next)

830 if (
entry
 == 
cursor
->
next
->
data


831 || 
table
->
	`comparator
 (
entry
, 
cursor
->
next
->
data
))

833 void *
data
 = 
cursor
->
next
->data;

835 if (
delete
)

837 struct 
hash_entry
 *
next
 = 
cursor
->next;

841 
cursor
->
next
 = next->next;

842 
	`free_entry
 (
table
, 
next
);

845 return 
data
;

850 return 
NULL
;

851 
	}
}

859 static 
bool


860 
	$transfer_entries
 (
Hash_table
 *
dst
, Hash_table *
src
, 
bool
 
safe
)

862 struct 
hash_entry
 *
bucket
;

863 struct 
hash_entry
 *
cursor
;

864 struct 
hash_entry
 *
next
;

865 for (
bucket
 = 
src
->bucket; bucket < src->
bucket_limit
; bucket++)

866 if (
bucket
->
data
)

868 void *
data
;

869 struct 
hash_entry
 *
new_bucket
;

877 for (
cursor
 = 
bucket
->
next
; cursor; cursor = next)

879 
data
 = 
cursor
->data;

880 
new_bucket
 = 
	`safe_hasher
 (
dst
, 
data
);

882 
next
 = 
cursor
->next;

884 if (
new_bucket
->
data
)

888 
cursor
->
next
 = 
new_bucket
->next;

889 
new_bucket
->
next
 = 
cursor
;

895 
new_bucket
->
data
 = data;

896 
dst
->
n_buckets_used
++;

897 
	`free_entry
 (
dst
, 
cursor
);

903 
data
 = 
bucket
->data;

904 
bucket
->
next
 = 
NULL
;

905 if (
safe
)

907 
new_bucket
 = 
	`safe_hasher
 (
dst
, 
data
);

909 if (
new_bucket
->
data
)

913 struct 
hash_entry
 *
new_entry
 = 
	`allocate_entry
 (
dst
);

915 if (
new_entry
 == 
NULL
)

916 return 
false
;

918 
new_entry
->
data
 = data;

919 
new_entry
->
next
 = 
new_bucket
->next;

920 
new_bucket
->
next
 = 
new_entry
;

925 
new_bucket
->
data
 = data;

926 
dst
->
n_buckets_used
++;

928 
bucket
->
data
 = 
NULL
;

929 
src
->
n_buckets_used
--;

931 return 
true
;

932 
	}
}

942 
bool


943 
	$hash_rehash
 (
Hash_table
 *
table
, 
size_t
 
candidate
)

945 
Hash_table
 
storage
;

946 
Hash_table
 *
new_table
;

947 
size_t
 
new_size
 = 
	`compute_bucket_size
 (
candidate
, 
table
->
tuning
);

949 if (!
new_size
)

950 return 
false
;

951 if (
new_size
 == 
table
->
n_buckets
)

952 return 
true
;

953 
new_table
 = &
storage
;

954 
new_table
->
bucket
 = 
	`calloc
 (
new_size
, sizeof *new_table->bucket);

955 if (
new_table
->
bucket
 == 
NULL
)

956 return 
false
;

957 
new_table
->
n_buckets
 = 
new_size
;

958 
new_table
->
bucket_limit
 = new_table->
bucket
 + 
new_size
;

959 
new_table
->
n_buckets_used
 = 0;

960 
new_table
->
n_entries
 = 0;

961 
new_table
->
tuning
 = 
table
->tuning;

962 
new_table
->
hasher
 = 
table
->hasher;

963 
new_table
->
comparator
 = 
table
->comparator;

964 
new_table
->
data_freer
 = 
table
->data_freer;

981 #if 
USE_OBSTACK


982 
new_table
->
entry_stack
 = 
table
->entry_stack;

984 
new_table
->
free_entry_list
 = 
table
->free_entry_list;

986 if (
	`transfer_entries
 (
new_table
, 
table
, 
false
))

989 
	`free
 (
table
->
bucket
);

990 
table
->
bucket
 = 
new_table
->bucket;

991 
table
->
bucket_limit
 = 
new_table
->bucket_limit;

992 
table
->
n_buckets
 = 
new_table
->n_buckets;

993 
table
->
n_buckets_used
 = 
new_table
->n_buckets_used;

994 
table
->
free_entry_list
 = 
new_table
->free_entry_list;

996 return 
true
;

1012 
table
->
free_entry_list
 = 
new_table
->free_entry_list;

1013 if (! (
	`transfer_entries
 (
table
, 
new_table
, 
true
)

1014 && 
	`transfer_entries
 (
table
, 
new_table
, 
false
)))

1015 
	`abort
 ();

1017 
	`free
 (
new_table
->
bucket
);

1018 return 
false
;

1019 
	}
}

1036 
	$hash_insert0
 (
Hash_table
 *
table
, void const *
entry
, void const **
matched_ent
)

1038 void *
data
;

1039 struct 
hash_entry
 *
bucket
;

1044 if (! 
entry
)

1045 
	`abort
 ();

1048 if ((
data
 = 
	`hash_find_entry
 (
table
, 
entry
, &
bucket
, 
false
)) != 
NULL
)

1050 if (
matched_ent
)

1051 *
matched_ent
 = 
data
;

1060 if (
table
->
n_buckets_used


1061 > 
table
->
tuning
->
growth_threshold
 * table->
n_buckets
)

1065 
	`check_tuning
 (
table
);

1066 if (
table
->
n_buckets_used


1067 > 
table
->
tuning
->
growth_threshold
 * table->
n_buckets
)

1069 const 
Hash_tuning
 *
tuning
 = 
table
->tuning;

1070 float 
candidate
 =

1071 (
tuning
->
is_n_buckets


1072 ? (
table
->
n_buckets
 * 
tuning
->
growth_factor
)

1073 : (
table
->
n_buckets
 * 
tuning
->
growth_factor


1074 * 
tuning
->
growth_threshold
));

1076 if (
SIZE_MAX
 <= 
candidate
)

1080 if (!
	`hash_rehash
 (
table
, 
candidate
))

1084 if (
	`hash_find_entry
 (
table
, 
entry
, &
bucket
, 
false
) != 
NULL
)

1085 
	`abort
 ();

1091 if (
bucket
->
data
)

1093 struct 
hash_entry
 *
new_entry
 = 
	`allocate_entry
 (
table
);

1095 if (
new_entry
 == 
NULL
)

1100 
new_entry
->
data
 = (void *) 
entry
;

1101 
new_entry
->
next
 = 
bucket
->next;

1102 
bucket
->
next
 = 
new_entry
;

1103 
table
->
n_entries
++;

1109 
bucket
->
data
 = (void *) 
entry
;

1110 
table
->
n_entries
++;

1111 
table
->
n_buckets_used
++;

1114 
	}
}

1123 
	$hash_insert
 (
Hash_table
 *
table
, void const *
entry
)

1125 void const *
matched_ent
;

1126 int 
err
 = 
	`hash_insert0
 (
table
, 
entry
, &
matched_ent
);

1127 return (
err
 == -1

1128 ? 
NULL


1129 : (void *) (
err
 == 0 ? 
matched_ent
 : 
entry
));

1130 
	}
}

1137 
	$hash_delete
 (
Hash_table
 *
table
, const void *
entry
)

1139 void *
data
;

1140 struct 
hash_entry
 *
bucket
;

1142 
data
 = 
	`hash_find_entry
 (
table
, 
entry
, &
bucket
, 
true
);

1143 if (!
data
)

1144 return 
NULL
;

1146 
table
->
n_entries
--;

1147 if (!
bucket
->
data
)

1149 
table
->
n_buckets_used
--;

1154 if (
table
->
n_buckets_used


1155 < 
table
->
tuning
->
shrink_threshold
 * table->
n_buckets
)

1159 
	`check_tuning
 (
table
);

1160 if (
table
->
n_buckets_used


1161 < 
table
->
tuning
->
shrink_threshold
 * table->
n_buckets
)

1163 const 
Hash_tuning
 *
tuning
 = 
table
->tuning;

1164 
size_t
 
candidate
 =

1165 (
tuning
->
is_n_buckets


1166 ? 
table
->
n_buckets
 * 
tuning
->
shrink_factor


1167 : (
table
->
n_buckets
 * 
tuning
->
shrink_factor


1168 * 
tuning
->
growth_threshold
));

1170 if (!
	`hash_rehash
 (
table
, 
candidate
))

1177 #if ! 
USE_OBSTACK


1178 struct 
hash_entry
 *
cursor
 = 
table
->
free_entry_list
;

1179 struct 
hash_entry
 *
next
;

1180 while (
cursor
)

1182 
next
 = 
cursor
->next;

1183 
	`free
 (
cursor
);

1184 
cursor
 = 
next
;

1186 
table
->
free_entry_list
 = 
NULL
;

1193 return 
data
;

1194 
	}
}

1198 #if 
TESTING


1201 
	$hash_print
 (const 
Hash_table
 *
table
)

1203 struct 
hash_entry
 *
bucket
 = (struct hash_entry *) 
table
->bucket;

1205 for ( ; 
bucket
 < 
table
->
bucket_limit
; bucket++)

1207 struct 
hash_entry
 *
cursor
;

1209 if (
bucket
)

1210 
	`printf
 ("%lu:\n", (unsigned long int) (
bucket
 - 
table
->bucket));

1212 for (
cursor
 = 
bucket
; cursor; cursor = cursor->
next
)

1214 char const *
s
 = 
cursor
->
data
;

1216 if (
s
)

1217 
	`printf
 (" %s\n", 
s
);

1220 
	}
}

	@lib/hash.h

24 #ifndef 
HASH_H_


25 #define 
	#HASH_H_


	)

27 #include 
	~<stdio.h
>

28 #include 
	~<stdbool.h
>

32 #if 
__GNUC__
 > 3 || (__GNUC__ == 3 && 
__GNUC_MINOR__
 >= 4)

33 #define 
	#_GL_ATTRIBUTE_WUR
 
	`__attribute__
 ((
__warn_unused_result__
))

	)

35 #define 
	#_GL_ATTRIBUTE_WUR


	)

38 typedef 
	$size_t
 (*
	tHash_hasher
) (const void *, 
	tsize_t
);

39 typedef 
	$bool
 (*
	tHash_comparator
) (const void *, const void *);

40 typedef void (*
	tHash_data_freer
) (void *);

41 typedef 
	$bool
 (*
	tHash_processor
) (void *, void *);

43 struct 
	shash_tuning


48 float 
shrink_threshold
;

49 float 
shrink_factor
;

50 float 
growth_threshold
;

51 float 
growth_factor
;

52 
bool
 
is_n_buckets
;

55 typedef struct 
hash_tuning
 
	tHash_tuning
;

57 struct 
hash_table
;

59 typedef struct 
hash_table
 
	tHash_table
;

62 
size_t
 
	`hash_get_n_buckets
 (const 
Hash_table
 *);

63 
size_t
 
	`hash_get_n_buckets_used
 (const 
Hash_table
 *);

64 
size_t
 
	`hash_get_n_entries
 (const 
Hash_table
 *);

65 
size_t
 
	`hash_get_max_bucket_length
 (const 
Hash_table
 *);

66 
bool
 
	`hash_table_ok
 (const 
Hash_table
 *);

67 void 
	`hash_print_statistics
 (const 
Hash_table
 *, 
FILE
 *);

68 void *
	`hash_lookup
 (const 
Hash_table
 *, const void *);

71 void *
	`hash_get_first
 (const 
Hash_table
 *);

72 void *
	`hash_get_next
 (const 
Hash_table
 *, const void *);

73 
size_t
 
	`hash_get_entries
 (const 
Hash_table
 *, void **, size_t);

74 
size_t
 
	`hash_do_for_each
 (const 
Hash_table
 *, 
Hash_processor
, void *);

77 
size_t
 
	`hash_string
 (const char *, size_t);

78 void 
	`hash_reset_tuning
 (
Hash_tuning
 *);

79 
Hash_table
 *
	$hash_initialize
 (
size_t
, const 
Hash_tuning
 *,

80 
Hash_hasher
, 
Hash_comparator
,

81 
Hash_data_freer
) 
_GL_ATTRIBUTE_WUR
;

82 void 
	`hash_clear
 (
Hash_table
 *);

83 void 
	`hash_free
 (
Hash_table
 *);

86 
bool
 
	$hash_rehash
 (
Hash_table
 *, 
size_t
) 
_GL_ATTRIBUTE_WUR
;

87 void *
	$hash_insert
 (
Hash_table
 *, const void *) 
_GL_ATTRIBUTE_WUR
;

88 int 
	`hash_insert0
 (
Hash_table
 *
table
, const void *
entry
,

89 const void **
matched_ent
);

90 void *
	`hash_delete
 (
Hash_table
 *, const void *);

	@lib/iconv.c

20 #include 
	~<config.h
>

23 #include 
	~<iconv.h
>

25 #include 
	~<stddef.h
>

27 #if 
REPLACE_ICONV_UTF


28 #include 
	~<errno.h
>

29 #include 
	~<stdint.h
>

30 #include 
	~<stdlib.h
>

31 #include 
	~"unistr.h
"

32 #ifndef 
uintptr_t


33 #define 
	#uintptr_t
 unsigned long

	)

37 #if 
REPLACE_ICONV_UTF


42 #define 
	#RET_ILSEQ
 -1

	)

44 #define 
	#RET_TOOFEW
 -2

	)

47 #define 
	#RET_ILUNI
 -1

	)

49 #define 
	#RET_TOOSMALL
 -2

	)

58 
	$utf16be_mbtowc
 (
ucs4_t
 *
pwc
, const unsigned char *
s
, 
size_t
 
n
)

60 if (
n
 >= 2)

62 
ucs4_t
 
wc
 = (
s
[0] << 8) + s[1];

63 if (
wc
 >= 0xd800 && wc < 0xdc00)

65 if (
n
 >= 4)

67 
ucs4_t
 
wc2
 = (
s
[2] << 8) + s[3];

68 if (!(
wc2
 >= 0xdc00 && wc2 < 0xe000))

69 return 
RET_ILSEQ
;

70 *
pwc
 = 0x10000 + ((
wc
 - 0xd800) << 10) + (
wc2
 - 0xdc00);

74 else if (
wc
 >= 0xdc00 && wc < 0xe000)

76 return 
RET_ILSEQ
;

80 *
pwc
 = 
wc
;

84 return 
RET_TOOFEW
;

85 
	}
}

88 
	$utf16be_wctomb
 (unsigned char *
r
, 
ucs4_t
 
wc
, 
size_t
 
n
)

90 if (!(
wc
 >= 0xd800 && wc < 0xe000))

92 if (
wc
 < 0x10000)

94 if (
n
 >= 2)

96 
r
[0] = (unsigned char) (
wc
 >> 8);

97 
r
[1] = (unsigned char) 
wc
;

101 return 
RET_TOOSMALL
;

103 else if (
wc
 < 0x110000)

105 if (
n
 >= 4)

107 
ucs4_t
 
wc1
 = 0xd800 + ((
wc
 - 0x10000) >> 10);

108 
ucs4_t
 
wc2
 = 0xdc00 + ((
wc
 - 0x10000) & 0x3ff);

109 
r
[0] = (unsigned char) (
wc1
 >> 8);

110 
r
[1] = (unsigned char) 
wc1
;

111 
r
[2] = (unsigned char) (
wc2
 >> 8);

112 
r
[3] = (unsigned char) 
wc2
;

116 return 
RET_TOOSMALL
;

119 return 
RET_ILUNI
;

120 
	}
}

129 
	$utf16le_mbtowc
 (
ucs4_t
 *
pwc
, const unsigned char *
s
, 
size_t
 
n
)

131 if (
n
 >= 2)

133 
ucs4_t
 
wc
 = 
s
[0] + (s[1] << 8);

134 if (
wc
 >= 0xd800 && wc < 0xdc00)

136 if (
n
 >= 4)

138 
ucs4_t
 
wc2
 = 
s
[2] + (s[3] << 8);

139 if (!(
wc2
 >= 0xdc00 && wc2 < 0xe000))

140 return 
RET_ILSEQ
;

141 *
pwc
 = 0x10000 + ((
wc
 - 0xd800) << 10) + (
wc2
 - 0xdc00);

145 else if (
wc
 >= 0xdc00 && wc < 0xe000)

147 return 
RET_ILSEQ
;

151 *
pwc
 = 
wc
;

155 return 
RET_TOOFEW
;

156 
	}
}

159 
	$utf16le_wctomb
 (unsigned char *
r
, 
ucs4_t
 
wc
, 
size_t
 
n
)

161 if (!(
wc
 >= 0xd800 && wc < 0xe000))

163 if (
wc
 < 0x10000)

165 if (
n
 >= 2)

167 
r
[0] = (unsigned char) 
wc
;

168 
r
[1] = (unsigned char) (
wc
 >> 8);

172 return 
RET_TOOSMALL
;

174 else if (
wc
 < 0x110000)

176 if (
n
 >= 4)

178 
ucs4_t
 
wc1
 = 0xd800 + ((
wc
 - 0x10000) >> 10);

179 
ucs4_t
 
wc2
 = 0xdc00 + ((
wc
 - 0x10000) & 0x3ff);

180 
r
[0] = (unsigned char) 
wc1
;

181 
r
[1] = (unsigned char) (
wc1
 >> 8);

182 
r
[2] = (unsigned char) 
wc2
;

183 
r
[3] = (unsigned char) (
wc2
 >> 8);

187 return 
RET_TOOSMALL
;

190 return 
RET_ILUNI
;

191 
	}
}

200 
	$utf32be_mbtowc
 (
ucs4_t
 *
pwc
, const unsigned char *
s
, 
size_t
 
n
)

202 if (
n
 >= 4)

204 
ucs4_t
 
wc
 = (
s
[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];

205 if (
wc
 < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))

207 *
pwc
 = 
wc
;

211 return 
RET_ILSEQ
;

213 return 
RET_TOOFEW
;

214 
	}
}

217 
	$utf32be_wctomb
 (unsigned char *
r
, 
ucs4_t
 
wc
, 
size_t
 
n
)

219 if (
wc
 < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))

221 if (
n
 >= 4)

223 
r
[0] = 0;

224 
r
[1] = (unsigned char) (
wc
 >> 16);

225 
r
[2] = (unsigned char) (
wc
 >> 8);

226 
r
[3] = (unsigned char) 
wc
;

230 return 
RET_TOOSMALL
;

232 return 
RET_ILUNI
;

233 
	}
}

242 
	$utf32le_mbtowc
 (
ucs4_t
 *
pwc
, const unsigned char *
s
, 
size_t
 
n
)

244 if (
n
 >= 4)

246 
ucs4_t
 
wc
 = 
s
[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);

247 if (
wc
 < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))

249 *
pwc
 = 
wc
;

253 return 
RET_ILSEQ
;

255 return 
RET_TOOFEW
;

256 
	}
}

259 
	$utf32le_wctomb
 (unsigned char *
r
, 
ucs4_t
 
wc
, 
size_t
 
n
)

261 if (
wc
 < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))

263 if (
n
 >= 4)

265 
r
[0] = (unsigned char) 
wc
;

266 
r
[1] = (unsigned char) (
wc
 >> 8);

267 
r
[2] = (unsigned char) (
wc
 >> 16);

268 
r
[3] = 0;

272 return 
RET_TOOSMALL
;

274 return 
RET_ILUNI
;

275 
	}
}

279 
size_t


280 
	$rpl_iconv
 (
iconv_t
 
cd
,

281 
ICONV_CONST
 char **
inbuf
, 
size_t
 *
inbytesleft
,

282 char **
outbuf
, 
size_t
 *
outbytesleft
)

283 #undef 
iconv


285 #if 
REPLACE_ICONV_UTF


286 switch ((
uintptr_t
) 
cd
)

289 int (*
xxx_wctomb
) (unsigned char *, 
ucs4_t
, 
size_t
);

291 case (
uintptr_t
) 
_ICONV_UTF8_UTF16BE
:

292 
xxx_wctomb
 = 
utf16be_wctomb
;

293 goto 
loop_from_utf8
;

294 case (
uintptr_t
) 
_ICONV_UTF8_UTF16LE
:

295 
xxx_wctomb
 = 
utf16le_wctomb
;

296 goto 
loop_from_utf8
;

297 case (
uintptr_t
) 
_ICONV_UTF8_UTF32BE
:

298 
xxx_wctomb
 = 
utf32be_wctomb
;

299 goto 
loop_from_utf8
;

300 case (
uintptr_t
) 
_ICONV_UTF8_UTF32LE
:

301 
xxx_wctomb
 = 
utf32le_wctomb
;

302 goto 
loop_from_utf8
;

304 
loop_from_utf8
:

305 if (
inbuf
 == 
NULL
 || *inbuf == NULL)

308 
ICONV_CONST
 char *
inptr
 = *
inbuf
;

309 
size_t
 
inleft
 = *
inbytesleft
;

310 char *
outptr
 = *
outbuf
;

311 
size_t
 
outleft
 = *
outbytesleft
;

312 
size_t
 
res
 = 0;

313 while (
inleft
 > 0)

315 
ucs4_t
 
uc
;

316 int 
m
 = 
	`u8_mbtoucr
 (&
uc
, (const 
uint8_t
 *) 
inptr
, 
inleft
);

317 if (
m
 <= 0)

319 if (
m
 == -1)

321 
errno
 = 
EILSEQ
;

322 
res
 = (
size_t
)(-1);

325 if (
m
 == -2)

327 
errno
 = 
EINVAL
;

328 
res
 = (
size_t
)(-1);

331 
	`abort
 ();

335 int 
n
 = 
	`xxx_wctomb
 ((
uint8_t
 *) 
outptr
, 
uc
, 
outleft
);

336 if (
n
 < 0)

338 if (
n
 == 
RET_ILUNI
)

340 
errno
 = 
EILSEQ
;

341 
res
 = (
size_t
)(-1);

344 if (
n
 == 
RET_TOOSMALL
)

346 
errno
 = 
E2BIG
;

347 
res
 = (
size_t
)(-1);

350 
	`abort
 ();

354 
inptr
 += 
m
;

355 
inleft
 -= 
m
;

356 
outptr
 += 
n
;

357 
outleft
 -= 
n
;

361 *
inbuf
 = 
inptr
;

362 *
inbytesleft
 = 
inleft
;

363 *
outbuf
 = 
outptr
;

364 *
outbytesleft
 = 
outleft
;

365 return 
res
;

370 int (*
xxx_mbtowc
) (
ucs4_t
 *, const unsigned char *, 
size_t
);

372 case (
uintptr_t
) 
_ICONV_UTF16BE_UTF8
:

373 
xxx_mbtowc
 = 
utf16be_mbtowc
;

374 goto 
loop_to_utf8
;

375 case (
uintptr_t
) 
_ICONV_UTF16LE_UTF8
:

376 
xxx_mbtowc
 = 
utf16le_mbtowc
;

377 goto 
loop_to_utf8
;

378 case (
uintptr_t
) 
_ICONV_UTF32BE_UTF8
:

379 
xxx_mbtowc
 = 
utf32be_mbtowc
;

380 goto 
loop_to_utf8
;

381 case (
uintptr_t
) 
_ICONV_UTF32LE_UTF8
:

382 
xxx_mbtowc
 = 
utf32le_mbtowc
;

383 goto 
loop_to_utf8
;

385 
loop_to_utf8
:

386 if (
inbuf
 == 
NULL
 || *inbuf == NULL)

389 
ICONV_CONST
 char *
inptr
 = *
inbuf
;

390 
size_t
 
inleft
 = *
inbytesleft
;

391 char *
outptr
 = *
outbuf
;

392 
size_t
 
outleft
 = *
outbytesleft
;

393 
size_t
 
res
 = 0;

394 while (
inleft
 > 0)

396 
ucs4_t
 
uc
;

397 int 
m
 = 
	`xxx_mbtowc
 (&
uc
, (const 
uint8_t
 *) 
inptr
, 
inleft
);

398 if (
m
 <= 0)

400 if (
m
 == 
RET_ILSEQ
)

402 
errno
 = 
EILSEQ
;

403 
res
 = (
size_t
)(-1);

406 if (
m
 == 
RET_TOOFEW
)

408 
errno
 = 
EINVAL
;

409 
res
 = (
size_t
)(-1);

412 
	`abort
 ();

416 int 
n
 = 
	`u8_uctomb
 ((
uint8_t
 *) 
outptr
, 
uc
, 
outleft
);

417 if (
n
 < 0)

419 if (
n
 == -1)

421 
errno
 = 
EILSEQ
;

422 
res
 = (
size_t
)(-1);

425 if (
n
 == -2)

427 
errno
 = 
E2BIG
;

428 
res
 = (
size_t
)(-1);

431 
	`abort
 ();

435 
inptr
 += 
m
;

436 
inleft
 -= 
m
;

437 
outptr
 += 
n
;

438 
outleft
 -= 
n
;

442 *
inbuf
 = 
inptr
;

443 *
inbytesleft
 = 
inleft
;

444 *
outbuf
 = 
outptr
;

445 *
outbytesleft
 = 
outleft
;

446 return 
res
;

451 return 
	`iconv
 (
cd
, 
inbuf
, 
inbytesleft
, 
outbuf
, 
outbytesleft
);

452 
	}
}

	@lib/iconv.in.h

21 #ifndef 
_
@
GUARD_PREFIX
@
_ICONV_H


23 #if 
__GNUC__
 >= 3

24 @
	gPRAGMA_SYSTEM_HEADER
@

26 @
	gPRAGMA_COLUMNS
@

29 #@
INCLUDE_NEXT
@ @
NEXT_ICONV_H
@

31 #ifndef 
_
@
GUARD_PREFIX
@
_ICONV_H


32 #define 
	#_
@
GUARD_PREFIX
@
_ICONV_H


	)

41 #if @
GNULIB_ICONV
@

42 #if @
REPLACE_ICONV_OPEN
@

45 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

46 #define 
	#iconv_open
 
rpl_iconv_open


	)

48 
_GL_FUNCDECL_RPL
 (
iconv_open
, 
iconv_t
,

49 (const char *
tocode
, const char *
fromcode
)

50 
_GL_ARG_NONNULL
 ((1, 2)));

51 
_GL_CXXALIAS_RPL
 (
iconv_open
, 
iconv_t
,

52 (const char *
tocode
, const char *
fromcode
));

54 
_GL_CXXALIAS_SYS
 (
iconv_open
, 
iconv_t
,

55 (const char *
tocode
, const char *
fromcode
));

57 
_GL_CXXALIASWARN
 (
iconv_open
);

60 #if @
REPLACE_ICONV_UTF
@

63 #define 
	#_ICONV_UTF8_UTF16BE
 (
iconv_t
)(-161)

	)

64 #define 
	#_ICONV_UTF8_UTF16LE
 (
iconv_t
)(-162)

	)

65 #define 
	#_ICONV_UTF8_UTF32BE
 (
iconv_t
)(-163)

	)

66 #define 
	#_ICONV_UTF8_UTF32LE
 (
iconv_t
)(-164)

	)

67 #define 
	#_ICONV_UTF16BE_UTF8
 (
iconv_t
)(-165)

	)

68 #define 
	#_ICONV_UTF16LE_UTF8
 (
iconv_t
)(-166)

	)

69 #define 
	#_ICONV_UTF32BE_UTF8
 (
iconv_t
)(-167)

	)

70 #define 
	#_ICONV_UTF32LE_UTF8
 (
iconv_t
)(-168)

	)

73 #if @
GNULIB_ICONV
@

74 #if @
REPLACE_ICONV
@

75 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

76 #define 
	#iconv
 
rpl_iconv


	)

78 
_GL_FUNCDECL_RPL
 (
iconv
, 
size_t
,

79 (
iconv_t
 
cd
,

80 @
ICONV_CONST
@ char **
inbuf
, 
size_t
 *
inbytesleft
,

81 char **
outbuf
, 
size_t
 *
outbytesleft
));

82 
_GL_CXXALIAS_RPL
 (
iconv
, 
size_t
,

83 (
iconv_t
 
cd
,

84 @
ICONV_CONST
@ char **
inbuf
, 
size_t
 *
inbytesleft
,

85 char **
outbuf
, 
size_t
 *
outbytesleft
));

87 
_GL_CXXALIAS_SYS
 (
iconv
, 
size_t
,

88 (
iconv_t
 
cd
,

89 @
ICONV_CONST
@ char **
inbuf
, 
size_t
 *
inbytesleft
,

90 char **
outbuf
, 
size_t
 *
outbytesleft
));

92 
_GL_CXXALIASWARN
 (
iconv
);

93 #ifndef 
ICONV_CONST


94 #define 
	#ICONV_CONST
 @
ICONV_CONST
@

	)

98 #if @
GNULIB_ICONV
@

99 #if @
REPLACE_ICONV
@

100 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

101 #define 
	#iconv_close
 
rpl_iconv_close


	)

103 
_GL_FUNCDECL_RPL
 (
iconv_close
, int, (
iconv_t
 
cd
));

104 
_GL_CXXALIAS_RPL
 (
iconv_close
, int, (
iconv_t
 
cd
));

106 
_GL_CXXALIAS_SYS
 (
iconv_close
, int, (
iconv_t
 
cd
));

108 
_GL_CXXALIASWARN
 (
iconv_close
);

	@lib/iconv_close.c

20 #include 
	~<config.h
>

23 #include 
	~<iconv.h
>

25 #include 
	~<stdint.h
>

26 #ifndef 
uintptr_t


27 #define 
	#uintptr_t
 unsigned long

	)

31 
	$rpl_iconv_close
 (
iconv_t
 
cd
)

32 #undef 
iconv_close


34 #if 
REPLACE_ICONV_UTF


35 switch ((
uintptr_t
) 
cd
)

37 case (
uintptr_t
) 
_ICONV_UTF8_UTF16BE
:

38 case (
uintptr_t
) 
_ICONV_UTF8_UTF16LE
:

39 case (
uintptr_t
) 
_ICONV_UTF8_UTF32BE
:

40 case (
uintptr_t
) 
_ICONV_UTF8_UTF32LE
:

41 case (
uintptr_t
) 
_ICONV_UTF16BE_UTF8
:

42 case (
uintptr_t
) 
_ICONV_UTF16LE_UTF8
:

43 case (
uintptr_t
) 
_ICONV_UTF32BE_UTF8
:

44 case (
uintptr_t
) 
_ICONV_UTF32LE_UTF8
:

48 return 
	`iconv_close
 (
cd
);

49 
	}
}

	@lib/iconv_open-aix.h

33 struct 
	smapping
 { int 
standard_name
; const char 
	mvendor_name
[10 + 1]; };

35 #define 
	#TOTAL_KEYWORDS
 32

	)

36 #define 
	#MIN_WORD_LENGTH
 4

	)

37 #define 
	#MAX_WORD_LENGTH
 11

	)

38 #define 
	#MIN_HASH_VALUE
 6

	)

39 #define 
	#MAX_HASH_VALUE
 44

	)

42 #ifdef 
__GNUC__


43 
	g__inline


45 #ifdef 
__cplusplus


46 
	ginline


50 
	$mapping_hash
 (register const char *
str
, register unsigned int 
len
)

52 static const unsigned char 
asso_values
[] =

81 return 
len
 + 
asso_values
[(unsigned char)
str
[3]+2] + asso_values[(unsigned char)str[len - 1]];

82 
	}
}

84 struct 
	sstringpool_t


86 char 
	mstringpool_str6
[sizeof("EUC-TW")];

87 char 
	mstringpool_str7
[sizeof("EUC-KR")];

88 char 
	mstringpool_str8
[sizeof("CP852")];

89 char 
	mstringpool_str9
[sizeof("EUC-JP")];

90 char 
	mstringpool_str10
[sizeof("ISO-8859-2")];

91 char 
	mstringpool_str11
[sizeof("CP857")];

92 char 
	mstringpool_str12
[sizeof("CP850")];

93 char 
	mstringpool_str13
[sizeof("ISO-8859-7")];

94 char 
	mstringpool_str14
[sizeof("CP932")];

95 char 
	mstringpool_str15
[sizeof("GB2312")];

96 char 
	mstringpool_str16
[sizeof("BIG5")];

97 char 
	mstringpool_str17
[sizeof("CP437")];

98 char 
	mstringpool_str19
[sizeof("ISO-8859-5")];

99 char 
	mstringpool_str20
[sizeof("ISO-8859-15")];

100 char 
	mstringpool_str21
[sizeof("ISO-8859-3")];

101 char 
	mstringpool_str22
[sizeof("ISO-8859-13")];

102 char 
	mstringpool_str23
[sizeof("CP1046")];

103 char 
	mstringpool_str24
[sizeof("ISO-8859-8")];

104 char 
	mstringpool_str25
[sizeof("CP856")];

105 char 
	mstringpool_str26
[sizeof("CP1125")];

106 char 
	mstringpool_str27
[sizeof("ISO-8859-6")];

107 char 
	mstringpool_str28
[sizeof("CP865")];

108 char 
	mstringpool_str29
[sizeof("CP922")];

109 char 
	mstringpool_str30
[sizeof("CP1252")];

110 char 
	mstringpool_str31
[sizeof("ISO-8859-9")];

111 char 
	mstringpool_str33
[sizeof("CP943")];

112 char 
	mstringpool_str34
[sizeof("ISO-8859-4")];

113 char 
	mstringpool_str35
[sizeof("ISO-8859-1")];

114 char 
	mstringpool_str38
[sizeof("CP1129")];

115 char 
	mstringpool_str40
[sizeof("CP869")];

116 char 
	mstringpool_str41
[sizeof("CP1124")];

117 char 
	mstringpool_str44
[sizeof("CP861")];

119 static const struct 
stringpool_t
 
	gstringpool_contents
 =

154 #define 
	#stringpool
 ((const char *) &
stringpool_contents
)

	)

156 static const struct 
mapping
 
	gmappings
[] =

160 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str6
, "IBM-eucTW"},

162 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str7
, "IBM-eucKR"},

164 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str8
, "IBM-852"},

166 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str9
, "IBM-eucJP"},

168 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str10
, "ISO8859-2"},

170 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str11
, "IBM-857"},

172 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str12
, "IBM-850"},

174 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str13
, "ISO8859-7"},

176 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str14
, "IBM-932"},

178 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str15
, "IBM-eucCN"},

180 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str16
, "big5"},

182 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str17
, "IBM-437"},

185 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str19
, "ISO8859-5"},

187 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str20
, "ISO8859-15"},

189 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str21
, "ISO8859-3"},

191 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str22
, "IBM-921"},

193 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str23
, "IBM-1046"},

195 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str24
, "ISO8859-8"},

197 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str25
, "IBM-856"},

199 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str26
, "IBM-1125"},

201 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str27
, "ISO8859-6"},

203 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str28
, "IBM-865"},

205 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str29
, "IBM-922"},

207 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str30
, "IBM-1252"},

209 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str31
, "ISO8859-9"},

212 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str33
, "IBM-943"},

214 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str34
, "ISO8859-4"},

216 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str35
, "ISO8859-1"},

219 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str38
, "IBM-1129"},

222 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str40
, "IBM-869"},

224 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str41
, "IBM-1124"},

227 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str44
, "IBM-861"}

230 #ifdef 
__GNUC__


231 
	g__inline


232 #if 
defined
 
__GNUC_STDC_INLINE__
 || defined 
__GNUC_GNU_INLINE__


233 
__attribute__
 ((
__gnu_inline__
))

236 const struct 
mapping
 *

237 
	$mapping_lookup
 (register const char *
str
, register unsigned int 
len
)

239 if (
len
 <= 
MAX_WORD_LENGTH
 && len >= 
MIN_WORD_LENGTH
)

241 register int 
key
 = 
	`mapping_hash
 (
str
, 
len
);

243 if (
key
 <= 
MAX_HASH_VALUE
 && key >= 0)

245 register int 
o
 = 
mappings
[
key
].
standard_name
;

246 if (
o
 >= 0)

248 register const char *
s
 = 
o
 + 
stringpool
;

250 if (*
str
 == *
s
 && !
	`strcmp
 (str + 1, s + 1))

251 return &
mappings
[
key
];

256 
	}
}

	@lib/iconv_open-hpux.h

33 struct 
	smapping
 { int 
standard_name
; const char 
	mvendor_name
[9 + 1]; };

35 #define 
	#TOTAL_KEYWORDS
 44

	)

36 #define 
	#MIN_WORD_LENGTH
 4

	)

37 #define 
	#MAX_WORD_LENGTH
 11

	)

38 #define 
	#MIN_HASH_VALUE
 6

	)

39 #define 
	#MAX_HASH_VALUE
 49

	)

42 #ifdef 
__GNUC__


43 
	g__inline


45 #ifdef 
__cplusplus


46 
	ginline


50 
	$mapping_hash
 (register const char *
str
, register unsigned int 
len
)

52 static const unsigned char 
asso_values
[] =

81 return 
len
 + 
asso_values
[(unsigned char)
str
[3]+4] + asso_values[(unsigned char)str[len - 1]];

82 
	}
}

84 struct 
	sstringpool_t


86 char 
	mstringpool_str6
[sizeof("CP1256")];

87 char 
	mstringpool_str7
[sizeof("CP1250")];

88 char 
	mstringpool_str8
[sizeof("CP1251")];

89 char 
	mstringpool_str9
[sizeof("CP850")];

90 char 
	mstringpool_str10
[sizeof("TIS-620")];

91 char 
	mstringpool_str11
[sizeof("CP1254")];

92 char 
	mstringpool_str12
[sizeof("ISO-8859-6")];

93 char 
	mstringpool_str13
[sizeof("EUC-TW")];

94 char 
	mstringpool_str14
[sizeof("ISO-8859-1")];

95 char 
	mstringpool_str15
[sizeof("ISO-8859-9")];

96 char 
	mstringpool_str16
[sizeof("CP1255")];

97 char 
	mstringpool_str17
[sizeof("BIG5")];

98 char 
	mstringpool_str18
[sizeof("CP855")];

99 char 
	mstringpool_str19
[sizeof("CP1257")];

100 char 
	mstringpool_str20
[sizeof("EUC-KR")];

101 char 
	mstringpool_str21
[sizeof("CP857")];

102 char 
	mstringpool_str22
[sizeof("ISO-8859-5")];

103 char 
	mstringpool_str23
[sizeof("ISO-8859-15")];

104 char 
	mstringpool_str24
[sizeof("CP866")];

105 char 
	mstringpool_str25
[sizeof("ISO-8859-7")];

106 char 
	mstringpool_str26
[sizeof("CP861")];

107 char 
	mstringpool_str27
[sizeof("CP869")];

108 char 
	mstringpool_str28
[sizeof("CP874")];

109 char 
	mstringpool_str29
[sizeof("CP864")];

110 char 
	mstringpool_str30
[sizeof("CP1252")];

111 char 
	mstringpool_str31
[sizeof("CP437")];

112 char 
	mstringpool_str32
[sizeof("CP852")];

113 char 
	mstringpool_str33
[sizeof("CP775")];

114 char 
	mstringpool_str34
[sizeof("CP865")];

115 char 
	mstringpool_str35
[sizeof("EUC-JP")];

116 char 
	mstringpool_str36
[sizeof("ISO-8859-2")];

117 char 
	mstringpool_str37
[sizeof("SHIFT_JIS")];

118 char 
	mstringpool_str38
[sizeof("CP1258")];

119 char 
	mstringpool_str39
[sizeof("UTF-8")];

120 char 
	mstringpool_str40
[sizeof("HP-KANA8")];

121 char 
	mstringpool_str41
[sizeof("HP-ROMAN8")];

122 char 
	mstringpool_str42
[sizeof("HP-HEBREW8")];

123 char 
	mstringpool_str43
[sizeof("GB2312")];

124 char 
	mstringpool_str44
[sizeof("ISO-8859-8")];

125 char 
	mstringpool_str45
[sizeof("HP-TURKISH8")];

126 char 
	mstringpool_str46
[sizeof("HP-GREEK8")];

127 char 
	mstringpool_str47
[sizeof("HP-ARABIC8")];

128 char 
	mstringpool_str48
[sizeof("CP862")];

129 char 
	mstringpool_str49
[sizeof("CP1253")];

131 static const struct 
stringpool_t
 
	gstringpool_contents
 =

178 #define 
	#stringpool
 ((const char *) &
stringpool_contents
)

	)

180 static const struct 
mapping
 
	gmappings
[] =

184 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str6
, "cp1256"},

186 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str7
, "cp1250"},

188 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str8
, "cp1251"},

190 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str9
, "cp850"},

192 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str10
, "tis620"},

194 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str11
, "cp1254"},

196 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str12
, "iso88596"},

198 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str13
, "eucTW"},

200 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str14
, "iso88591"},

202 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str15
, "iso88599"},

204 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str16
, "cp1255"},

206 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str17
, "big5"},

208 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str18
, "cp855"},

210 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str19
, "cp1257"},

212 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str20
, "eucKR"},

214 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str21
, "cp857"},

216 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str22
, "iso88595"},

218 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str23
, "iso885915"},

220 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str24
, "cp866"},

222 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str25
, "iso88597"},

224 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str26
, "cp861"},

226 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str27
, "cp869"},

228 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str28
, "cp874"},

230 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str29
, "cp864"},

232 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str30
, "cp1252"},

234 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str31
, "cp437"},

236 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str32
, "cp852"},

238 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str33
, "cp775"},

240 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str34
, "cp865"},

242 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str35
, "eucJP"},

244 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str36
, "iso88592"},

246 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str37
, "sjis"},

248 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str38
, "cp1258"},

250 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str39
, "utf8"},

252 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str40
, "kana8"},

254 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str41
, "roman8"},

256 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str42
, "hebrew8"},

258 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str43
, "hp15CN"},

260 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str44
, "iso88598"},

262 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str45
, "turkish8"},

264 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str46
, "greek8"},

266 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str47
, "arabic8"},

268 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str48
, "cp862"},

270 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str49
, "cp1253"}

273 #ifdef 
__GNUC__


274 
	g__inline


275 #if 
defined
 
__GNUC_STDC_INLINE__
 || defined 
__GNUC_GNU_INLINE__


276 
__attribute__
 ((
__gnu_inline__
))

279 const struct 
mapping
 *

280 
	$mapping_lookup
 (register const char *
str
, register unsigned int 
len
)

282 if (
len
 <= 
MAX_WORD_LENGTH
 && len >= 
MIN_WORD_LENGTH
)

284 register int 
key
 = 
	`mapping_hash
 (
str
, 
len
);

286 if (
key
 <= 
MAX_HASH_VALUE
 && key >= 0)

288 register int 
o
 = 
mappings
[
key
].
standard_name
;

289 if (
o
 >= 0)

291 register const char *
s
 = 
o
 + 
stringpool
;

293 if (*
str
 == *
s
 && !
	`strcmp
 (str + 1, s + 1))

294 return &
mappings
[
key
];

299 
	}
}

	@lib/iconv_open-irix.h

33 struct 
	smapping
 { int 
standard_name
; const char 
	mvendor_name
[10 + 1]; };

35 #define 
	#TOTAL_KEYWORDS
 19

	)

36 #define 
	#MIN_WORD_LENGTH
 5

	)

37 #define 
	#MAX_WORD_LENGTH
 11

	)

38 #define 
	#MIN_HASH_VALUE
 5

	)

39 #define 
	#MAX_HASH_VALUE
 23

	)

42 #ifdef 
__GNUC__


43 
	g__inline


45 #ifdef 
__cplusplus


46 
	ginline


50 
	$mapping_hash
 (register const char *
str
, register unsigned int 
len
)

52 static const unsigned char 
asso_values
[] =

81 return 
len
 + 
asso_values
[(unsigned char)
str
[len - 1]] + asso_values[(unsigned char)str[0]];

82 
	}
}

84 struct 
	sstringpool_t


86 char 
	mstringpool_str5
[sizeof("CP855")];

87 char 
	mstringpool_str6
[sizeof("EUC-TW")];

88 char 
	mstringpool_str7
[sizeof("EUC-KR")];

89 char 
	mstringpool_str8
[sizeof("CP1251")];

90 char 
	mstringpool_str9
[sizeof("SHIFT_JIS")];

91 char 
	mstringpool_str10
[sizeof("ISO-8859-5")];

92 char 
	mstringpool_str11
[sizeof("ISO-8859-15")];

93 char 
	mstringpool_str12
[sizeof("ISO-8859-1")];

94 char 
	mstringpool_str13
[sizeof("EUC-JP")];

95 char 
	mstringpool_str14
[sizeof("KOI8-R")];

96 char 
	mstringpool_str15
[sizeof("ISO-8859-2")];

97 char 
	mstringpool_str16
[sizeof("GB2312")];

98 char 
	mstringpool_str17
[sizeof("ISO-8859-9")];

99 char 
	mstringpool_str18
[sizeof("ISO-8859-8")];

100 char 
	mstringpool_str19
[sizeof("ISO-8859-7")];

101 char 
	mstringpool_str20
[sizeof("ISO-8859-6")];

102 char 
	mstringpool_str21
[sizeof("ISO-8859-4")];

103 char 
	mstringpool_str22
[sizeof("ISO-8859-3")];

104 char 
	mstringpool_str23
[sizeof("TIS-620")];

106 static const struct 
stringpool_t
 
	gstringpool_contents
 =

128 #define 
	#stringpool
 ((const char *) &
stringpool_contents
)

	)

130 static const struct 
mapping
 
	gmappings
[] =

134 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str5
, "DOS855"},

136 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str6
, "eucTW"},

138 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str7
, "eucKR"},

140 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str8
, "WIN1251"},

142 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str9
, "sjis"},

144 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str10
, "ISO8859-5"},

146 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str11
, "ISO8859-15"},

148 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str12
, "ISO8859-1"},

150 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str13
, "eucJP"},

152 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str14
, "KOI8"},

154 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str15
, "ISO8859-2"},

156 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str16
, "eucCN"},

158 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str17
, "ISO8859-9"},

160 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str18
, "ISO8859-8"},

162 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str19
, "ISO8859-7"},

164 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str20
, "ISO8859-6"},

166 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str21
, "ISO8859-4"},

168 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str22
, "ISO8859-3"},

170 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str23
, "TIS620"}

173 #ifdef 
__GNUC__


174 
	g__inline


175 #if 
defined
 
__GNUC_STDC_INLINE__
 || defined 
__GNUC_GNU_INLINE__


176 
__attribute__
 ((
__gnu_inline__
))

179 const struct 
mapping
 *

180 
	$mapping_lookup
 (register const char *
str
, register unsigned int 
len
)

182 if (
len
 <= 
MAX_WORD_LENGTH
 && len >= 
MIN_WORD_LENGTH
)

184 register int 
key
 = 
	`mapping_hash
 (
str
, 
len
);

186 if (
key
 <= 
MAX_HASH_VALUE
 && key >= 0)

188 register int 
o
 = 
mappings
[
key
].
standard_name
;

189 if (
o
 >= 0)

191 register const char *
s
 = 
o
 + 
stringpool
;

193 if (*
str
 == *
s
 && !
	`strcmp
 (str + 1, s + 1))

194 return &
mappings
[
key
];

199 
	}
}

	@lib/iconv_open-osf.h

33 struct 
	smapping
 { int 
standard_name
; const char 
	mvendor_name
[10 + 1]; };

35 #define 
	#TOTAL_KEYWORDS
 38

	)

36 #define 
	#MIN_WORD_LENGTH
 4

	)

37 #define 
	#MAX_WORD_LENGTH
 11

	)

38 #define 
	#MIN_HASH_VALUE
 6

	)

39 #define 
	#MAX_HASH_VALUE
 47

	)

42 #ifdef 
__GNUC__


43 
	g__inline


45 #ifdef 
__cplusplus


46 
	ginline


50 
	$mapping_hash
 (register const char *
str
, register unsigned int 
len
)

52 static const unsigned char 
asso_values
[] =

81 return 
len
 + 
asso_values
[(unsigned char)
str
[3]+3] + asso_values[(unsigned char)str[len - 1]];

82 
	}
}

84 struct 
	sstringpool_t


86 char 
	mstringpool_str6
[sizeof("CP1255")];

87 char 
	mstringpool_str7
[sizeof("CP775")];

88 char 
	mstringpool_str8
[sizeof("CP1250")];

89 char 
	mstringpool_str9
[sizeof("EUC-TW")];

90 char 
	mstringpool_str10
[sizeof("EUC-KR")];

91 char 
	mstringpool_str11
[sizeof("TIS-620")];

92 char 
	mstringpool_str12
[sizeof("ISO-8859-5")];

93 char 
	mstringpool_str13
[sizeof("ISO-8859-15")];

94 char 
	mstringpool_str14
[sizeof("BIG5")];

95 char 
	mstringpool_str15
[sizeof("CP855")];

96 char 
	mstringpool_str16
[sizeof("CP1258")];

97 char 
	mstringpool_str17
[sizeof("CP850")];

98 char 
	mstringpool_str18
[sizeof("CP865")];

99 char 
	mstringpool_str19
[sizeof("EUC-JP")];

100 char 
	mstringpool_str20
[sizeof("CP1257")];

101 char 
	mstringpool_str21
[sizeof("CP1256")];

102 char 
	mstringpool_str22
[sizeof("ISO-8859-8")];

103 char 
	mstringpool_str23
[sizeof("SHIFT_JIS")];

104 char 
	mstringpool_str25
[sizeof("ISO-8859-9")];

105 char 
	mstringpool_str26
[sizeof("ISO-8859-7")];

106 char 
	mstringpool_str27
[sizeof("ISO-8859-6")];

107 char 
	mstringpool_str29
[sizeof("CP857")];

108 char 
	mstringpool_str30
[sizeof("CP1252")];

109 char 
	mstringpool_str31
[sizeof("CP869")];

110 char 
	mstringpool_str32
[sizeof("CP949")];

111 char 
	mstringpool_str33
[sizeof("CP866")];

112 char 
	mstringpool_str34
[sizeof("CP437")];

113 char 
	mstringpool_str35
[sizeof("CP1251")];

114 char 
	mstringpool_str36
[sizeof("ISO-8859-2")];

115 char 
	mstringpool_str37
[sizeof("CP1254")];

116 char 
	mstringpool_str38
[sizeof("CP874")];

117 char 
	mstringpool_str39
[sizeof("CP852")];

118 char 
	mstringpool_str40
[sizeof("CP1253")];

119 char 
	mstringpool_str41
[sizeof("ISO-8859-1")];

120 char 
	mstringpool_str42
[sizeof("CP862")];

121 char 
	mstringpool_str43
[sizeof("ISO-8859-4")];

122 char 
	mstringpool_str46
[sizeof("ISO-8859-3")];

123 char 
	mstringpool_str47
[sizeof("CP861")];

125 static const struct 
stringpool_t
 
	gstringpool_contents
 =

166 #define 
	#stringpool
 ((const char *) &
stringpool_contents
)

	)

168 static const struct 
mapping
 
	gmappings
[] =

172 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str6
, "cp1255"},

174 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str7
, "cp775"},

176 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str8
, "cp1250"},

178 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str9
, "eucTW"},

180 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str10
, "eucKR"},

182 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str11
, "TACTIS"},

184 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str12
, "ISO8859-5"},

186 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str13
, "ISO8859-15"},

188 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str14
, "big5"},

190 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str15
, "cp855"},

192 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str16
, "cp1258"},

194 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str17
, "cp850"},

196 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str18
, "cp865"},

198 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str19
, "eucJP"},

200 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str20
, "cp1257"},

202 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str21
, "cp1256"},

204 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str22
, "ISO8859-8"},

206 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str23
, "SJIS"},

209 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str25
, "ISO8859-9"},

211 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str26
, "ISO8859-7"},

213 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str27
, "ISO8859-6"},

216 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str29
, "cp857"},

218 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str30
, "cp1252"},

220 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str31
, "cp869"},

222 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str32
, "KSC5601"},

224 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str33
, "cp866"},

226 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str34
, "cp437"},

228 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str35
, "cp1251"},

230 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str36
, "ISO8859-2"},

232 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str37
, "cp1254"},

234 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str38
, "cp874"},

236 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str39
, "cp852"},

238 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str40
, "cp1253"},

240 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str41
, "ISO8859-1"},

242 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str42
, "cp862"},

244 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str43
, "ISO8859-4"},

247 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str46
, "ISO8859-3"},

249 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str47
, "cp861"}

252 #ifdef 
__GNUC__


253 
	g__inline


254 #if 
defined
 
__GNUC_STDC_INLINE__
 || defined 
__GNUC_GNU_INLINE__


255 
__attribute__
 ((
__gnu_inline__
))

258 const struct 
mapping
 *

259 
	$mapping_lookup
 (register const char *
str
, register unsigned int 
len
)

261 if (
len
 <= 
MAX_WORD_LENGTH
 && len >= 
MIN_WORD_LENGTH
)

263 register int 
key
 = 
	`mapping_hash
 (
str
, 
len
);

265 if (
key
 <= 
MAX_HASH_VALUE
 && key >= 0)

267 register int 
o
 = 
mappings
[
key
].
standard_name
;

268 if (
o
 >= 0)

270 register const char *
s
 = 
o
 + 
stringpool
;

272 if (*
str
 == *
s
 && !
	`strcmp
 (str + 1, s + 1))

273 return &
mappings
[
key
];

278 
	}
}

	@lib/iconv_open-solaris.h

33 struct 
	smapping
 { int 
standard_name
; const char 
	mvendor_name
[10 + 1]; };

35 #define 
	#TOTAL_KEYWORDS
 13

	)

36 #define 
	#MIN_WORD_LENGTH
 5

	)

37 #define 
	#MAX_WORD_LENGTH
 11

	)

38 #define 
	#MIN_HASH_VALUE
 5

	)

39 #define 
	#MAX_HASH_VALUE
 19

	)

42 #ifdef 
__GNUC__


43 
	g__inline


45 #ifdef 
__cplusplus


46 
	ginline


50 
	$mapping_hash
 (register const char *
str
, register unsigned int 
len
)

52 static const unsigned char 
asso_values
[] =

81 register int 
hval
 = 
len
;

83 switch (
hval
)

86 
hval
 += 
asso_values
[(unsigned char)
str
[9]];

95 return 
hval
;

96 
	}
}

98 struct 
	sstringpool_t


100 char 
	mstringpool_str5
[sizeof("ASCII")];

101 char 
	mstringpool_str6
[sizeof("CP1251")];

102 char 
	mstringpool_str7
[sizeof("$ abc")];

103 char 
	mstringpool_str10
[sizeof("ISO-8859-1")];

104 char 
	mstringpool_str11
[sizeof("ISO-8859-15")];

105 char 
	mstringpool_str12
[sizeof("ISO-8859-9")];

106 char 
	mstringpool_str13
[sizeof("ISO-8859-8")];

107 char 
	mstringpool_str14
[sizeof("ISO-8859-7")];

108 char 
	mstringpool_str15
[sizeof("ISO-8859-6")];

109 char 
	mstringpool_str16
[sizeof("ISO-8859-5")];

110 char 
	mstringpool_str17
[sizeof("ISO-8859-4")];

111 char 
	mstringpool_str18
[sizeof("ISO-8859-3")];

112 char 
	mstringpool_str19
[sizeof("ISO-8859-2")];

114 static const struct 
stringpool_t
 
	gstringpool_contents
 =

130 #define 
	#stringpool
 ((const char *) &
stringpool_contents
)

	)

132 static const struct 
mapping
 
	gmappings
[] =

136 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str5
, "646"},

138 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str6
, "ansi-1251"},

140 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str7
},

143 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str10
, "ISO8859-1"},

145 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str11
, "ISO8859-15"},

147 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str12
, "ISO8859-9"},

149 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str13
, "ISO8859-8"},

151 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str14
, "ISO8859-7"},

153 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str15
, "ISO8859-6"},

155 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str16
, "ISO8859-5"},

157 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str17
, "ISO8859-4"},

159 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str18
, "ISO8859-3"},

161 {(int)(long)&((struct 
stringpool_t
 *)0)->
stringpool_str19
, "ISO8859-2"}

164 #ifdef 
__GNUC__


165 
	g__inline


166 #if 
defined
 
__GNUC_STDC_INLINE__
 || defined 
__GNUC_GNU_INLINE__


167 
__attribute__
 ((
__gnu_inline__
))

170 const struct 
mapping
 *

171 
	$mapping_lookup
 (register const char *
str
, register unsigned int 
len
)

173 if (
len
 <= 
MAX_WORD_LENGTH
 && len >= 
MIN_WORD_LENGTH
)

175 register int 
key
 = 
	`mapping_hash
 (
str
, 
len
);

177 if (
key
 <= 
MAX_HASH_VALUE
 && key >= 0)

179 register int 
o
 = 
mappings
[
key
].
standard_name
;

180 if (
o
 >= 0)

182 register const char *
s
 = 
o
 + 
stringpool
;

184 if (*
str
 == *
s
 && !
	`strcmp
 (str + 1, s + 1))

185 return &
mappings
[
key
];

190 
	}
}

	@lib/iconv_open.c

20 #include 
	~<config.h
>

23 #include 
	~<iconv.h
>

25 #include 
	~<errno.h
>

26 #include 
	~<string.h
>

27 #include 
	~"c-ctype.h
"

28 #include 
	~"c-strcase.h
"

30 #define 
	#SIZEOF
(
a
) (sizeof(a) / sizeof(a[0]))

	)

33 #define 
	#mapping_lookup
 
rpl_iconv_open_mapping_lookup


	)

37 #define 
	#ICONV_FLAVOR_AIX
 "iconv_open-aix.h"

	)

38 #define 
	#ICONV_FLAVOR_HPUX
 "iconv_open-hpux.h"

	)

39 #define 
	#ICONV_FLAVOR_IRIX
 "iconv_open-irix.h"

	)

40 #define 
	#ICONV_FLAVOR_OSF
 "iconv_open-osf.h"

	)

41 #define 
	#ICONV_FLAVOR_SOLARIS
 "iconv_open-solaris.h"

	)

43 #ifdef 
ICONV_FLAVOR


44 #include 
ICONV_FLAVOR


47 
iconv_t


48 
	$rpl_iconv_open
 (const char *
tocode
, const char *
fromcode
)

49 #undef 
iconv_open


51 char 
fromcode_upper
[32];

52 char 
tocode_upper
[32];

53 char *
fromcode_upper_end
;

54 char *
tocode_upper_end
;

56 #if 
REPLACE_ICONV_UTF


66 if (
	`c_toupper
 (
fromcode
[0]) == 'U'

67 && 
	`c_toupper
 (
fromcode
[1]) == 'T'

68 && 
	`c_toupper
 (
fromcode
[2]) == 'F'

69 && 
fromcode
[3] == '-')

71 if (
	`c_toupper
 (
tocode
[0]) == 'U'

72 && 
	`c_toupper
 (
tocode
[1]) == 'T'

73 && 
	`c_toupper
 (
tocode
[2]) == 'F'

74 && 
tocode
[3] == '-')

76 if (
	`strcmp
 (
fromcode
 + 4, "8") == 0)

78 if (
	`c_strcasecmp
 (
tocode
 + 4, "16BE") == 0)

79 return 
_ICONV_UTF8_UTF16BE
;

80 if (
	`c_strcasecmp
 (
tocode
 + 4, "16LE") == 0)

81 return 
_ICONV_UTF8_UTF16LE
;

82 if (
	`c_strcasecmp
 (
tocode
 + 4, "32BE") == 0)

83 return 
_ICONV_UTF8_UTF32BE
;

84 if (
	`c_strcasecmp
 (
tocode
 + 4, "32LE") == 0)

85 return 
_ICONV_UTF8_UTF32LE
;

87 else if (
	`strcmp
 (
tocode
 + 4, "8") == 0)

89 if (
	`c_strcasecmp
 (
fromcode
 + 4, "16BE") == 0)

90 return 
_ICONV_UTF16BE_UTF8
;

91 if (
	`c_strcasecmp
 (
fromcode
 + 4, "16LE") == 0)

92 return 
_ICONV_UTF16LE_UTF8
;

93 if (
	`c_strcasecmp
 (
fromcode
 + 4, "32BE") == 0)

94 return 
_ICONV_UTF32BE_UTF8
;

95 if (
	`c_strcasecmp
 (
fromcode
 + 4, "32LE") == 0)

96 return 
_ICONV_UTF32LE_UTF8
;

114 
iconv_t
 
cd
 = 
	`iconv_open
 (
tocode
, 
fromcode
);

115 if (
cd
 != (
iconv_t
)(-1))

116 return 
cd
;

124 const char *
p
 = 
fromcode
;

125 char *
q
 = 
fromcode_upper
;

126 while ((*
q
 = 
	`c_toupper
 (*
p
)) != '\0')

128 
p
++;

129 
q
++;

130 if (
q
 == &
fromcode_upper
[
	`SIZEOF
 (fromcode_upper)])

132 
errno
 = 
EINVAL
;

133 return (
iconv_t
)(-1);

136 
fromcode_upper_end
 = 
q
;

140 const char *
p
 = 
tocode
;

141 char *
q
 = 
tocode_upper
;

142 while ((*
q
 = 
	`c_toupper
 (*
p
)) != '\0')

144 
p
++;

145 
q
++;

146 if (
q
 == &
tocode_upper
[
	`SIZEOF
 (tocode_upper)])

148 
errno
 = 
EINVAL
;

149 return (
iconv_t
)(-1);

152 
tocode_upper_end
 = 
q
;

155 #ifdef 
ICONV_FLAVOR


158 const struct 
mapping
 *
m
 =

159 
	`mapping_lookup
 (
fromcode_upper
, 
fromcode_upper_end
 - fromcode_upper);

161 
fromcode
 = (
m
 != 
NULL
 ? m->
vendor_name
 : 
fromcode_upper
);

164 const struct 
mapping
 *
m
 =

165 
	`mapping_lookup
 (
tocode_upper
, 
tocode_upper_end
 - tocode_upper);

167 
tocode
 = (
m
 != 
NULL
 ? m->
vendor_name
 : 
tocode_upper
);

170 
fromcode
 = 
fromcode_upper
;

171 
tocode
 = 
tocode_upper
;

174 return 
	`iconv_open
 (
tocode
, 
fromcode
);

175 
	}
}

	@lib/ignore-value.h

35 #ifndef 
_GL_IGNORE_VALUE_H


36 #define 
	#_GL_IGNORE_VALUE_H


	)

38 #ifndef 
_GL_ATTRIBUTE_DEPRECATED


41 #if 
__GNUC__
 < 3 || (__GNUC__ == 3 && 
__GNUC_MINOR__
 < 1)

42 #define 
	#_GL_ATTRIBUTE_DEPRECATED


	)

44 #define 
	#_GL_ATTRIBUTE_DEPRECATED
 
	`__attribute__
 ((
__deprecated__
))

	)

51 #if 
__GNUC__
 < 3 || (__GNUC__ == 3 && 
__GNUC_MINOR__
 < 4)

52 #define 
	#ignore_value
(
x
) ((void) (x))

	)

54 #define 
	#ignore_value
(
x
) (({ 
	`__typeof__
 (x) 
__x
 = (x); (void) __x; }))

	)

59 static 
inline
 void 
_GL_ATTRIBUTE_DEPRECATED


60 
	$ignore_ptr
 (void *
p
) { (void) p; 
	}
}

	@lib/intprops.h

20 #ifndef 
_GL_INTPROPS_H


21 #define 
	#_GL_INTPROPS_H


	)

23 #include 
	~<limits.h
>

27 #define 
	#_GL_INT_CONVERT
(
e
, 
v
) (0 * (e) + (v))

	)

31 #define 
	#_GL_INT_NEGATE_CONVERT
(
e
, 
v
) (0 * (e) - (v))

	)

38 #define 
	#TYPE_IS_INTEGER
(
t
) ((t) 1.5 == 1)

	)

44 #define 
	#TYPE_TWOS_COMPLEMENT
(
t
) ((t) ~ (t) 0 == (t) -1)

	)

45 #define 
	#TYPE_ONES_COMPLEMENT
(
t
) ((t) ~ (t) 0 == 0)

	)

46 #define 
	#TYPE_SIGNED_MAGNITUDE
(
t
) ((t) ~ (t) 0 < (t) -1)

	)

49 #define 
	#_GL_INT_TWOS_COMPLEMENT
(
e
) (~ 
	`_GL_INT_CONVERT
 (e, 0) == -1)

	)

52 #define 
	#TYPE_SIGNED
(
t
) (! ((t) 0 < (t) -1))

	)

56 #define 
	#_GL_INT_SIGNED
(
e
) (
	`_GL_INT_NEGATE_CONVERT
 (e, 1) < 0)

	)

65 #define 
	#TYPE_MINIMUM
(
t
) \

66 ((
t
) (! 
	`TYPE_SIGNED
 (t) \

67 ? (
t
) 0 \

68 : 
	`TYPE_SIGNED_MAGNITUDE
 (
t
) \

69 ? ~ (
t
) 0 \

70 : ~ 
	`TYPE_MAXIMUM
 (
t
)))

	)

71 #define 
	#TYPE_MAXIMUM
(
t
) \

72 ((
t
) (! 
	`TYPE_SIGNED
 (t) \

73 ? (
t
) -1 \

74 : ((((
t
) 1 << (sizeof (t) * 
CHAR_BIT
 - 2)) - 1) * 2 + 1)))

	)

78 #define 
	#_GL_INT_MINIMUM
(
e
) \

79 (
	`_GL_INT_SIGNED
 (
e
) \

80 ? - 
	`_GL_INT_TWOS_COMPLEMENT
 (
e
) - 
	`_GL_SIGNED_INT_MAXIMUM
 (e) \

81 : 
	`_GL_INT_CONVERT
 (
e
, 0))

	)

82 #define 
	#_GL_INT_MAXIMUM
(
e
) \

83 (
	`_GL_INT_SIGNED
 (
e
) \

84 ? 
	`_GL_SIGNED_INT_MAXIMUM
 (
e
) \

85 : 
	`_GL_INT_NEGATE_CONVERT
 (
e
, 1))

	)

86 #define 
	#_GL_SIGNED_INT_MAXIMUM
(
e
) \

87 (((
	`_GL_INT_CONVERT
 (
e
, 1) << (sizeof ((e) + 0) * 
CHAR_BIT
 - 2)) - 1) * 2 + 1)

	)

92 #if 2 <= 
__GNUC__
 || 0x5110 <= 
__SUNPRO_C


93 #define 
	#_GL_HAVE___TYPEOF__
 1

	)

95 #define 
	#_GL_HAVE___TYPEOF__
 0

	)

101 #if 
_GL_HAVE___TYPEOF__


102 #define 
	#_GL_SIGNED_TYPE_OR_EXPR
(
t
) 
	`TYPE_SIGNED
 (
	`__typeof__
 (t))

	)

104 #define 
	#_GL_SIGNED_TYPE_OR_EXPR
(
t
) 1

	)

110 #define 
	#INT_BITS_STRLEN_BOUND
(
b
) (((b) * 146 + 484) / 485)

	)

119 #define 
	#INT_STRLEN_BOUND
(
t
) \

120 (
	`INT_BITS_STRLEN_BOUND
 (sizeof (
t
) * 
CHAR_BIT
 \

121 - 
	`_GL_SIGNED_TYPE_OR_EXPR
 (
t
)) \

122 + 
	`_GL_SIGNED_TYPE_OR_EXPR
 (
t
))

	)

126 #define 
	#INT_BUFSIZE_BOUND
(
t
) (
	`INT_STRLEN_BOUND
 (t) + 1)

	)

165 #define 
	#INT_ADD_RANGE_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

166 ((
b
) < 0 \

167 ? (
a
) < (
min
) - (
b
) \

168 : (
max
) - (
b
) < (
a
))

	)

172 #define 
	#INT_SUBTRACT_RANGE_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

173 ((
b
) < 0 \

174 ? (
max
) + (
b
) < (
a
) \

175 : (
a
) < (
min
) + (
b
))

	)

179 #define 
	#INT_NEGATE_RANGE_OVERFLOW
(
a
, 
min
, 
max
) \

180 ((
min
) < 0 \

181 ? (
a
) < - (
max
) \

182 : 0 < (
a
))

	)

188 #define 
	#INT_MULTIPLY_RANGE_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

189 ((
b
) < 0 \

190 ? ((
a
) < 0 \

191 ? (
a
) < (
max
) / (
b
) \

192 : (
b
) == -1 \

194 : (
min
) / (
b
) < (
a
)) \

195 : (
b
) == 0 \

197 : ((
a
) < 0 \

198 ? (
a
) < (
min
) / (
b
) \

199 : (
max
) / (
b
) < (
a
)))

	)

203 #define 
	#INT_DIVIDE_RANGE_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

204 ((
min
) < 0 && (
b
) == -1 && (
a
) < - (
max
))

	)

211 #define 
	#INT_REMAINDER_RANGE_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

212 
	`INT_DIVIDE_RANGE_OVERFLOW
 (
a
, 
b
, 
min
, 
max
)

	)

221 #define 
	#INT_LEFT_SHIFT_RANGE_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

222 ((
a
) < 0 \

223 ? (
a
) < (
min
) >> (
b
) \

224 : (
max
) >> (
b
) < (
a
))

	)

231 #define 
	#_GL_ADD_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

232 ((
min
) < 0 ? 
	`INT_ADD_RANGE_OVERFLOW
 (
a
, 
b
, min, 
max
) \

233 : (
a
) < 0 ? (
b
) <= (a) + (b) \

234 : (
b
) < 0 ? (
a
) <= (a) + (b) \

235 : (
a
) + (
b
) < (b))

	)

236 #define 
	#_GL_SUBTRACT_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

237 ((
min
) < 0 ? 
	`INT_SUBTRACT_RANGE_OVERFLOW
 (
a
, 
b
, min, 
max
) \

238 : (
a
) < 0 ? 1 \

239 : (
b
) < 0 ? (
a
) - (b) <= (a) \

240 : (
a
) < (
b
))

	)

241 #define 
	#_GL_MULTIPLY_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

242 (((
min
) == 0 && (((
a
) < 0 && 0 < (
b
)) || ((b) < 0 && 0 < (a)))) \

243 || 
	`INT_MULTIPLY_RANGE_OVERFLOW
 (
a
, 
b
, 
min
, 
max
))

	)

244 #define 
	#_GL_DIVIDE_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

245 ((
min
) < 0 ? (
b
) == 
	`_GL_INT_NEGATE_CONVERT
 (min, 1) && (
a
) < - (
max
) \

246 : (
a
) < 0 ? (
b
) <= (a) + (b) - 1 \

247 : (
b
) < 0 && (
a
) + (b) <= (a))

	)

248 #define 
	#_GL_REMAINDER_OVERFLOW
(
a
, 
b
, 
min
, 
max
) \

249 ((
min
) < 0 ? (
b
) == 
	`_GL_INT_NEGATE_CONVERT
 (min, 1) && (
a
) < - (
max
) \

250 : (
a
) < 0 ? (a) % (
b
) != ((
max
) - (b) + 1) % (b) \

251 : (
b
) < 0 && ! 
	`_GL_UNSIGNED_NEG_MULTIPLE
 (
a
, b, 
max
))

	)

257 #define 
	#_GL_UNSIGNED_NEG_MULTIPLE
(
a
, 
b
, 
max
) \

258 (((
b
) < -
	`_GL_SIGNED_INT_MAXIMUM
 (b) \

259 ? (
	`_GL_SIGNED_INT_MAXIMUM
 (
b
) == (
max
) \

260 ? (
a
) \

261 : (
a
) % (
	`_GL_INT_CONVERT
 (a, 
	`_GL_SIGNED_INT_MAXIMUM
 (
b
)) + 1)) \

262 : (
a
) % - (
b
)) \

263 == 0)

	)

294 #define 
	#INT_ADD_OVERFLOW
(
a
, 
b
) \

295 
	`_GL_BINARY_OP_OVERFLOW
 (
a
, 
b
, 
_GL_ADD_OVERFLOW
)

	)

296 #define 
	#INT_SUBTRACT_OVERFLOW
(
a
, 
b
) \

297 
	`_GL_BINARY_OP_OVERFLOW
 (
a
, 
b
, 
_GL_SUBTRACT_OVERFLOW
)

	)

298 #define 
	#INT_NEGATE_OVERFLOW
(
a
) \

299 
	`INT_NEGATE_RANGE_OVERFLOW
 (
a
, 
	`_GL_INT_MINIMUM
 (a), 
	`_GL_INT_MAXIMUM
 (a))

	)

300 #define 
	#INT_MULTIPLY_OVERFLOW
(
a
, 
b
) \

301 
	`_GL_BINARY_OP_OVERFLOW
 (
a
, 
b
, 
_GL_MULTIPLY_OVERFLOW
)

	)

302 #define 
	#INT_DIVIDE_OVERFLOW
(
a
, 
b
) \

303 
	`_GL_BINARY_OP_OVERFLOW
 (
a
, 
b
, 
_GL_DIVIDE_OVERFLOW
)

	)

304 #define 
	#INT_REMAINDER_OVERFLOW
(
a
, 
b
) \

305 
	`_GL_BINARY_OP_OVERFLOW
 (
a
, 
b
, 
_GL_REMAINDER_OVERFLOW
)

	)

306 #define 
	#INT_LEFT_SHIFT_OVERFLOW
(
a
, 
b
) \

307 
	`INT_LEFT_SHIFT_RANGE_OVERFLOW
 (
a
, 
b
, \

308 
	`_GL_INT_MINIMUM
 (
a
), 
	`_GL_INT_MAXIMUM
 (a))

	)

314 #define 
	#_GL_BINARY_OP_OVERFLOW
(
a
, 
b
, 
op_result_overflow
) \

315 
	`op_result_overflow
 (
a
, 
b
, \

316 
	`_GL_INT_MINIMUM
 (0 * (
b
) + (
a
)), \

317 
	`_GL_INT_MAXIMUM
 (0 * (
b
) + (
a
)))

	)

	@lib/inttypes.in.h

23 #if 
__GNUC__
 >= 3

24 @
	gPRAGMA_SYSTEM_HEADER
@

26 @
	gPRAGMA_COLUMNS
@

32 #if ! 
defined
 
INTTYPES_H
 || defined 
_GL_JUST_INCLUDE_SYSTEM_INTTYPES_H


33 #if @
HAVE_INTTYPES_H
@

34 #@
INCLUDE_NEXT
@ @
NEXT_INTTYPES_H
@

38 #if ! 
defined
 
INTTYPES_H
 && ! defined 
_GL_JUST_INCLUDE_SYSTEM_INTTYPES_H


39 #define 
	#INTTYPES_H


	)

43 #ifndef 
__GLIBC__


44 #include 
	~<stdint.h
>

47 #include 
	~<limits.h
>

49 #if !(
INT_MIN
 == 
INT32_MIN
 && 
INT_MAX
 == 
INT32_MAX
)

59 #if ! 
defined
 
__cplusplus
 || defined 
__STDC_FORMAT_MACROS


61 #if 
defined
 
_TNS_R_TARGET


64 #define 
	#_LONG_LONG_FORMAT_PREFIX
 "L"

	)

66 #define 
	#_LONG_LONG_FORMAT_PREFIX
 "ll"

	)

69 #if !
defined
 
PRId8
 || @
PRI_MACROS_BROKEN
@

70 #undef 
PRId8


71 #ifdef 
INT8_MAX


72 #define 
	#PRId8
 "d"

	)

75 #if !
defined
 
PRIi8
 || @
PRI_MACROS_BROKEN
@

76 #undef 
PRIi8


77 #ifdef 
INT8_MAX


78 #define 
	#PRIi8
 "i"

	)

81 #if !
defined
 
PRIo8
 || @
PRI_MACROS_BROKEN
@

82 #undef 
PRIo8


83 #ifdef 
UINT8_MAX


84 #define 
	#PRIo8
 "o"

	)

87 #if !
defined
 
PRIu8
 || @
PRI_MACROS_BROKEN
@

88 #undef 
PRIu8


89 #ifdef 
UINT8_MAX


90 #define 
	#PRIu8
 "u"

	)

93 #if !
defined
 
PRIx8
 || @
PRI_MACROS_BROKEN
@

94 #undef 
PRIx8


95 #ifdef 
UINT8_MAX


96 #define 
	#PRIx8
 "x"

	)

99 #if !
defined
 
PRIX8
 || @
PRI_MACROS_BROKEN
@

100 #undef 
PRIX8


101 #ifdef 
UINT8_MAX


102 #define 
	#PRIX8
 "X"

	)

105 #if !
defined
 
PRId16
 || @
PRI_MACROS_BROKEN
@

106 #undef 
PRId16


107 #ifdef 
INT16_MAX


108 #define 
	#PRId16
 "d"

	)

111 #if !
defined
 
PRIi16
 || @
PRI_MACROS_BROKEN
@

112 #undef 
PRIi16


113 #ifdef 
INT16_MAX


114 #define 
	#PRIi16
 "i"

	)

117 #if !
defined
 
PRIo16
 || @
PRI_MACROS_BROKEN
@

118 #undef 
PRIo16


119 #ifdef 
UINT16_MAX


120 #define 
	#PRIo16
 "o"

	)

123 #if !
defined
 
PRIu16
 || @
PRI_MACROS_BROKEN
@

124 #undef 
PRIu16


125 #ifdef 
UINT16_MAX


126 #define 
	#PRIu16
 "u"

	)

129 #if !
defined
 
PRIx16
 || @
PRI_MACROS_BROKEN
@

130 #undef 
PRIx16


131 #ifdef 
UINT16_MAX


132 #define 
	#PRIx16
 "x"

	)

135 #if !
defined
 
PRIX16
 || @
PRI_MACROS_BROKEN
@

136 #undef 
PRIX16


137 #ifdef 
UINT16_MAX


138 #define 
	#PRIX16
 "X"

	)

141 #if !
defined
 
PRId32
 || @
PRI_MACROS_BROKEN
@

142 #undef 
PRId32


143 #ifdef 
INT32_MAX


144 #define 
	#PRId32
 "d"

	)

147 #if !
defined
 
PRIi32
 || @
PRI_MACROS_BROKEN
@

148 #undef 
PRIi32


149 #ifdef 
INT32_MAX


150 #define 
	#PRIi32
 "i"

	)

153 #if !
defined
 
PRIo32
 || @
PRI_MACROS_BROKEN
@

154 #undef 
PRIo32


155 #ifdef 
UINT32_MAX


156 #define 
	#PRIo32
 "o"

	)

159 #if !
defined
 
PRIu32
 || @
PRI_MACROS_BROKEN
@

160 #undef 
PRIu32


161 #ifdef 
UINT32_MAX


162 #define 
	#PRIu32
 "u"

	)

165 #if !
defined
 
PRIx32
 || @
PRI_MACROS_BROKEN
@

166 #undef 
PRIx32


167 #ifdef 
UINT32_MAX


168 #define 
	#PRIx32
 "x"

	)

171 #if !
defined
 
PRIX32
 || @
PRI_MACROS_BROKEN
@

172 #undef 
PRIX32


173 #ifdef 
UINT32_MAX


174 #define 
	#PRIX32
 "X"

	)

177 #ifdef 
INT64_MAX


178 #if (@
APPLE_UNIVERSAL_BUILD
@ ? 
defined
 
_LP64
 : @
INT64_MAX_EQ_LONG_MAX
@)

179 #define 
	#_PRI64_PREFIX
 "l"

	)

180 #elif 
defined
 
_MSC_VER
 || defined 
__MINGW32__


181 #define 
	#_PRI64_PREFIX
 "I64"

	)

182 #elif @
HAVE_LONG_LONG_INT
@ && 
LONG_MAX
 >> 30 == 1

183 #define 
	#_PRI64_PREFIX
 
_LONG_LONG_FORMAT_PREFIX


	)

185 #if !
defined
 
PRId64
 || @
PRI_MACROS_BROKEN
@

186 #undef 
PRId64


187 #define 
	#PRId64
 
_PRI64_PREFIX
 "d"

	)

189 #if !
defined
 
PRIi64
 || @
PRI_MACROS_BROKEN
@

190 #undef 
PRIi64


191 #define 
	#PRIi64
 
_PRI64_PREFIX
 "i"

	)

194 #ifdef 
UINT64_MAX


195 #if (@
APPLE_UNIVERSAL_BUILD
@ ? 
defined
 
_LP64
 : @
UINT64_MAX_EQ_ULONG_MAX
@)

196 #define 
	#_PRIu64_PREFIX
 "l"

	)

197 #elif 
defined
 
_MSC_VER
 || defined 
__MINGW32__


198 #define 
	#_PRIu64_PREFIX
 "I64"

	)

199 #elif @
HAVE_UNSIGNED_LONG_LONG_INT
@ && 
ULONG_MAX
 >> 31 == 1

200 #define 
	#_PRIu64_PREFIX
 
_LONG_LONG_FORMAT_PREFIX


	)

202 #if !
defined
 
PRIo64
 || @
PRI_MACROS_BROKEN
@

203 #undef 
PRIo64


204 #define 
	#PRIo64
 
_PRIu64_PREFIX
 "o"

	)

206 #if !
defined
 
PRIu64
 || @
PRI_MACROS_BROKEN
@

207 #undef 
PRIu64


208 #define 
	#PRIu64
 
_PRIu64_PREFIX
 "u"

	)

210 #if !
defined
 
PRIx64
 || @
PRI_MACROS_BROKEN
@

211 #undef 
PRIx64


212 #define 
	#PRIx64
 
_PRIu64_PREFIX
 "x"

	)

214 #if !
defined
 
PRIX64
 || @
PRI_MACROS_BROKEN
@

215 #undef 
PRIX64


216 #define 
	#PRIX64
 
_PRIu64_PREFIX
 "X"

	)

220 #if !
defined
 
PRIdLEAST8
 || @
PRI_MACROS_BROKEN
@

221 #undef 
PRIdLEAST8


222 #define 
	#PRIdLEAST8
 "d"

	)

224 #if !
defined
 
PRIiLEAST8
 || @
PRI_MACROS_BROKEN
@

225 #undef 
PRIiLEAST8


226 #define 
	#PRIiLEAST8
 "i"

	)

228 #if !
defined
 
PRIoLEAST8
 || @
PRI_MACROS_BROKEN
@

229 #undef 
PRIoLEAST8


230 #define 
	#PRIoLEAST8
 "o"

	)

232 #if !
defined
 
PRIuLEAST8
 || @
PRI_MACROS_BROKEN
@

233 #undef 
PRIuLEAST8


234 #define 
	#PRIuLEAST8
 "u"

	)

236 #if !
defined
 
PRIxLEAST8
 || @
PRI_MACROS_BROKEN
@

237 #undef 
PRIxLEAST8


238 #define 
	#PRIxLEAST8
 "x"

	)

240 #if !
defined
 
PRIXLEAST8
 || @
PRI_MACROS_BROKEN
@

241 #undef 
PRIXLEAST8


242 #define 
	#PRIXLEAST8
 "X"

	)

244 #if !
defined
 
PRIdLEAST16
 || @
PRI_MACROS_BROKEN
@

245 #undef 
PRIdLEAST16


246 #define 
	#PRIdLEAST16
 "d"

	)

248 #if !
defined
 
PRIiLEAST16
 || @
PRI_MACROS_BROKEN
@

249 #undef 
PRIiLEAST16


250 #define 
	#PRIiLEAST16
 "i"

	)

252 #if !
defined
 
PRIoLEAST16
 || @
PRI_MACROS_BROKEN
@

253 #undef 
PRIoLEAST16


254 #define 
	#PRIoLEAST16
 "o"

	)

256 #if !
defined
 
PRIuLEAST16
 || @
PRI_MACROS_BROKEN
@

257 #undef 
PRIuLEAST16


258 #define 
	#PRIuLEAST16
 "u"

	)

260 #if !
defined
 
PRIxLEAST16
 || @
PRI_MACROS_BROKEN
@

261 #undef 
PRIxLEAST16


262 #define 
	#PRIxLEAST16
 "x"

	)

264 #if !
defined
 
PRIXLEAST16
 || @
PRI_MACROS_BROKEN
@

265 #undef 
PRIXLEAST16


266 #define 
	#PRIXLEAST16
 "X"

	)

268 #if !
defined
 
PRIdLEAST32
 || @
PRI_MACROS_BROKEN
@

269 #undef 
PRIdLEAST32


270 #define 
	#PRIdLEAST32
 "d"

	)

272 #if !
defined
 
PRIiLEAST32
 || @
PRI_MACROS_BROKEN
@

273 #undef 
PRIiLEAST32


274 #define 
	#PRIiLEAST32
 "i"

	)

276 #if !
defined
 
PRIoLEAST32
 || @
PRI_MACROS_BROKEN
@

277 #undef 
PRIoLEAST32


278 #define 
	#PRIoLEAST32
 "o"

	)

280 #if !
defined
 
PRIuLEAST32
 || @
PRI_MACROS_BROKEN
@

281 #undef 
PRIuLEAST32


282 #define 
	#PRIuLEAST32
 "u"

	)

284 #if !
defined
 
PRIxLEAST32
 || @
PRI_MACROS_BROKEN
@

285 #undef 
PRIxLEAST32


286 #define 
	#PRIxLEAST32
 "x"

	)

288 #if !
defined
 
PRIXLEAST32
 || @
PRI_MACROS_BROKEN
@

289 #undef 
PRIXLEAST32


290 #define 
	#PRIXLEAST32
 "X"

	)

292 #ifdef 
INT64_MAX


293 #if !
defined
 
PRIdLEAST64
 || @
PRI_MACROS_BROKEN
@

294 #undef 
PRIdLEAST64


295 #define 
	#PRIdLEAST64
 
PRId64


	)

297 #if !
defined
 
PRIiLEAST64
 || @
PRI_MACROS_BROKEN
@

298 #undef 
PRIiLEAST64


299 #define 
	#PRIiLEAST64
 
PRIi64


	)

302 #ifdef 
UINT64_MAX


303 #if !
defined
 
PRIoLEAST64
 || @
PRI_MACROS_BROKEN
@

304 #undef 
PRIoLEAST64


305 #define 
	#PRIoLEAST64
 
PRIo64


	)

307 #if !
defined
 
PRIuLEAST64
 || @
PRI_MACROS_BROKEN
@

308 #undef 
PRIuLEAST64


309 #define 
	#PRIuLEAST64
 
PRIu64


	)

311 #if !
defined
 
PRIxLEAST64
 || @
PRI_MACROS_BROKEN
@

312 #undef 
PRIxLEAST64


313 #define 
	#PRIxLEAST64
 
PRIx64


	)

315 #if !
defined
 
PRIXLEAST64
 || @
PRI_MACROS_BROKEN
@

316 #undef 
PRIXLEAST64


317 #define 
	#PRIXLEAST64
 
PRIX64


	)

321 #if !
defined
 
PRIdFAST8
 || @
PRI_MACROS_BROKEN
@

322 #undef 
PRIdFAST8


323 #if 
INT_FAST8_MAX
 > 
INT32_MAX


324 #define 
	#PRIdFAST8
 
PRId64


	)

326 #define 
	#PRIdFAST8
 "d"

	)

329 #if !
defined
 
PRIiFAST8
 || @
PRI_MACROS_BROKEN
@

330 #undef 
PRIiFAST8


331 #if 
INT_FAST8_MAX
 > 
INT32_MAX


332 #define 
	#PRIiFAST8
 
PRIi64


	)

334 #define 
	#PRIiFAST8
 "i"

	)

337 #if !
defined
 
PRIoFAST8
 || @
PRI_MACROS_BROKEN
@

338 #undef 
PRIoFAST8


339 #if 
UINT_FAST8_MAX
 > 
UINT32_MAX


340 #define 
	#PRIoFAST8
 
PRIo64


	)

342 #define 
	#PRIoFAST8
 "o"

	)

345 #if !
defined
 
PRIuFAST8
 || @
PRI_MACROS_BROKEN
@

346 #undef 
PRIuFAST8


347 #if 
UINT_FAST8_MAX
 > 
UINT32_MAX


348 #define 
	#PRIuFAST8
 
PRIu64


	)

350 #define 
	#PRIuFAST8
 "u"

	)

353 #if !
defined
 
PRIxFAST8
 || @
PRI_MACROS_BROKEN
@

354 #undef 
PRIxFAST8


355 #if 
UINT_FAST8_MAX
 > 
UINT32_MAX


356 #define 
	#PRIxFAST8
 
PRIx64


	)

358 #define 
	#PRIxFAST8
 "x"

	)

361 #if !
defined
 
PRIXFAST8
 || @
PRI_MACROS_BROKEN
@

362 #undef 
PRIXFAST8


363 #if 
UINT_FAST8_MAX
 > 
UINT32_MAX


364 #define 
	#PRIXFAST8
 
PRIX64


	)

366 #define 
	#PRIXFAST8
 "X"

	)

369 #if !
defined
 
PRIdFAST16
 || @
PRI_MACROS_BROKEN
@

370 #undef 
PRIdFAST16


371 #if 
INT_FAST16_MAX
 > 
INT32_MAX


372 #define 
	#PRIdFAST16
 
PRId64


	)

374 #define 
	#PRIdFAST16
 "d"

	)

377 #if !
defined
 
PRIiFAST16
 || @
PRI_MACROS_BROKEN
@

378 #undef 
PRIiFAST16


379 #if 
INT_FAST16_MAX
 > 
INT32_MAX


380 #define 
	#PRIiFAST16
 
PRIi64


	)

382 #define 
	#PRIiFAST16
 "i"

	)

385 #if !
defined
 
PRIoFAST16
 || @
PRI_MACROS_BROKEN
@

386 #undef 
PRIoFAST16


387 #if 
UINT_FAST16_MAX
 > 
UINT32_MAX


388 #define 
	#PRIoFAST16
 
PRIo64


	)

390 #define 
	#PRIoFAST16
 "o"

	)

393 #if !
defined
 
PRIuFAST16
 || @
PRI_MACROS_BROKEN
@

394 #undef 
PRIuFAST16


395 #if 
UINT_FAST16_MAX
 > 
UINT32_MAX


396 #define 
	#PRIuFAST16
 
PRIu64


	)

398 #define 
	#PRIuFAST16
 "u"

	)

401 #if !
defined
 
PRIxFAST16
 || @
PRI_MACROS_BROKEN
@

402 #undef 
PRIxFAST16


403 #if 
UINT_FAST16_MAX
 > 
UINT32_MAX


404 #define 
	#PRIxFAST16
 
PRIx64


	)

406 #define 
	#PRIxFAST16
 "x"

	)

409 #if !
defined
 
PRIXFAST16
 || @
PRI_MACROS_BROKEN
@

410 #undef 
PRIXFAST16


411 #if 
UINT_FAST16_MAX
 > 
UINT32_MAX


412 #define 
	#PRIXFAST16
 
PRIX64


	)

414 #define 
	#PRIXFAST16
 "X"

	)

417 #if !
defined
 
PRIdFAST32
 || @
PRI_MACROS_BROKEN
@

418 #undef 
PRIdFAST32


419 #if 
INT_FAST32_MAX
 > 
INT32_MAX


420 #define 
	#PRIdFAST32
 
PRId64


	)

422 #define 
	#PRIdFAST32
 "d"

	)

425 #if !
defined
 
PRIiFAST32
 || @
PRI_MACROS_BROKEN
@

426 #undef 
PRIiFAST32


427 #if 
INT_FAST32_MAX
 > 
INT32_MAX


428 #define 
	#PRIiFAST32
 
PRIi64


	)

430 #define 
	#PRIiFAST32
 "i"

	)

433 #if !
defined
 
PRIoFAST32
 || @
PRI_MACROS_BROKEN
@

434 #undef 
PRIoFAST32


435 #if 
UINT_FAST32_MAX
 > 
UINT32_MAX


436 #define 
	#PRIoFAST32
 
PRIo64


	)

438 #define 
	#PRIoFAST32
 "o"

	)

441 #if !
defined
 
PRIuFAST32
 || @
PRI_MACROS_BROKEN
@

442 #undef 
PRIuFAST32


443 #if 
UINT_FAST32_MAX
 > 
UINT32_MAX


444 #define 
	#PRIuFAST32
 
PRIu64


	)

446 #define 
	#PRIuFAST32
 "u"

	)

449 #if !
defined
 
PRIxFAST32
 || @
PRI_MACROS_BROKEN
@

450 #undef 
PRIxFAST32


451 #if 
UINT_FAST32_MAX
 > 
UINT32_MAX


452 #define 
	#PRIxFAST32
 
PRIx64


	)

454 #define 
	#PRIxFAST32
 "x"

	)

457 #if !
defined
 
PRIXFAST32
 || @
PRI_MACROS_BROKEN
@

458 #undef 
PRIXFAST32


459 #if 
UINT_FAST32_MAX
 > 
UINT32_MAX


460 #define 
	#PRIXFAST32
 
PRIX64


	)

462 #define 
	#PRIXFAST32
 "X"

	)

465 #ifdef 
INT64_MAX


466 #if !
defined
 
PRIdFAST64
 || @
PRI_MACROS_BROKEN
@

467 #undef 
PRIdFAST64


468 #define 
	#PRIdFAST64
 
PRId64


	)

470 #if !
defined
 
PRIiFAST64
 || @
PRI_MACROS_BROKEN
@

471 #undef 
PRIiFAST64


472 #define 
	#PRIiFAST64
 
PRIi64


	)

475 #ifdef 
UINT64_MAX


476 #if !
defined
 
PRIoFAST64
 || @
PRI_MACROS_BROKEN
@

477 #undef 
PRIoFAST64


478 #define 
	#PRIoFAST64
 
PRIo64


	)

480 #if !
defined
 
PRIuFAST64
 || @
PRI_MACROS_BROKEN
@

481 #undef 
PRIuFAST64


482 #define 
	#PRIuFAST64
 
PRIu64


	)

484 #if !
defined
 
PRIxFAST64
 || @
PRI_MACROS_BROKEN
@

485 #undef 
PRIxFAST64


486 #define 
	#PRIxFAST64
 
PRIx64


	)

488 #if !
defined
 
PRIXFAST64
 || @
PRI_MACROS_BROKEN
@

489 #undef 
PRIXFAST64


490 #define 
	#PRIXFAST64
 
PRIX64


	)

494 #if !
defined
 
PRIdMAX
 || @
PRI_MACROS_BROKEN
@

495 #undef 
PRIdMAX


496 #if @
INT32_MAX_LT_INTMAX_MAX
@

497 #define 
	#PRIdMAX
 
PRId64


	)

499 #define 
	#PRIdMAX
 "ld"

	)

502 #if !
defined
 
PRIiMAX
 || @
PRI_MACROS_BROKEN
@

503 #undef 
PRIiMAX


504 #if @
INT32_MAX_LT_INTMAX_MAX
@

505 #define 
	#PRIiMAX
 
PRIi64


	)

507 #define 
	#PRIiMAX
 "li"

	)

510 #if !
defined
 
PRIoMAX
 || @
PRI_MACROS_BROKEN
@

511 #undef 
PRIoMAX


512 #if @
UINT32_MAX_LT_UINTMAX_MAX
@

513 #define 
	#PRIoMAX
 
PRIo64


	)

515 #define 
	#PRIoMAX
 "lo"

	)

518 #if !
defined
 
PRIuMAX
 || @
PRI_MACROS_BROKEN
@

519 #undef 
PRIuMAX


520 #if @
UINT32_MAX_LT_UINTMAX_MAX
@

521 #define 
	#PRIuMAX
 
PRIu64


	)

523 #define 
	#PRIuMAX
 "lu"

	)

526 #if !
defined
 
PRIxMAX
 || @
PRI_MACROS_BROKEN
@

527 #undef 
PRIxMAX


528 #if @
UINT32_MAX_LT_UINTMAX_MAX
@

529 #define 
	#PRIxMAX
 
PRIx64


	)

531 #define 
	#PRIxMAX
 "lx"

	)

534 #if !
defined
 
PRIXMAX
 || @
PRI_MACROS_BROKEN
@

535 #undef 
PRIXMAX


536 #if @
UINT32_MAX_LT_UINTMAX_MAX
@

537 #define 
	#PRIXMAX
 
PRIX64


	)

539 #define 
	#PRIXMAX
 "lX"

	)

543 #if !
defined
 
PRIdPTR
 || @
PRI_MACROS_BROKEN
@

544 #undef 
PRIdPTR


545 #ifdef 
INTPTR_MAX


546 #define 
	#PRIdPTR
 @
PRIPTR_PREFIX
@ "d"

	)

549 #if !
defined
 
PRIiPTR
 || @
PRI_MACROS_BROKEN
@

550 #undef 
PRIiPTR


551 #ifdef 
INTPTR_MAX


552 #define 
	#PRIiPTR
 @
PRIPTR_PREFIX
@ "i"

	)

555 #if !
defined
 
PRIoPTR
 || @
PRI_MACROS_BROKEN
@

556 #undef 
PRIoPTR


557 #ifdef 
UINTPTR_MAX


558 #define 
	#PRIoPTR
 @
PRIPTR_PREFIX
@ "o"

	)

561 #if !
defined
 
PRIuPTR
 || @
PRI_MACROS_BROKEN
@

562 #undef 
PRIuPTR


563 #ifdef 
UINTPTR_MAX


564 #define 
	#PRIuPTR
 @
PRIPTR_PREFIX
@ "u"

	)

567 #if !
defined
 
PRIxPTR
 || @
PRI_MACROS_BROKEN
@

568 #undef 
PRIxPTR


569 #ifdef 
UINTPTR_MAX


570 #define 
	#PRIxPTR
 @
PRIPTR_PREFIX
@ "x"

	)

573 #if !
defined
 
PRIXPTR
 || @
PRI_MACROS_BROKEN
@

574 #undef 
PRIXPTR


575 #ifdef 
UINTPTR_MAX


576 #define 
	#PRIXPTR
 @
PRIPTR_PREFIX
@ "X"

	)

580 #if !
defined
 
SCNd8
 || @
PRI_MACROS_BROKEN
@

581 #undef 
SCNd8


582 #ifdef 
INT8_MAX


583 #define 
	#SCNd8
 "hhd"

	)

586 #if !
defined
 
SCNi8
 || @
PRI_MACROS_BROKEN
@

587 #undef 
SCNi8


588 #ifdef 
INT8_MAX


589 #define 
	#SCNi8
 "hhi"

	)

592 #if !
defined
 
SCNo8
 || @
PRI_MACROS_BROKEN
@

593 #undef 
SCNo8


594 #ifdef 
UINT8_MAX


595 #define 
	#SCNo8
 "hho"

	)

598 #if !
defined
 
SCNu8
 || @
PRI_MACROS_BROKEN
@

599 #undef 
SCNu8


600 #ifdef 
UINT8_MAX


601 #define 
	#SCNu8
 "hhu"

	)

604 #if !
defined
 
SCNx8
 || @
PRI_MACROS_BROKEN
@

605 #undef 
SCNx8


606 #ifdef 
UINT8_MAX


607 #define 
	#SCNx8
 "hhx"

	)

610 #if !
defined
 
SCNd16
 || @
PRI_MACROS_BROKEN
@

611 #undef 
SCNd16


612 #ifdef 
INT16_MAX


613 #define 
	#SCNd16
 "hd"

	)

616 #if !
defined
 
SCNi16
 || @
PRI_MACROS_BROKEN
@

617 #undef 
SCNi16


618 #ifdef 
INT16_MAX


619 #define 
	#SCNi16
 "hi"

	)

622 #if !
defined
 
SCNo16
 || @
PRI_MACROS_BROKEN
@

623 #undef 
SCNo16


624 #ifdef 
UINT16_MAX


625 #define 
	#SCNo16
 "ho"

	)

628 #if !
defined
 
SCNu16
 || @
PRI_MACROS_BROKEN
@

629 #undef 
SCNu16


630 #ifdef 
UINT16_MAX


631 #define 
	#SCNu16
 "hu"

	)

634 #if !
defined
 
SCNx16
 || @
PRI_MACROS_BROKEN
@

635 #undef 
SCNx16


636 #ifdef 
UINT16_MAX


637 #define 
	#SCNx16
 "hx"

	)

640 #if !
defined
 
SCNd32
 || @
PRI_MACROS_BROKEN
@

641 #undef 
SCNd32


642 #ifdef 
INT32_MAX


643 #define 
	#SCNd32
 "d"

	)

646 #if !
defined
 
SCNi32
 || @
PRI_MACROS_BROKEN
@

647 #undef 
SCNi32


648 #ifdef 
INT32_MAX


649 #define 
	#SCNi32
 "i"

	)

652 #if !
defined
 
SCNo32
 || @
PRI_MACROS_BROKEN
@

653 #undef 
SCNo32


654 #ifdef 
UINT32_MAX


655 #define 
	#SCNo32
 "o"

	)

658 #if !
defined
 
SCNu32
 || @
PRI_MACROS_BROKEN
@

659 #undef 
SCNu32


660 #ifdef 
UINT32_MAX


661 #define 
	#SCNu32
 "u"

	)

664 #if !
defined
 
SCNx32
 || @
PRI_MACROS_BROKEN
@

665 #undef 
SCNx32


666 #ifdef 
UINT32_MAX


667 #define 
	#SCNx32
 "x"

	)

670 #ifdef 
INT64_MAX


671 #if (@
APPLE_UNIVERSAL_BUILD
@ ? 
defined
 
_LP64
 : @
INT64_MAX_EQ_LONG_MAX
@)

672 #define 
	#_SCN64_PREFIX
 "l"

	)

673 #elif 
defined
 
_MSC_VER
 || defined 
__MINGW32__


674 #define 
	#_SCN64_PREFIX
 "I64"

	)

675 #elif @
HAVE_LONG_LONG_INT
@ && 
LONG_MAX
 >> 30 == 1

676 #define 
	#_SCN64_PREFIX
 
_LONG_LONG_FORMAT_PREFIX


	)

678 #if !
defined
 
SCNd64
 || @
PRI_MACROS_BROKEN
@

679 #undef 
SCNd64


680 #define 
	#SCNd64
 
_SCN64_PREFIX
 "d"

	)

682 #if !
defined
 
SCNi64
 || @
PRI_MACROS_BROKEN
@

683 #undef 
SCNi64


684 #define 
	#SCNi64
 
_SCN64_PREFIX
 "i"

	)

687 #ifdef 
UINT64_MAX


688 #if (@
APPLE_UNIVERSAL_BUILD
@ ? 
defined
 
_LP64
 : @
UINT64_MAX_EQ_ULONG_MAX
@)

689 #define 
	#_SCNu64_PREFIX
 "l"

	)

690 #elif 
defined
 
_MSC_VER
 || defined 
__MINGW32__


691 #define 
	#_SCNu64_PREFIX
 "I64"

	)

692 #elif @
HAVE_UNSIGNED_LONG_LONG_INT
@ && 
ULONG_MAX
 >> 31 == 1

693 #define 
	#_SCNu64_PREFIX
 
_LONG_LONG_FORMAT_PREFIX


	)

695 #if !
defined
 
SCNo64
 || @
PRI_MACROS_BROKEN
@

696 #undef 
SCNo64


697 #define 
	#SCNo64
 
_SCNu64_PREFIX
 "o"

	)

699 #if !
defined
 
SCNu64
 || @
PRI_MACROS_BROKEN
@

700 #undef 
SCNu64


701 #define 
	#SCNu64
 
_SCNu64_PREFIX
 "u"

	)

703 #if !
defined
 
SCNx64
 || @
PRI_MACROS_BROKEN
@

704 #undef 
SCNx64


705 #define 
	#SCNx64
 
_SCNu64_PREFIX
 "x"

	)

709 #if !
defined
 
SCNdLEAST8
 || @
PRI_MACROS_BROKEN
@

710 #undef 
SCNdLEAST8


711 #define 
	#SCNdLEAST8
 "hhd"

	)

713 #if !
defined
 
SCNiLEAST8
 || @
PRI_MACROS_BROKEN
@

714 #undef 
SCNiLEAST8


715 #define 
	#SCNiLEAST8
 "hhi"

	)

717 #if !
defined
 
SCNoLEAST8
 || @
PRI_MACROS_BROKEN
@

718 #undef 
SCNoLEAST8


719 #define 
	#SCNoLEAST8
 "hho"

	)

721 #if !
defined
 
SCNuLEAST8
 || @
PRI_MACROS_BROKEN
@

722 #undef 
SCNuLEAST8


723 #define 
	#SCNuLEAST8
 "hhu"

	)

725 #if !
defined
 
SCNxLEAST8
 || @
PRI_MACROS_BROKEN
@

726 #undef 
SCNxLEAST8


727 #define 
	#SCNxLEAST8
 "hhx"

	)

729 #if !
defined
 
SCNdLEAST16
 || @
PRI_MACROS_BROKEN
@

730 #undef 
SCNdLEAST16


731 #define 
	#SCNdLEAST16
 "hd"

	)

733 #if !
defined
 
SCNiLEAST16
 || @
PRI_MACROS_BROKEN
@

734 #undef 
SCNiLEAST16


735 #define 
	#SCNiLEAST16
 "hi"

	)

737 #if !
defined
 
SCNoLEAST16
 || @
PRI_MACROS_BROKEN
@

738 #undef 
SCNoLEAST16


739 #define 
	#SCNoLEAST16
 "ho"

	)

741 #if !
defined
 
SCNuLEAST16
 || @
PRI_MACROS_BROKEN
@

742 #undef 
SCNuLEAST16


743 #define 
	#SCNuLEAST16
 "hu"

	)

745 #if !
defined
 
SCNxLEAST16
 || @
PRI_MACROS_BROKEN
@

746 #undef 
SCNxLEAST16


747 #define 
	#SCNxLEAST16
 "hx"

	)

749 #if !
defined
 
SCNdLEAST32
 || @
PRI_MACROS_BROKEN
@

750 #undef 
SCNdLEAST32


751 #define 
	#SCNdLEAST32
 "d"

	)

753 #if !
defined
 
SCNiLEAST32
 || @
PRI_MACROS_BROKEN
@

754 #undef 
SCNiLEAST32


755 #define 
	#SCNiLEAST32
 "i"

	)

757 #if !
defined
 
SCNoLEAST32
 || @
PRI_MACROS_BROKEN
@

758 #undef 
SCNoLEAST32


759 #define 
	#SCNoLEAST32
 "o"

	)

761 #if !
defined
 
SCNuLEAST32
 || @
PRI_MACROS_BROKEN
@

762 #undef 
SCNuLEAST32


763 #define 
	#SCNuLEAST32
 "u"

	)

765 #if !
defined
 
SCNxLEAST32
 || @
PRI_MACROS_BROKEN
@

766 #undef 
SCNxLEAST32


767 #define 
	#SCNxLEAST32
 "x"

	)

769 #ifdef 
INT64_MAX


770 #if !
defined
 
SCNdLEAST64
 || @
PRI_MACROS_BROKEN
@

771 #undef 
SCNdLEAST64


772 #define 
	#SCNdLEAST64
 
SCNd64


	)

774 #if !
defined
 
SCNiLEAST64
 || @
PRI_MACROS_BROKEN
@

775 #undef 
SCNiLEAST64


776 #define 
	#SCNiLEAST64
 
SCNi64


	)

779 #ifdef 
UINT64_MAX


780 #if !
defined
 
SCNoLEAST64
 || @
PRI_MACROS_BROKEN
@

781 #undef 
SCNoLEAST64


782 #define 
	#SCNoLEAST64
 
SCNo64


	)

784 #if !
defined
 
SCNuLEAST64
 || @
PRI_MACROS_BROKEN
@

785 #undef 
SCNuLEAST64


786 #define 
	#SCNuLEAST64
 
SCNu64


	)

788 #if !
defined
 
SCNxLEAST64
 || @
PRI_MACROS_BROKEN
@

789 #undef 
SCNxLEAST64


790 #define 
	#SCNxLEAST64
 
SCNx64


	)

794 #if !
defined
 
SCNdFAST8
 || @
PRI_MACROS_BROKEN
@

795 #undef 
SCNdFAST8


796 #if 
INT_FAST8_MAX
 > 
INT32_MAX


797 #define 
	#SCNdFAST8
 
SCNd64


	)

798 #elif 
INT_FAST8_MAX
 == 0x7fff

799 #define 
	#SCNdFAST8
 "hd"

	)

800 #elif 
INT_FAST8_MAX
 == 0x7f

801 #define 
	#SCNdFAST8
 "hhd"

	)

803 #define 
	#SCNdFAST8
 "d"

	)

806 #if !
defined
 
SCNiFAST8
 || @
PRI_MACROS_BROKEN
@

807 #undef 
SCNiFAST8


808 #if 
INT_FAST8_MAX
 > 
INT32_MAX


809 #define 
	#SCNiFAST8
 
SCNi64


	)

810 #elif 
INT_FAST8_MAX
 == 0x7fff

811 #define 
	#SCNiFAST8
 "hi"

	)

812 #elif 
INT_FAST8_MAX
 == 0x7f

813 #define 
	#SCNiFAST8
 "hhi"

	)

815 #define 
	#SCNiFAST8
 "i"

	)

818 #if !
defined
 
SCNoFAST8
 || @
PRI_MACROS_BROKEN
@

819 #undef 
SCNoFAST8


820 #if 
UINT_FAST8_MAX
 > 
UINT32_MAX


821 #define 
	#SCNoFAST8
 
SCNo64


	)

822 #elif 
UINT_FAST8_MAX
 == 0xffff

823 #define 
	#SCNoFAST8
 "ho"

	)

824 #elif 
UINT_FAST8_MAX
 == 0xff

825 #define 
	#SCNoFAST8
 "hho"

	)

827 #define 
	#SCNoFAST8
 "o"

	)

830 #if !
defined
 
SCNuFAST8
 || @
PRI_MACROS_BROKEN
@

831 #undef 
SCNuFAST8


832 #if 
UINT_FAST8_MAX
 > 
UINT32_MAX


833 #define 
	#SCNuFAST8
 
SCNu64


	)

834 #elif 
UINT_FAST8_MAX
 == 0xffff

835 #define 
	#SCNuFAST8
 "hu"

	)

836 #elif 
UINT_FAST8_MAX
 == 0xff

837 #define 
	#SCNuFAST8
 "hhu"

	)

839 #define 
	#SCNuFAST8
 "u"

	)

842 #if !
defined
 
SCNxFAST8
 || @
PRI_MACROS_BROKEN
@

843 #undef 
SCNxFAST8


844 #if 
UINT_FAST8_MAX
 > 
UINT32_MAX


845 #define 
	#SCNxFAST8
 
SCNx64


	)

846 #elif 
UINT_FAST8_MAX
 == 0xffff

847 #define 
	#SCNxFAST8
 "hx"

	)

848 #elif 
UINT_FAST8_MAX
 == 0xff

849 #define 
	#SCNxFAST8
 "hhx"

	)

851 #define 
	#SCNxFAST8
 "x"

	)

854 #if !
defined
 
SCNdFAST16
 || @
PRI_MACROS_BROKEN
@

855 #undef 
SCNdFAST16


856 #if 
INT_FAST16_MAX
 > 
INT32_MAX


857 #define 
	#SCNdFAST16
 
SCNd64


	)

858 #elif 
INT_FAST16_MAX
 == 0x7fff

859 #define 
	#SCNdFAST16
 "hd"

	)

861 #define 
	#SCNdFAST16
 "d"

	)

864 #if !
defined
 
SCNiFAST16
 || @
PRI_MACROS_BROKEN
@

865 #undef 
SCNiFAST16


866 #if 
INT_FAST16_MAX
 > 
INT32_MAX


867 #define 
	#SCNiFAST16
 
SCNi64


	)

868 #elif 
INT_FAST16_MAX
 == 0x7fff

869 #define 
	#SCNiFAST16
 "hi"

	)

871 #define 
	#SCNiFAST16
 "i"

	)

874 #if !
defined
 
SCNoFAST16
 || @
PRI_MACROS_BROKEN
@

875 #undef 
SCNoFAST16


876 #if 
UINT_FAST16_MAX
 > 
UINT32_MAX


877 #define 
	#SCNoFAST16
 
SCNo64


	)

878 #elif 
UINT_FAST16_MAX
 == 0xffff

879 #define 
	#SCNoFAST16
 "ho"

	)

881 #define 
	#SCNoFAST16
 "o"

	)

884 #if !
defined
 
SCNuFAST16
 || @
PRI_MACROS_BROKEN
@

885 #undef 
SCNuFAST16


886 #if 
UINT_FAST16_MAX
 > 
UINT32_MAX


887 #define 
	#SCNuFAST16
 
SCNu64


	)

888 #elif 
UINT_FAST16_MAX
 == 0xffff

889 #define 
	#SCNuFAST16
 "hu"

	)

891 #define 
	#SCNuFAST16
 "u"

	)

894 #if !
defined
 
SCNxFAST16
 || @
PRI_MACROS_BROKEN
@

895 #undef 
SCNxFAST16


896 #if 
UINT_FAST16_MAX
 > 
UINT32_MAX


897 #define 
	#SCNxFAST16
 
SCNx64


	)

898 #elif 
UINT_FAST16_MAX
 == 0xffff

899 #define 
	#SCNxFAST16
 "hx"

	)

901 #define 
	#SCNxFAST16
 "x"

	)

904 #if !
defined
 
SCNdFAST32
 || @
PRI_MACROS_BROKEN
@

905 #undef 
SCNdFAST32


906 #if 
INT_FAST32_MAX
 > 
INT32_MAX


907 #define 
	#SCNdFAST32
 
SCNd64


	)

909 #define 
	#SCNdFAST32
 "d"

	)

912 #if !
defined
 
SCNiFAST32
 || @
PRI_MACROS_BROKEN
@

913 #undef 
SCNiFAST32


914 #if 
INT_FAST32_MAX
 > 
INT32_MAX


915 #define 
	#SCNiFAST32
 
SCNi64


	)

917 #define 
	#SCNiFAST32
 "i"

	)

920 #if !
defined
 
SCNoFAST32
 || @
PRI_MACROS_BROKEN
@

921 #undef 
SCNoFAST32


922 #if 
UINT_FAST32_MAX
 > 
UINT32_MAX


923 #define 
	#SCNoFAST32
 
SCNo64


	)

925 #define 
	#SCNoFAST32
 "o"

	)

928 #if !
defined
 
SCNuFAST32
 || @
PRI_MACROS_BROKEN
@

929 #undef 
SCNuFAST32


930 #if 
UINT_FAST32_MAX
 > 
UINT32_MAX


931 #define 
	#SCNuFAST32
 
SCNu64


	)

933 #define 
	#SCNuFAST32
 "u"

	)

936 #if !
defined
 
SCNxFAST32
 || @
PRI_MACROS_BROKEN
@

937 #undef 
SCNxFAST32


938 #if 
UINT_FAST32_MAX
 > 
UINT32_MAX


939 #define 
	#SCNxFAST32
 
SCNx64


	)

941 #define 
	#SCNxFAST32
 "x"

	)

944 #ifdef 
INT64_MAX


945 #if !
defined
 
SCNdFAST64
 || @
PRI_MACROS_BROKEN
@

946 #undef 
SCNdFAST64


947 #define 
	#SCNdFAST64
 
SCNd64


	)

949 #if !
defined
 
SCNiFAST64
 || @
PRI_MACROS_BROKEN
@

950 #undef 
SCNiFAST64


951 #define 
	#SCNiFAST64
 
SCNi64


	)

954 #ifdef 
UINT64_MAX


955 #if !
defined
 
SCNoFAST64
 || @
PRI_MACROS_BROKEN
@

956 #undef 
SCNoFAST64


957 #define 
	#SCNoFAST64
 
SCNo64


	)

959 #if !
defined
 
SCNuFAST64
 || @
PRI_MACROS_BROKEN
@

960 #undef 
SCNuFAST64


961 #define 
	#SCNuFAST64
 
SCNu64


	)

963 #if !
defined
 
SCNxFAST64
 || @
PRI_MACROS_BROKEN
@

964 #undef 
SCNxFAST64


965 #define 
	#SCNxFAST64
 
SCNx64


	)

969 #if !
defined
 
SCNdMAX
 || @
PRI_MACROS_BROKEN
@

970 #undef 
SCNdMAX


971 #if @
INT32_MAX_LT_INTMAX_MAX
@

972 #define 
	#SCNdMAX
 
SCNd64


	)

974 #define 
	#SCNdMAX
 "ld"

	)

977 #if !
defined
 
SCNiMAX
 || @
PRI_MACROS_BROKEN
@

978 #undef 
SCNiMAX


979 #if @
INT32_MAX_LT_INTMAX_MAX
@

980 #define 
	#SCNiMAX
 
SCNi64


	)

982 #define 
	#SCNiMAX
 "li"

	)

985 #if !
defined
 
SCNoMAX
 || @
PRI_MACROS_BROKEN
@

986 #undef 
SCNoMAX


987 #if @
UINT32_MAX_LT_UINTMAX_MAX
@

988 #define 
	#SCNoMAX
 
SCNo64


	)

990 #define 
	#SCNoMAX
 "lo"

	)

993 #if !
defined
 
SCNuMAX
 || @
PRI_MACROS_BROKEN
@

994 #undef 
SCNuMAX


995 #if @
UINT32_MAX_LT_UINTMAX_MAX
@

996 #define 
	#SCNuMAX
 
SCNu64


	)

998 #define 
	#SCNuMAX
 "lu"

	)

1001 #if !
defined
 
SCNxMAX
 || @
PRI_MACROS_BROKEN
@

1002 #undef 
SCNxMAX


1003 #if @
UINT32_MAX_LT_UINTMAX_MAX
@

1004 #define 
	#SCNxMAX
 
SCNx64


	)

1006 #define 
	#SCNxMAX
 "lx"

	)

1010 #if !
defined
 
SCNdPTR
 || @
PRI_MACROS_BROKEN
@

1011 #undef 
SCNdPTR


1012 #ifdef 
INTPTR_MAX


1013 #define 
	#SCNdPTR
 @
PRIPTR_PREFIX
@ "d"

	)

1016 #if !
defined
 
SCNiPTR
 || @
PRI_MACROS_BROKEN
@

1017 #undef 
SCNiPTR


1018 #ifdef 
INTPTR_MAX


1019 #define 
	#SCNiPTR
 @
PRIPTR_PREFIX
@ "i"

	)

1022 #if !
defined
 
SCNoPTR
 || @
PRI_MACROS_BROKEN
@

1023 #undef 
SCNoPTR


1024 #ifdef 
UINTPTR_MAX


1025 #define 
	#SCNoPTR
 @
PRIPTR_PREFIX
@ "o"

	)

1028 #if !
defined
 
SCNuPTR
 || @
PRI_MACROS_BROKEN
@

1029 #undef 
SCNuPTR


1030 #ifdef 
UINTPTR_MAX


1031 #define 
	#SCNuPTR
 @
PRIPTR_PREFIX
@ "u"

	)

1034 #if !
defined
 
SCNxPTR
 || @
PRI_MACROS_BROKEN
@

1035 #undef 
SCNxPTR


1036 #ifdef 
UINTPTR_MAX


1037 #define 
	#SCNxPTR
 @
PRIPTR_PREFIX
@ "x"

	)

1045 #ifdef 
__cplusplus


1049 #if @
GNULIB_IMAXABS
@

1050 #if !@
HAVE_DECL_IMAXABS
@

1051 extern 
intmax_t
 
imaxabs
 (intmax_t);

1053 #elif 
defined
 
GNULIB_POSIXCHECK


1054 #undef 
imaxabs


1055 #if 
HAVE_RAW_DECL_IMAXABS


1056 
_GL_WARN_ON_USE
 (
imaxabs
, "imaxabs is unportable - "

1061 #if @
GNULIB_IMAXDIV
@

1062 #if !@
HAVE_DECL_IMAXDIV
@

1063 #if !
GNULIB_defined_imaxdiv_t


1064 typedef struct { 
intmax_t
 
	mquot
; intmax_t 
	mrem
; } 
	timaxdiv_t
;

1065 #define 
	#GNULIB_defined_imaxdiv_t
 1

	)

1067 extern 
imaxdiv_t
 
imaxdiv
 (
intmax_t
, intmax_t);

1069 #elif 
defined
 
GNULIB_POSIXCHECK


1070 #undef 
imaxdiv


1071 #if 
HAVE_RAW_DECL_IMAXDIV


1072 
_GL_WARN_ON_USE
 (
imaxdiv
, "imaxdiv is unportable - "

1077 #if @
GNULIB_STRTOIMAX
@

1078 #if !@
HAVE_DECL_STRTOIMAX
@

1079 #undef 
strtoimax


1080 extern 
intmax_t
 
	$strtoimax
 (const char *, char **, int) 
	`_GL_ARG_NONNULL
 ((1));

1082 #elif 
defined
 
GNULIB_POSIXCHECK


1083 #undef 
strtoimax


1084 #if 
HAVE_RAW_DECL_STRTOIMAX


1085 
	`_GL_WARN_ON_USE
 (
strtoimax
, "strtoimax is unportable - "

1090 #if @
GNULIB_STRTOUMAX
@

1091 #if !@
HAVE_DECL_STRTOUMAX
@

1092 #undef 
strtoumax


1093 extern 
uintmax_t
 
	$strtoumax
 (const char *, char **, int) 
	`_GL_ARG_NONNULL
 ((1));

1095 #elif 
defined
 
GNULIB_POSIXCHECK


1096 #undef 
strtoumax


1097 #if 
HAVE_RAW_DECL_STRTOUMAX


1098 
	`_GL_WARN_ON_USE
 (
strtoumax
, "strtoumax is unportable - "

1106 #ifdef 
__cplusplus


1107 
	}
}

	@lib/isblank.c

18 #include 
	~<config.h
>

21 #include 
	~<ctype.h
>

24 
	$isblank
 (int 
c
)

32 return (
c
 == ' ' || c == '\t');

33 
	}
}

	@lib/isdir.c

18 #include 
	~<config.h
>

20 #include 
	~"isdir.h
"

22 #include 
	~<sys/types.h
>

23 #include 
	~<sys/stat.h
>

28 
	$isdir
 (const char *
path
)

30 struct 
stat
 
stats
;

32 return 
	`stat
 (
path
, &
stats
) == 0 && 
	`S_ISDIR
 (stats.
st_mode
);

33 
	}
}

	@lib/isdir.h

1 int 
isdir
 (const char *
path
);

	@lib/iswblank.c

20 #include 
	~<config.h
>

23 #include 
	~<wctype.h
>

26 
	$iswblank
 (
wint_t
 
wc
)

28 return 
wc
 == ' ' || wc == '\t';

29 
	}
}

	@lib/langinfo.in.h

25 #ifndef 
_
@
GUARD_PREFIX
@
_LANGINFO_H


27 #if 
__GNUC__
 >= 3

28 @
	gPRAGMA_SYSTEM_HEADER
@

30 @
	gPRAGMA_COLUMNS
@

33 #if @
HAVE_LANGINFO_H
@

34 #@
INCLUDE_NEXT
@ @
NEXT_LANGINFO_H
@

37 #ifndef 
_
@
GUARD_PREFIX
@
_LANGINFO_H


38 #define 
	#_
@
GUARD_PREFIX
@
_LANGINFO_H


	)

41 #if !@
HAVE_LANGINFO_H
@

46 #if !
GNULIB_defined_nl_item


47 typedef int 
	tnl_item
;

48 #define 
	#GNULIB_defined_nl_item
 1

	)

52 #define 
	#CODESET
 10000

	)

54 #define 
	#RADIXCHAR
 10001

	)

55 #define 
	#THOUSEP
 10002

	)

57 #define 
	#D_T_FMT
 10003

	)

58 #define 
	#D_FMT
 10004

	)

59 #define 
	#T_FMT
 10005

	)

60 #define 
	#T_FMT_AMPM
 10006

	)

61 #define 
	#AM_STR
 10007

	)

62 #define 
	#PM_STR
 10008

	)

63 #define 
	#DAY_1
 10009

	)

64 #define 
	#DAY_2
 (
DAY_1
 + 1)

	)

65 #define 
	#DAY_3
 (
DAY_1
 + 2)

	)

66 #define 
	#DAY_4
 (
DAY_1
 + 3)

	)

67 #define 
	#DAY_5
 (
DAY_1
 + 4)

	)

68 #define 
	#DAY_6
 (
DAY_1
 + 5)

	)

69 #define 
	#DAY_7
 (
DAY_1
 + 6)

	)

70 #define 
	#ABDAY_1
 10016

	)

71 #define 
	#ABDAY_2
 (
ABDAY_1
 + 1)

	)

72 #define 
	#ABDAY_3
 (
ABDAY_1
 + 2)

	)

73 #define 
	#ABDAY_4
 (
ABDAY_1
 + 3)

	)

74 #define 
	#ABDAY_5
 (
ABDAY_1
 + 4)

	)

75 #define 
	#ABDAY_6
 (
ABDAY_1
 + 5)

	)

76 #define 
	#ABDAY_7
 (
ABDAY_1
 + 6)

	)

77 #define 
	#MON_1
 10023

	)

78 #define 
	#MON_2
 (
MON_1
 + 1)

	)

79 #define 
	#MON_3
 (
MON_1
 + 2)

	)

80 #define 
	#MON_4
 (
MON_1
 + 3)

	)

81 #define 
	#MON_5
 (
MON_1
 + 4)

	)

82 #define 
	#MON_6
 (
MON_1
 + 5)

	)

83 #define 
	#MON_7
 (
MON_1
 + 6)

	)

84 #define 
	#MON_8
 (
MON_1
 + 7)

	)

85 #define 
	#MON_9
 (
MON_1
 + 8)

	)

86 #define 
	#MON_10
 (
MON_1
 + 9)

	)

87 #define 
	#MON_11
 (
MON_1
 + 10)

	)

88 #define 
	#MON_12
 (
MON_1
 + 11)

	)

89 #define 
	#ABMON_1
 10035

	)

90 #define 
	#ABMON_2
 (
ABMON_1
 + 1)

	)

91 #define 
	#ABMON_3
 (
ABMON_1
 + 2)

	)

92 #define 
	#ABMON_4
 (
ABMON_1
 + 3)

	)

93 #define 
	#ABMON_5
 (
ABMON_1
 + 4)

	)

94 #define 
	#ABMON_6
 (
ABMON_1
 + 5)

	)

95 #define 
	#ABMON_7
 (
ABMON_1
 + 6)

	)

96 #define 
	#ABMON_8
 (
ABMON_1
 + 7)

	)

97 #define 
	#ABMON_9
 (
ABMON_1
 + 8)

	)

98 #define 
	#ABMON_10
 (
ABMON_1
 + 9)

	)

99 #define 
	#ABMON_11
 (
ABMON_1
 + 10)

	)

100 #define 
	#ABMON_12
 (
ABMON_1
 + 11)

	)

101 #define 
	#ERA
 10047

	)

102 #define 
	#ERA_D_FMT
 10048

	)

103 #define 
	#ERA_D_T_FMT
 10049

	)

104 #define 
	#ERA_T_FMT
 10050

	)

105 #define 
	#ALT_DIGITS
 10051

	)

107 #define 
	#CRNCYSTR
 10052

	)

109 #define 
	#YESEXPR
 10053

	)

110 #define 
	#NOEXPR
 10054

	)

116 #if !@
HAVE_LANGINFO_CODESET
@

117 #define 
	#CODESET
 10000

	)

118 #define 
	#GNULIB_defined_CODESET
 1

	)

121 #if !@
HAVE_LANGINFO_T_FMT_AMPM
@

122 #define 
	#T_FMT_AMPM
 10006

	)

123 #define 
	#GNULIB_defined_T_FMT_AMPM
 1

	)

126 #if !@
HAVE_LANGINFO_ERA
@

127 #define 
	#ERA
 10047

	)

128 #define 
	#ERA_D_FMT
 10048

	)

129 #define 
	#ERA_D_T_FMT
 10049

	)

130 #define 
	#ERA_T_FMT
 10050

	)

131 #define 
	#ALT_DIGITS
 10051

	)

132 #define 
	#GNULIB_defined_ERA
 1

	)

135 #if !@
HAVE_LANGINFO_YESEXPR
@

136 #define 
	#YESEXPR
 10053

	)

137 #define 
	#NOEXPR
 10054

	)

138 #define 
	#GNULIB_defined_YESEXPR
 1

	)

154 #if @
GNULIB_NL_LANGINFO
@

155 #if @
REPLACE_NL_LANGINFO
@

156 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

157 #undef 
nl_langinfo


158 #define 
	#nl_langinfo
 
rpl_nl_langinfo


	)

160 
_GL_FUNCDECL_RPL
 (
nl_langinfo
, char *, (
nl_item
 
item
));

161 
_GL_CXXALIAS_RPL
 (
nl_langinfo
, char *, (
nl_item
 
item
));

163 #if !@
HAVE_NL_LANGINFO
@

164 
_GL_FUNCDECL_SYS
 (
nl_langinfo
, char *, (
nl_item
 
item
));

166 
_GL_CXXALIAS_SYS
 (
nl_langinfo
, char *, (
nl_item
 
item
));

168 
_GL_CXXALIASWARN
 (
nl_langinfo
);

169 #elif 
defined
 
GNULIB_POSIXCHECK


170 #undef 
nl_langinfo


171 #if 
HAVE_RAW_DECL_NL_LANGINFO


172 
_GL_WARN_ON_USE
 (
nl_langinfo
, "nl_langinfo is not portable - "

	@lib/localcharset.c

23 #include 
	~<config.h
>

26 #include 
	~"localcharset.h
"

28 #include 
	~<fcntl.h
>

29 #include 
	~<stddef.h
>

30 #include 
	~<stdio.h
>

31 #include 
	~<string.h
>

32 #include 
	~<stdlib.h
>

34 #if 
defined
 
__APPLE__
 && defined 
__MACH__
 && 
HAVE_LANGINFO_CODESET


35 #define 
	#DARWIN7


	)

38 #if 
defined
 
_WIN32
 || defined 
__WIN32__


39 #define 
	#WIN32_NATIVE


	)

42 #if 
defined
 
__EMX__


44 #ifndef 
OS2


45 #define 
	#OS2


	)

49 #if !
defined
 
WIN32_NATIVE


50 #include 
	~<unistd.h
>

51 #if 
HAVE_LANGINFO_CODESET


52 #include 
	~<langinfo.h
>

55 #include 
	~<locale.h
>

58 #ifdef 
__CYGWIN__


59 #define 
	#WIN32_LEAN_AND_MEAN


	)

60 #include 
	~<windows.h
>

62 #elif 
defined
 
WIN32_NATIVE


63 #define 
	#WIN32_LEAN_AND_MEAN


	)

64 #include 
	~<windows.h
>

66 #if 
defined
 
OS2


67 #define 
	#INCL_DOS


	)

68 #include 
	~<os2.h
>

71 #if 
ENABLE_RELOCATABLE


72 #include 
	~"relocatable.h
"

74 #define 
	#relocate
(
pathname
) (pathname)

	)

78 #ifndef 
LIBDIR


79 #include 
	~"configmake.h
"

83 #ifndef 
O_NOFOLLOW


84 #define 
	#O_NOFOLLOW
 0

	)

87 #if 
defined
 
_WIN32
 || defined 
__WIN32__
 || defined 
__CYGWIN__
 || defined 
__EMX__
 || defined 
__DJGPP__


89 #define 
	#ISSLASH
(
C
) ((C) == '/' || (C) == '\\')

	)

92 #ifndef 
DIRECTORY_SEPARATOR


93 #define 
	#DIRECTORY_SEPARATOR
 '/'

	)

96 #ifndef 
ISSLASH


97 #define 
	#ISSLASH
(
C
) ((C) == 
DIRECTORY_SEPARATOR
)

	)

100 #if 
HAVE_DECL_GETC_UNLOCKED


101 #undef 
getc


102 #define 
	#getc
 
getc_unlocked


	)

111 #if 
__STDC__
 != 1

112 #define volatile

	)

117 static const char * volatile 
	gcharset_aliases
;

121 
	$get_charset_aliases
 (void)

123 const char *
cp
;

125 
cp
 = 
charset_aliases
;

126 if (
cp
 == 
NULL
)

128 #if !(
defined
 
DARWIN7
 || defined 
VMS
 || defined 
WIN32_NATIVE
 || defined 
__CYGWIN__
)

129 const char *
dir
;

130 const char *
base
 = "charset.alias";

131 char *
file_name
;

135 
dir
 = 
	`getenv
 ("CHARSETALIASDIR");

136 if (
dir
 == 
NULL
 || dir[0] == '\0')

137 
dir
 = 
	`relocate
 (
LIBDIR
);

141 
size_t
 
dir_len
 = 
	`strlen
 (
dir
);

142 
size_t
 
base_len
 = 
	`strlen
 (
base
);

143 int 
add_slash
 = (
dir_len
 > 0 && !
	`ISSLASH
 (
dir
[dir_len - 1]));

144 
file_name
 = (char *) 
	`malloc
 (
dir_len
 + 
add_slash
 + 
base_len
 + 1);

145 if (
file_name
 != 
NULL
)

147 
	`memcpy
 (
file_name
, 
dir
, 
dir_len
);

148 if (
add_slash
)

149 
file_name
[
dir_len
] = 
DIRECTORY_SEPARATOR
;

150 
	`memcpy
 (
file_name
 + 
dir_len
 + 
add_slash
, 
base
, 
base_len
 + 1);

154 if (
file_name
 == 
NULL
)

156 
cp
 = "";

159 int 
fd
;

168 
fd
 = 
	`open
 (
file_name
,

169 
O_RDONLY
 | (
HAVE_WORKING_O_NOFOLLOW
 ? 
O_NOFOLLOW
 : 0));

170 if (
fd
 < 0)

172 
cp
 = "";

175 
FILE
 *
fp
;

177 
fp
 = 
	`fdopen
 (
fd
, "r");

178 if (
fp
 == 
NULL
)

181 
	`close
 (
fd
);

182 
cp
 = "";

187 char *
res_ptr
 = 
NULL
;

188 
size_t
 
res_size
 = 0;

192 int 
c
;

193 char 
buf1
[50+1];

194 char 
buf2
[50+1];

195 
size_t
 
l1
, 
l2
;

196 char *
old_res_ptr
;

198 
c
 = 
	`getc
 (
fp
);

199 if (
c
 == 
EOF
)

201 if (
c
 == '\n' || c == ' ' || c == '\t')

203 if (
c
 == '#')

207 
c
 = 
	`getc
 (
fp
);

208 while (!(
c
 == 
EOF
 || c == '\n'));

209 if (
c
 == 
EOF
)

213 
	`ungetc
 (
c
, 
fp
);

214 if (
	`fscanf
 (
fp
, "%50s %50s", 
buf1
, 
buf2
) < 2)

216 
l1
 = 
	`strlen
 (
buf1
);

217 
l2
 = 
	`strlen
 (
buf2
);

218 
old_res_ptr
 = 
res_ptr
;

219 if (
res_size
 == 0)

221 
res_size
 = 
l1
 + 1 + 
l2
 + 1;

222 
res_ptr
 = (char *) 
	`malloc
 (
res_size
 + 1);

226 
res_size
 += 
l1
 + 1 + 
l2
 + 1;

227 
res_ptr
 = (char *) 
	`realloc
 (res_ptr, 
res_size
 + 1);

229 if (
res_ptr
 == 
NULL
)

232 
res_size
 = 0;

233 
	`free
 (
old_res_ptr
);

236 
	`strcpy
 (
res_ptr
 + 
res_size
 - (
l2
 + 1) - (
l1
 + 1), 
buf1
);

237 
	`strcpy
 (
res_ptr
 + 
res_size
 - (
l2
 + 1), 
buf2
);

239 
	`fclose
 (
fp
);

240 if (
res_size
 == 0)

241 
cp
 = "";

244 *(
res_ptr
 + 
res_size
) = '\0';

245 
cp
 = 
res_ptr
;

250 
	`free
 (
file_name
);

255 #if 
defined
 
DARWIN7


259 
cp
 = "ISO8859-1" "\0" "ISO-8859-1" "\0"

288 #if 
defined
 
VMS


294 
cp
 = "ISO8859-1" "\0" "ISO-8859-1" "\0"

313 #if 
defined
 
WIN32_NATIVE
 || defined 
__CYGWIN__


318 
cp
 = "CP936" "\0" "GBK" "\0"

344 
charset_aliases
 = 
cp
;

347 return 
cp
;

348 
	}
}

356 #ifdef 
STATIC


357 
	gSTATIC


360 
	$locale_charset
 (void)

362 const char *
codeset
;

363 const char *
aliases
;

365 #if !(
defined
 
WIN32_NATIVE
 || defined 
OS2
)

367 #if 
HAVE_LANGINFO_CODESET


370 
codeset
 = 
	`nl_langinfo
 (
CODESET
);

372 #ifdef 
__CYGWIN__


376 if (
codeset
 != 
NULL
 && 
	`strcmp
 (codeset, "US-ASCII") == 0)

378 const char *
locale
;

379 static char 
buf
[2 + 10 + 1];

381 
locale
 = 
	`getenv
 ("LC_ALL");

382 if (
locale
 == 
NULL
 || locale[0] == '\0')

384 
locale
 = 
	`getenv
 ("LC_CTYPE");

385 if (
locale
 == 
NULL
 || locale[0] == '\0')

386 
locale
 = 
	`getenv
 ("LANG");

388 if (
locale
 != 
NULL
 && locale[0] != '\0')

392 const char *
dot
 = 
	`strchr
 (
locale
, '.');

394 if (
dot
 != 
NULL
)

396 const char *
modifier
;

398 
dot
++;

400 
modifier
 = 
	`strchr
 (
dot
, '@');

401 if (
modifier
 == 
NULL
)

402 return 
dot
;

403 if (
modifier
 - 
dot
 < sizeof (
buf
))

405 
	`memcpy
 (
buf
, 
dot
, 
modifier
 - dot);

406 
buf
 [
modifier
 - 
dot
] = '\0';

407 return 
buf
;

423 
	`sprintf
 (
buf
, "CP%u", 
	`GetACP
 ());

424 
codeset
 = 
buf
;

431 const char *
locale
 = 
NULL
;

438 
locale
 = 
	`setlocale
 (
LC_CTYPE
, 
NULL
);

440 if (
locale
 == 
NULL
 || locale[0] == '\0')

442 
locale
 = 
	`getenv
 ("LC_ALL");

443 if (
locale
 == 
NULL
 || locale[0] == '\0')

445 
locale
 = 
	`getenv
 ("LC_CTYPE");

446 if (
locale
 == 
NULL
 || locale[0] == '\0')

447 
locale
 = 
	`getenv
 ("LANG");

454 
codeset
 = 
locale
;

458 #elif 
defined
 
WIN32_NATIVE


460 static char 
buf
[2 + 10 + 1];

469 
	`sprintf
 (
buf
, "CP%u", 
	`GetACP
 ());

470 
codeset
 = 
buf
;

472 #elif 
defined
 
OS2


474 const char *
locale
;

475 static char 
buf
[2 + 10 + 1];

476 
ULONG
 
cp
[3];

477 
ULONG
 
cplen
;

481 
locale
 = 
	`getenv
 ("LC_ALL");

482 if (
locale
 == 
NULL
 || locale[0] == '\0')

484 
locale
 = 
	`getenv
 ("LC_CTYPE");

485 if (
locale
 == 
NULL
 || locale[0] == '\0')

486 
locale
 = 
	`getenv
 ("LANG");

488 if (
locale
 != 
NULL
 && locale[0] != '\0')

491 const char *
dot
 = 
	`strchr
 (
locale
, '.');

493 if (
dot
 != 
NULL
)

495 const char *
modifier
;

497 
dot
++;

499 
modifier
 = 
	`strchr
 (
dot
, '@');

500 if (
modifier
 == 
NULL
)

501 return 
dot
;

502 if (
modifier
 - 
dot
 < sizeof (
buf
))

504 
	`memcpy
 (
buf
, 
dot
, 
modifier
 - dot);

505 
buf
 [
modifier
 - 
dot
] = '\0';

506 return 
buf
;

511 
codeset
 = 
locale
;

516 if (
	`DosQueryCp
 (sizeof (
cp
), cp, &
cplen
))

517 
codeset
 = "";

520 
	`sprintf
 (
buf
, "CP%u", 
cp
[0]);

521 
codeset
 = 
buf
;

527 if (
codeset
 == 
NULL
)

529 
codeset
 = "";

532 for (
aliases
 = 
	`get_charset_aliases
 ();

533 *
aliases
 != '\0';

534 
aliases
 += 
	`strlen
 (aliases) + 1, aliases += strlen (aliases) + 1)

535 if (
	`strcmp
 (
codeset
, 
aliases
) == 0

536 || (
aliases
[0] == '*' && aliases[1] == '\0'))

538 
codeset
 = 
aliases
 + 
	`strlen
 (aliases) + 1;

545 if (
codeset
[0] == '\0')

546 
codeset
 = "ASCII";

548 return 
codeset
;

549 
	}
}

	@lib/localcharset.h

21 #ifndef 
_LOCALCHARSET_H


22 #define 
	#_LOCALCHARSET_H


	)

25 #ifdef 
__cplusplus


35 extern const char * 
locale_charset
 (void);

38 #ifdef 
__cplusplus


	@lib/locale.in.h

17 #ifndef 
_
@
GUARD_PREFIX
@
_LOCALE_H


19 #if 
__GNUC__
 >= 3

20 @
	gPRAGMA_SYSTEM_HEADER
@

22 @
	gPRAGMA_COLUMNS
@

25 #@
INCLUDE_NEXT
@ @
NEXT_LOCALE_H
@

27 #ifndef 
_
@
GUARD_PREFIX
@
_LOCALE_H


28 #define 
	#_
@
GUARD_PREFIX
@
_LOCALE_H


	)

31 #include 
	~<stddef.h
>

34 #if @
HAVE_XLOCALE_H
@

35 #include 
	~<xlocale.h
>

46 #if !
defined
 
LC_MESSAGES


47 #define 
	#LC_MESSAGES
 1729

	)

50 #if @
GNULIB_SETLOCALE
@

51 #if @
REPLACE_SETLOCALE
@

52 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

53 #undef 
setlocale


54 #define 
	#setlocale
 
rpl_setlocale


	)

55 #define 
	#GNULIB_defined_setlocale
 1

	)

57 
_GL_FUNCDECL_RPL
 (
setlocale
, char *, (int 
category
, const char *
locale
));

58 
_GL_CXXALIAS_RPL
 (
setlocale
, char *, (int 
category
, const char *
locale
));

60 
_GL_CXXALIAS_SYS
 (
setlocale
, char *, (int 
category
, const char *
locale
));

62 
_GL_CXXALIASWARN
 (
setlocale
);

63 #elif 
defined
 
GNULIB_POSIXCHECK


64 #undef 
setlocale


65 #if 
HAVE_RAW_DECL_SETLOCALE


66 
_GL_WARN_ON_USE
 (
setlocale
, "setlocale works differently on native Windows - "

71 #if @
GNULIB_DUPLOCALE
@

72 #if @
REPLACE_DUPLOCALE
@

73 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

74 #undef 
duplocale


75 #define 
	#duplocale
 
rpl_duplocale


	)

77 
_GL_FUNCDECL_RPL
 (
duplocale
, 
locale_t
, (locale_t 
locale
) 
_GL_ARG_NONNULL
 ((1)));

78 
_GL_CXXALIAS_RPL
 (
duplocale
, 
locale_t
, (locale_t 
locale
));

80 #if @
HAVE_DUPLOCALE
@

81 
_GL_CXXALIAS_SYS
 (
duplocale
, 
locale_t
, (locale_t 
locale
));

84 #if @
HAVE_DUPLOCALE
@

85 
_GL_CXXALIASWARN
 (
duplocale
);

87 #elif 
defined
 
GNULIB_POSIXCHECK


88 #undef 
duplocale


89 #if 
HAVE_RAW_DECL_DUPLOCALE


90 
_GL_WARN_ON_USE
 (
duplocale
, "duplocale is buggy on some glibc systems - "

	@lib/lseek.c

20 #include 
	~<config.h
>

23 #include 
	~<unistd.h
>

25 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


28 #include 
	~<windows.h
>

30 #include 
	~"msvc-nothrow.h
"

32 #include 
	~<sys/stat.h
>

34 #include 
	~<errno.h
>

36 #undef 
lseek


38 
off_t


39 
	$rpl_lseek
 (int 
fd
, 
off_t
 
offset
, int 
whence
)

41 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


43 
HANDLE
 
h
 = (HANDLE) 
	`_get_osfhandle
 (
fd
);

44 if (
h
 == 
INVALID_HANDLE_VALUE
)

46 
errno
 = 
EBADF
;

49 if (
	`GetFileType
 (
h
) != 
FILE_TYPE_DISK
)

51 
errno
 = 
ESPIPE
;

56 struct 
stat
 
statbuf
;

57 if (
	`fstat
 (
fd
, &
statbuf
) < 0)

59 if (!
	`S_ISREG
 (
statbuf
.
st_mode
))

61 
errno
 = 
ESPIPE
;

65 return 
	`lseek
 (
fd
, 
offset
, 
whence
);

66 
	}
}

	@lib/malloc.c

23 #define 
	#_GL_USE_STDLIB_ALLOC
 1

	)

24 #include 
	~<config.h
>

26 #ifdef 
malloc


27 #define 
	#NEED_MALLOC_GNU
 1

	)

28 #undef 
malloc


30 #elif 
GNULIB_MALLOC_GNU
 && !
HAVE_MALLOC_GNU


31 #define 
	#NEED_MALLOC_GNU
 1

	)

34 #include 
	~<stdlib.h
>

36 #include 
	~<errno.h
>

42 
	$rpl_malloc
 (
size_t
 
n
)

44 void *
result
;

46 #if 
NEED_MALLOC_GNU


47 if (
n
 == 0)

48 
n
 = 1;

51 
result
 = 
	`malloc
 (
n
);

53 #if !
HAVE_MALLOC_POSIX


54 if (
result
 == 
NULL
)

55 
errno
 = 
ENOMEM
;

58 return 
result
;

59 
	}
}

	@lib/malloca.c

21 #define 
	#_GL_USE_STDLIB_ALLOC
 1

	)

22 #include 
	~<config.h
>

25 #include 
	~"malloca.h
"

27 #include 
	~"verify.h
"

34 #if 
HAVE_ALLOCA


49 #define 
	#MAGIC_NUMBER
 0x1415fb4a

	)

50 #define 
	#MAGIC_SIZE
 sizeof (int)

	)

53 struct 
	spreliminary_header
 { void *
	mnext
; char 
	mroom
[
MAGIC_SIZE
]; };

55 #define 
	#HEADER_SIZE
 \

56 (((sizeof (struct 
preliminary_header
) + 
sa_alignment_max
 - 1) / sa_alignment_max) * sa_alignment_max)

	)

57 struct 
	sheader
 { void *
	mnext
; char 
	mroom
[
HEADER_SIZE
 - sizeof (struct 
preliminary_header
) + 
MAGIC_SIZE
]; };

58 
verify
 (
HEADER_SIZE
 == sizeof (struct 
header
));

63 #define 
	#HASH_TABLE_SIZE
 257

	)

64 static void * 
	gmmalloca_results
[
HASH_TABLE_SIZE
];

69 
	$mmalloca
 (
size_t
 
n
)

71 #if 
HAVE_ALLOCA


74 
size_t
 
nplus
 = 
n
 + 
HEADER_SIZE
;

76 if (
nplus
 >= 
n
)

78 char *
p
 = (char *) 
	`malloc
 (
nplus
);

80 if (
p
 != 
NULL
)

82 
size_t
 
slot
;

84 
p
 += 
HEADER_SIZE
;

87 ((int *) 
p
)[-1] = 
MAGIC_NUMBER
;

90 
slot
 = (unsigned long) 
p
 % 
HASH_TABLE_SIZE
;

91 ((struct 
header
 *) (
p
 - 
HEADER_SIZE
))->
next
 = 
mmalloca_results
[
slot
];

92 
mmalloca_results
[
slot
] = 
p
;

94 return 
p
;

98 return 
NULL
;

100 #if !
MALLOC_0_IS_NONNULL


101 if (
n
 == 0)

102 
n
 = 1;

104 return 
	`malloc
 (
n
);

106 
	}
}

108 #if 
HAVE_ALLOCA


110 
	$freea
 (void *
p
)

113 if (
p
 != 
NULL
)

119 if (((int *) 
p
)[-1] == 
MAGIC_NUMBER
)

123 
size_t
 
slot
 = (unsigned long) 
p
 % 
HASH_TABLE_SIZE
;

124 void **
chain
 = &
mmalloca_results
[
slot
];

125 for (; *
chain
 != 
NULL
;)

127 if (*
chain
 == 
p
)

130 char *
p_begin
 = (char *) 
p
 - 
HEADER_SIZE
;

131 *
chain
 = ((struct 
header
 *) 
p_begin
)->
next
;

132 
	`free
 (
p_begin
);

135 
chain
 = &((struct 
header
 *) ((char *) *chain - 
HEADER_SIZE
))->
next
;

140 
	}
}

	@lib/malloca.h

21 #ifndef 
_MALLOCA_H


22 #define 
	#_MALLOCA_H


	)

24 #include 
	~<alloca.h
>

25 #include 
	~<stddef.h
>

26 #include 
	~<stdlib.h
>

29 #ifdef 
__cplusplus


43 #if 
HAVE_ALLOCA


49 #define 
	#safe_alloca
(
N
) ((N) < 4032 ? 
	`alloca
 (N) : 
NULL
)

	)

51 #define 
	#safe_alloca
(
N
) ((void) (N), 
NULL
)

	)

57 #if 
HAVE_ALLOCA


58 #define 
	#malloca
(
N
) \

59 ((
N
) < 4032 - 
sa_increment
 \

60 ? (void *) ((char *) 
	`alloca
 ((
N
) + 
sa_increment
) + sa_increment) \

61 : 
	`mmalloca
 (
N
))

	)

63 #define 
	#malloca
(
N
) \

64 
	`mmalloca
 (
N
)

	)

66 extern void * 
mmalloca
 (
size_t
 
n
);

69 #if 
HAVE_ALLOCA


70 extern void 
freea
 (void *
p
);

72 #define 
	#freea
 
free


	)

81 #define 
	#nmalloca
(
n
, 
s
) \

82 ((
n
) > (
size_t
) (sizeof (
ptrdiff_t
) <= sizeof (size_t) ? -1 : -2) / (
s
) \

83 ? 
NULL
 \

84 : 
	`malloca
 ((
n
) * (
s
)))

	)

86 extern void * 
nmalloca
 (
size_t
 
n
, size_t 
s
);

90 #ifdef 
__cplusplus


98 #if 
defined
 
__GNUC__


99 #define 
	#sa_alignof
 
__alignof__


	)

100 #elif 
defined
 
__cplusplus


101 
	gtemplate
 <
class
 
	gtype
> struct 
	ssa_alignof_helper
 { char 
	g__slot1
; 
type
 
	g__slot2
; };

102 #define 
	#sa_alignof
(
type
) 
	`offsetof
 (
sa_alignof_helper
<type>, 
__slot2
)

	)

103 #elif 
defined
 
__hpux


106 #define 
	#sa_alignof
(
type
) (sizeof (type) <= 4 ? 4 : 8)

	)

107 #elif 
defined
 
_AIX


110 #define 
	#sa_alignof
(
type
) (sizeof (type) <= 4 ? 4 : 8)

	)

112 #define 
	#sa_alignof
(
type
) 
	`offsetof
 (struct { char 
__slot1
; type 
__slot2
; }, __slot2)

	)

119 
	gsa_alignment_long
 = 
sa_alignof
 (long),

120 
	gsa_alignment_double
 = 
sa_alignof
 (double),

121 #if 
HAVE_LONG_LONG_INT


122 
	gsa_alignment_longlong
 = 
sa_alignof
 (long long),

124 
	gsa_alignment_longdouble
 = 
sa_alignof
 (long double),

125 
	gsa_alignment_max
 = ((
sa_alignment_long
 - 1) | (
sa_alignment_double
 - 1)

126 #if 
HAVE_LONG_LONG_INT


127 | (
sa_alignment_longlong
 - 1)

129 | (
sa_alignment_longdouble
 - 1)

133 
	gsa_increment
 = ((sizeof (int) + 
sa_alignment_max
 - 1) / sa_alignment_max) * sa_alignment_max

	@lib/mbchar.c

17 #include 
	~<config.h
>

19 #include 
	~<limits.h
>

21 #include 
	~"mbchar.h
"

23 #if 
IS_BASIC_ASCII


26 const unsigned int 
	gis_basic_table
 [
UCHAR_MAX
 / 32 + 1] =

	@lib/mbchar.h

144 #ifndef 
_MBCHAR_H


145 #define 
	#_MBCHAR_H
 1

	)

147 #include 
	~<stdbool.h
>

148 #include 
	~<string.h
>

154 #include 
	~<stdio.h
>

155 #include 
	~<time.h
>

156 #include 
	~<wchar.h
>

157 #include 
	~<wctype.h
>

159 #define 
	#MBCHAR_BUF_SIZE
 24

	)

161 struct 
	smbchar


163 const char *
	mptr
;

164 
size_t
 
	mbytes
;

165 
bool
 
	mwc_valid
;

166 
wchar_t
 
	mwc
;

167 char 
	mbuf
[
MBCHAR_BUF_SIZE
];

173 typedef struct 
mbchar
 
	tmbchar_t
;

176 #define 
	#mb_ptr
(
mbc
) ((mbc).
ptr
)

	)

177 #define 
	#mb_len
(
mbc
) ((mbc).
bytes
)

	)

180 #define 
	#mb_iseq
(
mbc
, 
sc
) ((mbc).
wc_valid
 && (mbc).
wc
 == (sc))

	)

181 #define 
	#mb_isnul
(
mbc
) ((mbc).
wc_valid
 && (mbc).
wc
 == 0)

	)

182 #define 
	#mb_cmp
(
mbc1
, 
mbc2
) \

183 ((
mbc1
).
wc_valid
 \

184 ? ((
mbc2
).
wc_valid
 \

185 ? (int) (
mbc1
).
wc
 - (int) (
mbc2
).wc \

187 : ((
mbc2
).
wc_valid
 \

189 : (
mbc1
).
bytes
 == (
mbc2
).bytes \

190 ? 
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc1).
bytes
) \

191 : (
mbc1
).
bytes
 < (
mbc2
).bytes \

192 ? (
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc1).
bytes
) > 0 ? 1 : -1) \

193 : (
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc2).
bytes
) >= 0 ? 1 : -1)))

	)

194 #define 
	#mb_casecmp
(
mbc1
, 
mbc2
) \

195 ((
mbc1
).
wc_valid
 \

196 ? ((
mbc2
).
wc_valid
 \

197 ? (int) 
	`towlower
 ((
mbc1
).
wc
) - (int) towlower ((
mbc2
).wc) \

199 : ((
mbc2
).
wc_valid
 \

201 : (
mbc1
).
bytes
 == (
mbc2
).bytes \

202 ? 
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc1).
bytes
) \

203 : (
mbc1
).
bytes
 < (
mbc2
).bytes \

204 ? (
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc1).
bytes
) > 0 ? 1 : -1) \

205 : (
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc2).
bytes
) >= 0 ? 1 : -1)))

	)

206 #define 
	#mb_equal
(
mbc1
, 
mbc2
) \

207 ((
mbc1
).
wc_valid
 && (
mbc2
).wc_valid \

208 ? (
mbc1
).
wc
 == (
mbc2
).wc \

209 : (
mbc1
).
bytes
 == (
mbc2
).bytes \

210 && 
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc1).
bytes
) == 0)

	)

211 #define 
	#mb_caseequal
(
mbc1
, 
mbc2
) \

212 ((
mbc1
).
wc_valid
 && (
mbc2
).wc_valid \

213 ? 
	`towlower
 ((
mbc1
).
wc
) == towlower ((
mbc2
).wc) \

214 : (
mbc1
).
bytes
 == (
mbc2
).bytes \

215 && 
	`memcmp
 ((
mbc1
).
ptr
, (
mbc2
).ptr, (mbc1).
bytes
) == 0)

	)

218 #define 
	#mb_isascii
(
mbc
) \

219 ((
mbc
).
wc_valid
 && (mbc).
wc
 >= 0 && (mbc).wc <= 127)

	)

220 #define 
	#mb_isalnum
(
mbc
) ((mbc).
wc_valid
 && 
	`iswalnum
 ((mbc).
wc
))

	)

221 #define 
	#mb_isalpha
(
mbc
) ((mbc).
wc_valid
 && 
	`iswalpha
 ((mbc).
wc
))

	)

222 #define 
	#mb_isblank
(
mbc
) ((mbc).
wc_valid
 && 
	`iswblank
 ((mbc).
wc
))

	)

223 #define 
	#mb_iscntrl
(
mbc
) ((mbc).
wc_valid
 && 
	`iswcntrl
 ((mbc).
wc
))

	)

224 #define 
	#mb_isdigit
(
mbc
) ((mbc).
wc_valid
 && 
	`iswdigit
 ((mbc).
wc
))

	)

225 #define 
	#mb_isgraph
(
mbc
) ((mbc).
wc_valid
 && 
	`iswgraph
 ((mbc).
wc
))

	)

226 #define 
	#mb_islower
(
mbc
) ((mbc).
wc_valid
 && 
	`iswlower
 ((mbc).
wc
))

	)

227 #define 
	#mb_isprint
(
mbc
) ((mbc).
wc_valid
 && 
	`iswprint
 ((mbc).
wc
))

	)

228 #define 
	#mb_ispunct
(
mbc
) ((mbc).
wc_valid
 && 
	`iswpunct
 ((mbc).
wc
))

	)

229 #define 
	#mb_isspace
(
mbc
) ((mbc).
wc_valid
 && 
	`iswspace
 ((mbc).
wc
))

	)

230 #define 
	#mb_isupper
(
mbc
) ((mbc).
wc_valid
 && 
	`iswupper
 ((mbc).
wc
))

	)

231 #define 
	#mb_isxdigit
(
mbc
) ((mbc).
wc_valid
 && 
	`iswxdigit
 ((mbc).
wc
))

	)

236 #define 
	#MB_UNPRINTABLE_WIDTH
 1

	)

238 static 
inline
 int

239 
	$mb_width_aux
 (
wint_t
 
wc
)

241 int 
w
 = 
	`wcwidth
 (
wc
);

244 return (
w
 >= 0 ? w : 
	`iswcntrl
 (
wc
) ? 0 : 
MB_UNPRINTABLE_WIDTH
);

245 
	}
}

247 #define 
	#mb_width
(
mbc
) \

248 ((
mbc
).
wc_valid
 ? 
	`mb_width_aux
 ((mbc).
wc
) : 
MB_UNPRINTABLE_WIDTH
)

	)

251 #define 
	#mb_putc
(
mbc
, 
stream
) 
	`fwrite
 ((mbc).
ptr
, 1, (mbc).
bytes
, (stream))

	)

254 #define 
	#mb_setascii
(
mbc
, 
sc
) \

255 ((
mbc
)->
ptr
 = (mbc)->
buf
, (mbc)->
bytes
 = 1, (mbc)->
wc_valid
 = 1, \

256 (
mbc
)->
wc
 = (mbc)->
buf
[0] = (
sc
))

	)

259 static 
inline
 void

260 
	$mb_copy
 (
mbchar_t
 *
new_mbc
, const mbchar_t *
old_mbc
)

262 if (
old_mbc
->
ptr
 == &old_mbc->
buf
[0])

264 
	`memcpy
 (&
new_mbc
->
buf
[0], &
old_mbc
->buf[0], old_mbc->
bytes
);

265 
new_mbc
->
ptr
 = &new_mbc->
buf
[0];

268 
new_mbc
->
ptr
 = 
old_mbc
->ptr;

269 
new_mbc
->
bytes
 = 
old_mbc
->bytes;

270 if ((
new_mbc
->
wc_valid
 = 
old_mbc
->wc_valid))

271 
new_mbc
->
wc
 = 
old_mbc
->wc;

272 
	}
}

303 #define 
	#IS_BASIC_ASCII
 1

	)

305 extern const unsigned int 
is_basic_table
[];

307 static 
inline
 
bool


308 
	$is_basic
 (char 
c
)

310 return (
is_basic_table
 [(unsigned char) 
c
 >> 5] >> ((unsigned char) c & 31))

312 
	}
}

316 static 
inline
 
bool


317 
	$is_basic
 (char 
c
)

319 switch (
c
)

346 
	}
}

	@lib/mbiter.h

82 #ifndef 
_MBITER_H


83 #define 
	#_MBITER_H
 1

	)

85 #include 
	~<assert.h
>

86 #include 
	~<stdbool.h
>

87 #include 
	~<stddef.h
>

88 #include 
	~<string.h
>

94 #include 
	~<stdio.h
>

95 #include 
	~<time.h
>

96 #include 
	~<wchar.h
>

98 #include 
	~"mbchar.h
"

100 struct 
	smbiter_multi


102 const char *
	mlimit
;

103 
bool
 
	min_shift
;

104 
mbstate_t
 
	mstate
;

105 
bool
 
	mnext_done
;

106 struct 
mbchar
 
	mcur
;

115 static 
inline
 void

116 
	$mbiter_multi_next
 (struct 
mbiter_multi
 *
iter
)

118 if (
iter
->
next_done
)

120 if (
iter
->
in_shift
)

121 goto 
with_shift
;

123 if (
	`is_basic
 (*
iter
->
cur
.
ptr
))

128 
iter
->
cur
.
bytes
 = 1;

129 
iter
->
cur
.
wc
 = *iter->cur.
ptr
;

130 
iter
->
cur
.
wc_valid
 = 
true
;

134 
	`assert
 (
	`mbsinit
 (&
iter
->
state
));

135 
iter
->
in_shift
 = 
true
;

136 
with_shift
:

137 
iter
->
cur
.
bytes
 = 
	`mbrtowc
 (&iter->cur.
wc
, iter->cur.
ptr
,

138 
iter
->
limit
 - iter->
cur
.
ptr
, &iter->
state
);

139 if (
iter
->
cur
.
bytes
 == (
size_t
) -1)

142 
iter
->
cur
.
bytes
 = 1;

143 
iter
->
cur
.
wc_valid
 = 
false
;

147 else if (
iter
->
cur
.
bytes
 == (
size_t
) -2)

150 
iter
->
cur
.
bytes
 = iter->
limit
 - iter->cur.
ptr
;

151 
iter
->
cur
.
wc_valid
 = 
false
;

157 if (
iter
->
cur
.
bytes
 == 0)

160 
iter
->
cur
.
bytes
 = 1;

161 
	`assert
 (*
iter
->
cur
.
ptr
 == '\0');

162 
	`assert
 (
iter
->
cur
.
wc
 == 0);

164 
iter
->
cur
.
wc_valid
 = 
true
;

168 if (
	`mbsinit
 (&
iter
->
state
))

169 
iter
->
in_shift
 = 
false
;

172 
iter
->
next_done
 = 
true
;

173 
	}
}

175 static 
inline
 void

176 
	$mbiter_multi_reloc
 (struct 
mbiter_multi
 *
iter
, 
ptrdiff_t
 
ptrdiff
)

178 
iter
->
cur
.
ptr
 += 
ptrdiff
;

179 
iter
->
limit
 += 
ptrdiff
;

180 
	}
}

182 static 
inline
 void

183 
	$mbiter_multi_copy
 (struct 
mbiter_multi
 *
new_iter
, const struct mbiter_multi *
old_iter
)

185 
new_iter
->
limit
 = 
old_iter
->limit;

186 if ((
new_iter
->
in_shift
 = 
old_iter
->in_shift))

187 
	`memcpy
 (&
new_iter
->
state
, &
old_iter
->state, sizeof (
mbstate_t
));

189 
	`memset
 (&
new_iter
->
state
, 0, sizeof (
mbstate_t
));

190 
new_iter
->
next_done
 = 
old_iter
->next_done;

191 
	`mb_copy
 (&
new_iter
->
cur
, &
old_iter
->cur);

192 
	}
}

195 typedef struct 
mbiter_multi
 
	tmbi_iterator_t
;

196 #define 
	#mbi_init
(
iter
, 
startptr
, 
length
) \

197 ((
iter
).
cur
.
ptr
 = (
startptr
), (iter).
limit
 = (iter).cur.ptr + (
length
), \

198 (
iter
).
in_shift
 = 
false
, 
	`memset
 (&(iter).
state
, '\0', sizeof (
mbstate_t
)), \

199 (
iter
).
next_done
 = 
false
)

	)

200 #define 
	#mbi_avail
(
iter
) \

201 ((
iter
).
cur
.
ptr
 < (iter).
limit
 && (
	`mbiter_multi_next
 (&(iter)), 
true
))

	)

202 #define 
	#mbi_advance
(
iter
) \

203 ((
iter
).
cur
.
ptr
 += (iter).cur.
bytes
, (iter).
next_done
 = 
false
)

	)

206 #define 
	#mbi_cur
(
iter
) (iter).
cur


	)

207 #define 
	#mbi_cur_ptr
(
iter
) (iter).
cur
.
ptr


	)

210 #define 
	#mbi_reloc
(
iter
, 
ptrdiff
) 
	`mbiter_multi_reloc
 (&iter, ptrdiff)

	)

213 #define 
	#mbi_copy
 
mbiter_multi_copy


	)

	@lib/mbrlen.c

18 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

24 static 
mbstate_t
 
	ginternal_state
;

26 
size_t


27 
	$mbrlen
 (const char *
s
, 
size_t
 
n
, 
mbstate_t
 *
ps
)

29 if (
ps
 == 
NULL
)

30 
ps
 = &
internal_state
;

31 return 
	`mbrtowc
 (
NULL
, 
s
, 
n
, 
ps
);

32 
	}
}

	@lib/mbrtowc.c

18 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #if 
GNULIB_defined_mbstate_t


26 #include 
	~<errno.h
>

27 #include 
	~<stdlib.h
>

29 #include 
	~"localcharset.h
"

30 #include 
	~"streq.h
"

31 #include 
	~"verify.h
"

34 
verify
 (sizeof (
mbstate_t
) >= 4);

36 static char 
	ginternal_state
[4];

38 
size_t


39 
	$mbrtowc
 (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
, 
mbstate_t
 *
ps
)

41 char *
pstate
 = (char *)
ps
;

43 if (
s
 == 
NULL
)

45 
pwc
 = 
NULL
;

46 
s
 = "";

47 
n
 = 1;

50 if (
n
 == 0)

51 return (
size_t
)(-2);

55 if (
pstate
 == 
NULL
)

56 
pstate
 = 
internal_state
;

59 
size_t
 
nstate
 = 
pstate
[0];

60 char 
buf
[4];

61 const char *
p
;

62 
size_t
 
m
;

64 switch (
nstate
)

67 
p
 = 
s
;

68 
m
 = 
n
;

71 
buf
[2] = 
pstate
[3];

74 
buf
[1] = 
pstate
[2];

77 
buf
[0] = 
pstate
[1];

78 
p
 = 
buf
;

79 
m
 = 
nstate
;

80 
buf
[
m
++] = 
s
[0];

81 if (
n
 >= 2 && 
m
 < 4)

83 
buf
[
m
++] = 
s
[1];

84 if (
n
 >= 3 && 
m
 < 4)

85 
buf
[
m
++] = 
s
[2];

89 
errno
 = 
EINVAL
;

90 return (
size_t
)(-1);

95 #if 
__GLIBC__
 || 
defined
 
__UCLIBC__


97 
	`mbtowc
 (
NULL
, NULL, 0);

100 int 
res
 = 
	`mbtowc
 (
pwc
, 
p
, 
m
);

102 if (
res
 >= 0)

104 if (
pwc
 != 
NULL
 && ((*pwc == 0) != (
res
 == 0)))

105 
	`abort
 ();

106 if (
nstate
 >= (
res
 > 0 ? res : 1))

107 
	`abort
 ();

108 
res
 -= 
nstate
;

109 
pstate
[0] = 0;

110 return 
res
;

125 if (
m
 >= 4 || m >= 
MB_CUR_MAX
)

126 goto 
invalid
;

129 const char *
encoding
 = 
	`locale_charset
 ();

131 if (
	`STREQ
 (
encoding
, "UTF-8", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))

134 unsigned char 
c
 = (unsigned char) 
p
[0];

136 if (
c
 >= 0xc2)

138 if (
c
 < 0xe0)

140 if (
m
 == 1)

141 goto 
incomplete
;

143 else if (
c
 < 0xf0)

145 if (
m
 == 1)

146 goto 
incomplete
;

147 if (
m
 == 2)

149 unsigned char 
c2
 = (unsigned char) 
p
[1];

151 if ((
c2
 ^ 0x80) < 0x40

152 && (
c
 >= 0xe1 || 
c2
 >= 0xa0)

153 && (
c
 != 0xed || 
c2
 < 0xa0))

154 goto 
incomplete
;

157 else if (
c
 <= 0xf4)

159 if (
m
 == 1)

160 goto 
incomplete
;

163 unsigned char 
c2
 = (unsigned char) 
p
[1];

165 if ((
c2
 ^ 0x80) < 0x40

166 && (
c
 >= 0xf1 || 
c2
 >= 0x90)

167 && (
c
 < 0xf4 || (c == 0xf4 && 
c2
 < 0x90)))

169 if (
m
 == 2)

170 goto 
incomplete
;

173 unsigned char 
c3
 = (unsigned char) 
p
[2];

175 if ((
c3
 ^ 0x80) < 0x40)

176 goto 
incomplete
;

182 goto 
invalid
;

188 if (
	`STREQ
 (
encoding
, "EUC-JP", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))

190 if (
m
 == 1)

192 unsigned char 
c
 = (unsigned char) 
p
[0];

194 if ((
c
 >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)

195 goto 
incomplete
;

197 if (
m
 == 2)

199 unsigned char 
c
 = (unsigned char) 
p
[0];

201 if (
c
 == 0x8f)

203 unsigned char 
c2
 = (unsigned char) 
p
[1];

205 if (
c2
 >= 0xa1 && c2 < 0xff)

206 goto 
incomplete
;

209 goto 
invalid
;

211 if (
	`STREQ
 (
encoding
, "EUC-KR", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)

212 || 
	`STREQ
 (
encoding
, "GB2312", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)

213 || 
	`STREQ
 (
encoding
, "BIG5", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))

215 if (
m
 == 1)

217 unsigned char 
c
 = (unsigned char) 
p
[0];

219 if (
c
 >= 0xa1 && c < 0xff)

220 goto 
incomplete
;

222 goto 
invalid
;

224 if (
	`STREQ
 (
encoding
, "EUC-TW", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))

226 if (
m
 == 1)

228 unsigned char 
c
 = (unsigned char) 
p
[0];

230 if ((
c
 >= 0xa1 && c < 0xff) || c == 0x8e)

231 goto 
incomplete
;

235 unsigned char 
c
 = (unsigned char) 
p
[0];

237 if (
c
 == 0x8e)

238 goto 
incomplete
;

240 goto 
invalid
;

242 if (
	`STREQ
 (
encoding
, "GB18030", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))

244 if (
m
 == 1)

246 unsigned char 
c
 = (unsigned char) 
p
[0];

248 if ((
c
 >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))

249 goto 
incomplete
;

253 unsigned char 
c
 = (unsigned char) 
p
[0];

255 if (
c
 >= 0x90 && c <= 0xe3)

257 unsigned char 
c2
 = (unsigned char) 
p
[1];

259 if (
c2
 >= 0x30 && c2 <= 0x39)

261 if (
m
 == 2)

262 goto 
incomplete
;

265 unsigned char 
c3
 = (unsigned char) 
p
[2];

267 if (
c3
 >= 0x81 && c3 <= 0xfe)

268 goto 
incomplete
;

273 goto 
invalid
;

275 if (
	`STREQ
 (
encoding
, "SJIS", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))

277 if (
m
 == 1)

279 unsigned char 
c
 = (unsigned char) 
p
[0];

281 if ((
c
 >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)

282 || (
c
 >= 0xf0 && c <= 0xf9))

283 goto 
incomplete
;

285 goto 
invalid
;

289 goto 
incomplete
;

292 
incomplete
:

294 
size_t
 
k
 = 
nstate
;

296 
pstate
[++
k
] = 
s
[0];

297 if (
k
 < 
m
)

299 
pstate
[++
k
] = 
s
[1];

300 if (
k
 < 
m
)

301 
pstate
[++
k
] = 
s
[2];

303 if (
k
 != 
m
)

304 
	`abort
 ();

306 
pstate
[0] = 
m
;

307 return (
size_t
)(-2);

309 
invalid
:

310 
errno
 = 
EILSEQ
;

312 return (
size_t
)(-1);

315 
	}
}

320 #undef 
mbrtowc


322 
size_t


323 
	$rpl_mbrtowc
 (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
, 
mbstate_t
 *
ps
)

325 #if 
MBRTOWC_NULL_ARG2_BUG
 || 
MBRTOWC_RETVAL_BUG


326 if (
s
 == 
NULL
)

328 
pwc
 = 
NULL
;

329 
s
 = "";

330 
n
 = 1;

334 #if 
MBRTOWC_RETVAL_BUG


336 static 
mbstate_t
 
internal_state
;

340 if (
ps
 == 
NULL
)

341 
ps
 = &
internal_state
;

343 if (!
	`mbsinit
 (
ps
))

346 
size_t
 
count
 = 0;

347 for (; 
n
 > 0; 
s
++, n--)

349 
wchar_t
 
wc
;

350 
size_t
 
ret
 = 
	`mbrtowc
 (&
wc
, 
s
, 1, 
ps
);

352 if (
ret
 == (
size_t
)(-1))

353 return (
size_t
)(-1);

354 
count
++;

355 if (
ret
 != (
size_t
)(-2))

358 if (
pwc
 != 
NULL
)

359 *
pwc
 = 
wc
;

360 return (
wc
 == 0 ? 0 : 
count
);

363 return (
size_t
)(-2);

368 #if 
MBRTOWC_NUL_RETVAL_BUG


370 
wchar_t
 
wc
;

371 
size_t
 
ret
 = 
	`mbrtowc
 (&
wc
, 
s
, 
n
, 
ps
);

373 if (
ret
 != (
size_t
)(-1) && ret != (size_t)(-2))

375 if (
pwc
 != 
NULL
)

376 *
pwc
 = 
wc
;

377 if (
wc
 == 0)

378 
ret
 = 0;

380 return 
ret
;

384 #if 
MBRTOWC_NULL_ARG1_BUG


385 
wchar_t
 
dummy
;

387 if (
pwc
 == 
NULL
)

388 
pwc
 = &
dummy
;

391 return 
	`mbrtowc
 (
pwc
, 
s
, 
n
, 
ps
);

394 
	}
}

	@lib/mbscasecmp.c

19 #include 
	~<config.h
>

22 #include 
	~<string.h
>

24 #include 
	~<ctype.h
>

25 #include 
	~<limits.h
>

27 #include 
	~"mbuiter.h
"

29 #define 
	#TOLOWER
(
Ch
) (
	`isupper
 (Ch) ? 
	`tolower
 (Ch) : (Ch))

	)

37 
	$mbscasecmp
 (const char *
s1
, const char *
s2
)

39 if (
s1
 == 
s2
)

45 if (
MB_CUR_MAX
 > 1)

47 
mbui_iterator_t
 
iter1
;

48 
mbui_iterator_t
 
iter2
;

50 
	`mbui_init
 (
iter1
, 
s1
);

51 
	`mbui_init
 (
iter2
, 
s2
);

53 while (
	`mbui_avail
 (
iter1
) && mbui_avail (
iter2
))

55 int 
cmp
 = 
	`mb_casecmp
 (
	`mbui_cur
 (
iter1
), mbui_cur (
iter2
));

57 if (
cmp
 != 0)

58 return 
cmp
;

60 
	`mbui_advance
 (
iter1
);

61 
	`mbui_advance
 (
iter2
);

63 if (
	`mbui_avail
 (
iter1
))

66 if (
	`mbui_avail
 (
iter2
))

73 const unsigned char *
p1
 = (const unsigned char *) 
s1
;

74 const unsigned char *
p2
 = (const unsigned char *) 
s2
;

75 unsigned char 
c1
, 
c2
;

79 
c1
 = 
	`TOLOWER
 (*
p1
);

80 
c2
 = 
	`TOLOWER
 (*
p2
);

82 if (
c1
 == '\0')

85 ++
p1
;

86 ++
p2
;

88 while (
c1
 == 
c2
);

90 if (
UCHAR_MAX
 <= 
INT_MAX
)

91 return 
c1
 - 
c2
;

96 return (
c1
 > 
c2
 ? 1 : c1 < c2 ? -1 : 0);

98 
	}
}

	@lib/mbsinit.c

18 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #include 
	~"verify.h
"

25 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && !defined 
__CYGWIN__


30 
	$mbsinit
 (const 
mbstate_t
 *
ps
)

32 return 
ps
 == 
NULL
 || *ps == 0;

33 
	}
}

51 
verify
 (sizeof (
mbstate_t
) >= 4);

54 
	$mbsinit
 (const 
mbstate_t
 *
ps
)

56 const char *
pstate
 = (const char *)
ps
;

58 return 
pstate
 == 
NULL
 || pstate[0] == 0;

59 
	}
}

	@lib/mbslen.c

18 #include 
	~<config.h
>

21 #include 
	~<string.h
>

23 #include 
	~<stdlib.h
>

25 #include 
	~"mbuiter.h
"

28 
size_t


29 
	$mbslen
 (const char *
string
)

31 if (
MB_CUR_MAX
 > 1)

33 
size_t
 
count
;

34 
mbui_iterator_t
 
iter
;

36 
count
 = 0;

37 for (
	`mbui_init
 (
iter
, 
string
); 
	`mbui_avail
 (iter); 
	`mbui_advance
 (iter))

38 
count
++;

40 return 
count
;

43 return 
	`strlen
 (
string
);

44 
	}
}

	@lib/mbsrtowcs-impl.h

18 
size_t


19 
	$mbsrtowcs
 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
len
, 
mbstate_t
 *
ps
)

21 if (
ps
 == 
NULL
)

22 
ps
 = &
_gl_mbsrtowcs_state
;

24 const char *
src
 = *
srcp
;

26 if (
dest
 != 
NULL
)

28 
wchar_t
 *
destptr
 = 
dest
;

30 for (; 
len
 > 0; 
destptr
++, len--)

32 
size_t
 
src_avail
;

33 
size_t
 
ret
;

37 if (
src
[0] == '\0')

38 
src_avail
 = 1;

39 else if (
src
[1] == '\0')

40 
src_avail
 = 2;

41 else if (
src
[2] == '\0')

42 
src_avail
 = 3;

43 else if (
MB_LEN_MAX
 <= 4 || 
src
[3] == '\0')

44 
src_avail
 = 4;

46 
src_avail
 = 4 + 
	`strnlen1
 (
src
 + 4, 
MB_LEN_MAX
 - 4);

49 
ret
 = 
	`mbrtowc
 (
destptr
, 
src
, 
src_avail
, 
ps
);

51 if (
ret
 == (
size_t
)(-2))

54 
	`abort
 ();

56 if (
ret
 == (
size_t
)(-1))

57 goto 
bad_input
;

58 if (
ret
 == 0)

60 
src
 = 
NULL
;

64 
src
 += 
ret
;

67 *
srcp
 = 
src
;

68 return 
destptr
 - 
dest
;

74 
mbstate_t
 
state
 = *
ps
;

75 
size_t
 
totalcount
 = 0;

77 for (;; 
totalcount
++)

79 
size_t
 
src_avail
;

80 
size_t
 
ret
;

84 if (
src
[0] == '\0')

85 
src_avail
 = 1;

86 else if (
src
[1] == '\0')

87 
src_avail
 = 2;

88 else if (
src
[2] == '\0')

89 
src_avail
 = 3;

90 else if (
MB_LEN_MAX
 <= 4 || 
src
[3] == '\0')

91 
src_avail
 = 4;

93 
src_avail
 = 4 + 
	`strnlen1
 (
src
 + 4, 
MB_LEN_MAX
 - 4);

96 
ret
 = 
	`mbrtowc
 (
NULL
, 
src
, 
src_avail
, &
state
);

98 if (
ret
 == (
size_t
)(-2))

101 
	`abort
 ();

103 if (
ret
 == (
size_t
)(-1))

104 goto 
bad_input2
;

105 if (
ret
 == 0)

110 
src
 += 
ret
;

113 return 
totalcount
;

116 
bad_input
:

117 *
srcp
 = 
src
;

118 
bad_input2
:

119 
errno
 = 
EILSEQ
;

120 return (
size_t
)(-1);

122 
	}
}

	@lib/mbsrtowcs-state.c

18 #include 
	~<config.h
>

20 #include 
	~<wchar.h
>

23 
mbstate_t
 
	g_gl_mbsrtowcs_state


31 #if 
defined
 
__ELF__


	@lib/mbsrtowcs.c

18 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #include 
	~<errno.h
>

24 #include 
	~<limits.h
>

25 #include 
	~<stdlib.h
>

27 #include 
	~"strnlen1.h
"

30 extern 
mbstate_t
 
_gl_mbsrtowcs_state
;

32 #include 
	~"mbsrtowcs-impl.h
"

	@lib/mbsstr.c

18 #include 
	~<config.h
>

21 #include 
	~<string.h
>

23 #include 
	~<stdbool.h
>

24 #include 
	~<stddef.h
>

26 #include 
	~"malloca.h
"

27 #include 
	~"mbuiter.h
"

30 #define 
	#UNIT
 unsigned char

	)

31 #define 
	#CANON_ELEMENT
(
c
) 
	)
c

32 #include 
	~"str-kmp.h
"

39 static 
bool


40 
	$knuth_morris_pratt_multibyte
 (const char *
haystack
, const char *
needle
,

41 const char **
resultp
)

43 
size_t
 
m
 = 
	`mbslen
 (
needle
);

44 
mbchar_t
 *
needle_mbchars
;

45 
size_t
 *
table
;

48 char *
memory
 = (char *) 
	`nmalloca
 (
m
, sizeof (
mbchar_t
) + sizeof (
size_t
));

49 if (
memory
 == 
NULL
)

50 return 
false
;

51 
needle_mbchars
 = (
mbchar_t
 *) 
memory
;

52 
table
 = (
size_t
 *) (
memory
 + 
m
 * sizeof (
mbchar_t
));

56 
mbui_iterator_t
 
iter
;

57 
size_t
 
j
;

59 
j
 = 0;

60 for (
	`mbui_init
 (
iter
, 
needle
); 
	`mbui_avail
 (iter); 
	`mbui_advance
 (iter), 
j
++)

61 
	`mb_copy
 (&
needle_mbchars
[
j
], &
	`mbui_cur
 (
iter
));

80 
size_t
 
i
, 
j
;

83 
table
[1] = 1;

84 
j
 = 0;

86 for (
i
 = 2; i < 
m
; i++)

92 
mbchar_t
 *
b
 = &
needle_mbchars
[
i
 - 1];

99 if (
	`mb_equal
 (*
b
, 
needle_mbchars
[
j
]))

102 
table
[
i
] = i - ++
j
;

108 if (
j
 == 0)

111 
table
[
i
] = i;

125 
j
 = j - 
table
[j];

133 
size_t
 
j
;

134 
mbui_iterator_t
 
rhaystack
;

135 
mbui_iterator_t
 
phaystack
;

137 *
resultp
 = 
NULL
;

138 
j
 = 0;

139 
	`mbui_init
 (
rhaystack
, 
haystack
);

140 
	`mbui_init
 (
phaystack
, 
haystack
);

142 while (
	`mbui_avail
 (
phaystack
))

143 if (
	`mb_equal
 (
needle_mbchars
[
j
], 
	`mbui_cur
 (
phaystack
)))

145 
j
++;

146 
	`mbui_advance
 (
phaystack
);

147 if (
j
 == 
m
)

150 *
resultp
 = 
	`mbui_cur_ptr
 (
rhaystack
);

154 else if (
j
 > 0)

157 
size_t
 
count
 = 
table
[
j
];

158 
j
 -= 
count
;

159 for (; 
count
 > 0; count--)

161 if (!
	`mbui_avail
 (
rhaystack
))

162 
	`abort
 ();

163 
	`mbui_advance
 (
rhaystack
);

169 if (!
	`mbui_avail
 (
rhaystack
))

170 
	`abort
 ();

171 
	`mbui_advance
 (
rhaystack
);

172 
	`mbui_advance
 (
phaystack
);

176 
	`freea
 (
memory
);

177 return 
true
;

178 
	}
}

183 
	$mbsstr
 (const char *
haystack
, const char *
needle
)

190 if (
MB_CUR_MAX
 > 1)

192 
mbui_iterator_t
 
iter_needle
;

194 
	`mbui_init
 (
iter_needle
, 
needle
);

195 if (
	`mbui_avail
 (
iter_needle
))

211 
bool
 
try_kmp
 = 
true
;

212 
size_t
 
outer_loop_count
 = 0;

213 
size_t
 
comparison_count
 = 0;

214 
size_t
 
last_ccount
 = 0;

215 
mbui_iterator_t
 
iter_needle_last_ccount
;

217 
mbui_iterator_t
 
iter_haystack
;

219 
	`mbui_init
 (
iter_needle_last_ccount
, 
needle
);

220 
	`mbui_init
 (
iter_haystack
, 
haystack
);

221 for (;; 
	`mbui_advance
 (
iter_haystack
))

223 if (!
	`mbui_avail
 (
iter_haystack
))

225 return 
NULL
;

229 if (
try_kmp


230 && 
outer_loop_count
 >= 10

231 && 
comparison_count
 >= 5 * 
outer_loop_count
)

235 
size_t
 
count
 = 
comparison_count
 - 
last_ccount
;

237 
count
 > 0 && 
	`mbui_avail
 (
iter_needle_last_ccount
);

238 
count
--)

239 
	`mbui_advance
 (
iter_needle_last_ccount
);

240 
last_ccount
 = 
comparison_count
;

241 if (!
	`mbui_avail
 (
iter_needle_last_ccount
))

244 const char *
result
;

245 
bool
 
success
 =

246 
	`knuth_morris_pratt_multibyte
 (
haystack
, 
needle
,

247 &
result
);

248 if (
success
)

249 return (char *) 
result
;

250 
try_kmp
 = 
false
;

254 
outer_loop_count
++;

255 
comparison_count
++;

256 if (
	`mb_equal
 (
	`mbui_cur
 (
iter_haystack
), mbui_cur (
iter_needle
)))

259 
mbui_iterator_t
 
rhaystack
;

260 
mbui_iterator_t
 
rneedle
;

262 
	`memcpy
 (&
rhaystack
, &
iter_haystack
, sizeof (
mbui_iterator_t
));

263 
	`mbui_advance
 (
rhaystack
);

265 
	`mbui_init
 (
rneedle
, 
needle
);

266 if (!
	`mbui_avail
 (
rneedle
))

267 
	`abort
 ();

268 
	`mbui_advance
 (
rneedle
);

270 for (;; 
	`mbui_advance
 (
rhaystack
), mbui_advance (
rneedle
))

272 if (!
	`mbui_avail
 (
rneedle
))

274 return (char *) 
	`mbui_cur_ptr
 (
iter_haystack
);

275 if (!
	`mbui_avail
 (
rhaystack
))

277 return 
NULL
;

278 
comparison_count
++;

279 if (!
	`mb_equal
 (
	`mbui_cur
 (
rhaystack
), mbui_cur (
rneedle
)))

287 return (char *) 
haystack
;

291 if (*
needle
 != '\0')

307 
bool
 
try_kmp
 = 
true
;

308 
size_t
 
outer_loop_count
 = 0;

309 
size_t
 
comparison_count
 = 0;

310 
size_t
 
last_ccount
 = 0;

311 const char *
needle_last_ccount
 = 
needle
;

315 char 
b
 = *
needle
++;

317 for (;; 
haystack
++)

319 if (*
haystack
 == '\0')

321 return 
NULL
;

325 if (
try_kmp


326 && 
outer_loop_count
 >= 10

327 && 
comparison_count
 >= 5 * 
outer_loop_count
)

331 if (
needle_last_ccount
 != 
NULL
)

333 
needle_last_ccount
 +=

334 
	`strnlen
 (
needle_last_ccount
,

335 
comparison_count
 - 
last_ccount
);

336 if (*
needle_last_ccount
 == '\0')

337 
needle_last_ccount
 = 
NULL
;

338 
last_ccount
 = 
comparison_count
;

340 if (
needle_last_ccount
 == 
NULL
)

343 const unsigned char *
result
;

344 
bool
 
success
 =

345 
	`knuth_morris_pratt
 ((const unsigned char *) 
haystack
,

346 (const unsigned char *) (
needle
 - 1),

347 
	`strlen
 (
needle
 - 1),

348 &
result
);

349 if (
success
)

350 return (char *) 
result
;

351 
try_kmp
 = 
false
;

355 
outer_loop_count
++;

356 
comparison_count
++;

357 if (*
haystack
 == 
b
)

360 const char *
rhaystack
 = 
haystack
 + 1;

361 const char *
rneedle
 = 
needle
;

363 for (;; 
rhaystack
++, 
rneedle
++)

365 if (*
rneedle
 == '\0')

367 return (char *) 
haystack
;

368 if (*
rhaystack
 == '\0')

370 return 
NULL
;

371 
comparison_count
++;

372 if (*
rhaystack
 != *
rneedle
)

380 return (char *) 
haystack
;

382 
	}
}

	@lib/mbtowc-impl.h

23 
	$mbtowc
 (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
)

25 if (
s
 == 
NULL
)

29 
mbstate_t
 
state
;

30 
wchar_t
 
wc
;

31 
size_t
 
result
;

33 
	`memset
 (&
state
, 0, sizeof (
mbstate_t
));

34 
result
 = 
	`mbrtowc
 (&
wc
, 
s
, 
n
, &
state
);

35 if (
result
 == (
size_t
)-1 || result == (size_t)-2)

37 
errno
 = 
EILSEQ
;

40 if (
pwc
 != 
NULL
)

41 *
pwc
 = 
wc
;

42 return (
wc
 == 0 ? 0 : 
result
);

44 
	}
}

	@lib/mbtowc.c

18 #include 
	~<config.h
>

20 #include 
	~<stdlib.h
>

22 #include 
	~<errno.h
>

23 #include 
	~<string.h
>

24 #include 
	~<wchar.h
>

26 #include 
	~"mbtowc-impl.h
"

	@lib/mbuiter.h

89 #ifndef 
_MBUITER_H


90 #define 
	#_MBUITER_H
 1

	)

92 #include 
	~<assert.h
>

93 #include 
	~<stdbool.h
>

94 #include 
	~<stddef.h
>

95 #include 
	~<stdlib.h
>

96 #include 
	~<string.h
>

102 #include 
	~<stdio.h
>

103 #include 
	~<time.h
>

104 #include 
	~<wchar.h
>

106 #include 
	~"mbchar.h
"

107 #include 
	~"strnlen1.h
"

109 struct 
	smbuiter_multi


111 
bool
 
	min_shift
;

112 
mbstate_t
 
	mstate
;

113 
bool
 
	mnext_done
;

114 struct 
mbchar
 
	mcur
;

123 static 
inline
 void

124 
	$mbuiter_multi_next
 (struct 
mbuiter_multi
 *
iter
)

126 if (
iter
->
next_done
)

128 if (
iter
->
in_shift
)

129 goto 
with_shift
;

131 if (
	`is_basic
 (*
iter
->
cur
.
ptr
))

136 
iter
->
cur
.
bytes
 = 1;

137 
iter
->
cur
.
wc
 = *iter->cur.
ptr
;

138 
iter
->
cur
.
wc_valid
 = 
true
;

142 
	`assert
 (
	`mbsinit
 (&
iter
->
state
));

143 
iter
->
in_shift
 = 
true
;

144 
with_shift
:

145 
iter
->
cur
.
bytes
 = 
	`mbrtowc
 (&iter->cur.
wc
, iter->cur.
ptr
,

146 
	`strnlen1
 (
iter
->
cur
.
ptr
, 
MB_CUR_MAX
),

147 &
iter
->
state
);

148 if (
iter
->
cur
.
bytes
 == (
size_t
) -1)

151 
iter
->
cur
.
bytes
 = 1;

152 
iter
->
cur
.
wc_valid
 = 
false
;

156 else if (
iter
->
cur
.
bytes
 == (
size_t
) -2)

159 
iter
->
cur
.
bytes
 = 
	`strlen
 (iter->cur.
ptr
);

160 
iter
->
cur
.
wc_valid
 = 
false
;

166 if (
iter
->
cur
.
bytes
 == 0)

169 
iter
->
cur
.
bytes
 = 1;

170 
	`assert
 (*
iter
->
cur
.
ptr
 == '\0');

171 
	`assert
 (
iter
->
cur
.
wc
 == 0);

173 
iter
->
cur
.
wc_valid
 = 
true
;

177 if (
	`mbsinit
 (&
iter
->
state
))

178 
iter
->
in_shift
 = 
false
;

181 
iter
->
next_done
 = 
true
;

182 
	}
}

184 static 
inline
 void

185 
	$mbuiter_multi_reloc
 (struct 
mbuiter_multi
 *
iter
, 
ptrdiff_t
 
ptrdiff
)

187 
iter
->
cur
.
ptr
 += 
ptrdiff
;

188 
	}
}

190 static 
inline
 void

191 
	$mbuiter_multi_copy
 (struct 
mbuiter_multi
 *
new_iter
, const struct mbuiter_multi *
old_iter
)

193 if ((
new_iter
->
in_shift
 = 
old_iter
->in_shift))

194 
	`memcpy
 (&
new_iter
->
state
, &
old_iter
->state, sizeof (
mbstate_t
));

196 
	`memset
 (&
new_iter
->
state
, 0, sizeof (
mbstate_t
));

197 
new_iter
->
next_done
 = 
old_iter
->next_done;

198 
	`mb_copy
 (&
new_iter
->
cur
, &
old_iter
->cur);

199 
	}
}

202 typedef struct 
mbuiter_multi
 
	tmbui_iterator_t
;

203 #define 
	#mbui_init
(
iter
, 
startptr
) \

204 ((
iter
).
cur
.
ptr
 = (
startptr
), \

205 (
iter
).
in_shift
 = 
false
, 
	`memset
 (&(iter).
state
, '\0', sizeof (
mbstate_t
)), \

206 (
iter
).
next_done
 = 
false
)

	)

207 #define 
	#mbui_avail
(
iter
) \

208 (
	`mbuiter_multi_next
 (&(
iter
)), !
	`mb_isnul
 ((iter).
cur
))

	)

209 #define 
	#mbui_advance
(
iter
) \

210 ((
iter
).
cur
.
ptr
 += (iter).cur.
bytes
, (iter).
next_done
 = 
false
)

	)

213 #define 
	#mbui_cur
(
iter
) (iter).
cur


	)

214 #define 
	#mbui_cur_ptr
(
iter
) (iter).
cur
.
ptr


	)

217 #define 
	#mbui_reloc
(
iter
, 
ptrdiff
) 
	`mbuiter_multi_reloc
 (&iter, ptrdiff)

	)

220 #define 
	#mbui_copy
 
mbuiter_multi_copy


	)

	@lib/memchr.c

26 #ifndef 
_LIBC


27 #include 
	~<config.h
>

30 #include 
	~<string.h
>

32 #include 
	~<stddef.h
>

34 #if 
defined
 
_LIBC


35 #include 
	~<memcopy.h
>

37 #define 
	#reg_char
 char

	)

40 #include 
	~<limits.h
>

42 #if 
HAVE_BP_SYM_H
 || 
defined
 
_LIBC


43 #include 
	~<bp-sym.h
>

45 #define 
	#BP_SYM
(
sym
) 
	)
sym

48 #undef 
__memchr


49 #ifdef 
_LIBC


50 #undef 
memchr


53 #ifndef 
weak_alias


54 #define 
	#__memchr
 
memchr


	)

59 
	$__memchr
 (void const *
s
, int 
c_in
, 
size_t
 
n
)

66 typedef unsigned long int 
	tlongword
;

68 const unsigned char *
char_ptr
;

69 const 
longword
 *
longword_ptr
;

70 
longword
 
repeated_one
;

71 
longword
 
repeated_c
;

72 unsigned 
reg_char
 
c
;

74 
c
 = (unsigned char) 
c_in
;

78 for (
char_ptr
 = (const unsigned char *) 
s
;

79 
n
 > 0 && (
size_t
) 
char_ptr
 % sizeof (
longword
) != 0;

80 --
n
, ++
char_ptr
)

81 if (*
char_ptr
 == 
c
)

82 return (void *) 
char_ptr
;

84 
longword_ptr
 = (const 
longword
 *) 
char_ptr
;

92 
repeated_one
 = 0x01010101;

93 
repeated_c
 = 
c
 | (c << 8);

94 
repeated_c
 |= repeated_c << 16;

95 if (0xffffffffU < (
longword
) -1)

97 
repeated_one
 |= repeated_one << 31 << 1;

98 
repeated_c
 |= repeated_c << 31 << 1;

99 if (8 < sizeof (
longword
))

101 
size_t
 
i
;

103 for (
i
 = 64; i < sizeof (
longword
) * 8; i *= 2)

105 
repeated_one
 |= repeated_one << 
i
;

106 
repeated_c
 |= repeated_c << 
i
;

142 while (
n
 >= sizeof (
longword
))

144 
longword
 
longword1
 = *
longword_ptr
 ^ 
repeated_c
;

146 if ((((
longword1
 - 
repeated_one
) & ~longword1)

147 & (
repeated_one
 << 7)) != 0)

149 
longword_ptr
++;

150 
n
 -= sizeof (
longword
);

153 
char_ptr
 = (const unsigned char *) 
longword_ptr
;

162 for (; 
n
 > 0; --n, ++
char_ptr
)

164 if (*
char_ptr
 == 
c
)

165 return (void *) 
char_ptr
;

168 return 
NULL
;

169 
	}
}

170 #ifdef 
weak_alias


171 
weak_alias
 (
__memchr
, 
	$BP_SYM
 (
memchr
))

	@lib/mempcpy.c

20 #include 
	~<config.h
>

23 #include 
	~<string.h
>

28 
	$mempcpy
 (void *
dest
, const void *
src
, 
size_t
 
n
)

30 return (char *) 
	`memcpy
 (
dest
, 
src
, 
n
) + n;

31 
	}
}

	@lib/minmax.h

21 #ifndef 
_MINMAX_H


22 #define 
	#_MINMAX_H


	)

34 #if 
HAVE_MINMAX_IN_LIMITS_H


35 #include 
	~<limits.h
>

36 #elif 
HAVE_MINMAX_IN_SYS_PARAM_H


37 #include 
	~<sys/param.h
>

54 #ifndef 
MAX


55 #define 
	#MAX
(
a
,
b
) ((a) > (b) ? (a) : (b))

	)

59 #ifndef 
MIN


60 #define 
	#MIN
(
a
,
b
) ((a) < (b) ? (a) : (b))

	)

	@lib/msvc-inval.c

20 #include 
	~<config.h
>

23 #include 
	~"msvc-inval.h
"

25 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER
 \

26 && !(
	gMSVC_INVALID_PARAMETER_HANDLING
 == 
SANE_LIBRARY_HANDLING
)

30 #include 
	~<stdlib.h
>

32 #if 
MSVC_INVALID_PARAMETER_HANDLING
 == 
DEFAULT_HANDLING


34 static void 
cdecl


35 
	$gl_msvc_invalid_parameter_handler
 (const 
wchar_t
 *
expression
,

36 const 
wchar_t
 *
function
,

37 const 
wchar_t
 *
file
,

38 unsigned int 
line
,

39 
uintptr_t
 
dummy
)

41 
	}
}

46 #define 
	#WIN32_LEAN_AND_MEAN


	)

47 #include 
	~<windows.h
>

49 #if 
defined
 
_MSC_VER


51 static void 
cdecl


52 
	$gl_msvc_invalid_parameter_handler
 (const 
wchar_t
 *
expression
,

53 const 
wchar_t
 *
function
,

54 const 
wchar_t
 *
file
,

55 unsigned int 
line
,

56 
uintptr_t
 
dummy
)

58 
	`RaiseException
 (
STATUS_GNULIB_INVALID_PARAMETER
, 0, 0, 
NULL
);

59 
	}
}

64 static 
DWORD
 
	gtls_index
;

65 static int 
	gtls_initialized
 ;

68 static struct 
gl_msvc_inval_per_thread
 
	gnot_per_thread
;

70 struct 
gl_msvc_inval_per_thread
 *

71 
	$gl_msvc_inval_current
 (void)

73 if (!
tls_initialized
)

75 
tls_index
 = 
	`TlsAlloc
 ();

76 
tls_initialized
 = 1;

78 if (
tls_index
 == 
TLS_OUT_OF_INDEXES
)

80 return &
not_per_thread
;

83 struct 
gl_msvc_inval_per_thread
 *
pointer
 =

84 (struct 
gl_msvc_inval_per_thread
 *) 
	`TlsGetValue
 (
tls_index
);

85 if (
pointer
 == 
NULL
)

88 
pointer
 =

89 (struct 
gl_msvc_inval_per_thread
 *)

90 
	`malloc
 (sizeof (struct 
gl_msvc_inval_per_thread
));

91 if (
pointer
 == 
NULL
)

93 
pointer
 = &
not_per_thread
;

94 
	`TlsSetValue
 (
tls_index
, 
pointer
);

96 return 
pointer
;

98 
	}
}

100 static void 
cdecl


101 
	$gl_msvc_invalid_parameter_handler
 (const 
wchar_t
 *
expression
,

102 const 
wchar_t
 *
function
,

103 const 
wchar_t
 *
file
,

104 unsigned int 
line
,

105 
uintptr_t
 
dummy
)

107 struct 
gl_msvc_inval_per_thread
 *
current
 = 
	`gl_msvc_inval_current
 ();

108 if (
current
->
restart_valid
)

109 
	`longjmp
 (
current
->
restart
, 1);

113 
	`RaiseException
 (
STATUS_GNULIB_INVALID_PARAMETER
, 0, 0, 
NULL
);

114 
	}
}

120 static int 
	ggl_msvc_inval_initialized
 ;

123 
	$gl_msvc_inval_ensure_handler
 (void)

125 if (
gl_msvc_inval_initialized
 == 0)

127 
	`_set_invalid_parameter_handler
 (
gl_msvc_invalid_parameter_handler
);

128 
gl_msvc_inval_initialized
 = 1;

130 
	}
}

	@lib/msvc-inval.h

20 #ifndef 
_MSVC_INVAL_H


21 #define 
	#_MSVC_INVAL_H


	)

58 #define 
	#DEFAULT_HANDLING
 0

	)

59 #define 
	#HAIRY_LIBRARY_HANDLING
 1

	)

60 #define 
	#SANE_LIBRARY_HANDLING
 2

	)

62 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER
 \

63 && !(
	gMSVC_INVALID_PARAMETER_HANDLING
 == 
SANE_LIBRARY_HANDLING
)

67 #if 
MSVC_INVALID_PARAMETER_HANDLING
 == 
DEFAULT_HANDLING


70 #ifdef 
__cplusplus


77 extern void 
gl_msvc_inval_ensure_handler
 (void);

79 #ifdef 
__cplusplus


83 #define 
	#TRY_MSVC_INVAL
 \

86 
	`gl_msvc_inval_ensure_handler
 (); \

87 if (1)

	)

88 #define 
	#CATCH_MSVC_INVAL
 \

89 else

	)

90 #define 
	#DONE_MSVC_INVAL
 \

92 while (0)

	)

97 #include 
	~<excpt.h
>

107 #define 
	#STATUS_GNULIB_INVALID_PARAMETER
 (0xE0000000 + 0x474E550 + 0)

	)

109 #if 
defined
 
_MSC_VER


115 #ifdef 
__cplusplus


123 extern void 
gl_msvc_inval_ensure_handler
 (void);

125 #ifdef 
__cplusplus


129 #define 
	#TRY_MSVC_INVAL
 \

132 
	`gl_msvc_inval_ensure_handler
 (); \

133 
__try


	)

134 #define 
	#CATCH_MSVC_INVAL
 \

135 
	`__except
 (
	`GetExceptionCode
 () == 
STATUS_GNULIB_INVALID_PARAMETER
 \

136 ? 
EXCEPTION_EXECUTE_HANDLER
 \

137 : 
EXCEPTION_CONTINUE_SEARCH
)

	)

138 #define 
	#DONE_MSVC_INVAL
 \

140 while (0)

	)

146 #include 
	~<setjmp.h
>

148 #ifdef 
__cplusplus


152 struct 
	sgl_msvc_inval_per_thread


157 
jmp_buf
 
restart
;

160 int 
restart_valid
;

168 extern void 
gl_msvc_inval_ensure_handler
 (void);

171 extern struct 
gl_msvc_inval_per_thread
 *
gl_msvc_inval_current
 (void);

173 #ifdef 
__cplusplus


177 #define 
	#TRY_MSVC_INVAL
 \

180 struct 
gl_msvc_inval_per_thread
 *
msvc_inval_current
; \

181 
	`gl_msvc_inval_ensure_handler
 (); \

182 
msvc_inval_current
 = 
	`gl_msvc_inval_current
 (); \

184 if (
	`setjmp
 (
msvc_inval_current
->
restart
) == 0) \

187 
msvc_inval_current
->
restart_valid
 = 1;

	)

188 #define 
	#CATCH_MSVC_INVAL
 \

191 
msvc_inval_current
->
restart_valid
 = 0; \

197 
msvc_inval_current
->
restart_valid
 = 0;

	)

198 #define 
	#DONE_MSVC_INVAL
 \

201 while (0)

	)

213 #define 
	#TRY_MSVC_INVAL
 \

216 if (1)

	)

217 #define 
	#CATCH_MSVC_INVAL
 \

218 else

	)

219 #define 
	#DONE_MSVC_INVAL
 \

221 while (0)

	)

	@lib/msvc-nothrow.c

21 #include 
	~<config.h
>

24 #include 
	~"msvc-nothrow.h
"

27 #define 
	#WIN32_LEAN_AND_MEAN


	)

28 #include 
	~<windows.h
>

30 #include 
	~"msvc-inval.h
"

32 #undef 
_get_osfhandle


34 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER


35 
intptr_t


36 
	$_gl_nothrow_get_osfhandle
 (int 
fd
)

38 
intptr_t
 
result
;

40 
TRY_MSVC_INVAL


42 
result
 = 
	`_get_osfhandle
 (
fd
);

44 
CATCH_MSVC_INVAL


46 
result
 = (
intptr_t
) 
INVALID_HANDLE_VALUE
;

48 
DONE_MSVC_INVAL
;

50 return 
result
;

51 
	}
}

	@lib/msvc-nothrow.h

21 #ifndef 
_MSVC_NOTHROW_H


22 #define 
	#_MSVC_NOTHROW_H


	)

31 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


34 #include 
	~<io.h
>

36 #if 
HAVE_MSVC_INVALID_PARAMETER_HANDLER


39 extern 
intptr_t
 
_gl_nothrow_get_osfhandle
 (int 
fd
);

40 #define 
	#_get_osfhandle
 
_gl_nothrow_get_osfhandle


	)

	@lib/nl_langinfo.c

18 #include 
	~<config.h
>

21 #include 
	~<langinfo.h
>

23 #if 
REPLACE_NL_LANGINFO


27 #include 
	~<locale.h
>

28 #include 
	~<string.h
>

30 #undef 
nl_langinfo


33 
	$rpl_nl_langinfo
 (
nl_item
 
item
)

35 switch (
item
)

37 #if 
GNULIB_defined_CODESET


38 case 
CODESET
:

40 const char *
locale
;

41 static char 
buf
[2 + 10 + 1];

43 
locale
 = 
	`setlocale
 (
LC_CTYPE
, 
NULL
);

44 if (
locale
 != 
NULL
 && locale[0] != '\0')

48 const char *
dot
 = 
	`strchr
 (
locale
, '.');

50 if (
dot
 != 
NULL
)

52 const char *
modifier
;

54 
dot
++;

56 
modifier
 = 
	`strchr
 (
dot
, '@');

57 if (
modifier
 == 
NULL
)

58 return 
dot
;

59 if (
modifier
 - 
dot
 < sizeof (
buf
))

61 
	`memcpy
 (
buf
, 
dot
, 
modifier
 - dot);

62 
buf
 [
modifier
 - 
dot
] = '\0';

63 return 
buf
;

70 #if 
GNULIB_defined_T_FMT_AMPM


71 case 
T_FMT_AMPM
:

74 #if 
GNULIB_defined_ERA


75 case 
ERA
:

80 case 
ERA_D_FMT
:

83 
item
 = 
D_FMT
;

85 case 
ERA_D_T_FMT
:

88 
item
 = 
D_T_FMT
;

90 case 
ERA_T_FMT
:

93 
item
 = 
T_FMT
;

95 case 
ALT_DIGITS
:

100 #if 
GNULIB_defined_YESEXPR
 || !
FUNC_NL_LANGINFO_YESEXPR_WORKS


101 case 
YESEXPR
:

103 case 
NOEXPR
:

109 return 
	`nl_langinfo
 (
item
);

110 
	}
}

116 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


120 #define 
	#WIN32_LEAN_AND_MEAN


	)

121 #include 
	~<windows.h
>

123 #include 
	~<stdio.h
>

131 #include 
	~<locale.h
>

134 
	$nl_langinfo
 (
nl_item
 
item
)

136 switch (
item
)

139 case 
CODESET
:

140 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


142 static char 
buf
[2 + 10 + 1];

145 
	`sprintf
 (
buf
, "CP%u", 
	`GetACP
 ());

146 return 
buf
;

148 #elif 
defined
 
__BEOS__


154 case 
RADIXCHAR
:

155 return 
	`localeconv
 () ->
decimal_point
;

156 case 
THOUSEP
:

157 return 
	`localeconv
 () ->
thousands_sep
;

160 case 
D_T_FMT
:

161 case 
ERA_D_T_FMT
:

163 case 
D_FMT
:

164 case 
ERA_D_FMT
:

166 case 
T_FMT
:

167 case 
ERA_T_FMT
:

169 case 
T_FMT_AMPM
:

171 case 
AM_STR
:

173 case 
PM_STR
:

175 case 
DAY_1
:

177 case 
DAY_2
:

179 case 
DAY_3
:

181 case 
DAY_4
:

183 case 
DAY_5
:

185 case 
DAY_6
:

187 case 
DAY_7
:

189 case 
ABDAY_1
:

191 case 
ABDAY_2
:

193 case 
ABDAY_3
:

195 case 
ABDAY_4
:

197 case 
ABDAY_5
:

199 case 
ABDAY_6
:

201 case 
ABDAY_7
:

203 case 
MON_1
:

205 case 
MON_2
:

207 case 
MON_3
:

209 case 
MON_4
:

211 case 
MON_5
:

213 case 
MON_6
:

215 case 
MON_7
:

217 case 
MON_8
:

219 case 
MON_9
:

221 case 
MON_10
:

223 case 
MON_11
:

225 case 
MON_12
:

227 case 
ABMON_1
:

229 case 
ABMON_2
:

231 case 
ABMON_3
:

233 case 
ABMON_4
:

235 case 
ABMON_5
:

237 case 
ABMON_6
:

239 case 
ABMON_7
:

241 case 
ABMON_8
:

243 case 
ABMON_9
:

245 case 
ABMON_10
:

247 case 
ABMON_11
:

249 case 
ABMON_12
:

251 case 
ERA
:

253 case 
ALT_DIGITS
:

257 case 
CRNCYSTR
:

261 case 
YESEXPR
:

263 case 
NOEXPR
:

268 
	}
}

	@lib/obstack.c

18 #ifdef 
_LIBC


19 #include 
	~<obstack.h
>

20 #include 
	~<shlib-compat.h
>

22 #include 
	~<config.h
>

23 #include 
	~"obstack.h
"

29 #define 
	#OBSTACK_INTERFACE_VERSION
 1

	)

40 #include 
	~<stdio.h
>

41 #if !
defined
 
_LIBC
 && defined 
__GNU_LIBRARY__
 && __GNU_LIBRARY__ > 1

42 #include 
	~<gnu-versions.h
>

43 #if 
_GNU_OBSTACK_INTERFACE_VERSION
 == 
OBSTACK_INTERFACE_VERSION


44 #define 
	#ELIDE_CODE


	)

48 #include 
	~<stddef.h
>

50 #ifndef 
ELIDE_CODE


52 #include 
	~<stdint.h
>

55 union 
	ufooround


57 
uintmax_t
 
	mi
;

58 long double 
	md
;

59 void *
	mp
;

61 struct 
	sfooalign


63 char 
	mc
;

64 union 
fooround
 
	mu
;

71 
	mDEFAULT_ALIGNMENT
 = 
offsetof
 (struct 
fooalign
, 
u
),

72 
	mDEFAULT_ROUNDING
 = sizeof (union 
fooround
)

79 #ifndef 
COPYING_UNIT


80 #define 
	#COPYING_UNIT
 int

	)

90 static 
_Noreturn
 void 
print_and_abort
 (void);

91 void (*
obstack_alloc_failed_handler
) (void) = 
print_and_abort
;

94 #include 
	~<stdlib.h
>

95 #ifdef 
_LIBC


96 int 
obstack_exit_failure
 = 
EXIT_FAILURE
;

98 #include 
	~"exitfail.h
"

99 #define 
	#obstack_exit_failure
 
exit_failure


	)

102 #ifdef 
_LIBC


103 #if 
	`SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_3_4
)

107 struct 
obstack
 *
_obstack_compat
;

108 
	`compat_symbol
 (
libc
, 
_obstack_compat
, 
_obstack
, 
GLIBC_2_0
);

118 #define 
	#CALL_CHUNKFUN
(
h
, 
size
) \

119 (((
h
) -> 
use_extra_arg
) \

120 ? (*(
h
)->
chunkfun
) ((h)->
extra_arg
, (
size
)) \

121 : (*(struct 
_obstack_chunk
 *(*) (long)) (
h
)->
chunkfun
) ((
size
)))

	)

123 #define 
	#CALL_FREEFUN
(
h
, 
old_chunk
) \

125 if ((
h
) -> 
use_extra_arg
) \

126 (*(
h
)->
freefun
) ((h)->
extra_arg
, (
old_chunk
)); \

128 (*(void (*) (void *)) (
h
)->
freefun
) ((
old_chunk
)); \

129 
	}
} while (0)

	)

141 
_obstack_begin
 (struct 
obstack
 *
h
,

142 int 
size
, int 
alignment
,

143 void *(*
chunkfun
) (long),

144 void (*
freefun
) (void *))

146 register struct 
_obstack_chunk
 *
chunk
;

148 if (
alignment
 == 0)

149 
alignment
 = 
DEFAULT_ALIGNMENT
;

150 if (
size
 == 0)

161 int 
extra
 = ((((12 + 
DEFAULT_ROUNDING
 - 1) & ~(DEFAULT_ROUNDING - 1))

162 + 4 + 
DEFAULT_ROUNDING
 - 1)

163 & ~(
DEFAULT_ROUNDING
 - 1));

164 
size
 = 4096 - 
extra
;

167 
h
->
chunkfun
 = (struct 
_obstack_chunk
 * (*)(void *, long)) chunkfun;

168 
h
->
freefun
 = (void (*) (void *, struct 
_obstack_chunk
 *)) freefun;

169 
h
->
chunk_size
 = 
size
;

170 
h
->
alignment_mask
 = 
alignment
 - 1;

171 
h
->
use_extra_arg
 = 0;

173 
chunk
 = 
h
->chunk = 
	`CALL_CHUNKFUN
 (h, h -> 
chunk_size
);

174 if (!
chunk
)

175 (*
obstack_alloc_failed_handler
) ();

176 
h
->
next_free
 = h->
object_base
 = 
	`__PTR_ALIGN
 ((char *) 
chunk
, chunk->
contents
,

177 
alignment
 - 1);

178 
h
->
chunk_limit
 = 
chunk
->
limit


179 = (char *) 
chunk
 + 
h
->
chunk_size
;

180 
chunk
->
prev
 = 0;

182 
h
->
maybe_empty_object
 = 0;

183 
h
->
alloc_failed
 = 0;

185 
	}
}

188 
_obstack_begin_1
 (struct 
obstack
 *
h
, int 
size
, int 
alignment
,

189 void *(*
chunkfun
) (void *, long),

190 void (*
freefun
) (void *, void *),

191 void *
arg
)

193 register struct 
_obstack_chunk
 *
chunk
;

195 if (
alignment
 == 0)

196 
alignment
 = 
DEFAULT_ALIGNMENT
;

197 if (
size
 == 0)

208 int 
extra
 = ((((12 + 
DEFAULT_ROUNDING
 - 1) & ~(DEFAULT_ROUNDING - 1))

209 + 4 + 
DEFAULT_ROUNDING
 - 1)

210 & ~(
DEFAULT_ROUNDING
 - 1));

211 
size
 = 4096 - 
extra
;

214 
h
->
chunkfun
 = (struct 
_obstack_chunk
 * (*)(void *,long)) chunkfun;

215 
h
->
freefun
 = (void (*) (void *, struct 
_obstack_chunk
 *)) freefun;

216 
h
->
chunk_size
 = 
size
;

217 
h
->
alignment_mask
 = 
alignment
 - 1;

218 
h
->
extra_arg
 = 
arg
;

219 
h
->
use_extra_arg
 = 1;

221 
chunk
 = 
h
->chunk = 
	`CALL_CHUNKFUN
 (h, h -> 
chunk_size
);

222 if (!
chunk
)

223 (*
obstack_alloc_failed_handler
) ();

224 
h
->
next_free
 = h->
object_base
 = 
	`__PTR_ALIGN
 ((char *) 
chunk
, chunk->
contents
,

225 
alignment
 - 1);

226 
h
->
chunk_limit
 = 
chunk
->
limit


227 = (char *) 
chunk
 + 
h
->
chunk_size
;

228 
chunk
->
prev
 = 0;

230 
h
->
maybe_empty_object
 = 0;

231 
h
->
alloc_failed
 = 0;

233 
	}
}

242 
	$_obstack_newchunk
 (struct 
obstack
 *
h
, int 
length
)

244 register struct 
_obstack_chunk
 *
old_chunk
 = 
h
->
chunk
;

245 register struct 
_obstack_chunk
 *
new_chunk
;

246 register long 
new_size
;

247 register long 
obj_size
 = 
h
->
next_free
 - h->
object_base
;

248 register long 
i
;

249 long 
already
;

250 char *
object_base
;

253 
new_size
 = (
obj_size
 + 
length
) + (obj_size >> 3) + 
h
->
alignment_mask
 + 100;

254 if (
new_size
 < 
h
->
chunk_size
)

255 
new_size
 = 
h
->
chunk_size
;

258 
new_chunk
 = 
	`CALL_CHUNKFUN
 (
h
, 
new_size
);

259 if (!
new_chunk
)

260 (*
obstack_alloc_failed_handler
) ();

261 
h
->
chunk
 = 
new_chunk
;

262 
new_chunk
->
prev
 = 
old_chunk
;

263 
new_chunk
->
limit
 = 
h
->
chunk_limit
 = (char *) new_chunk + 
new_size
;

266 
object_base
 =

267 
	`__PTR_ALIGN
 ((char *) 
new_chunk
, new_chunk->
contents
, 
h
->
alignment_mask
);

272 if (
h
->
alignment_mask
 + 1 >= 
DEFAULT_ALIGNMENT
)

274 for (
i
 = 
obj_size
 / sizeof (
COPYING_UNIT
) - 1;

275 
i
 >= 0; i--)

276 ((
COPYING_UNIT
 *)
object_base
)[
i
]

277 = ((
COPYING_UNIT
 *)
h
->
object_base
)[
i
];

281 
already
 = 
obj_size
 / sizeof (
COPYING_UNIT
) * sizeof (COPYING_UNIT);

284 
already
 = 0;

286 for (
i
 = 
already
; i < 
obj_size
; i++)

287 
object_base
[
i
] = 
h
->object_base[i];

292 if (! 
h
->
maybe_empty_object


293 && (
h
->
object_base


294 == 
	`__PTR_ALIGN
 ((char *) 
old_chunk
, old_chunk->
contents
,

295 
h
->
alignment_mask
)))

297 
new_chunk
->
prev
 = 
old_chunk
->prev;

298 
	`CALL_FREEFUN
 (
h
, 
old_chunk
);

301 
h
->
object_base
 = object_base;

302 
h
->
next_free
 = h->
object_base
 + 
obj_size
;

304 
h
->
maybe_empty_object
 = 0;

305 
	}
}

306 #ifdef 
_LIBC


307 
	$libc_hidden_def
 (
_obstack_newchunk
)

316 int 
	`_obstack_allocated_p
 (struct 
obstack
 *
h
, void *
obj
);

319 
	$_obstack_allocated_p
 (struct 
obstack
 *
h
, void *
obj
)

321 register struct 
_obstack_chunk
 *
lp
;

322 register struct 
_obstack_chunk
 *
plp
;

324 
lp
 = (
h
)->
chunk
;

328 while (
lp
 != 0 && ((void *) lp >= 
obj
 || (void *) (lp)->
limit
 < obj))

330 
plp
 = 
lp
->
prev
;

331 
lp
 = 
plp
;

333 return 
lp
 != 0;

334 
	}
}

339 #undef 
obstack_free


342 
	$__obstack_free
 (struct 
obstack
 *
h
, void *
obj
)

344 register struct 
_obstack_chunk
 *
lp
;

345 register struct 
_obstack_chunk
 *
plp
;

347 
lp
 = 
h
->
chunk
;

351 while (
lp
 != 0 && ((void *) lp >= 
obj
 || (void *) (lp)->
limit
 < obj))

353 
plp
 = 
lp
->
prev
;

354 
	`CALL_FREEFUN
 (
h
, 
lp
);

355 
lp
 = 
plp
;

358 
h
->
maybe_empty_object
 = 1;

360 if (
lp
)

362 
h
->
object_base
 = h->
next_free
 = (char *) (
obj
);

363 
h
->
chunk_limit
 = 
lp
->
limit
;

364 
h
->
chunk
 = 
lp
;

366 else if (
obj
 != 0)

368 
	`abort
 ();

369 
	}
}

371 #ifdef 
_LIBC


374 
	$strong_alias
 (
obstack_free
, 
_obstack_free
)

378 
	$_obstack_memory_used
 (struct 
obstack
 *
h
)

380 register struct 
_obstack_chunk
* 
lp
;

381 register int 
nbytes
 = 0;

383 for (
lp
 = 
h
->
chunk
; lp != 0; lp = lp->
prev
)

385 
nbytes
 += 
lp
->
limit
 - (char *) lp;

387 return 
nbytes
;

388 
	}
}

391 #ifdef 
_LIBC


392 #include 
	~<libintl.h
>

394 #include 
	~"gettext.h
"

396 #ifndef 
_


397 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

400 #ifdef 
_LIBC


401 #include 
	~<libio/iolibio.h
>

404 static 
_Noreturn
 void

405 
	$print_and_abort
 (void)

412 #ifdef 
_LIBC


413 (void) 
	`__fxprintf
 (
NULL
, "%s\n", 
	`_
("memory exhausted"));

415 
	`fprintf
 (
stderr
, "%s\n", 
	`_
("memory exhausted"));

417 
	`exit
 (
obstack_exit_failure
);

418 
	}
}

	@lib/obstack.h

104 #ifndef 
_OBSTACK_H


105 #define 
	#_OBSTACK_H
 1

	)

112 #ifdef 
__PTRDIFF_TYPE__


113 #define 
	#PTR_INT_TYPE
 
__PTRDIFF_TYPE__


	)

115 #include 
	~<stddef.h
>

116 #define 
	#PTR_INT_TYPE
 
ptrdiff_t


	)

123 #define 
	#__BPTR_ALIGN
(
B
, 
P
, 
A
) ((B) + (((P) - (B) + (A)) & ~(A)))

	)

132 #define 
	#__PTR_ALIGN
(
B
, 
P
, 
A
) \

133 
	`__BPTR_ALIGN
 (sizeof (
PTR_INT_TYPE
) < sizeof (void *) ? (
B
) : (char *) 0, \

134 
P
, 
A
)

	)

136 #include 
	~<string.h
>

138 #ifdef 
__cplusplus


142 struct 
	s_obstack_chunk


144 char *
limit
;

145 struct 
_obstack_chunk
 *
prev
;

146 char 
contents
[4];

149 struct 
	sobstack


151 long 
chunk_size
;

152 struct 
_obstack_chunk
 *
chunk
;

153 char *
object_base
;

154 char *
next_free
;

155 char *
chunk_limit
;

158 
PTR_INT_TYPE
 
tempint
;

159 void *
tempptr
;

160 } 
temp
;

161 int 
alignment_mask
;

165 struct 
_obstack_chunk
 *(*
chunkfun
) (void *, long);

166 void (*
freefun
) (void *, struct 
_obstack_chunk
 *);

167 void *
extra_arg
;

168 unsigned 
use_extra_arg
:1;

169 unsigned 
maybe_empty_object
:1;

173 unsigned 
alloc_failed
:1;

180 extern void 
_obstack_newchunk
 (struct 
obstack
 *, int);

181 extern int 
_obstack_begin
 (struct 
obstack
 *, int, int,

183 extern int 
_obstack_begin_1
 (struct 
obstack
 *, int, int,

186 extern int 
_obstack_memory_used
 (struct 
obstack
 *);

190 #ifndef 
__obstack_free


191 #define 
	#__obstack_free
 
obstack_free


	)

193 extern void 
__obstack_free
 (struct 
obstack
 *obstack, void *
block
);

200 extern void (*
obstack_alloc_failed_handler
) (void);

203 extern int 
obstack_exit_failure
;

209 #define 
	#obstack_base
(
h
) ((void *) (h)->
object_base
)

	)

213 #define 
	#obstack_chunk_size
(
h
) ((h)->
chunk_size
)

	)

217 #define 
	#obstack_next_free
(
h
) ((h)->
next_free
)

	)

221 #define 
	#obstack_alignment_mask
(
h
) ((h)->
alignment_mask
)

	)

224 #define 
	#obstack_init
(
h
) \

225 
	`_obstack_begin
 ((
h
), 0, 0, \

226 (void *(*) (long)) 
obstack_chunk_alloc
, \

227 (void (*) (void *)) 
obstack_chunk_free
)

	)

229 #define 
	#obstack_begin
(
h
, 
size
) \

230 
	`_obstack_begin
 ((
h
), (
size
), 0, \

231 (void *(*) (long)) 
obstack_chunk_alloc
, \

232 (void (*) (void *)) 
obstack_chunk_free
)

	)

234 #define 
	#obstack_specify_allocation
(
h
, 
size
, 
alignment
, 
chunkfun
, 
freefun
) \

235 
	`_obstack_begin
 ((
h
), (
size
), (
alignment
), \

236 (void *(*) (long)) (
chunkfun
), \

237 (void (*) (void *)) (
freefun
))

	)

239 #define 
	#obstack_specify_allocation_with_arg
(
h
, 
size
, 
alignment
, 
chunkfun
, 
freefun
, 
arg
) \

240 
	`_obstack_begin_1
 ((
h
), (
size
), (
alignment
), \

241 (void *(*) (void *, long)) (
chunkfun
), \

242 (void (*) (void *, void *)) (
freefun
), (
arg
))

	)

244 #define 
	#obstack_chunkfun
(
h
, 
newchunkfun
) \

245 ((
h
) -> 
chunkfun
 = (struct 
_obstack_chunk
 *(*)(void *, long)) (
newchunkfun
))

	)

247 #define 
	#obstack_freefun
(
h
, 
newfreefun
) \

248 ((
h
) -> 
freefun
 = (void (*)(void *, struct 
_obstack_chunk
 *)) (
newfreefun
))

	)

250 #define 
	#obstack_1grow_fast
(
h
,
achar
) (*((h)->
next_free
)++ = (achar))

	)

252 #define 
	#obstack_blank_fast
(
h
,
n
) ((h)->
next_free
 += (n))

	)

254 #define 
	#obstack_memory_used
(
h
) 
	`_obstack_memory_used
 (h)

	)

256 #if 
defined
 
__GNUC__
 && defined 
__STDC__
 && __STDC__

260 #if 
__GNUC__
 < 2 || (
__NeXT__
 && !
__GNUC_MINOR__
)

261 #define 
	#__extension__


	)

269 #define 
	#obstack_object_size
(
OBSTACK
) \

270 
__extension__
 \

271 ({ struct 
obstack
 const *
__o
 = (
OBSTACK
); \

272 (unsigned) (
__o
->
next_free
 - __o->
object_base
); })

	)

274 #define 
	#obstack_room
(
OBSTACK
) \

275 
__extension__
 \

276 ({ struct 
obstack
 const *
__o
 = (
OBSTACK
); \

277 (unsigned) (
__o
->
chunk_limit
 - __o->
next_free
); })

	)

279 #define 
	#obstack_make_room
(
OBSTACK
,
length
) \

280 
__extension__
 \

281 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

282 int 
__len
 = (
length
); \

283 if (
__o
->
chunk_limit
 - __o->
next_free
 < 
__len
) \

284 
	`_obstack_newchunk
 (
__o
, 
__len
); \

285 (void) 0; })

	)

287 #define 
	#obstack_empty_p
(
OBSTACK
) \

288 
__extension__
 \

289 ({ struct 
obstack
 const *
__o
 = (
OBSTACK
); \

290 (
__o
->
chunk
->
prev
 == 0 \

291 && 
__o
->
next_free
 == 
	`__PTR_ALIGN
 ((char *) __o->
chunk
, \

292 
__o
->
chunk
->
contents
, \

293 
__o
->
alignment_mask
)); })

	)

295 #define 
	#obstack_grow
(
OBSTACK
,
where
,
length
) \

296 
__extension__
 \

297 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

298 int 
__len
 = (
length
); \

299 if (
__o
->
next_free
 + 
__len
 > __o->
chunk_limit
) \

300 
	`_obstack_newchunk
 (
__o
, 
__len
); \

301 
	`memcpy
 (
__o
->
next_free
, 
where
, 
__len
); \

302 
__o
->
next_free
 += 
__len
; \

303 (void) 0; })

	)

305 #define 
	#obstack_grow0
(
OBSTACK
,
where
,
length
) \

306 
__extension__
 \

307 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

308 int 
__len
 = (
length
); \

309 if (
__o
->
next_free
 + 
__len
 + 1 > __o->
chunk_limit
) \

310 
	`_obstack_newchunk
 (
__o
, 
__len
 + 1); \

311 
	`memcpy
 (
__o
->
next_free
, 
where
, 
__len
); \

312 
__o
->
next_free
 += 
__len
; \

313 *(
__o
->
next_free
)++ = 0; \

314 (void) 0; })

	)

316 #define 
	#obstack_1grow
(
OBSTACK
,
datum
) \

317 
__extension__
 \

318 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

319 if (
__o
->
next_free
 + 1 > __o->
chunk_limit
) \

320 
	`_obstack_newchunk
 (
__o
, 1); \

321 
	`obstack_1grow_fast
 (
__o
, 
datum
); \

322 (void) 0; })

	)

328 #define 
	#obstack_ptr_grow
(
OBSTACK
,
datum
) \

329 
__extension__
 \

330 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

331 if (
__o
->
next_free
 + sizeof (void *) > __o->
chunk_limit
) \

332 
	`_obstack_newchunk
 (
__o
, sizeof (void *)); \

333 
	`obstack_ptr_grow_fast
 (
__o
, 
datum
); }) \

334 

	)

335 #define 
	#obstack_int_grow
(
OBSTACK
,
datum
) \

336 
__extension__
 \

337 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

338 if (
__o
->
next_free
 + sizeof (int) > __o->
chunk_limit
) \

339 
	`_obstack_newchunk
 (
__o
, sizeof (int)); \

340 
	`obstack_int_grow_fast
 (
__o
, 
datum
); })

	)

342 #define 
	#obstack_ptr_grow_fast
(
OBSTACK
,
aptr
) \

343 
__extension__
 \

344 ({ struct 
obstack
 *
__o1
 = (
OBSTACK
); \

345 *(const void **) 
__o1
->
next_free
 = (
aptr
); \

346 
__o1
->
next_free
 += sizeof (const void *); \

347 (void) 0; })

	)

349 #define 
	#obstack_int_grow_fast
(
OBSTACK
,
aint
) \

350 
__extension__
 \

351 ({ struct 
obstack
 *
__o1
 = (
OBSTACK
); \

352 *(int *) 
__o1
->
next_free
 = (
aint
); \

353 
__o1
->
next_free
 += sizeof (int); \

354 (void) 0; })

	)

356 #define 
	#obstack_blank
(
OBSTACK
,
length
) \

357 
__extension__
 \

358 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

359 int 
__len
 = (
length
); \

360 if (
__o
->
chunk_limit
 - __o->
next_free
 < 
__len
) \

361 
	`_obstack_newchunk
 (
__o
, 
__len
); \

362 
	`obstack_blank_fast
 (
__o
, 
__len
); \

363 (void) 0; })

	)

365 #define 
	#obstack_alloc
(
OBSTACK
,
length
) \

366 
__extension__
 \

367 ({ struct 
obstack
 *
__h
 = (
OBSTACK
); \

368 
	`obstack_blank
 (
__h
, (
length
)); \

369 
	`obstack_finish
 (
__h
); })

	)

371 #define 
	#obstack_copy
(
OBSTACK
,
where
,
length
) \

372 
__extension__
 \

373 ({ struct 
obstack
 *
__h
 = (
OBSTACK
); \

374 
	`obstack_grow
 (
__h
, (
where
), (
length
)); \

375 
	`obstack_finish
 (
__h
); })

	)

377 #define 
	#obstack_copy0
(
OBSTACK
,
where
,
length
) \

378 
__extension__
 \

379 ({ struct 
obstack
 *
__h
 = (
OBSTACK
); \

380 
	`obstack_grow0
 (
__h
, (
where
), (
length
)); \

381 
	`obstack_finish
 (
__h
); })

	)

385 #define 
	#obstack_finish
(
OBSTACK
) \

386 
__extension__
 \

387 ({ struct 
obstack
 *
__o1
 = (
OBSTACK
); \

388 void *
__value
 = (void *) 
__o1
->
object_base
; \

389 if (
__o1
->
next_free
 == 
__value
) \

390 
__o1
->
maybe_empty_object
 = 1; \

391 
__o1
->
next_free
 \

392 = 
	`__PTR_ALIGN
 (
__o1
->
object_base
, __o1->
next_free
, \

393 
__o1
->
alignment_mask
); \

394 if (
__o1
->
next_free
 - (char *)__o1->
chunk
 \

395 > 
__o1
->
chunk_limit
 - (char *)__o1->
chunk
) \

396 
__o1
->
next_free
 = __o1->
chunk_limit
; \

397 
__o1
->
object_base
 = __o1->
next_free
; \

398 
__value
; })

	)

400 #define 
	#obstack_free
(
OBSTACK
, 
OBJ
) \

401 
__extension__
 \

402 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

403 void *
__obj
 = (
OBJ
); \

404 if (
__obj
 > (void *)
__o
->
chunk
 && __obj < (void *)__o->
chunk_limit
) \

405 
__o
->
next_free
 = __o->
object_base
 = (char *)
__obj
; \

406 else (
__obstack_free
) (
__o
, 
__obj
); })

	)

410 #define 
	#obstack_object_size
(
h
) \

411 (unsigned) ((
h
)->
next_free
 - (h)->
object_base
)

	)

413 #define 
	#obstack_room
(
h
) \

414 (unsigned) ((
h
)->
chunk_limit
 - (h)->
next_free
)

	)

416 #define 
	#obstack_empty_p
(
h
) \

417 ((
h
)->
chunk
->
prev
 == 0 \

418 && (
h
)->
next_free
 == 
	`__PTR_ALIGN
 ((char *) (h)->
chunk
, \

419 (
h
)->
chunk
->
contents
, \

420 (
h
)->
alignment_mask
))

	)

428 #define 
	#obstack_make_room
(
h
,
length
) \

429 ( (
h
)->
temp
.
tempint
 = (
length
), \

430 (((
h
)->
next_free
 + (h)->
temp
.
tempint
 > (h)->
chunk_limit
) \

431 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
), 0) : 0))

	)

433 #define 
	#obstack_grow
(
h
,
where
,
length
) \

434 ( (
h
)->
temp
.
tempint
 = (
length
), \

435 (((
h
)->
next_free
 + (h)->
temp
.
tempint
 > (h)->
chunk_limit
) \

436 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
), 0) : 0), \

437 
	`memcpy
 ((
h
)->
next_free
, 
where
, (h)->
temp
.
tempint
), \

438 (
h
)->
next_free
 += (h)->
temp
.
tempint
)

	)

440 #define 
	#obstack_grow0
(
h
,
where
,
length
) \

441 ( (
h
)->
temp
.
tempint
 = (
length
), \

442 (((
h
)->
next_free
 + (h)->
temp
.
tempint
 + 1 > (h)->
chunk_limit
) \

443 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
 + 1), 0) : 0), \

444 
	`memcpy
 ((
h
)->
next_free
, 
where
, (h)->
temp
.
tempint
), \

445 (
h
)->
next_free
 += (h)->
temp
.
tempint
, \

446 *((
h
)->
next_free
)++ = 0)

	)

448 #define 
	#obstack_1grow
(
h
,
datum
) \

449 ( (((
h
)->
next_free
 + 1 > (h)->
chunk_limit
) \

450 ? (
	`_obstack_newchunk
 ((
h
), 1), 0) : 0), \

451 
	`obstack_1grow_fast
 (
h
, 
datum
))

	)

453 #define 
	#obstack_ptr_grow
(
h
,
datum
) \

454 ( (((
h
)->
next_free
 + sizeof (char *) > (h)->
chunk_limit
) \

455 ? (
	`_obstack_newchunk
 ((
h
), sizeof (char *)), 0) : 0), \

456 
	`obstack_ptr_grow_fast
 (
h
, 
datum
))

	)

458 #define 
	#obstack_int_grow
(
h
,
datum
) \

459 ( (((
h
)->
next_free
 + sizeof (int) > (h)->
chunk_limit
) \

460 ? (
	`_obstack_newchunk
 ((
h
), sizeof (int)), 0) : 0), \

461 
	`obstack_int_grow_fast
 (
h
, 
datum
))

	)

463 #define 
	#obstack_ptr_grow_fast
(
h
,
aptr
) \

464 (((const void **) ((
h
)->
next_free
 += sizeof (void *)))[-1] = (
aptr
))

	)

466 #define 
	#obstack_int_grow_fast
(
h
,
aint
) \

467 (((int *) ((
h
)->
next_free
 += sizeof (int)))[-1] = (
aint
))

	)

469 #define 
	#obstack_blank
(
h
,
length
) \

470 ( (
h
)->
temp
.
tempint
 = (
length
), \

471 (((
h
)->
chunk_limit
 - (h)->
next_free
 < (h)->
temp
.
tempint
) \

472 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
), 0) : 0), \

473 
	`obstack_blank_fast
 (
h
, (h)->
temp
.
tempint
))

	)

475 #define 
	#obstack_alloc
(
h
,
length
) \

476 (
	`obstack_blank
 ((
h
), (
length
)), 
	`obstack_finish
 ((h)))

	)

478 #define 
	#obstack_copy
(
h
,
where
,
length
) \

479 (
	`obstack_grow
 ((
h
), (
where
), (
length
)), 
	`obstack_finish
 ((h)))

	)

481 #define 
	#obstack_copy0
(
h
,
where
,
length
) \

482 (
	`obstack_grow0
 ((
h
), (
where
), (
length
)), 
	`obstack_finish
 ((h)))

	)

484 #define 
	#obstack_finish
(
h
) \

485 ( ((
h
)->
next_free
 == (h)->
object_base
 \

486 ? (((
h
)->
maybe_empty_object
 = 1), 0) \

488 (
h
)->
temp
.
tempptr
 = (h)->
object_base
, \

489 (
h
)->
next_free
 \

490 = 
	`__PTR_ALIGN
 ((
h
)->
object_base
, (h)->
next_free
, \

491 (
h
)->
alignment_mask
), \

492 (((
h
)->
next_free
 - (char *) (h)->
chunk
 \

493 > (
h
)->
chunk_limit
 - (char *) (h)->
chunk
) \

494 ? ((
h
)->
next_free
 = (h)->
chunk_limit
) : 0), \

495 (
h
)->
object_base
 = (h)->
next_free
, \

496 (
h
)->
temp
.
tempptr
)

	)

498 #define 
	#obstack_free
(
h
,
obj
) \

499 ( (
h
)->
temp
.
tempint
 = (char *) (
obj
) - (char *) (h)->
chunk
, \

500 ((((
h
)->
temp
.
tempint
 > 0 \

501 && (
h
)->
temp
.
tempint
 < (h)->
chunk_limit
 - (char *) (h)->
chunk
)) \

502 ? (int) ((
h
)->
next_free
 = (h)->
object_base
 \

503 = (
h
)->
temp
.
tempint
 + (char *) (h)->
chunk
) \

504 : (((
__obstack_free
) ((
h
), (h)->
temp
.
tempint
 + (char *) (h)->
chunk
), 0), 0)))

	)

508 #ifdef 
__cplusplus


	@lib/open.c

22 #define 
	#__need_system_fcntl_h


	)

23 #include 
	~<config.h
>

26 #include 
	~<fcntl.h
>

27 #include 
	~<sys/types.h
>

28 #undef 
__need_system_fcntl_h


30 static 
inline
 int

31 
	$orig_open
 (const char *
filename
, int 
flags
, 
mode_t
 
mode
)

33 return 
	`open
 (
filename
, 
flags
, 
mode
);

34 
	}
}

39 #include 
	~"fcntl.h
"

41 #include 
	~<errno.h
>

42 #include 
	~<stdarg.h
>

43 #include 
	~<string.h
>

44 #include 
	~<sys/types.h
>

45 #include 
	~<sys/stat.h
>

46 #include 
	~<unistd.h
>

48 #ifndef 
REPLACE_OPEN_DIRECTORY


49 #define 
	#REPLACE_OPEN_DIRECTORY
 0

	)

53 
	$open
 (const char *
filename
, int 
flags
, ...)

55 
mode_t
 
mode
;

56 int 
fd
;

58 
mode
 = 0;

59 if (
flags
 & 
O_CREAT
)

61 
va_list
 
arg
;

62 
	`va_start
 (
arg
, 
flags
);

66 
mode
 = 
	`va_arg
 (
arg
, 
PROMOTED_MODE_T
);

68 
	`va_end
 (
arg
);

71 #if 
GNULIB_defined_O_NONBLOCK


77 
flags
 &= ~
O_NONBLOCK
;

80 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


81 if (
	`strcmp
 (
filename
, "/dev/null") == 0)

82 
filename
 = "NUL";

85 #if 
OPEN_TRAILING_SLASH_BUG


107 if (
flags
 & (
O_CREAT
 | 
O_WRONLY
 | 
O_RDWR
))

109 
size_t
 
len
 = 
	`strlen
 (
filename
);

110 if (
len
 > 0 && 
filename
[len - 1] == '/')

112 
errno
 = 
EISDIR
;

118 
fd
 = 
	`orig_open
 (
filename
, 
flags
, 
mode
);

120 #if 
REPLACE_FCHDIR


127 if (
REPLACE_OPEN_DIRECTORY
 && 
fd
 < 0 && 
errno
 == 
EACCES


128 && ((
flags
 & 
O_ACCMODE
) == 
O_RDONLY


129 || (
O_SEARCH
 != 
O_RDONLY
 && (
flags
 & 
O_ACCMODE
) == O_SEARCH)))

131 struct 
stat
 
statbuf
;

132 if (
	`stat
 (
filename
, &
statbuf
) == 0 && 
	`S_ISDIR
 (statbuf.
st_mode
))

135 
fd
 = 
	`open
 ("/dev/null", 
flags
, 
mode
);

136 if (0 <= 
fd
)

137 
fd
 = 
	`_gl_register_fd
 (fd, 
filename
);

140 
errno
 = 
EACCES
;

144 #if 
OPEN_TRAILING_SLASH_BUG


157 if (
fd
 >= 0)

160 
size_t
 
len
 = 
	`strlen
 (
filename
);

161 if (
filename
[
len
 - 1] == '/')

163 struct 
stat
 
statbuf
;

165 if (
	`fstat
 (
fd
, &
statbuf
) >= 0 && !
	`S_ISDIR
 (statbuf.
st_mode
))

167 
	`close
 (
fd
);

168 
errno
 = 
ENOTDIR
;

175 #if 
REPLACE_FCHDIR


176 if (!
REPLACE_OPEN_DIRECTORY
 && 0 <= 
fd
)

177 
fd
 = 
	`_gl_register_fd
 (fd, 
filename
);

180 return 
fd
;

181 
	}
}

	@lib/pathmax.h

21 #ifndef 
_PATHMAX_H


22 #define 
	#_PATHMAX_H


	)

45 #include 
	~<unistd.h
>

47 #include 
	~<limits.h
>

49 #ifndef 
_POSIX_PATH_MAX


50 #define 
	#_POSIX_PATH_MAX
 256

	)

54 #if 
defined
 
HAVE_SYS_PARAM_H
 && !defined 
PATH_MAX
 && !defined 
MAXPATHLEN


55 #include 
	~<sys/param.h
>

58 #if !
defined
 
PATH_MAX
 && defined 
MAXPATHLEN


59 #define 
	#PATH_MAX
 
MAXPATHLEN


	)

62 #ifdef 
__hpux


67 #undef 
PATH_MAX


68 #define 
	#PATH_MAX
 1024

	)

71 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


82 #undef 
PATH_MAX


83 #define 
	#PATH_MAX
 260

	)

	@lib/progname.c

19 #include 
	~<config.h
>

22 #undef 
ENABLE_RELOCATABLE


23 #include 
	~"progname.h
"

25 #include 
	~<errno.h
>

26 #include 
	~<stdio.h
>

27 #include 
	~<stdlib.h
>

28 #include 
	~<string.h
>

33 const char *
	gprogram_name
 = 
NULL
;

39 
	$set_program_name
 (const char *
argv0
)

46 const char *
slash
;

47 const char *
base
;

51 if (
argv0
 == 
NULL
)

54 
	`fputs
 ("A NULL argv[0] was passed through an exec system call.\n",

55 
stderr
);

56 
	`abort
 ();

59 
slash
 = 
	`strrchr
 (
argv0
, '/');

60 
base
 = (
slash
 != 
NULL
 ? slash + 1 : 
argv0
);

61 if (
base
 - 
argv0
 >= 7 && 
	`strncmp
 (base - 7, "/.libs/", 7) == 0)

63 
argv0
 = 
base
;

64 if (
	`strncmp
 (
base
, "lt-", 3) == 0)

66 
argv0
 = 
base
 + 3;

69 #if 
HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME


70 
program_invocation_short_name
 = (char *) 
argv0
;

84 
program_name
 = 
argv0
;

89 #if 
HAVE_DECL_PROGRAM_INVOCATION_NAME


90 
program_invocation_name
 = (char *) 
argv0
;

92 
	}
}

	@lib/progname.h

18 #ifndef 
_PROGNAME_H


19 #define 
	#_PROGNAME_H


	)

26 #ifdef 
__cplusplus


32 extern const char *
program_name
;

37 extern void 
set_program_name
 (const char *
argv0
);

39 #if 
ENABLE_RELOCATABLE


43 extern void 
set_program_name_and_installdir
 (const char *
argv0
,

44 const char *
orig_installprefix
,

45 const char *
orig_installdir
);

46 #undef 
set_program_name


47 #define 
	#set_program_name
(
ARG0
) \

48 
	`set_program_name_and_installdir
 (
ARG0
, 
INSTALLPREFIX
, 
INSTALLDIR
)

	)

52 extern char *
get_full_program_name
 (void);

57 #ifdef 
__cplusplus


	@lib/propername.c

18 #include 
	~<config.h
>

21 #include 
	~"propername.h
"

23 #include 
	~<ctype.h
>

24 #include 
	~<stdbool.h
>

25 #include 
	~<stdio.h
>

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

28 #if 
HAVE_ICONV


29 #include 
	~<iconv.h
>

32 #include 
	~"trim.h
"

33 #include 
	~"mbchar.h
"

34 #include 
	~"mbuiter.h
"

35 #include 
	~"localcharset.h
"

36 #include 
	~"c-strcase.h
"

37 #include 
	~"xstriconv.h
"

38 #include 
	~"xalloc.h
"

39 #include 
	~"gettext.h
"

48 static 
bool


49 
	$mbsstr_trimmed_wordbounded
 (const char *
string
, const char *
sub
)

51 char *
tsub
 = 
	`trim
 (
sub
);

52 
bool
 
found
 = 
false
;

54 for (; *
string
 != '\0';)

56 const char *
tsub_in_string
 = 
	`mbsstr
 (
string
, 
tsub
);

57 if (
tsub_in_string
 == 
NULL
)

61 if (
MB_CUR_MAX
 > 1)

63 
mbui_iterator_t
 
string_iter
;

64 
bool
 
word_boundary_before
;

65 
bool
 
word_boundary_after
;

67 
	`mbui_init
 (
string_iter
, 
string
);

68 
word_boundary_before
 = 
true
;

69 if (
	`mbui_cur_ptr
 (
string_iter
) < 
tsub_in_string
)

71 
mbchar_t
 
last_char_before_tsub
;

74 if (!
	`mbui_avail
 (
string_iter
))

75 
	`abort
 ();

76 
last_char_before_tsub
 = 
	`mbui_cur
 (
string_iter
);

77 
	`mbui_advance
 (
string_iter
);

79 while (
	`mbui_cur_ptr
 (
string_iter
) < 
tsub_in_string
);

80 if (
	`mb_isalnum
 (
last_char_before_tsub
))

81 
word_boundary_before
 = 
false
;

84 
	`mbui_init
 (
string_iter
, 
tsub_in_string
);

86 
mbui_iterator_t
 
tsub_iter
;

88 for (
	`mbui_init
 (
tsub_iter
, 
tsub
);

89 
	`mbui_avail
 (
tsub_iter
);

90 
	`mbui_advance
 (
tsub_iter
))

92 if (!
	`mbui_avail
 (
string_iter
))

93 
	`abort
 ();

94 
	`mbui_advance
 (
string_iter
);

97 
word_boundary_after
 = 
true
;

98 if (
	`mbui_avail
 (
string_iter
))

100 
mbchar_t
 
first_char_after_tsub
 = 
	`mbui_cur
 (
string_iter
);

101 if (
	`mb_isalnum
 (
first_char_after_tsub
))

102 
word_boundary_after
 = 
false
;

105 if (
word_boundary_before
 && 
word_boundary_after
)

107 
found
 = 
true
;

111 
	`mbui_init
 (
string_iter
, 
tsub_in_string
);

112 if (!
	`mbui_avail
 (
string_iter
))

114 
string
 = 
tsub_in_string
 + 
	`mb_len
 (
	`mbui_cur
 (
string_iter
));

118 
bool
 
word_boundary_before
;

119 const char *
p
;

120 
bool
 
word_boundary_after
;

122 
word_boundary_before
 = 
true
;

123 if (
string
 < 
tsub_in_string
)

124 if (
	`isalnum
 ((unsigned char) 
tsub_in_string
[-1]))

125 
word_boundary_before
 = 
false
;

127 
p
 = 
tsub_in_string
 + 
	`strlen
 (
tsub
);

128 
word_boundary_after
 = 
true
;

129 if (*
p
 != '\0')

130 if (
	`isalnum
 ((unsigned char) *
p
))

131 
word_boundary_after
 = 
false
;

133 if (
word_boundary_before
 && 
word_boundary_after
)

135 
found
 = 
true
;

139 if (*
tsub_in_string
 == '\0')

141 
string
 = 
tsub_in_string
 + 1;

145 
	`free
 (
tsub
);

146 return 
found
;

147 
	}
}

152 
	$proper_name
 (const char *
name
)

155 const char *
translation
 = 
	`gettext
 (
name
);

157 if (
translation
 != 
name
)

160 if (
	`mbsstr_trimmed_wordbounded
 (
translation
, 
name
))

161 return 
translation
;

165 char *
result
 =

166 
	`XNMALLOC
 (
	`strlen
 (
translation
) + 2 + strlen (
name
) + 1 + 1, char);

168 
	`sprintf
 (
result
, "%s (%s)", 
translation
, 
name
);

169 return 
result
;

173 return 
name
;

174 
	}
}

182 
	$proper_name_utf8
 (const char *
name_ascii
, const char *
name_utf8
)

185 const char *
translation
 = 
	`gettext
 (
name_ascii
);

188 const char *
locale_code
 = 
	`locale_charset
 ();

189 char *
alloc_name_converted
 = 
NULL
;

190 char *
alloc_name_converted_translit
 = 
NULL
;

191 const char *
name_converted
 = 
NULL
;

192 const char *
name_converted_translit
 = 
NULL
;

193 const char *
name
;

195 if (
	`c_strcasecmp
 (
locale_code
, "UTF-8") != 0)

197 #if 
HAVE_ICONV


198 
name_converted
 = 
alloc_name_converted
 =

199 
	`xstr_iconv
 (
name_utf8
, "UTF-8", 
locale_code
);

201 #if (((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 2) || __GLIBC__ > 2) \

202 && !
defined
 
__UCLIBC__
) \

203 || 
_LIBICONV_VERSION
 >= 0x0105

205 char *
converted_translit
;

207 
size_t
 
len
 = 
	`strlen
 (
locale_code
);

208 char *
locale_code_translit
 = 
	`XNMALLOC
 (
len
 + 10 + 1, char);

209 
	`memcpy
 (
locale_code_translit
, 
locale_code
, 
len
);

210 
	`memcpy
 (
locale_code_translit
 + 
len
, "//TRANSLIT", 10 + 1);

212 
converted_translit
 =

213 
	`xstr_iconv
 (
name_utf8
, "UTF-8", 
locale_code_translit
);

215 
	`free
 (
locale_code_translit
);

217 if (
converted_translit
 != 
NULL
)

219 #if !
_LIBICONV_VERSION


224 if (
	`strchr
 (
converted_translit
, '?') != 
NULL
)

225 
	`free
 (
converted_translit
);

228 
name_converted_translit
 = 
alloc_name_converted_translit
 =

229 
converted_translit
;

237 
name_converted
 = 
name_utf8
;

238 
name_converted_translit
 = 
name_utf8
;

242 
name
 = (
name_converted
 != 
NULL
 ? name_converted :

243 
name_converted_translit
 != 
NULL
 ? name_converted_translit :

244 
name_ascii
);

249 if (
	`strcmp
 (
translation
, 
name_ascii
) != 0)

252 if (
	`mbsstr_trimmed_wordbounded
 (
translation
, 
name_ascii
)

253 || (
name_converted
 != 
NULL


254 && 
	`mbsstr_trimmed_wordbounded
 (
translation
, 
name_converted
))

255 || (
name_converted_translit
 != 
NULL


256 && 
	`mbsstr_trimmed_wordbounded
 (
translation
, 
name_converted_translit
)))

258 if (
alloc_name_converted
 != 
NULL
)

259 
	`free
 (
alloc_name_converted
);

260 if (
alloc_name_converted_translit
 != 
NULL
)

261 
	`free
 (
alloc_name_converted_translit
);

262 return 
translation
;

267 char *
result
 =

268 
	`XNMALLOC
 (
	`strlen
 (
translation
) + 2 + strlen (
name
) + 1 + 1, char);

270 
	`sprintf
 (
result
, "%s (%s)", 
translation
, 
name
);

272 if (
alloc_name_converted
 != 
NULL
)

273 
	`free
 (
alloc_name_converted
);

274 if (
alloc_name_converted_translit
 != 
NULL
)

275 
	`free
 (
alloc_name_converted_translit
);

276 return 
result
;

281 if (
alloc_name_converted
 != 
NULL
 && alloc_name_converted != 
name
)

282 
	`free
 (
alloc_name_converted
);

283 if (
alloc_name_converted_translit
 != 
NULL


284 && 
alloc_name_converted_translit
 != 
name
)

285 
	`free
 (
alloc_name_converted_translit
);

286 return 
name
;

288 
	}
}

290 #ifdef 
TEST1


291 #include 
	~<locale.h
>

293 
	$main
 (int 
argc
, char *
argv
[])

295 
	`setlocale
 (
LC_ALL
, "");

296 if (
	`mbsstr_trimmed_wordbounded
 (
argv
[1], argv[2]))

297 
	`printf
("found\n");

299 
	}
}

302 #ifdef 
TEST2


303 #include 
	~<locale.h
>

304 #include 
	~<stdio.h
>

306 
	$main
 (int 
argc
, char *
argv
[])

308 
	`setlocale
 (
LC_ALL
, "");

309 
	`printf
 ("%s\n", 
	`proper_name_utf8
 ("Franc,ois Pinard", "Fran\303\247ois Pinard"));

311 
	}
}

	@lib/propername.h

83 #ifndef 
_PROPERNAME_H


84 #define 
	#_PROPERNAME_H


	)

87 #ifdef 
__cplusplus


92 extern const char * 
proper_name
 (const char *
name
);

98 extern const char * 
proper_name_utf8
 (const char *
name_ascii
,

99 const char *
name_utf8
);

101 #ifdef 
__cplusplus


	@lib/quote.c

21 #include 
	~<config.h
>

23 #include 
	~"quotearg.h
"

24 #include 
	~"quote.h
"

29 
	$quote_n
 (int 
n
, char const *
name
)

31 return 
	`quotearg_n_style
 (
n
, 
locale_quoting_style
, 
name
);

32 
	}
}

37 
	$quote
 (char const *
name
)

39 return 
	`quote_n
 (0, 
name
);

40 
	}
}

	@lib/quote.h

19 char const *
quote_n
 (int 
n
, char const *
name
);

20 char const *
quote
 (char const *
name
);

	@lib/quotearg.c

20 #include 
	~<config.h
>

22 #include 
	~"quotearg.h
"

24 #include 
	~"xalloc.h
"

26 #include 
	~<ctype.h
>

27 #include 
	~<errno.h
>

28 #include 
	~<limits.h
>

29 #include 
	~<stdbool.h
>

30 #include 
	~<stdlib.h
>

31 #include 
	~<string.h
>

32 #include 
	~<wchar.h
>

33 #include 
	~<wctype.h
>

35 #include 
	~"gettext.h
"

36 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

37 #define 
	#N_
(
msgid
) 
	)
msgid

39 #ifndef 
SIZE_MAX


40 #define 
	#SIZE_MAX
 ((
size_t
) -1)

	)

43 #define 
	#INT_BITS
 (sizeof (int) * 
CHAR_BIT
)

	)

45 struct 
	squoting_options


48 enum 
quoting_style
 
	mstyle
;

51 int 
	mflags
;

55 unsigned int 
	mquote_these_too
[(
UCHAR_MAX
 / 
INT_BITS
) + 1];

58 char const *
	mleft_quote
;

61 char const *
	mright_quote
;

65 char const *const 
	gquoting_style_args
[] =

79 enum 
quoting_style
 const 
	gquoting_style_vals
[] =

81 
literal_quoting_style
,

82 
shell_quoting_style
,

83 
shell_always_quoting_style
,

84 
c_quoting_style
,

85 
c_maybe_quoting_style
,

86 
escape_quoting_style
,

87 
locale_quoting_style
,

88 
clocale_quoting_style


92 static struct 
quoting_options
 
	gdefault_quoting_options
;

97 struct 
quoting_options
 *

98 
	$clone_quoting_options
 (struct 
quoting_options
 *
o
)

100 int 
e
 = 
errno
;

101 struct 
quoting_options
 *
p
 = 
	`xmemdup
 (
o
 ? o : &
default_quoting_options
,

102 sizeof *
o
);

103 
errno
 = 
e
;

104 return 
p
;

105 
	}
}

108 enum 
quoting_style


109 
	$get_quoting_style
 (struct 
quoting_options
 *
o
)

111 return (
o
 ? o : &
default_quoting_options
)->
style
;

112 
	}
}

117 
	$set_quoting_style
 (struct 
quoting_options
 *
o
, enum 
quoting_style
 
s
)

119 (
o
 ? o : &
default_quoting_options
)->
style
 = 
s
;

120 
	}
}

128 
	$set_char_quoting
 (struct 
quoting_options
 *
o
, char 
c
, int 
i
)

130 unsigned char 
uc
 = 
c
;

131 unsigned int *
p
 =

132 (
o
 ? o : &
default_quoting_options
)->
quote_these_too
 + 
uc
 / 
INT_BITS
;

133 int 
shift
 = 
uc
 % 
INT_BITS
;

134 int 
r
 = (*
p
 >> 
shift
) & 1;

135 *
p
 ^= ((
i
 & 1) ^ 
r
) << 
shift
;

136 return 
r
;

137 
	}
}

144 
	$set_quoting_flags
 (struct 
quoting_options
 *
o
, int 
i
)

146 int 
r
;

147 if (!
o
)

148 
o
 = &
default_quoting_options
;

149 
r
 = 
o
->
flags
;

150 
o
->
flags
 = 
i
;

151 return 
r
;

152 
	}
}

155 
	$set_custom_quoting
 (struct 
quoting_options
 *
o
,

156 char const *
left_quote
, char const *
right_quote
)

158 if (!
o
)

159 
o
 = &
default_quoting_options
;

160 
o
->
style
 = 
custom_quoting_style
;

161 if (!
left_quote
 || !
right_quote
)

162 
	`abort
 ();

163 
o
->
left_quote
 = left_quote;

164 
o
->
right_quote
 = right_quote;

165 
	}
}

168 static struct 
quoting_options


169 
	$quoting_options_from_style
 (enum 
quoting_style
 
style
)

171 struct 
quoting_options
 
o
 = { 0 };

172 if (
style
 == 
custom_quoting_style
)

173 
	`abort
 ();

174 
o
.
style
 = style;

175 return 
o
;

176 
	}
}

181 
	$gettext_quote
 (char const *
msgid
, enum 
quoting_style
 
s
)

183 char const *
translation
 = 
	`_
(
msgid
);

184 if (
translation
 == 
msgid
 && 
s
 == 
clocale_quoting_style
)

185 
translation
 = "\"";

186 return 
translation
;

187 
	}
}

202 static 
size_t


203 
	$quotearg_buffer_restyled
 (char *
buffer
, 
size_t
 
buffersize
,

204 char const *
arg
, 
size_t
 
argsize
,

205 enum 
quoting_style
 quoting_style, int 
flags
,

206 unsigned int const *
quote_these_too
,

207 char const *
left_quote
,

208 char const *
right_quote
)

210 
size_t
 
i
;

211 
size_t
 
len
 = 0;

212 char const *
quote_string
 = 0;

213 
size_t
 
quote_string_len
 = 0;

214 
bool
 
backslash_escapes
 = 
false
;

215 
bool
 
unibyte_locale
 = 
MB_CUR_MAX
 == 1;

216 
bool
 
elide_outer_quotes
 = (
flags
 & 
QA_ELIDE_OUTER_QUOTES
) != 0;

218 #define 
	#STORE
(
c
) \

221 if (
len
 < 
buffersize
) \

222 
buffer
[
len
] = (
c
); \

223 
len
++; \

225 while (0)

	)

227 switch (
quoting_style
)

229 case 
c_maybe_quoting_style
:

230 
quoting_style
 = 
c_quoting_style
;

231 
elide_outer_quotes
 = 
true
;

233 case 
c_quoting_style
:

234 if (!
elide_outer_quotes
)

235 
	`STORE
 ('"');

236 
backslash_escapes
 = 
true
;

237 
quote_string
 = "\"";

238 
quote_string_len
 = 1;

241 case 
escape_quoting_style
:

242 
backslash_escapes
 = 
true
;

243 
elide_outer_quotes
 = 
false
;

246 case 
locale_quoting_style
:

247 case 
clocale_quoting_style
:

248 case 
custom_quoting_style
:

250 if (
quoting_style
 != 
custom_quoting_style
)

271 
left_quote
 = 
	`gettext_quote
 (
	`N_
("`"), 
quoting_style
);

272 
right_quote
 = 
	`gettext_quote
 (
	`N_
("'"), 
quoting_style
);

274 if (!
elide_outer_quotes
)

275 for (
quote_string
 = 
left_quote
; *quote_string; quote_string++)

276 
	`STORE
 (*
quote_string
);

277 
backslash_escapes
 = 
true
;

278 
quote_string
 = 
right_quote
;

279 
quote_string_len
 = 
	`strlen
 (
quote_string
);

283 case 
shell_quoting_style
:

284 
quoting_style
 = 
shell_always_quoting_style
;

285 
elide_outer_quotes
 = 
true
;

287 case 
shell_always_quoting_style
:

288 if (!
elide_outer_quotes
)

289 
	`STORE
 ('\'');

290 
quote_string
 = "'";

291 
quote_string_len
 = 1;

294 case 
literal_quoting_style
:

295 
elide_outer_quotes
 = 
false
;

299 
	`abort
 ();

302 for (
i
 = 0; ! (
argsize
 == 
SIZE_MAX
 ? 
arg
[i] == '\0' : i == argsize); i++)

304 unsigned char 
c
;

305 unsigned char 
esc
;

306 
bool
 
is_right_quote
 = 
false
;

308 if (
backslash_escapes


309 && 
quote_string_len


310 && 
i
 + 
quote_string_len
 <= 
argsize


311 && 
	`memcmp
 (
arg
 + 
i
, 
quote_string
, 
quote_string_len
) == 0)

313 if (
elide_outer_quotes
)

314 goto 
force_outer_quoting_style
;

315 
is_right_quote
 = 
true
;

318 
c
 = 
arg
[
i
];

319 switch (
c
)

322 if (
backslash_escapes
)

324 if (
elide_outer_quotes
)

325 goto 
force_outer_quoting_style
;

326 
	`STORE
 ('\\');

332 if (
i
 + 1 < 
argsize
 && '0' <= 
arg
[i + 1] && arg[i + 1] <= '9')

334 
	`STORE
 ('0');

335 
	`STORE
 ('0');

337 
c
 = '0';

343 else if (
flags
 & 
QA_ELIDE_NULL_BYTES
)

348 switch (
quoting_style
)

350 case 
shell_always_quoting_style
:

351 if (
elide_outer_quotes
)

352 goto 
force_outer_quoting_style
;

355 case 
c_quoting_style
:

356 if ((
flags
 & 
QA_SPLIT_TRIGRAPHS
)

357 && 
i
 + 2 < 
argsize
 && 
arg
[i + 1] == '?')

358 switch (
arg
[
i
 + 2])

365 if (
elide_outer_quotes
)

366 goto 
force_outer_quoting_style
;

367 
c
 = 
arg
[
i
 + 2];

368 
i
 += 2;

369 
	`STORE
 ('?');

370 
	`STORE
 ('"');

371 
	`STORE
 ('"');

372 
	`STORE
 ('?');

385 case '\a': 
esc
 = 'a'; goto 
c_escape
;

386 case '\b': 
esc
 = 'b'; goto 
c_escape
;

387 case '\f': 
esc
 = 'f'; goto 
c_escape
;

388 case '\n': 
esc
 = 'n'; goto 
c_and_shell_escape
;

389 case '\r': 
esc
 = 'r'; goto 
c_and_shell_escape
;

390 case '\t': 
esc
 = 't'; goto 
c_and_shell_escape
;

391 case '\v': 
esc
 = 'v'; goto 
c_escape
;

392 case '\\': 
esc
 = 
c
;

395 if (
backslash_escapes
 && 
elide_outer_quotes
 && 
quote_string_len
)

396 goto 
store_c
;

398 
c_and_shell_escape
:

399 if (
quoting_style
 == 
shell_always_quoting_style


400 && 
elide_outer_quotes
)

401 goto 
force_outer_quoting_style
;

403 
c_escape
:

404 if (
backslash_escapes
)

406 
c
 = 
esc
;

407 goto 
store_escape
;

412 if (! (
argsize
 == 
SIZE_MAX
 ? 
arg
[1] == '\0' : argsize == 1))

416 if (
i
 != 0)

432 if (
quoting_style
 == 
shell_always_quoting_style


433 && 
elide_outer_quotes
)

434 goto 
force_outer_quoting_style
;

438 if (
quoting_style
 == 
shell_always_quoting_style
)

440 if (
elide_outer_quotes
)

441 goto 
force_outer_quoting_style
;

442 
	`STORE
 ('\'');

443 
	`STORE
 ('\\');

444 
	`STORE
 ('\'');

480 
size_t
 
m
;

482 
bool
 
printable
;

484 if (
unibyte_locale
)

486 
m
 = 1;

487 
printable
 = 
	`isprint
 (
c
) != 0;

491 
mbstate_t
 
mbstate
;

492 
	`memset
 (&
mbstate
, 0, sizeof mbstate);

494 
m
 = 0;

495 
printable
 = 
true
;

496 if (
argsize
 == 
SIZE_MAX
)

497 
argsize
 = 
	`strlen
 (
arg
);

501 
wchar_t
 
w
;

502 
size_t
 
bytes
 = 
	`mbrtowc
 (&
w
, &
arg
[
i
 + 
m
],

503 
argsize
 - (
i
 + 
m
), &
mbstate
);

504 if (
bytes
 == 0)

506 else if (
bytes
 == (
size_t
) -1)

508 
printable
 = 
false
;

511 else if (
bytes
 == (
size_t
) -2)

513 
printable
 = 
false
;

514 while (
i
 + 
m
 < 
argsize
 && 
arg
[i + m])

515 
m
++;

524 if ('[' == 0x5b && 
elide_outer_quotes


525 && 
quoting_style
 == 
shell_always_quoting_style
)

527 
size_t
 
j
;

528 for (
j
 = 1; j < 
bytes
; j++)

529 switch (
arg
[
i
 + 
m
 + 
j
])

533 goto 
force_outer_quoting_style
;

540 if (! 
	`iswprint
 (
w
))

541 
printable
 = 
false
;

542 
m
 += 
bytes
;

545 while (! 
	`mbsinit
 (&
mbstate
));

548 if (1 < 
m
 || (
backslash_escapes
 && ! 
printable
))

552 
size_t
 
ilim
 = 
i
 + 
m
;

556 if (
backslash_escapes
 && ! 
printable
)

558 if (
elide_outer_quotes
)

559 goto 
force_outer_quoting_style
;

560 
	`STORE
 ('\\');

561 
	`STORE
 ('0' + (
c
 >> 6));

562 
	`STORE
 ('0' + ((
c
 >> 3) & 7));

563 
c
 = '0' + (c & 7);

565 else if (
is_right_quote
)

567 
	`STORE
 ('\\');

568 
is_right_quote
 = 
false
;

570 if (
ilim
 <= 
i
 + 1)

572 
	`STORE
 (
c
);

573 
c
 = 
arg
[++
i
];

576 goto 
store_c
;

581 if (! ((
backslash_escapes
 || 
elide_outer_quotes
)

582 && 
quote_these_too


583 && 
quote_these_too
[
c
 / 
INT_BITS
] & (1 << (c % INT_BITS)))

584 && !
is_right_quote
)

585 goto 
store_c
;

587 
store_escape
:

588 if (
elide_outer_quotes
)

589 goto 
force_outer_quoting_style
;

590 
	`STORE
 ('\\');

592 
store_c
:

593 
	`STORE
 (
c
);

596 if (
len
 == 0 && 
quoting_style
 == 
shell_always_quoting_style


597 && 
elide_outer_quotes
)

598 goto 
force_outer_quoting_style
;

600 if (
quote_string
 && !
elide_outer_quotes
)

601 for (; *
quote_string
; quote_string++)

602 
	`STORE
 (*
quote_string
);

604 if (
len
 < 
buffersize
)

605 
buffer
[
len
] = '\0';

606 return 
len
;

608 
force_outer_quoting_style
:

611 return 
	`quotearg_buffer_restyled
 (
buffer
, 
buffersize
, 
arg
, 
argsize
,

612 
quoting_style
,

613 
flags
 & ~
QA_ELIDE_OUTER_QUOTES
, 
NULL
,

614 
left_quote
, 
right_quote
);

615 
	}
}

626 
size_t


627 
	$quotearg_buffer
 (char *
buffer
, 
size_t
 
buffersize
,

628 char const *
arg
, 
size_t
 
argsize
,

629 struct 
quoting_options
 const *
o
)

631 struct 
quoting_options
 const *
p
 = 
o
 ? o : &
default_quoting_options
;

632 int 
e
 = 
errno
;

633 
size_t
 
r
 = 
	`quotearg_buffer_restyled
 (
buffer
, 
buffersize
, 
arg
, 
argsize
,

634 
p
->
style
, p->
flags
, p->
quote_these_too
,

635 
p
->
left_quote
, p->
right_quote
);

636 
errno
 = 
e
;

637 return 
r
;

638 
	}
}

642 
	$quotearg_alloc
 (char const *
arg
, 
size_t
 
argsize
,

643 struct 
quoting_options
 const *
o
)

645 return 
	`quotearg_alloc_mem
 (
arg
, 
argsize
, 
NULL
, 
o
);

646 
	}
}

655 
	$quotearg_alloc_mem
 (char const *
arg
, 
size_t
 
argsize
, size_t *
size
,

656 struct 
quoting_options
 const *
o
)

658 struct 
quoting_options
 const *
p
 = 
o
 ? o : &
default_quoting_options
;

659 int 
e
 = 
errno
;

661 int 
flags
 = 
p
->flags | (
size
 ? 0 : 
QA_ELIDE_NULL_BYTES
);

662 
size_t
 
bufsize
 = 
	`quotearg_buffer_restyled
 (0, 0, 
arg
, 
argsize
, 
p
->
style
,

663 
flags
, 
p
->
quote_these_too
,

664 
p
->
left_quote
,

665 
p
->
right_quote
) + 1;

666 char *
buf
 = 
	`xcharalloc
 (
bufsize
);

667 
	`quotearg_buffer_restyled
 (
buf
, 
bufsize
, 
arg
, 
argsize
, 
p
->
style
, 
flags
,

668 
p
->
quote_these_too
,

669 
p
->
left_quote
, p->
right_quote
);

670 
errno
 = 
e
;

671 if (
size
)

672 *
size
 = 
bufsize
 - 1;

673 return 
buf
;

674 
	}
}

677 struct 
	sslotvec


679 
size_t
 
	msize
;

680 char *
	mval
;

685 static char 
	gslot0
[256];

686 static unsigned int 
	gnslots
 = 1;

687 static struct 
slotvec
 
	gslotvec0
 = {sizeof 
slot0
, slot0};

688 static struct 
slotvec
 *
	gslotvec
 = &
slotvec0
;

691 
	$quotearg_free
 (void)

693 struct 
slotvec
 *
sv
 = slotvec;

694 unsigned int 
i
;

695 for (
i
 = 1; i < 
nslots
; i++)

696 
	`free
 (
sv
[
i
].
val
);

697 if (
sv
[0].
val
 != 
slot0
)

699 
	`free
 (
sv
[0].
val
);

700 
slotvec0
.
size
 = sizeof 
slot0
;

701 
slotvec0
.
val
 = 
slot0
;

703 if (
sv
 != &
slotvec0
)

705 
	`free
 (
sv
);

706 
slotvec
 = &
slotvec0
;

708 
nslots
 = 1;

709 
	}
}

720 
	$quotearg_n_options
 (int 
n
, char const *
arg
, 
size_t
 
argsize
,

721 struct 
quoting_options
 const *
options
)

723 int 
e
 = 
errno
;

725 unsigned int 
n0
 = 
n
;

726 struct 
slotvec
 *
sv
 = slotvec;

728 if (
n
 < 0)

729 
	`abort
 ();

731 if (
nslots
 <= 
n0
)

738 
size_t
 
n1
 = 
n0
 + 1;

739 
bool
 
preallocated
 = (
sv
 == &
slotvec0
);

741 if (
	`xalloc_oversized
 (
n1
, sizeof *
sv
))

742 
	`xalloc_die
 ();

744 
slotvec
 = 
sv
 = 
	`xrealloc
 (
preallocated
 ? 
NULL
 : sv, 
n1
 * sizeof *sv);

745 if (
preallocated
)

746 *
sv
 = 
slotvec0
;

747 
	`memset
 (
sv
 + 
nslots
, 0, (
n1
 - nslots) * sizeof *sv);

748 
nslots
 = 
n1
;

752 
size_t
 
size
 = 
sv
[
n
].size;

753 char *
val
 = 
sv
[
n
].val;

755 int 
flags
 = 
options
->flags | 
QA_ELIDE_NULL_BYTES
;

756 
size_t
 
qsize
 = 
	`quotearg_buffer_restyled
 (
val
, 
size
, 
arg
, 
argsize
,

757 
options
->
style
, 
flags
,

758 
options
->
quote_these_too
,

759 
options
->
left_quote
,

760 
options
->
right_quote
);

762 if (
size
 <= 
qsize
)

764 
sv
[
n
].
size
 = size = 
qsize
 + 1;

765 if (
val
 != 
slot0
)

766 
	`free
 (
val
);

767 
sv
[
n
].
val
 = val = 
	`xcharalloc
 (
size
);

768 
	`quotearg_buffer_restyled
 (
val
, 
size
, 
arg
, 
argsize
, 
options
->
style
,

769 
flags
, 
options
->
quote_these_too
,

770 
options
->
left_quote
,

771 
options
->
right_quote
);

774 
errno
 = 
e
;

775 return 
val
;

777 
	}
}

780 
	$quotearg_n
 (int 
n
, char const *
arg
)

782 return 
	`quotearg_n_options
 (
n
, 
arg
, 
SIZE_MAX
, &
default_quoting_options
);

783 
	}
}

786 
	$quotearg_n_mem
 (int 
n
, char const *
arg
, 
size_t
 
argsize
)

788 return 
	`quotearg_n_options
 (
n
, 
arg
, 
argsize
, &
default_quoting_options
);

789 
	}
}

792 
	$quotearg
 (char const *
arg
)

794 return 
	`quotearg_n
 (0, 
arg
);

795 
	}
}

798 
	$quotearg_mem
 (char const *
arg
, 
size_t
 
argsize
)

800 return 
	`quotearg_n_mem
 (0, 
arg
, 
argsize
);

801 
	}
}

804 
	$quotearg_n_style
 (int 
n
, enum 
quoting_style
 
s
, char const *
arg
)

806 struct 
quoting_options
 const 
o
 = 
	`quoting_options_from_style
 (
s
);

807 return 
	`quotearg_n_options
 (
n
, 
arg
, 
SIZE_MAX
, &
o
);

808 
	}
}

811 
	$quotearg_n_style_mem
 (int 
n
, enum 
quoting_style
 
s
,

812 char const *
arg
, 
size_t
 
argsize
)

814 struct 
quoting_options
 const 
o
 = 
	`quoting_options_from_style
 (
s
);

815 return 
	`quotearg_n_options
 (
n
, 
arg
, 
argsize
, &
o
);

816 
	}
}

819 
	$quotearg_style
 (enum 
quoting_style
 
s
, char const *
arg
)

821 return 
	`quotearg_n_style
 (0, 
s
, 
arg
);

822 
	}
}

825 
	$quotearg_style_mem
 (enum 
quoting_style
 
s
, char const *
arg
, 
size_t
 
argsize
)

827 return 
	`quotearg_n_style_mem
 (0, 
s
, 
arg
, 
argsize
);

828 
	}
}

831 
	$quotearg_char_mem
 (char const *
arg
, 
size_t
 
argsize
, char 
ch
)

833 struct 
quoting_options
 
options
;

834 
options
 = 
default_quoting_options
;

835 
	`set_char_quoting
 (&
options
, 
ch
, 1);

836 return 
	`quotearg_n_options
 (0, 
arg
, 
argsize
, &
options
);

837 
	}
}

840 
	$quotearg_char
 (char const *
arg
, char 
ch
)

842 return 
	`quotearg_char_mem
 (
arg
, 
SIZE_MAX
, 
ch
);

843 
	}
}

846 
	$quotearg_colon
 (char const *
arg
)

848 return 
	`quotearg_char
 (
arg
, ':');

849 
	}
}

852 
	$quotearg_colon_mem
 (char const *
arg
, 
size_t
 
argsize
)

854 return 
	`quotearg_char_mem
 (
arg
, 
argsize
, ':');

855 
	}
}

858 
	$quotearg_n_custom
 (int 
n
, char const *
left_quote
,

859 char const *
right_quote
, char const *
arg
)

861 return 
	`quotearg_n_custom_mem
 (
n
, 
left_quote
, 
right_quote
, 
arg
,

862 
SIZE_MAX
);

863 
	}
}

866 
	$quotearg_n_custom_mem
 (int 
n
, char const *
left_quote
,

867 char const *
right_quote
,

868 char const *
arg
, 
size_t
 
argsize
)

870 struct 
quoting_options
 
o
 = 
default_quoting_options
;

871 
	`set_custom_quoting
 (&
o
, 
left_quote
, 
right_quote
);

872 return 
	`quotearg_n_options
 (
n
, 
arg
, 
argsize
, &
o
);

873 
	}
}

876 
	$quotearg_custom
 (char const *
left_quote
, char const *
right_quote
,

877 char const *
arg
)

879 return 
	`quotearg_n_custom
 (0, 
left_quote
, 
right_quote
, 
arg
);

880 
	}
}

883 
	$quotearg_custom_mem
 (char const *
left_quote
, char const *
right_quote
,

884 char const *
arg
, 
size_t
 
argsize
)

886 return 
	`quotearg_n_custom_mem
 (0, 
left_quote
, 
right_quote
, 
arg
,

887 
argsize
);

888 
	}
}

	@lib/quotearg.h

21 #ifndef 
QUOTEARG_H_


22 #define 
	#QUOTEARG_H_
 1

	)

24 #include 
	~<stddef.h
>

32 enum 
	equoting_style


45 
	mliteral_quoting_style
,

59 
	mshell_quoting_style
,

74 
	mshell_always_quoting_style
,

88 
	mc_quoting_style
,

100 
	mc_maybe_quoting_style
,

113 
	mescape_quoting_style
,

137 
	mlocale_quoting_style
,

162 
	mclocale_quoting_style
,

205 
	mcustom_quoting_style


209 enum 
	equoting_flags


214 
	mQA_ELIDE_NULL_BYTES
 = 0x01,

219 
	mQA_ELIDE_OUTER_QUOTES
 = 0x02,

225 
	mQA_SPLIT_TRIGRAPHS
 = 0x04

229 #ifndef 
DEFAULT_QUOTING_STYLE


230 #define 
	#DEFAULT_QUOTING_STYLE
 
literal_quoting_style


	)

234 extern char const *const 
quoting_style_args
[];

235 extern enum 
quoting_style
 const 
quoting_style_vals
[];

237 struct 
	gquoting_options
;

245 struct 
quoting_options
 *
clone_quoting_options
 (struct quoting_options *
o
);

248 enum 
quoting_style
 
get_quoting_style
 (struct 
quoting_options
 *
o
);

252 void 
set_quoting_style
 (struct 
quoting_options
 *
o
, enum 
quoting_style
 
s
);

261 int 
set_char_quoting
 (struct 
quoting_options
 *
o
, char 
c
, int 
i
);

267 int 
set_quoting_flags
 (struct 
quoting_options
 *
o
, int 
i
);

278 void 
set_custom_quoting
 (struct 
quoting_options
 *
o
,

279 char const *
left_quote
,

280 char const *
right_quote
);

293 
size_t
 
quotearg_buffer
 (char *
buffer
, size_t 
buffersize
,

294 char const *
arg
, 
size_t
 
argsize
,

295 struct 
quoting_options
 const *
o
);

300 char *
quotearg_alloc
 (char const *
arg
, 
size_t
 
argsize
,

301 struct 
quoting_options
 const *
o
);

309 char *
quotearg_alloc_mem
 (char const *
arg
, 
size_t
 
argsize
,

310 
size_t
 *
size
, struct 
quoting_options
 const *
o
);

319 char *
quotearg_n
 (int 
n
, char const *
arg
);

322 char *
quotearg
 (char const *
arg
);

327 char *
quotearg_n_mem
 (int 
n
, char const *
arg
, 
size_t
 
argsize
);

330 char *
quotearg_mem
 (char const *
arg
, 
size_t
 
argsize
);

335 char *
quotearg_n_style
 (int 
n
, enum 
quoting_style
 
s
, char const *
arg
);

340 char *
quotearg_n_style_mem
 (int 
n
, enum 
quoting_style
 
s
,

341 char const *
arg
, 
size_t
 
argsize
);

344 char *
quotearg_style
 (enum 
quoting_style
 
s
, char const *
arg
);

347 char *
quotearg_style_mem
 (enum 
quoting_style
 
s
,

348 char const *
arg
, 
size_t
 
argsize
);

352 char *
quotearg_char
 (char const *
arg
, char 
ch
);

355 char *
quotearg_char_mem
 (char const *
arg
, 
size_t
 
argsize
, char 
ch
);

358 char *
quotearg_colon
 (char const *
arg
);

361 char *
quotearg_colon_mem
 (char const *
arg
, 
size_t
 
argsize
);

367 char *
quotearg_n_custom
 (int 
n
, char const *
left_quote
,

368 char const *
right_quote
, char const *
arg
);

372 char *
quotearg_n_custom_mem
 (int 
n
, char const *
left_quote
,

373 char const *
right_quote
,

374 char const *
arg
, 
size_t
 
argsize
);

377 char *
quotearg_custom
 (char const *
left_quote
, char const *
right_quote
,

378 char const *
arg
);

382 char *
quotearg_custom_mem
 (char const *
left_quote
,

383 char const *
right_quote
,

384 char const *
arg
, 
size_t
 
argsize
);

387 void 
quotearg_free
 (void);

	@lib/realloc.c

21 #define 
	#_GL_USE_STDLIB_ALLOC
 1

	)

22 #include 
	~<config.h
>

25 #ifdef 
realloc


26 #define 
	#NEED_REALLOC_GNU
 1

	)

28 #elif 
GNULIB_REALLOC_GNU
 && !
HAVE_REALLOC_GNU


29 #define 
	#NEED_REALLOC_GNU
 1

	)

34 #if 
GNULIB_MALLOC_GNU
 && 
HAVE_MALLOC_GNU


35 #define 
	#SYSTEM_MALLOC_GLIBC_COMPATIBLE
 1

	)

38 #include 
	~<stdlib.h
>

40 #include 
	~<errno.h
>

47 
	$rpl_realloc
 (void *
p
, 
size_t
 
n
)

49 void *
result
;

51 #if 
NEED_REALLOC_GNU


52 if (
n
 == 0)

54 
n
 = 1;

57 
	`free
 (
p
);

58 
p
 = 
NULL
;

62 if (
p
 == 
NULL
)

64 #if 
GNULIB_REALLOC_GNU
 && !
NEED_REALLOC_GNU
 && !
SYSTEM_MALLOC_GLIBC_COMPATIBLE


65 if (
n
 == 0)

66 
n
 = 1;

68 
result
 = 
	`malloc
 (
n
);

71 
result
 = 
	`realloc
 (
p
, 
n
);

73 #if !
HAVE_REALLOC_POSIX


74 if (
result
 == 
NULL
)

75 
errno
 = 
ENOMEM
;

78 return 
result
;

79 
	}
}

	@lib/regcomp.c

22 static 
reg_errcode_t
 
re_compile_internal
 (
regex_t
 *
preg
, const char * 
pattern
,

23 
size_t
 
length
, 
reg_syntax_t
 
syntax
);

24 static void 
re_compile_fastmap_iter
 (
regex_t
 *
bufp
,

25 const 
re_dfastate_t
 *
init_state
,

26 char *
fastmap
);

27 static 
reg_errcode_t
 
init_dfa
 (
re_dfa_t
 *
dfa
, 
size_t
 
pat_len
);

28 #ifdef 
RE_ENABLE_I18N


29 static void 
free_charset
 (
re_charset_t
 *
cset
);

31 static void 
free_workarea_compile
 (
regex_t
 *
preg
);

32 static 
reg_errcode_t
 
create_initial_state
 (
re_dfa_t
 *
dfa
);

33 #ifdef 
RE_ENABLE_I18N


34 static void 
optimize_utf8
 (
re_dfa_t
 *
dfa
);

36 static 
reg_errcode_t
 
analyze
 (
regex_t
 *
preg
);

37 static 
reg_errcode_t
 
preorder
 (
bin_tree_t
 *
root
,

38 
reg_errcode_t
 (
fn
 (void *, 
bin_tree_t
 *)),

39 void *
extra
);

40 static 
reg_errcode_t
 
postorder
 (
bin_tree_t
 *
root
,

41 
reg_errcode_t
 (
fn
 (void *, 
bin_tree_t
 *)),

42 void *
extra
);

43 static 
reg_errcode_t
 
optimize_subexps
 (void *
extra
, 
bin_tree_t
 *
node
);

44 static 
reg_errcode_t
 
lower_subexps
 (void *
extra
, 
bin_tree_t
 *
node
);

45 static 
bin_tree_t
 *
lower_subexp
 (
reg_errcode_t
 *
err
, 
regex_t
 *
preg
,

46 
bin_tree_t
 *
node
);

47 static 
reg_errcode_t
 
calc_first
 (void *
extra
, 
bin_tree_t
 *
node
);

48 static 
reg_errcode_t
 
calc_next
 (void *
extra
, 
bin_tree_t
 *
node
);

49 static 
reg_errcode_t
 
link_nfa_nodes
 (void *
extra
, 
bin_tree_t
 *
node
);

50 static 
Idx
 
duplicate_node
 (
re_dfa_t
 *
dfa
, Idx 
org_idx
, unsigned int 
constraint
);

51 static 
Idx
 
search_duplicated_node
 (const 
re_dfa_t
 *
dfa
, Idx 
org_node
,

52 unsigned int 
constraint
);

53 static 
reg_errcode_t
 
calc_eclosure
 (
re_dfa_t
 *
dfa
);

54 static 
reg_errcode_t
 
calc_eclosure_iter
 (
re_node_set
 *
new_set
, 
re_dfa_t
 *
dfa
,

55 
Idx
 
node
, 
bool
 
root
);

56 static 
reg_errcode_t
 
calc_inveclosure
 (
re_dfa_t
 *
dfa
);

57 static 
Idx
 
fetch_number
 (
re_string_t
 *
input
, 
re_token_t
 *
token
,

58 
reg_syntax_t
 
syntax
);

59 static int 
	$peek_token
 (
re_token_t
 *
token
, 
re_string_t
 *
input
,

60 
reg_syntax_t
 
syntax
) 
internal_function
;

61 static 
bin_tree_t
 *
	`parse
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
,

62 
reg_syntax_t
 
syntax
, 
reg_errcode_t
 *
err
);

63 static 
bin_tree_t
 *
	`parse_reg_exp
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
,

64 
re_token_t
 *
token
, 
reg_syntax_t
 
syntax
,

65 
Idx
 
nest
, 
reg_errcode_t
 *
err
);

66 static 
bin_tree_t
 *
	`parse_branch
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
,

67 
re_token_t
 *
token
, 
reg_syntax_t
 
syntax
,

68 
Idx
 
nest
, 
reg_errcode_t
 *
err
);

69 static 
bin_tree_t
 *
	`parse_expression
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
,

70 
re_token_t
 *
token
, 
reg_syntax_t
 
syntax
,

71 
Idx
 
nest
, 
reg_errcode_t
 *
err
);

72 static 
bin_tree_t
 *
	`parse_sub_exp
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
,

73 
re_token_t
 *
token
, 
reg_syntax_t
 
syntax
,

74 
Idx
 
nest
, 
reg_errcode_t
 *
err
);

75 static 
bin_tree_t
 *
	`parse_dup_op
 (bin_tree_t *
dup_elem
, 
re_string_t
 *
regexp
,

76 
re_dfa_t
 *
dfa
, 
re_token_t
 *
token
,

77 
reg_syntax_t
 
syntax
, 
reg_errcode_t
 *
err
);

78 static 
bin_tree_t
 *
	`parse_bracket_exp
 (
re_string_t
 *
regexp
, 
re_dfa_t
 *
dfa
,

79 
re_token_t
 *
token
, 
reg_syntax_t
 
syntax
,

80 
reg_errcode_t
 *
err
);

81 static 
reg_errcode_t
 
	`parse_bracket_element
 (
bracket_elem_t
 *
elem
,

82 
re_string_t
 *
regexp
,

83 
re_token_t
 *
token
, int 
token_len
,

84 
re_dfa_t
 *
dfa
,

85 
reg_syntax_t
 
syntax
,

86 
bool
 
accept_hyphen
);

87 static 
reg_errcode_t
 
	`parse_bracket_symbol
 (
bracket_elem_t
 *
elem
,

88 
re_string_t
 *
regexp
,

89 
re_token_t
 *
token
);

90 #ifdef 
RE_ENABLE_I18N


91 static 
reg_errcode_t
 
	`build_equiv_class
 (
bitset_t
 
sbcset
,

92 
re_charset_t
 *
mbcset
,

93 
Idx
 *
equiv_class_alloc
,

94 const unsigned char *
name
);

95 static 
reg_errcode_t
 
	`build_charclass
 (
RE_TRANSLATE_TYPE
 
trans
,

96 
bitset_t
 
sbcset
,

97 
re_charset_t
 *
mbcset
,

98 
Idx
 *
char_class_alloc
,

99 const unsigned char *
class_name
,

100 
reg_syntax_t
 
syntax
);

102 static 
reg_errcode_t
 
	`build_equiv_class
 (
bitset_t
 
sbcset
,

103 const unsigned char *
name
);

104 static 
reg_errcode_t
 
	`build_charclass
 (
RE_TRANSLATE_TYPE
 
trans
,

105 
bitset_t
 
sbcset
,

106 const unsigned char *
class_name
,

107 
reg_syntax_t
 
syntax
);

109 static 
bin_tree_t
 *
	`build_charclass_op
 (
re_dfa_t
 *
dfa
,

110 
RE_TRANSLATE_TYPE
 
trans
,

111 const unsigned char *
class_name
,

112 const unsigned char *
extra
,

113 
bool
 
non_match
, 
reg_errcode_t
 *
err
);

114 static 
bin_tree_t
 *
	`create_tree
 (
re_dfa_t
 *
dfa
,

115 
bin_tree_t
 *
left
, bin_tree_t *
right
,

116 
re_token_type_t
 
type
);

117 static 
bin_tree_t
 *
	`create_token_tree
 (
re_dfa_t
 *
dfa
,

118 
bin_tree_t
 *
left
, bin_tree_t *
right
,

119 const 
re_token_t
 *
token
);

120 static 
bin_tree_t
 *
	`duplicate_tree
 (const bin_tree_t *
src
, 
re_dfa_t
 *
dfa
);

121 static void 
	`free_token
 (
re_token_t
 *
node
);

122 static 
reg_errcode_t
 
	`free_tree
 (void *
extra
, 
bin_tree_t
 *
node
);

123 static 
reg_errcode_t
 
	`mark_opt_subexp
 (void *
extra
, 
bin_tree_t
 *
node
);

130 static const char 
__re_error_msgid
[] =

132 #define 
	#REG_NOERROR_IDX
 0

	)

133 
	`gettext_noop
 ("Success")

135 #define 
	#REG_NOMATCH_IDX
 (
REG_NOERROR_IDX
 + sizeof "Success")

	)

136 
	`gettext_noop
 ("No match")

138 #define 
	#REG_BADPAT_IDX
 (
REG_NOMATCH_IDX
 + sizeof "No match")

	)

139 
	`gettext_noop
 ("Invalid regular expression")

141 #define 
	#REG_ECOLLATE_IDX
 (
REG_BADPAT_IDX
 + sizeof "Invalid regular expression")

	)

142 
	`gettext_noop
 ("Invalid collation character")

144 #define 
	#REG_ECTYPE_IDX
 (
REG_ECOLLATE_IDX
 + sizeof "Invalid collation character")

	)

145 
	`gettext_noop
 ("Invalid character class name")

147 #define 
	#REG_EESCAPE_IDX
 (
REG_ECTYPE_IDX
 + sizeof "Invalid character class name")

	)

148 
	`gettext_noop
 ("Trailing backslash")

150 #define 
	#REG_ESUBREG_IDX
 (
REG_EESCAPE_IDX
 + sizeof "Trailing backslash")

	)

151 
	`gettext_noop
 ("Invalid back reference")

153 #define 
	#REG_EBRACK_IDX
 (
REG_ESUBREG_IDX
 + sizeof "Invalid back reference")

	)

154 
	`gettext_noop
 ("Unmatched [ or [^")

156 #define 
	#REG_EPAREN_IDX
 (
REG_EBRACK_IDX
 + sizeof "Unmatched [ or [^")

	)

157 
	`gettext_noop
 ("Unmatched ( or \\(")

159 #define 
	#REG_EBRACE_IDX
 (
REG_EPAREN_IDX
 + sizeof "Unmatched ( or \\(")

	)

160 
	`gettext_noop
 ("Unmatched \\{")

162 #define 
	#REG_BADBR_IDX
 (
REG_EBRACE_IDX
 + sizeof "Unmatched \\{")

	)

163 
	`gettext_noop
 ("Invalid content of \\{\\}")

165 #define 
	#REG_ERANGE_IDX
 (
REG_BADBR_IDX
 + sizeof "Invalid content of \\{\\}")

	)

166 
	`gettext_noop
 ("Invalid range end")

168 #define 
	#REG_ESPACE_IDX
 (
REG_ERANGE_IDX
 + sizeof "Invalid range end")

	)

169 
	`gettext_noop
 ("Memory exhausted")

171 #define 
	#REG_BADRPT_IDX
 (
REG_ESPACE_IDX
 + sizeof "Memory exhausted")

	)

172 
	`gettext_noop
 ("Invalid preceding regular expression")

174 #define 
	#REG_EEND_IDX
 (
REG_BADRPT_IDX
 + sizeof "Invalid preceding regular expression")

	)

175 
	`gettext_noop
 ("Premature end of regular expression")

177 #define 
	#REG_ESIZE_IDX
 (
REG_EEND_IDX
 + sizeof "Premature end of regular expression")

	)

178 
	`gettext_noop
 ("Regular expression too big")

180 #define 
	#REG_ERPAREN_IDX
 (
REG_ESIZE_IDX
 + sizeof "Regular expression too big")

	)

181 
	`gettext_noop
 ("Unmatched ) or \\)")

182 
	}
};

184 static const 
size_t
 
	g__re_error_msgid_idx
[] =

186 
REG_NOERROR_IDX
,

187 
REG_NOMATCH_IDX
,

188 
REG_BADPAT_IDX
,

189 
REG_ECOLLATE_IDX
,

190 
REG_ECTYPE_IDX
,

191 
REG_EESCAPE_IDX
,

192 
REG_ESUBREG_IDX
,

193 
REG_EBRACK_IDX
,

194 
REG_EPAREN_IDX
,

195 
REG_EBRACE_IDX
,

196 
REG_BADBR_IDX
,

197 
REG_ERANGE_IDX
,

198 
REG_ESPACE_IDX
,

199 
REG_BADRPT_IDX
,

200 
REG_EEND_IDX
,

201 
REG_ESIZE_IDX
,

202 
REG_ERPAREN_IDX


214 #ifdef 
_LIBC


216 
	$re_compile_pattern
 (
pattern
, 
length
, 
bufp
)

217 const char *
pattern
;

218 
size_t
 
length
;

219 struct 
re_pattern_buffer
 *
bufp
;

222 
	$re_compile_pattern
 (const char *
pattern
, 
size_t
 
length
,

223 struct 
re_pattern_buffer
 *
bufp
)

226 
reg_errcode_t
 
ret
;

231 
bufp
->
no_sub
 = !!(
re_syntax_options
 & 
RE_NO_SUB
);

234 
bufp
->
newline_anchor
 = 1;

236 
ret
 = 
	`re_compile_internal
 (
bufp
, 
pattern
, 
length
, 
re_syntax_options
);

238 if (!
ret
)

239 return 
NULL
;

240 return 
	`gettext
 (
__re_error_msgid
 + 
__re_error_msgid_idx
[(int) 
ret
]);

241 
	}
}

242 #ifdef 
_LIBC


243 
	$weak_alias
 (
__re_compile_pattern
, 
re_compile_pattern
)

251 
reg_syntax_t
 
re_syntax_options
;

261 
reg_syntax_t


262 
	$re_set_syntax
 (
syntax
)

263 
reg_syntax_t
 
syntax
;

265 
reg_syntax_t
 
ret
 = 
re_syntax_options
;

267 
re_syntax_options
 = 
syntax
;

268 return 
ret
;

269 
	}
}

270 #ifdef 
_LIBC


271 
	$weak_alias
 (
__re_set_syntax
, 
re_set_syntax
)

275 
	$re_compile_fastmap
 (
bufp
)

276 struct 
re_pattern_buffer
 *
bufp
;

278 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
bufp
->
buffer
;

279 char *
fastmap
 = 
bufp
->fastmap;

281 
	`memset
 (
fastmap
, '\0', sizeof (char) * 
SBC_MAX
);

282 
	`re_compile_fastmap_iter
 (
bufp
, 
dfa
->
init_state
, 
fastmap
);

283 if (
dfa
->
init_state
 != dfa->
init_state_word
)

284 
	`re_compile_fastmap_iter
 (
bufp
, 
dfa
->
init_state_word
, 
fastmap
);

285 if (
dfa
->
init_state
 != dfa->
init_state_nl
)

286 
	`re_compile_fastmap_iter
 (
bufp
, 
dfa
->
init_state_nl
, 
fastmap
);

287 if (
dfa
->
init_state
 != dfa->
init_state_begbuf
)

288 
	`re_compile_fastmap_iter
 (
bufp
, 
dfa
->
init_state_begbuf
, 
fastmap
);

289 
bufp
->
fastmap_accurate
 = 1;

291 
	}
}

292 #ifdef 
_LIBC


293 
	$weak_alias
 (
__re_compile_fastmap
, 
re_compile_fastmap
)

296 static 
inline
 void

297 
	`__attribute
 ((
always_inline
))

298 
	$re_set_fastmap
 (char *
fastmap
, 
bool
 
icase
, int 
ch
)

300 
fastmap
[
ch
] = 1;

301 if (
icase
)

302 
fastmap
[
	`tolower
 (
ch
)] = 1;

303 
	}
}

309 
	$re_compile_fastmap_iter
 (
regex_t
 *
bufp
, const 
re_dfastate_t
 *
init_state
,

310 char *
fastmap
)

312 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
bufp
->
buffer
;

313 
Idx
 
node_cnt
;

314 
bool
 
icase
 = (
dfa
->
mb_cur_max
 == 1 && (
bufp
->
syntax
 & 
RE_ICASE
));

315 for (
node_cnt
 = 0; node_cnt < 
init_state
->
nodes
.
nelem
; ++node_cnt)

317 
Idx
 
node
 = 
init_state
->
nodes
.
elems
[
node_cnt
];

318 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
node
].type;

320 if (
type
 == 
CHARACTER
)

322 
	`re_set_fastmap
 (
fastmap
, 
icase
, 
dfa
->
nodes
[
node
].
opr
.
c
);

323 #ifdef 
RE_ENABLE_I18N


324 if ((
bufp
->
syntax
 & 
RE_ICASE
) && 
dfa
->
mb_cur_max
 > 1)

326 unsigned char 
buf
[
MB_LEN_MAX
];

327 unsigned char *
p
;

328 
wchar_t
 
wc
;

329 
mbstate_t
 
state
;

331 
p
 = 
buf
;

332 *
p
++ = 
dfa
->
nodes
[
node
].
opr
.
c
;

333 while (++
node
 < 
dfa
->
nodes_len


334 && 
dfa
->
nodes
[
node
].
type
 == 
CHARACTER


335 && 
dfa
->
nodes
[
node
].
mb_partial
)

336 *
p
++ = 
dfa
->
nodes
[
node
].
opr
.
c
;

337 
	`memset
 (&
state
, '\0', sizeof (state));

338 if (
	`__mbrtowc
 (&
wc
, (const char *) 
buf
, 
p
 - buf,

339 &
state
) == 
p
 - 
buf


340 && (
	`__wcrtomb
 ((char *) 
buf
, 
	`towlower
 (
wc
), &
state
)

341 != (
size_t
) -1))

342 
	`re_set_fastmap
 (
fastmap
, 
false
, 
buf
[0]);

346 else if (
type
 == 
SIMPLE_BRACKET
)

348 int 
i
, 
ch
;

349 for (
i
 = 0, 
ch
 = 0; i < 
BITSET_WORDS
; ++i)

351 int 
j
;

352 
bitset_word_t
 
w
 = 
dfa
->
nodes
[
node
].
opr
.
sbcset
[
i
];

353 for (
j
 = 0; j < 
BITSET_WORD_BITS
; ++j, ++
ch
)

354 if (
w
 & ((
bitset_word_t
) 1 << 
j
))

355 
	`re_set_fastmap
 (
fastmap
, 
icase
, 
ch
);

358 #ifdef 
RE_ENABLE_I18N


359 else if (
type
 == 
COMPLEX_BRACKET
)

361 
re_charset_t
 *
cset
 = 
dfa
->
nodes
[
node
].
opr
.
mbcset
;

362 
Idx
 
i
;

364 #ifdef 
_LIBC


371 if (
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
) != 0

372 && (
cset
->
ncoll_syms
 || cset->
nranges
))

374 const 
int32_t
 *
table
 = (const int32_t *)

375 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_TABLEMB
);

376 for (
i
 = 0; i < 
SBC_MAX
; ++i)

377 if (
table
[
i
] < 0)

378 
	`re_set_fastmap
 (
fastmap
, 
icase
, 
i
);

386 if (
dfa
->
mb_cur_max
 > 1

387 && (
cset
->
nchar_classes
 || cset->
non_match
 || cset->
nranges


388 #ifdef 
_LIBC


389 || 
cset
->
nequiv_classes


393 unsigned char 
c
 = 0;

396 
mbstate_t
 
mbs
;

397 
	`memset
 (&
mbs
, 0, sizeof (mbs));

398 if (
	`__mbrtowc
 (
NULL
, (char *) &
c
, 1, &
mbs
) == (
size_t
) -2)

399 
	`re_set_fastmap
 (
fastmap
, 
false
, (int) 
c
);

401 while (++
c
 != 0);

407 for (
i
 = 0; i < 
cset
->
nmbchars
; ++i)

409 char 
buf
[256];

410 
mbstate_t
 
state
;

411 
	`memset
 (&
state
, '\0', sizeof (state));

412 if (
	`__wcrtomb
 (
buf
, 
cset
->
mbchars
[
i
], &
state
) != (
size_t
) -1)

413 
	`re_set_fastmap
 (
fastmap
, 
icase
, *(unsigned char *) 
buf
);

414 if ((
bufp
->
syntax
 & 
RE_ICASE
) && 
dfa
->
mb_cur_max
 > 1)

416 if (
	`__wcrtomb
 (
buf
, 
	`towlower
 (
cset
->
mbchars
[
i
]), &
state
)

417 != (
size_t
) -1)

418 
	`re_set_fastmap
 (
fastmap
, 
false
, *(unsigned char *) 
buf
);

424 else if (
type
 == 
OP_PERIOD


425 #ifdef 
RE_ENABLE_I18N


426 || 
type
 == 
OP_UTF8_PERIOD


428 || 
type
 == 
END_OF_RE
)

430 
	`memset
 (
fastmap
, '\1', sizeof (char) * 
SBC_MAX
);

431 if (
type
 == 
END_OF_RE
)

432 
bufp
->
can_be_null
 = 1;

436 
	}
}

475 
	$regcomp
 (
preg
, 
pattern
, 
cflags
)

476 
regex_t
 *
_Restrict_
 
preg
;

477 const char *
_Restrict_
 
pattern
;

478 int 
cflags
;

480 
reg_errcode_t
 
ret
;

481 
reg_syntax_t
 
syntax
 = ((
cflags
 & 
REG_EXTENDED
) ? 
RE_SYNTAX_POSIX_EXTENDED


482 : 
RE_SYNTAX_POSIX_BASIC
);

484 
preg
->
buffer
 = 
NULL
;

485 
preg
->
allocated
 = 0;

486 
preg
->
used
 = 0;

489 
preg
->
fastmap
 = 
	`re_malloc
 (char, 
SBC_MAX
);

490 if (
	`BE
 (
preg
->
fastmap
 == 
NULL
, 0))

491 return 
REG_ESPACE
;

493 
syntax
 |= (
cflags
 & 
REG_ICASE
) ? 
RE_ICASE
 : 0;

496 if (
cflags
 & 
REG_NEWLINE
)

498 
syntax
 &= ~
RE_DOT_NEWLINE
;

499 
syntax
 |= 
RE_HAT_LISTS_NOT_NEWLINE
;

501 
preg
->
newline_anchor
 = 1;

504 
preg
->
newline_anchor
 = 0;

505 
preg
->
no_sub
 = !!(
cflags
 & 
REG_NOSUB
);

506 
preg
->
translate
 = 
NULL
;

508 
ret
 = 
	`re_compile_internal
 (
preg
, 
pattern
, 
	`strlen
 (pattern), 
syntax
);

512 if (
ret
 == 
REG_ERPAREN
)

513 
ret
 = 
REG_EPAREN
;

516 if (
	`BE
 (
ret
 == 
REG_NOERROR
, 1))

519 (void) 
	`re_compile_fastmap
 (
preg
);

523 
	`re_free
 (
preg
->
fastmap
);

524 
preg
->
fastmap
 = 
NULL
;

527 return (int) 
ret
;

528 
	}
}

529 #ifdef 
_LIBC


530 
	$weak_alias
 (
__regcomp
, 
regcomp
)

536 #ifdef 
_LIBC


537 
size_t


538 
	$regerror
 (
errcode
, 
preg
, 
errbuf
, 
errbuf_size
)

539 int 
errcode
;

540 const 
regex_t
 *
_Restrict_
 
preg
;

541 char *
_Restrict_
 
errbuf
;

542 
size_t
 
errbuf_size
;

544 
size_t


545 
	$regerror
 (int 
errcode
, const 
regex_t
 *
_Restrict_
 
preg
 
_UNUSED_PARAMETER_
,

546 char *
_Restrict_
 
errbuf
, 
size_t
 
errbuf_size
)

549 const char *
msg
;

550 
size_t
 
msg_size
;

552 if (
	`BE
 (
errcode
 < 0

553 || 
errcode
 >= (int) (sizeof (
__re_error_msgid_idx
)

554 / sizeof (
__re_error_msgid_idx
[0])), 0))

559 
	`abort
 ();

561 
msg
 = 
	`gettext
 (
__re_error_msgid
 + 
__re_error_msgid_idx
[
errcode
]);

563 
msg_size
 = 
	`strlen
 (
msg
) + 1;

565 if (
	`BE
 (
errbuf_size
 != 0, 1))

567 
size_t
 
cpy_size
 = 
msg_size
;

568 if (
	`BE
 (
msg_size
 > 
errbuf_size
, 0))

570 
cpy_size
 = 
errbuf_size
 - 1;

571 
errbuf
[
cpy_size
] = '\0';

573 
	`memcpy
 (
errbuf
, 
msg
, 
cpy_size
);

576 return 
msg_size
;

577 
	}
}

578 #ifdef 
_LIBC


579 
	$weak_alias
 (
__regerror
, 
regerror
)

583 #ifdef 
RE_ENABLE_I18N


588 static const 
bitset_t
 
utf8_sb_map
 =

591 #if 4 * 
BITSET_WORD_BITS
 < 
ASCII_CHARS


593 #elif 3 * 
BITSET_WORD_BITS
 < 
ASCII_CHARS


594 
BITSET_WORD_MAX
, BITSET_WORD_MAX, BITSET_WORD_MAX,

595 #elif 2 * 
BITSET_WORD_BITS
 < 
ASCII_CHARS


596 
BITSET_WORD_MAX
, BITSET_WORD_MAX,

597 #elif 1 * 
BITSET_WORD_BITS
 < 
ASCII_CHARS


598 
BITSET_WORD_MAX
,

600 (
BITSET_WORD_MAX


601 >> (
SBC_MAX
 % 
BITSET_WORD_BITS
 == 0

603 : 
BITSET_WORD_BITS
 - 
SBC_MAX
 % BITSET_WORD_BITS))

604 
	}
};

609 
	$free_dfa_content
 (
re_dfa_t
 *
dfa
)

611 
Idx
 
i
, 
j
;

613 if (
dfa
->
nodes
)

614 for (
i
 = 0; i < 
dfa
->
nodes_len
; ++i)

615 
	`free_token
 (
dfa
->
nodes
 + 
i
);

616 
	`re_free
 (
dfa
->
nexts
);

617 for (
i
 = 0; i < 
dfa
->
nodes_len
; ++i)

619 if (
dfa
->
eclosures
 != 
NULL
)

620 
	`re_node_set_free
 (
dfa
->
eclosures
 + 
i
);

621 if (
dfa
->
inveclosures
 != 
NULL
)

622 
	`re_node_set_free
 (
dfa
->
inveclosures
 + 
i
);

623 if (
dfa
->
edests
 != 
NULL
)

624 
	`re_node_set_free
 (
dfa
->
edests
 + 
i
);

626 
	`re_free
 (
dfa
->
edests
);

627 
	`re_free
 (
dfa
->
eclosures
);

628 
	`re_free
 (
dfa
->
inveclosures
);

629 
	`re_free
 (
dfa
->
nodes
);

631 if (
dfa
->
state_table
)

632 for (
i
 = 0; i <= 
dfa
->
state_hash_mask
; ++i)

634 struct 
re_state_table_entry
 *
entry
 = 
dfa
->
state_table
 + 
i
;

635 for (
j
 = 0; j < 
entry
->
num
; ++j)

637 
re_dfastate_t
 *
state
 = 
entry
->
array
[
j
];

638 
	`free_state
 (
state
);

640 
	`re_free
 (
entry
->
array
);

642 
	`re_free
 (
dfa
->
state_table
);

643 #ifdef 
RE_ENABLE_I18N


644 if (
dfa
->
sb_char
 != 
utf8_sb_map
)

645 
	`re_free
 (
dfa
->
sb_char
);

647 
	`re_free
 (
dfa
->
subexp_map
);

648 #ifdef 
DEBUG


649 
	`re_free
 (
dfa
->
re_str
);

652 
	`re_free
 (
dfa
);

653 
	}
}

659 
	$regfree
 (
preg
)

660 
regex_t
 *
preg
;

662 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

663 if (
	`BE
 (
dfa
 != 
NULL
, 1))

664 
	`free_dfa_content
 (
dfa
);

665 
preg
->
buffer
 = 
NULL
;

666 
preg
->
allocated
 = 0;

668 
	`re_free
 (
preg
->
fastmap
);

669 
preg
->
fastmap
 = 
NULL
;

671 
	`re_free
 (
preg
->
translate
);

672 
preg
->
translate
 = 
NULL
;

673 
	}
}

674 #ifdef 
_LIBC


675 
	$weak_alias
 (
__regfree
, 
regfree
)

681 #if 
defined
 
_REGEX_RE_COMP
 || defined 
_LIBC


684 static struct 
re_pattern_buffer
 
re_comp_buf
;

687 #ifdef 
_LIBC


691 
weak_function


693 
	$re_comp
 (
s
)

694 const char *
s
;

696 
reg_errcode_t
 
ret
;

697 char *
fastmap
;

699 if (!
s
)

701 if (!
re_comp_buf
.
buffer
)

702 return 
	`gettext
 ("No previous regular expression");

706 if (
re_comp_buf
.
buffer
)

708 
fastmap
 = 
re_comp_buf
.fastmap;

709 
re_comp_buf
.
fastmap
 = 
NULL
;

710 
	`__regfree
 (&
re_comp_buf
);

711 
	`memset
 (&
re_comp_buf
, '\0', sizeof (re_comp_buf));

712 
re_comp_buf
.
fastmap
 = fastmap;

715 if (
re_comp_buf
.
fastmap
 == 
NULL
)

717 
re_comp_buf
.
fastmap
 = (char *) 
	`malloc
 (
SBC_MAX
);

718 if (
re_comp_buf
.
fastmap
 == 
NULL
)

719 return (char *) 
	`gettext
 (
__re_error_msgid


720 + 
__re_error_msgid_idx
[(int) 
REG_ESPACE
]);

727 
re_comp_buf
.
newline_anchor
 = 1;

729 
ret
 = 
	`re_compile_internal
 (&
re_comp_buf
, 
s
, 
	`strlen
 (s), 
re_syntax_options
);

731 if (!
ret
)

732 return 
NULL
;

735 return (char *) 
	`gettext
 (
__re_error_msgid
 + 
__re_error_msgid_idx
[(int) 
ret
]);

736 
	}
}

738 #ifdef 
_LIBC


739 
	$libc_freeres_fn
 (
free_mem
)

741 
	`__regfree
 (&
re_comp_buf
);

742 
	}
}

751 static 
reg_errcode_t


752 
	$re_compile_internal
 (
regex_t
 *
preg
, const char * 
pattern
, 
size_t
 
length
,

753 
reg_syntax_t
 
syntax
)

755 
reg_errcode_t
 
err
 = 
REG_NOERROR
;

756 
re_dfa_t
 *
dfa
;

757 
re_string_t
 
regexp
;

760 
preg
->
fastmap_accurate
 = 0;

761 
preg
->
syntax
 = syntax;

762 
preg
->
not_bol
 = preg->
not_eol
 = 0;

763 
preg
->
used
 = 0;

764 
preg
->
re_nsub
 = 0;

765 
preg
->
can_be_null
 = 0;

766 
preg
->
regs_allocated
 = 
REGS_UNALLOCATED
;

769 
dfa
 = (
re_dfa_t
 *) 
preg
->
buffer
;

770 if (
	`BE
 (
preg
->
allocated
 < sizeof (
re_dfa_t
), 0))

776 
dfa
 = 
	`re_realloc
 (
preg
->
buffer
, 
re_dfa_t
, 1);

777 if (
dfa
 == 
NULL
)

778 return 
REG_ESPACE
;

779 
preg
->
allocated
 = sizeof (
re_dfa_t
);

780 
preg
->
buffer
 = (unsigned char *) 
dfa
;

782 
preg
->
used
 = sizeof (
re_dfa_t
);

784 
err
 = 
	`init_dfa
 (
dfa
, 
length
);

785 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

787 
	`free_dfa_content
 (
dfa
);

788 
preg
->
buffer
 = 
NULL
;

789 
preg
->
allocated
 = 0;

790 return 
err
;

792 #ifdef 
DEBUG


794 
dfa
->
re_str
 = 
	`re_malloc
 (char, 
length
 + 1);

795 
	`strncpy
 (
dfa
->
re_str
, 
pattern
, 
length
 + 1);

798 
	`__libc_lock_init
 (
dfa
->
lock
);

800 
err
 = 
	`re_string_construct
 (&
regexp
, 
pattern
, 
length
, 
preg
->
translate
,

801 (
syntax
 & 
RE_ICASE
) != 0, 
dfa
);

802 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

804 
re_compile_internal_free_return
:

805 
	`free_workarea_compile
 (
preg
);

806 
	`re_string_destruct
 (&
regexp
);

807 
	`free_dfa_content
 (
dfa
);

808 
preg
->
buffer
 = 
NULL
;

809 
preg
->
allocated
 = 0;

810 return 
err
;

814 
preg
->
re_nsub
 = 0;

815 
dfa
->
str_tree
 = 
	`parse
 (&
regexp
, 
preg
, 
syntax
, &
err
);

816 if (
	`BE
 (
dfa
->
str_tree
 == 
NULL
, 0))

817 goto 
re_compile_internal_free_return
;

820 
err
 = 
	`analyze
 (
preg
);

821 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

822 goto 
re_compile_internal_free_return
;

824 #ifdef 
RE_ENABLE_I18N


826 if (
dfa
->
is_utf8
 && !(
syntax
 & 
RE_ICASE
) && 
preg
->
translate
 == 
NULL
)

827 
	`optimize_utf8
 (
dfa
);

831 
err
 = 
	`create_initial_state
 (
dfa
);

834 
	`free_workarea_compile
 (
preg
);

835 
	`re_string_destruct
 (&
regexp
);

837 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

839 
	`free_dfa_content
 (
dfa
);

840 
preg
->
buffer
 = 
NULL
;

841 
preg
->
allocated
 = 0;

844 return 
err
;

845 
	}
}

850 static 
reg_errcode_t


851 
	$init_dfa
 (
re_dfa_t
 *
dfa
, 
size_t
 
pat_len
)

853 
__re_size_t
 
table_size
;

854 #ifndef 
_LIBC


855 char *
codeset_name
;

857 #ifdef 
RE_ENABLE_I18N


858 
size_t
 
max_i18n_object_size
 = 
	`MAX
 (sizeof (
wchar_t
), sizeof (
wctype_t
));

860 
size_t
 
max_i18n_object_size
 = 0;

862 
size_t
 
max_object_size
 =

863 
	`MAX
 (sizeof (struct 
re_state_table_entry
),

864 
	`MAX
 (sizeof (
re_token_t
),

865 
	`MAX
 (sizeof (
re_node_set
),

866 
	`MAX
 (sizeof (
regmatch_t
),

867 
max_i18n_object_size
))));

869 
	`memset
 (
dfa
, '\0', sizeof (
re_dfa_t
));

872 
dfa
->
str_tree_storage_idx
 = 
BIN_TREE_STORAGE_SIZE
;

878 if (
	`BE
 (
SIZE_MAX
 / 
max_object_size
 / 2 <= 
pat_len
, 0))

879 return 
REG_ESPACE
;

881 
dfa
->
nodes_alloc
 = 
pat_len
 + 1;

882 
dfa
->
nodes
 = 
	`re_malloc
 (
re_token_t
, dfa->
nodes_alloc
);

885 for (
table_size
 = 1; ; table_size <<= 1)

886 if (
table_size
 > 
pat_len
)

889 
dfa
->
state_table
 = 
	`calloc
 (sizeof (struct 
re_state_table_entry
), 
table_size
);

890 
dfa
->
state_hash_mask
 = 
table_size
 - 1;

892 
dfa
->
mb_cur_max
 = 
MB_CUR_MAX
;

893 #ifdef 
_LIBC


894 if (
dfa
->
mb_cur_max
 == 6

895 && 
	`strcmp
 (
	`_NL_CURRENT
 (
LC_CTYPE
, 
_NL_CTYPE_CODESET_NAME
), "UTF-8") == 0)

896 
dfa
->
is_utf8
 = 1;

897 
dfa
->
map_notascii
 = (
	`_NL_CURRENT_WORD
 (
LC_CTYPE
, 
_NL_CTYPE_MAP_TO_NONASCII
)

900 
codeset_name
 = 
	`nl_langinfo
 (
CODESET
);

901 if (
	`strcasecmp
 (
codeset_name
, "UTF-8") == 0

902 || 
	`strcasecmp
 (
codeset_name
, "UTF8") == 0)

903 
dfa
->
is_utf8
 = 1;

907 
dfa
->
map_notascii
 = 0;

910 #ifdef 
RE_ENABLE_I18N


911 if (
dfa
->
mb_cur_max
 > 1)

913 if (
dfa
->
is_utf8
)

914 
dfa
->
sb_char
 = (
re_bitset_ptr_t
) 
utf8_sb_map
;

917 int 
i
, 
j
, 
ch
;

919 
dfa
->
sb_char
 = (
re_bitset_ptr_t
) 
	`calloc
 (sizeof (
bitset_t
), 1);

920 if (
	`BE
 (
dfa
->
sb_char
 == 
NULL
, 0))

921 return 
REG_ESPACE
;

924 for (
i
 = 0, 
ch
 = 0; i < 
BITSET_WORDS
; ++i)

925 for (
j
 = 0; j < 
BITSET_WORD_BITS
; ++j, ++
ch
)

927 
wint_t
 
wch
 = 
	`__btowc
 (
ch
);

928 if (
wch
 != 
WEOF
)

929 
dfa
->
sb_char
[
i
] |= (
bitset_word_t
) 1 << 
j
;

930 #ifndef 
_LIBC


931 if (
	`isascii
 (
ch
) && 
wch
 != ch)

932 
dfa
->
map_notascii
 = 1;

939 if (
	`BE
 (
dfa
->
nodes
 == 
NULL
 || dfa->
state_table
 == NULL, 0))

940 return 
REG_ESPACE
;

941 return 
REG_NOERROR
;

942 
	}
}

949 
internal_function


950 
	$init_word_char
 (
re_dfa_t
 *
dfa
)

952 int 
i
, 
j
, 
ch
;

953 
dfa
->
word_ops_used
 = 1;

954 for (
i
 = 0, 
ch
 = 0; i < 
BITSET_WORDS
; ++i)

955 for (
j
 = 0; j < 
BITSET_WORD_BITS
; ++j, ++
ch
)

956 if (
	`isalnum
 (
ch
) || ch == '_')

957 
dfa
->
word_char
[
i
] |= (
bitset_word_t
) 1 << 
j
;

958 
	}
}

963 
	$free_workarea_compile
 (
regex_t
 *
preg
)

965 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

966 
bin_tree_storage_t
 *
storage
, *
next
;

967 for (
storage
 = 
dfa
->
str_tree_storage
; storage; storage = 
next
)

969 
next
 = 
storage
->next;

970 
	`re_free
 (
storage
);

972 
dfa
->
str_tree_storage
 = 
NULL
;

973 
dfa
->
str_tree_storage_idx
 = 
BIN_TREE_STORAGE_SIZE
;

974 
dfa
->
str_tree
 = 
NULL
;

975 
	`re_free
 (
dfa
->
org_indices
);

976 
dfa
->
org_indices
 = 
NULL
;

977 
	}
}

981 static 
reg_errcode_t


982 
	$create_initial_state
 (
re_dfa_t
 *
dfa
)

984 
Idx
 
first
, 
i
;

985 
reg_errcode_t
 
err
;

986 
re_node_set
 
init_nodes
;

990 
first
 = 
dfa
->
str_tree
->first->
node_idx
;

991 
dfa
->
init_node
 = 
first
;

992 
err
 = 
	`re_node_set_init_copy
 (&
init_nodes
, 
dfa
->
eclosures
 + 
first
);

993 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

994 return 
err
;

1000 if (
dfa
->
nbackref
 > 0)

1001 for (
i
 = 0; i < 
init_nodes
.
nelem
; ++i)

1003 
Idx
 
node_idx
 = 
init_nodes
.
elems
[
i
];

1004 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
node_idx
].type;

1006 
Idx
 
clexp_idx
;

1007 if (
type
 != 
OP_BACK_REF
)

1009 for (
clexp_idx
 = 0; clexp_idx < 
init_nodes
.
nelem
; ++clexp_idx)

1011 
re_token_t
 *
clexp_node
;

1012 
clexp_node
 = 
dfa
->
nodes
 + 
init_nodes
.
elems
[
clexp_idx
];

1013 if (
clexp_node
->
type
 == 
OP_CLOSE_SUBEXP


1014 && 
clexp_node
->
opr
.
idx
 == 
dfa
->
nodes
[
node_idx
].opr.idx)

1017 if (
clexp_idx
 == 
init_nodes
.
nelem
)

1020 if (
type
 == 
OP_BACK_REF
)

1022 
Idx
 
dest_idx
 = 
dfa
->
edests
[
node_idx
].
elems
[0];

1023 if (!
	`re_node_set_contains
 (&
init_nodes
, 
dest_idx
))

1025 
reg_errcode_t
 
merge_err


1026 = 
	`re_node_set_merge
 (&
init_nodes
, 
dfa
->
eclosures
 + 
dest_idx
);

1027 if (
merge_err
 != 
REG_NOERROR
)

1028 return 
merge_err
;

1029 
i
 = 0;

1035 
dfa
->
init_state
 = 
	`re_acquire_state_context
 (&
err
, dfa, &
init_nodes
, 0);

1037 if (
	`BE
 (
dfa
->
init_state
 == 
NULL
, 0))

1038 return 
err
;

1039 if (
dfa
->
init_state
->
has_constraint
)

1041 
dfa
->
init_state_word
 = 
	`re_acquire_state_context
 (&
err
, dfa, &
init_nodes
,

1042 
CONTEXT_WORD
);

1043 
dfa
->
init_state_nl
 = 
	`re_acquire_state_context
 (&
err
, dfa, &
init_nodes
,

1044 
CONTEXT_NEWLINE
);

1045 
dfa
->
init_state_begbuf
 = 
	`re_acquire_state_context
 (&
err
, dfa,

1046 &
init_nodes
,

1047 
CONTEXT_NEWLINE


1048 | 
CONTEXT_BEGBUF
);

1049 if (
	`BE
 (
dfa
->
init_state_word
 == 
NULL
 || dfa->
init_state_nl
 == NULL

1050 || 
dfa
->
init_state_begbuf
 == 
NULL
, 0))

1051 return 
err
;

1054 
dfa
->
init_state_word
 = dfa->
init_state_nl


1055 = 
dfa
->
init_state_begbuf
 = dfa->
init_state
;

1057 
	`re_node_set_free
 (&
init_nodes
);

1058 return 
REG_NOERROR
;

1059 
	}
}

1061 #ifdef 
RE_ENABLE_I18N


1067 
	$optimize_utf8
 (
re_dfa_t
 *
dfa
)

1069 
Idx
 
node
;

1070 int 
i
;

1071 
bool
 
mb_chars
 = 
false
;

1072 
bool
 
has_period
 = 
false
;

1074 for (
node
 = 0; node < 
dfa
->
nodes_len
; ++node)

1075 switch (
dfa
->
nodes
[
node
].
type
)

1077 case 
CHARACTER
:

1078 if (
dfa
->
nodes
[
node
].
opr
.
c
 >= 
ASCII_CHARS
)

1079 
mb_chars
 = 
true
;

1081 case 
ANCHOR
:

1082 switch (
dfa
->
nodes
[
node
].
opr
.
ctx_type
)

1084 case 
LINE_FIRST
:

1085 case 
LINE_LAST
:

1086 case 
BUF_FIRST
:

1087 case 
BUF_LAST
:

1096 case 
OP_PERIOD
:

1097 
has_period
 = 
true
;

1099 case 
OP_BACK_REF
:

1100 case 
OP_ALT
:

1101 case 
END_OF_RE
:

1102 case 
OP_DUP_ASTERISK
:

1103 case 
OP_OPEN_SUBEXP
:

1104 case 
OP_CLOSE_SUBEXP
:

1106 case 
COMPLEX_BRACKET
:

1108 case 
SIMPLE_BRACKET
:

1111 int 
rshift
 = (
ASCII_CHARS
 % 
BITSET_WORD_BITS
 == 0

1113 : 
BITSET_WORD_BITS
 - 
ASCII_CHARS
 % BITSET_WORD_BITS);

1114 for (
i
 = 
ASCII_CHARS
 / 
BITSET_WORD_BITS
; i < 
BITSET_WORDS
; ++i)

1116 if (
dfa
->
nodes
[
node
].
opr
.
sbcset
[
i
] >> 
rshift
 != 0)

1118 
rshift
 = 0;

1123 
	`abort
 ();

1126 if (
mb_chars
 || 
has_period
)

1127 for (
node
 = 0; node < 
dfa
->
nodes_len
; ++node)

1129 if (
dfa
->
nodes
[
node
].
type
 == 
CHARACTER


1130 && 
dfa
->
nodes
[
node
].
opr
.
c
 >= 
ASCII_CHARS
)

1131 
dfa
->
nodes
[
node
].
mb_partial
 = 0;

1132 else if (
dfa
->
nodes
[
node
].
type
 == 
OP_PERIOD
)

1133 
dfa
->
nodes
[
node
].
type
 = 
OP_UTF8_PERIOD
;

1137 
dfa
->
mb_cur_max
 = 1;

1138 
dfa
->
is_utf8
 = 0;

1139 
dfa
->
has_mb_node
 = dfa->
nbackref
 > 0 || 
has_period
;

1140 
	}
}

1146 static 
reg_errcode_t


1147 
	$analyze
 (
regex_t
 *
preg
)

1149 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

1150 
reg_errcode_t
 
ret
;

1153 
dfa
->
nexts
 = 
	`re_malloc
 (
Idx
, dfa->
nodes_alloc
);

1154 
dfa
->
org_indices
 = 
	`re_malloc
 (
Idx
, dfa->
nodes_alloc
);

1155 
dfa
->
edests
 = 
	`re_malloc
 (
re_node_set
, dfa->
nodes_alloc
);

1156 
dfa
->
eclosures
 = 
	`re_malloc
 (
re_node_set
, dfa->
nodes_alloc
);

1157 if (
	`BE
 (
dfa
->
nexts
 == 
NULL
 || dfa->
org_indices
 == NULL || dfa->
edests
 == NULL

1158 || 
dfa
->
eclosures
 == 
NULL
, 0))

1159 return 
REG_ESPACE
;

1161 
dfa
->
subexp_map
 = 
	`re_malloc
 (
Idx
, 
preg
->
re_nsub
);

1162 if (
dfa
->
subexp_map
 != 
NULL
)

1164 
Idx
 
i
;

1165 for (
i
 = 0; i < 
preg
->
re_nsub
; i++)

1166 
dfa
->
subexp_map
[
i
] = i;

1167 
	`preorder
 (
dfa
->
str_tree
, 
optimize_subexps
, dfa);

1168 for (
i
 = 0; i < 
preg
->
re_nsub
; i++)

1169 if (
dfa
->
subexp_map
[
i
] != i)

1171 if (
i
 == 
preg
->
re_nsub
)

1173 
	`free
 (
dfa
->
subexp_map
);

1174 
dfa
->
subexp_map
 = 
NULL
;

1178 
ret
 = 
	`postorder
 (
dfa
->
str_tree
, 
lower_subexps
, 
preg
);

1179 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

1180 return 
ret
;

1181 
ret
 = 
	`postorder
 (
dfa
->
str_tree
, 
calc_first
, dfa);

1182 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

1183 return 
ret
;

1184 
	`preorder
 (
dfa
->
str_tree
, 
calc_next
, dfa);

1185 
ret
 = 
	`preorder
 (
dfa
->
str_tree
, 
link_nfa_nodes
, dfa);

1186 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

1187 return 
ret
;

1188 
ret
 = 
	`calc_eclosure
 (
dfa
);

1189 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

1190 return 
ret
;

1194 if ((!
preg
->
no_sub
 && preg->
re_nsub
 > 0 && 
dfa
->
has_plural_match
)

1195 || 
dfa
->
nbackref
)

1197 
dfa
->
inveclosures
 = 
	`re_malloc
 (
re_node_set
, dfa->
nodes_len
);

1198 if (
	`BE
 (
dfa
->
inveclosures
 == 
NULL
, 0))

1199 return 
REG_ESPACE
;

1200 
ret
 = 
	`calc_inveclosure
 (
dfa
);

1203 return 
ret
;

1204 
	}
}

1209 static 
reg_errcode_t


1210 
postorder
 (
bin_tree_t
 *
root
, 
reg_errcode_t
 (
fn
 (void *, bin_tree_t *)),

1211 void *
extra
)

1213 
bin_tree_t
 *
	gnode
, *
	gprev
;

1215 for (
	gnode
 = 
root
; ; )

1219 while (
	gnode
->
	gleft
 || node->
	gright
)

1220 if (
	gnode
->
	gleft
)

1221 
	gnode
 = 
node
->
left
;

1223 
	gnode
 = 
node
->
right
;

1227 
reg_errcode_t
 
	gerr
 = 
fn
 (
extra
, 
node
);

1228 if (
BE
 (
err
 != 
REG_NOERROR
, 0))

1229 return 
	gerr
;

1230 if (
	gnode
->
	gparent
 == 
NULL
)

1231 return 
REG_NOERROR
;

1232 
	gprev
 = 
node
;

1233 
	gnode
 = 
node
->
parent
;

1236 while (
	gnode
->
	gright
 == 
prev
 || 
node
->
right
 == 
NULL
);

1237 
	gnode
 = 
node
->
right
;

1241 static 
reg_errcode_t


1242 
preorder
 (
bin_tree_t
 *
root
, 
reg_errcode_t
 (
fn
 (void *, bin_tree_t *)),

1243 void *
extra
)

1245 
bin_tree_t
 *
	gnode
;

1247 for (
	gnode
 = 
root
; ; )

1249 
reg_errcode_t
 
	gerr
 = 
fn
 (
extra
, 
node
);

1250 if (
BE
 (
err
 != 
REG_NOERROR
, 0))

1251 return 
	gerr
;

1254 if (
	gnode
->
	gleft
)

1255 
	gnode
 = 
node
->
left
;

1258 
bin_tree_t
 *
	gprev
 = 
NULL
;

1259 while (
	gnode
->
	gright
 == 
prev
 || 
node
->
right
 == 
NULL
)

1261 
prev
 = 
node
;

1262 
	gnode
 = 
node
->
parent
;

1263 if (!
	gnode
)

1264 return 
	gREG_NOERROR
;

1266 
	gnode
 = 
node
->
right
;

1274 static 
reg_errcode_t


1275 
	$optimize_subexps
 (void *
extra
, 
bin_tree_t
 *
node
)

1277 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
extra
;

1279 if (
node
->
token
.
type
 == 
OP_BACK_REF
 && 
dfa
->
subexp_map
)

1281 int 
idx
 = 
node
->
token
.
opr
.idx;

1282 
node
->
token
.
opr
.
idx
 = 
dfa
->
subexp_map
[idx];

1283 
dfa
->
used_bkref_map
 |= 1 << 
node
->
token
.
opr
.
idx
;

1286 else if (
node
->
token
.
type
 == 
SUBEXP


1287 && 
node
->
left
 && node->left->
token
.
type
 == 
SUBEXP
)

1289 
Idx
 
other_idx
 = 
node
->
left
->
token
.
opr
.
idx
;

1291 
node
->
left
 = node->left->left;

1292 if (
node
->
left
)

1293 
node
->
left
->
parent
 = node;

1295 
dfa
->
subexp_map
[
other_idx
] = dfa->subexp_map[
node
->
token
.
opr
.
idx
];

1296 if (
other_idx
 < 
BITSET_WORD_BITS
)

1297 
dfa
->
used_bkref_map
 &= ~((
bitset_word_t
) 1 << 
other_idx
);

1300 return 
REG_NOERROR
;

1301 
	}
}

1305 static 
reg_errcode_t


1306 
	$lower_subexps
 (void *
extra
, 
bin_tree_t
 *
node
)

1308 
regex_t
 *
preg
 = (regex_t *) 
extra
;

1309 
reg_errcode_t
 
err
 = 
REG_NOERROR
;

1311 if (
node
->
left
 && node->left->
token
.
type
 == 
SUBEXP
)

1313 
node
->
left
 = 
	`lower_subexp
 (&
err
, 
preg
, node->left);

1314 if (
node
->
left
)

1315 
node
->
left
->
parent
 = node;

1317 if (
node
->
right
 && node->right->
token
.
type
 == 
SUBEXP
)

1319 
node
->
right
 = 
	`lower_subexp
 (&
err
, 
preg
, node->right);

1320 if (
node
->
right
)

1321 
node
->
right
->
parent
 = node;

1324 return 
err
;

1325 
	}
}

1327 static 
bin_tree_t
 *

1328 
	$lower_subexp
 (
reg_errcode_t
 *
err
, 
regex_t
 *
preg
, 
bin_tree_t
 *
node
)

1330 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

1331 
bin_tree_t
 *
body
 = 
node
->
left
;

1332 
bin_tree_t
 *
op
, *
cls
, *
tree1
, *
tree
;

1334 if (
preg
->
no_sub


1339 && 
node
->
left
 != 
NULL


1340 && (
node
->
token
.
opr
.
idx
 >= 
BITSET_WORD_BITS


1341 || !(
dfa
->
used_bkref_map


1342 & ((
bitset_word_t
) 1 << 
node
->
token
.
opr
.
idx
))))

1343 return 
node
->
left
;

1347 
op
 = 
	`create_tree
 (
dfa
, 
NULL
, NULL, 
OP_OPEN_SUBEXP
);

1348 
cls
 = 
	`create_tree
 (
dfa
, 
NULL
, NULL, 
OP_CLOSE_SUBEXP
);

1349 
tree1
 = 
body
 ? 
	`create_tree
 (
dfa
, body, 
cls
, 
CONCAT
) : cls;

1350 
tree
 = 
	`create_tree
 (
dfa
, 
op
, 
tree1
, 
CONCAT
);

1351 if (
	`BE
 (
tree
 == 
NULL
 || 
tree1
 == NULL || 
op
 == NULL || 
cls
 == NULL, 0))

1353 *
err
 = 
REG_ESPACE
;

1354 return 
NULL
;

1357 
op
->
token
.
opr
.
idx
 = 
cls
->token.opr.idx = 
node
->token.opr.idx;

1358 
op
->
token
.
opt_subexp
 = 
cls
->token.opt_subexp = 
node
->token.opt_subexp;

1359 return 
tree
;

1360 
	}
}

1364 static 
reg_errcode_t


1365 
	$calc_first
 (void *
extra
, 
bin_tree_t
 *
node
)

1367 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
extra
;

1368 if (
node
->
token
.
type
 == 
CONCAT
)

1370 
node
->
first
 = node->
left
->first;

1371 
node
->
node_idx
 = node->
left
->node_idx;

1375 
node
->
first
 = node;

1376 
node
->
node_idx
 = 
	`re_dfa_add_node
 (
dfa
, node->
token
);

1377 if (
	`BE
 (
node
->
node_idx
 == 
REG_MISSING
, 0))

1378 return 
REG_ESPACE
;

1379 if (
node
->
token
.
type
 == 
ANCHOR
)

1380 
dfa
->
nodes
[
node
->
node_idx
].
constraint
 = node->
token
.
opr
.
ctx_type
;

1382 return 
REG_NOERROR
;

1383 
	}
}

1386 static 
reg_errcode_t


1387 
	$calc_next
 (void *
extra
 
_UNUSED_PARAMETER_
, 
bin_tree_t
 *
node
)

1389 switch (
node
->
token
.
type
)

1391 case 
OP_DUP_ASTERISK
:

1392 
node
->
left
->
next
 = node;

1394 case 
CONCAT
:

1395 
node
->
left
->
next
 = node->
right
->
first
;

1396 
node
->
right
->
next
 = node->next;

1399 if (
node
->
left
)

1400 
node
->
left
->
next
 = node->next;

1401 if (
node
->
right
)

1402 
node
->
right
->
next
 = node->next;

1405 return 
REG_NOERROR
;

1406 
	}
}

1409 static 
reg_errcode_t


1410 
	$link_nfa_nodes
 (void *
extra
, 
bin_tree_t
 *
node
)

1412 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
extra
;

1413 
Idx
 
idx
 = 
node
->
node_idx
;

1414 
reg_errcode_t
 
err
 = 
REG_NOERROR
;

1416 switch (
node
->
token
.
type
)

1418 case 
CONCAT
:

1421 case 
END_OF_RE
:

1422 
	`assert
 (
node
->
next
 == 
NULL
);

1425 case 
OP_DUP_ASTERISK
:

1426 case 
OP_ALT
:

1428 
Idx
 
left
, 
right
;

1429 
dfa
->
has_plural_match
 = 1;

1430 if (
node
->
left
 != 
NULL
)

1431 
left
 = 
node
->left->
first
->
node_idx
;

1433 
left
 = 
node
->
next
->
node_idx
;

1434 if (
node
->
right
 != 
NULL
)

1435 
right
 = 
node
->right->
first
->
node_idx
;

1437 
right
 = 
node
->
next
->
node_idx
;

1438 
	`assert
 (
	`REG_VALID_INDEX
 (
left
));

1439 
	`assert
 (
	`REG_VALID_INDEX
 (
right
));

1440 
err
 = 
	`re_node_set_init_2
 (
dfa
->
edests
 + 
idx
, 
left
, 
right
);

1444 case 
ANCHOR
:

1445 case 
OP_OPEN_SUBEXP
:

1446 case 
OP_CLOSE_SUBEXP
:

1447 
err
 = 
	`re_node_set_init_1
 (
dfa
->
edests
 + 
idx
, 
node
->
next
->
node_idx
);

1450 case 
OP_BACK_REF
:

1451 
dfa
->
nexts
[
idx
] = 
node
->
next
->
node_idx
;

1452 if (
node
->
token
.
type
 == 
OP_BACK_REF
)

1453 
err
 = 
	`re_node_set_init_1
 (
dfa
->
edests
 + 
idx
, dfa->
nexts
[idx]);

1457 
	`assert
 (!
	`IS_EPSILON_NODE
 (
node
->
token
.
type
));

1458 
dfa
->
nexts
[
idx
] = 
node
->
next
->
node_idx
;

1462 return 
err
;

1463 
	}
}

1469 static 
reg_errcode_t


1470 
internal_function


1471 
	$duplicate_node_closure
 (
re_dfa_t
 *
dfa
, 
Idx
 
top_org_node
, Idx 
top_clone_node
,

1472 
Idx
 
root_node
, unsigned int 
init_constraint
)

1474 
Idx
 
org_node
, 
clone_node
;

1475 
bool
 
ok
;

1476 unsigned int 
constraint
 = 
init_constraint
;

1477 for (
org_node
 = 
top_org_node
, 
clone_node
 = 
top_clone_node
;;)

1479 
Idx
 
org_dest
, 
clone_dest
;

1480 if (
dfa
->
nodes
[
org_node
].
type
 == 
OP_BACK_REF
)

1486 
org_dest
 = 
dfa
->
nexts
[
org_node
];

1487 
	`re_node_set_empty
 (
dfa
->
edests
 + 
clone_node
);

1488 
clone_dest
 = 
	`duplicate_node
 (
dfa
, 
org_dest
, 
constraint
);

1489 if (
	`BE
 (
clone_dest
 == 
REG_MISSING
, 0))

1490 return 
REG_ESPACE
;

1491 
dfa
->
nexts
[
clone_node
] = dfa->nexts[
org_node
];

1492 
ok
 = 
	`re_node_set_insert
 (
dfa
->
edests
 + 
clone_node
, 
clone_dest
);

1493 if (
	`BE
 (! 
ok
, 0))

1494 return 
REG_ESPACE
;

1496 else if (
dfa
->
edests
[
org_node
].
nelem
 == 0)

1501 
dfa
->
nexts
[
clone_node
] = dfa->nexts[
org_node
];

1504 else if (
dfa
->
edests
[
org_node
].
nelem
 == 1)

1508 
org_dest
 = 
dfa
->
edests
[
org_node
].
elems
[0];

1509 
	`re_node_set_empty
 (
dfa
->
edests
 + 
clone_node
);

1512 if (
org_node
 == 
root_node
 && 
clone_node
 != org_node)

1514 
ok
 = 
	`re_node_set_insert
 (
dfa
->
edests
 + 
clone_node
, 
org_dest
);

1515 if (
	`BE
 (! 
ok
, 0))

1516 return 
REG_ESPACE
;

1520 
constraint
 |= 
dfa
->
nodes
[
org_node
].constraint;

1521 
clone_dest
 = 
	`duplicate_node
 (
dfa
, 
org_dest
, 
constraint
);

1522 if (
	`BE
 (
clone_dest
 == 
REG_MISSING
, 0))

1523 return 
REG_ESPACE
;

1524 
ok
 = 
	`re_node_set_insert
 (
dfa
->
edests
 + 
clone_node
, 
clone_dest
);

1525 if (
	`BE
 (! 
ok
, 0))

1526 return 
REG_ESPACE
;

1532 
org_dest
 = 
dfa
->
edests
[
org_node
].
elems
[0];

1533 
	`re_node_set_empty
 (
dfa
->
edests
 + 
clone_node
);

1535 
clone_dest
 = 
	`search_duplicated_node
 (
dfa
, 
org_dest
, 
constraint
);

1536 if (
clone_dest
 == 
REG_MISSING
)

1539 
reg_errcode_t
 
err
;

1540 
clone_dest
 = 
	`duplicate_node
 (
dfa
, 
org_dest
, 
constraint
);

1541 if (
	`BE
 (
clone_dest
 == 
REG_MISSING
, 0))

1542 return 
REG_ESPACE
;

1543 
ok
 = 
	`re_node_set_insert
 (
dfa
->
edests
 + 
clone_node
, 
clone_dest
);

1544 if (
	`BE
 (! 
ok
, 0))

1545 return 
REG_ESPACE
;

1546 
err
 = 
	`duplicate_node_closure
 (
dfa
, 
org_dest
, 
clone_dest
,

1547 
root_node
, 
constraint
);

1548 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1549 return 
err
;

1555 
ok
 = 
	`re_node_set_insert
 (
dfa
->
edests
 + 
clone_node
, 
clone_dest
);

1556 if (
	`BE
 (! 
ok
, 0))

1557 return 
REG_ESPACE
;

1560 
org_dest
 = 
dfa
->
edests
[
org_node
].
elems
[1];

1561 
clone_dest
 = 
	`duplicate_node
 (
dfa
, 
org_dest
, 
constraint
);

1562 if (
	`BE
 (
clone_dest
 == 
REG_MISSING
, 0))

1563 return 
REG_ESPACE
;

1564 
ok
 = 
	`re_node_set_insert
 (
dfa
->
edests
 + 
clone_node
, 
clone_dest
);

1565 if (
	`BE
 (! 
ok
, 0))

1566 return 
REG_ESPACE
;

1568 
org_node
 = 
org_dest
;

1569 
clone_node
 = 
clone_dest
;

1571 return 
REG_NOERROR
;

1572 
	}
}

1577 static 
Idx


1578 
	$search_duplicated_node
 (const 
re_dfa_t
 *
dfa
, 
Idx
 
org_node
,

1579 unsigned int 
constraint
)

1581 
Idx
 
idx
;

1582 for (
idx
 = 
dfa
->
nodes_len
 - 1; dfa->
nodes
[idx].
duplicated
 && idx > 0; --idx)

1584 if (
org_node
 == 
dfa
->
org_indices
[
idx
]

1585 && 
constraint
 == 
dfa
->
nodes
[
idx
].constraint)

1586 return 
idx
;

1588 return 
REG_MISSING
;

1589 
	}
}

1595 static 
Idx


1596 
	$duplicate_node
 (
re_dfa_t
 *
dfa
, 
Idx
 
org_idx
, unsigned int 
constraint
)

1598 
Idx
 
dup_idx
 = 
	`re_dfa_add_node
 (
dfa
, dfa->
nodes
[
org_idx
]);

1599 if (
	`BE
 (
dup_idx
 != 
REG_MISSING
, 1))

1601 
dfa
->
nodes
[
dup_idx
].
constraint
 = constraint;

1602 
dfa
->
nodes
[
dup_idx
].
constraint
 |= dfa->nodes[
org_idx
].constraint;

1603 
dfa
->
nodes
[
dup_idx
].
duplicated
 = 1;

1606 
dfa
->
org_indices
[
dup_idx
] = 
org_idx
;

1608 return 
dup_idx
;

1609 
	}
}

1611 static 
reg_errcode_t


1612 
	$calc_inveclosure
 (
re_dfa_t
 *
dfa
)

1614 
Idx
 
src
, 
idx
;

1615 
bool
 
ok
;

1616 for (
idx
 = 0; idx < 
dfa
->
nodes_len
; ++idx)

1617 
	`re_node_set_init_empty
 (
dfa
->
inveclosures
 + 
idx
);

1619 for (
src
 = 0; src < 
dfa
->
nodes_len
; ++src)

1621 
Idx
 *
elems
 = 
dfa
->
eclosures
[
src
].elems;

1622 for (
idx
 = 0; idx < 
dfa
->
eclosures
[
src
].
nelem
; ++idx)

1624 
ok
 = 
	`re_node_set_insert_last
 (
dfa
->
inveclosures
 + 
elems
[
idx
], 
src
);

1625 if (
	`BE
 (! 
ok
, 0))

1626 return 
REG_ESPACE
;

1630 return 
REG_NOERROR
;

1631 
	}
}

1635 static 
reg_errcode_t


1636 
	$calc_eclosure
 (
re_dfa_t
 *
dfa
)

1638 
Idx
 
node_idx
;

1639 
bool
 
incomplete
;

1640 #ifdef 
DEBUG


1641 
	`assert
 (
dfa
->
nodes_len
 > 0);

1643 
incomplete
 = 
false
;

1645 for (
node_idx
 = 0; ; ++node_idx)

1647 
reg_errcode_t
 
err
;

1648 
re_node_set
 
eclosure_elem
;

1649 if (
node_idx
 == 
dfa
->
nodes_len
)

1651 if (!
incomplete
)

1653 
incomplete
 = 
false
;

1654 
node_idx
 = 0;

1657 #ifdef 
DEBUG


1658 
	`assert
 (
dfa
->
eclosures
[
node_idx
].
nelem
 != 
REG_MISSING
);

1662 if (
dfa
->
eclosures
[
node_idx
].
nelem
 != 0)

1665 
err
 = 
	`calc_eclosure_iter
 (&
eclosure_elem
, 
dfa
, 
node_idx
, 
true
);

1666 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1667 return 
err
;

1669 if (
dfa
->
eclosures
[
node_idx
].
nelem
 == 0)

1671 
incomplete
 = 
true
;

1672 
	`re_node_set_free
 (&
eclosure_elem
);

1675 return 
REG_NOERROR
;

1676 
	}
}

1680 static 
reg_errcode_t


1681 
	$calc_eclosure_iter
 (
re_node_set
 *
new_set
, 
re_dfa_t
 *
dfa
, 
Idx
 
node
, 
bool
 
root
)

1683 
reg_errcode_t
 
err
;

1684 
Idx
 
i
;

1685 
re_node_set
 
eclosure
;

1686 
bool
 
ok
;

1687 
bool
 
incomplete
 = 
false
;

1688 
err
 = 
	`re_node_set_alloc
 (&
eclosure
, 
dfa
->
edests
[
node
].
nelem
 + 1);

1689 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1690 return 
err
;

1694 
dfa
->
eclosures
[
node
].
nelem
 = 
REG_MISSING
;

1698 if (
dfa
->
nodes
[
node
].
constraint


1699 && 
dfa
->
edests
[
node
].
nelem


1700 && !
dfa
->
nodes
[dfa->
edests
[
node
].
elems
[0]].
duplicated
)

1702 
err
 = 
	`duplicate_node_closure
 (
dfa
, 
node
, node, node,

1703 
dfa
->
nodes
[
node
].
constraint
);

1704 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1705 return 
err
;

1709 if (
	`IS_EPSILON_NODE
(
dfa
->
nodes
[
node
].
type
))

1710 for (
i
 = 0; i < 
dfa
->
edests
[
node
].
nelem
; ++i)

1712 
re_node_set
 
eclosure_elem
;

1713 
Idx
 
edest
 = 
dfa
->
edests
[
node
].
elems
[
i
];

1716 if (
dfa
->
eclosures
[
edest
].
nelem
 == 
REG_MISSING
)

1718 
incomplete
 = 
true
;

1723 if (
dfa
->
eclosures
[
edest
].
nelem
 == 0)

1725 
err
 = 
	`calc_eclosure_iter
 (&
eclosure_elem
, 
dfa
, 
edest
, 
false
);

1726 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1727 return 
err
;

1730 
eclosure_elem
 = 
dfa
->
eclosures
[
edest
];

1732 
err
 = 
	`re_node_set_merge
 (&
eclosure
, &
eclosure_elem
);

1733 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1734 return 
err
;

1737 if (
dfa
->
eclosures
[
edest
].
nelem
 == 0)

1739 
incomplete
 = 
true
;

1740 
	`re_node_set_free
 (&
eclosure_elem
);

1745 
ok
 = 
	`re_node_set_insert
 (&
eclosure
, 
node
);

1746 if (
	`BE
 (! 
ok
, 0))

1747 return 
REG_ESPACE
;

1748 if (
incomplete
 && !
root
)

1749 
dfa
->
eclosures
[
node
].
nelem
 = 0;

1751 
dfa
->
eclosures
[
node
] = 
eclosure
;

1752 *
new_set
 = 
eclosure
;

1753 return 
REG_NOERROR
;

1754 
	}
}

1762 
internal_function


1763 
	$fetch_token
 (
re_token_t
 *
result
, 
re_string_t
 *
input
, 
reg_syntax_t
 
syntax
)

1765 
	`re_string_skip_bytes
 (
input
, 
	`peek_token
 (
result
, input, 
syntax
));

1766 
	}
}

1772 
internal_function


1773 
	$peek_token
 (
re_token_t
 *
token
, 
re_string_t
 *
input
, 
reg_syntax_t
 
syntax
)

1775 unsigned char 
c
;

1777 if (
	`re_string_eoi
 (
input
))

1779 
token
->
type
 = 
END_OF_RE
;

1783 
c
 = 
	`re_string_peek_byte
 (
input
, 0);

1784 
token
->
opr
.
c
 = c;

1786 
token
->
word_char
 = 0;

1787 #ifdef 
RE_ENABLE_I18N


1788 
token
->
mb_partial
 = 0;

1789 if (
input
->
mb_cur_max
 > 1 &&

1790 !
	`re_string_first_byte
 (
input
, 
	`re_string_cur_idx
 (input)))

1792 
token
->
type
 = 
CHARACTER
;

1793 
token
->
mb_partial
 = 1;

1797 if (
c
 == '\\')

1799 unsigned char 
c2
;

1800 if (
	`re_string_cur_idx
 (
input
) + 1 >= 
	`re_string_length
 (input))

1802 
token
->
type
 = 
BACK_SLASH
;

1806 
c2
 = 
	`re_string_peek_byte_case
 (
input
, 1);

1807 
token
->
opr
.
c
 = 
c2
;

1808 
token
->
type
 = 
CHARACTER
;

1809 #ifdef 
RE_ENABLE_I18N


1810 if (
input
->
mb_cur_max
 > 1)

1812 
wint_t
 
wc
 = 
	`re_string_wchar_at
 (
input
,

1813 
	`re_string_cur_idx
 (
input
) + 1);

1814 
token
->
word_char
 = 
	`IS_WIDE_WORD_CHAR
 (
wc
) != 0;

1818 
token
->
word_char
 = 
	`IS_WORD_CHAR
 (
c2
) != 0;

1820 switch (
c2
)

1823 if (!(
syntax
 & 
RE_LIMITED_OPS
) && !(syntax & 
RE_NO_BK_VBAR
))

1824 
token
->
type
 = 
OP_ALT
;

1828 if (!(
syntax
 & 
RE_NO_BK_REFS
))

1830 
token
->
type
 = 
OP_BACK_REF
;

1831 
token
->
opr
.
idx
 = 
c2
 - '1';

1835 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1837 
token
->
type
 = 
ANCHOR
;

1838 
token
->
opr
.
ctx_type
 = 
WORD_FIRST
;

1842 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1844 
token
->
type
 = 
ANCHOR
;

1845 
token
->
opr
.
ctx_type
 = 
WORD_LAST
;

1849 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1851 
token
->
type
 = 
ANCHOR
;

1852 
token
->
opr
.
ctx_type
 = 
WORD_DELIM
;

1856 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1858 
token
->
type
 = 
ANCHOR
;

1859 
token
->
opr
.
ctx_type
 = 
NOT_WORD_DELIM
;

1863 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1864 
token
->
type
 = 
OP_WORD
;

1867 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1868 
token
->
type
 = 
OP_NOTWORD
;

1871 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1872 
token
->
type
 = 
OP_SPACE
;

1875 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1876 
token
->
type
 = 
OP_NOTSPACE
;

1879 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1881 
token
->
type
 = 
ANCHOR
;

1882 
token
->
opr
.
ctx_type
 = 
BUF_FIRST
;

1886 if (!(
syntax
 & 
RE_NO_GNU_OPS
))

1888 
token
->
type
 = 
ANCHOR
;

1889 
token
->
opr
.
ctx_type
 = 
BUF_LAST
;

1893 if (!(
syntax
 & 
RE_NO_BK_PARENS
))

1894 
token
->
type
 = 
OP_OPEN_SUBEXP
;

1897 if (!(
syntax
 & 
RE_NO_BK_PARENS
))

1898 
token
->
type
 = 
OP_CLOSE_SUBEXP
;

1901 if (!(
syntax
 & 
RE_LIMITED_OPS
) && (syntax & 
RE_BK_PLUS_QM
))

1902 
token
->
type
 = 
OP_DUP_PLUS
;

1905 if (!(
syntax
 & 
RE_LIMITED_OPS
) && (syntax & 
RE_BK_PLUS_QM
))

1906 
token
->
type
 = 
OP_DUP_QUESTION
;

1909 if ((
syntax
 & 
RE_INTERVALS
) && (!(syntax & 
RE_NO_BK_BRACES
)))

1910 
token
->
type
 = 
OP_OPEN_DUP_NUM
;

1913 if ((
syntax
 & 
RE_INTERVALS
) && (!(syntax & 
RE_NO_BK_BRACES
)))

1914 
token
->
type
 = 
OP_CLOSE_DUP_NUM
;

1922 
token
->
type
 = 
CHARACTER
;

1923 #ifdef 
RE_ENABLE_I18N


1924 if (
input
->
mb_cur_max
 > 1)

1926 
wint_t
 
wc
 = 
	`re_string_wchar_at
 (
input
, 
	`re_string_cur_idx
 (input));

1927 
token
->
word_char
 = 
	`IS_WIDE_WORD_CHAR
 (
wc
) != 0;

1931 
token
->
word_char
 = 
	`IS_WORD_CHAR
 (token->
opr
.
c
);

1933 switch (
c
)

1936 if (
syntax
 & 
RE_NEWLINE_ALT
)

1937 
token
->
type
 = 
OP_ALT
;

1940 if (!(
syntax
 & 
RE_LIMITED_OPS
) && (syntax & 
RE_NO_BK_VBAR
))

1941 
token
->
type
 = 
OP_ALT
;

1944 
token
->
type
 = 
OP_DUP_ASTERISK
;

1947 if (!(
syntax
 & 
RE_LIMITED_OPS
) && !(syntax & 
RE_BK_PLUS_QM
))

1948 
token
->
type
 = 
OP_DUP_PLUS
;

1951 if (!(
syntax
 & 
RE_LIMITED_OPS
) && !(syntax & 
RE_BK_PLUS_QM
))

1952 
token
->
type
 = 
OP_DUP_QUESTION
;

1955 if ((
syntax
 & 
RE_INTERVALS
) && (syntax & 
RE_NO_BK_BRACES
))

1956 
token
->
type
 = 
OP_OPEN_DUP_NUM
;

1959 if ((
syntax
 & 
RE_INTERVALS
) && (syntax & 
RE_NO_BK_BRACES
))

1960 
token
->
type
 = 
OP_CLOSE_DUP_NUM
;

1963 if (
syntax
 & 
RE_NO_BK_PARENS
)

1964 
token
->
type
 = 
OP_OPEN_SUBEXP
;

1967 if (
syntax
 & 
RE_NO_BK_PARENS
)

1968 
token
->
type
 = 
OP_CLOSE_SUBEXP
;

1971 
token
->
type
 = 
OP_OPEN_BRACKET
;

1974 
token
->
type
 = 
OP_PERIOD
;

1977 if (!(
syntax
 & (
RE_CONTEXT_INDEP_ANCHORS
 | 
RE_CARET_ANCHORS_HERE
)) &&

1978 
	`re_string_cur_idx
 (
input
) != 0)

1980 char 
prev
 = 
	`re_string_peek_byte
 (
input
, -1);

1981 if (!(
syntax
 & 
RE_NEWLINE_ALT
) || 
prev
 != '\n')

1984 
token
->
type
 = 
ANCHOR
;

1985 
token
->
opr
.
ctx_type
 = 
LINE_FIRST
;

1988 if (!(
syntax
 & 
RE_CONTEXT_INDEP_ANCHORS
) &&

1989 
	`re_string_cur_idx
 (
input
) + 1 != 
	`re_string_length
 (input))

1991 
re_token_t
 
next
;

1992 
	`re_string_skip_bytes
 (
input
, 1);

1993 
	`peek_token
 (&
next
, 
input
, 
syntax
);

1994 
	`re_string_skip_bytes
 (
input
, -1);

1995 if (
next
.
type
 != 
OP_ALT
 && next.type != 
OP_CLOSE_SUBEXP
)

1998 
token
->
type
 = 
ANCHOR
;

1999 
token
->
opr
.
ctx_type
 = 
LINE_LAST
;

2005 
	}
}

2011 
internal_function


2012 
	$peek_token_bracket
 (
re_token_t
 *
token
, 
re_string_t
 *
input
, 
reg_syntax_t
 
syntax
)

2014 unsigned char 
c
;

2015 if (
	`re_string_eoi
 (
input
))

2017 
token
->
type
 = 
END_OF_RE
;

2020 
c
 = 
	`re_string_peek_byte
 (
input
, 0);

2021 
token
->
opr
.
c
 = c;

2023 #ifdef 
RE_ENABLE_I18N


2024 if (
input
->
mb_cur_max
 > 1 &&

2025 !
	`re_string_first_byte
 (
input
, 
	`re_string_cur_idx
 (input)))

2027 
token
->
type
 = 
CHARACTER
;

2032 if (
c
 == '\\' && (
syntax
 & 
RE_BACKSLASH_ESCAPE_IN_LISTS
)

2033 && 
	`re_string_cur_idx
 (
input
) + 1 < 
	`re_string_length
 (input))

2036 unsigned char 
c2
;

2037 
	`re_string_skip_bytes
 (
input
, 1);

2038 
c2
 = 
	`re_string_peek_byte
 (
input
, 0);

2039 
token
->
opr
.
c
 = 
c2
;

2040 
token
->
type
 = 
CHARACTER
;

2043 if (
c
 == '[')

2045 unsigned char 
c2
;

2046 int 
token_len
;

2047 if (
	`re_string_cur_idx
 (
input
) + 1 < 
	`re_string_length
 (input))

2048 
c2
 = 
	`re_string_peek_byte
 (
input
, 1);

2050 
c2
 = 0;

2051 
token
->
opr
.
c
 = 
c2
;

2052 
token_len
 = 2;

2053 switch (
c2
)

2056 
token
->
type
 = 
OP_OPEN_COLL_ELEM
;

2059 
token
->
type
 = 
OP_OPEN_EQUIV_CLASS
;

2062 if (
syntax
 & 
RE_CHAR_CLASSES
)

2064 
token
->
type
 = 
OP_OPEN_CHAR_CLASS
;

2069 
token
->
type
 = 
CHARACTER
;

2070 
token
->
opr
.
c
 = c;

2071 
token_len
 = 1;

2074 return 
token_len
;

2076 switch (
c
)

2079 
token
->
type
 = 
OP_CHARSET_RANGE
;

2082 
token
->
type
 = 
OP_CLOSE_BRACKET
;

2085 
token
->
type
 = 
OP_NON_MATCH_LIST
;

2088 
token
->
type
 = 
CHARACTER
;

2091 
	}
}

2107 static 
bin_tree_t
 *

2108 
	$parse
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
, 
reg_syntax_t
 
syntax
,

2109 
reg_errcode_t
 *
err
)

2111 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

2112 
bin_tree_t
 *
tree
, *
eor
, *
root
;

2113 
re_token_t
 
current_token
;

2114 
dfa
->
syntax
 = syntax;

2115 
	`fetch_token
 (&
current_token
, 
regexp
, 
syntax
 | 
RE_CARET_ANCHORS_HERE
);

2116 
tree
 = 
	`parse_reg_exp
 (
regexp
, 
preg
, &
current_token
, 
syntax
, 0, 
err
);

2117 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2118 return 
NULL
;

2119 
eor
 = 
	`create_tree
 (
dfa
, 
NULL
, NULL, 
END_OF_RE
);

2120 if (
tree
 != 
NULL
)

2121 
root
 = 
	`create_tree
 (
dfa
, 
tree
, 
eor
, 
CONCAT
);

2123 
root
 = 
eor
;

2124 if (
	`BE
 (
eor
 == 
NULL
 || 
root
 == NULL, 0))

2126 *
err
 = 
REG_ESPACE
;

2127 return 
NULL
;

2129 return 
root
;

2130 
	}
}

2141 static 
bin_tree_t
 *

2142 
	$parse_reg_exp
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
, 
re_token_t
 *
token
,

2143 
reg_syntax_t
 
syntax
, 
Idx
 
nest
, 
reg_errcode_t
 *
err
)

2145 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

2146 
bin_tree_t
 *
tree
, *
branch
 = 
NULL
;

2147 
tree
 = 
	`parse_branch
 (
regexp
, 
preg
, 
token
, 
syntax
, 
nest
, 
err
);

2148 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2149 return 
NULL
;

2151 while (
token
->
type
 == 
OP_ALT
)

2153 
	`fetch_token
 (
token
, 
regexp
, 
syntax
 | 
RE_CARET_ANCHORS_HERE
);

2154 if (
token
->
type
 != 
OP_ALT
 && token->type != 
END_OF_RE


2155 && (
nest
 == 0 || 
token
->
type
 != 
OP_CLOSE_SUBEXP
))

2157 
branch
 = 
	`parse_branch
 (
regexp
, 
preg
, 
token
, 
syntax
, 
nest
, 
err
);

2158 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
branch
 == 
NULL
, 0))

2159 return 
NULL
;

2162 
branch
 = 
NULL
;

2163 
tree
 = 
	`create_tree
 (
dfa
, tree, 
branch
, 
OP_ALT
);

2164 if (
	`BE
 (
tree
 == 
NULL
, 0))

2166 *
err
 = 
REG_ESPACE
;

2167 return 
NULL
;

2170 return 
tree
;

2171 
	}
}

2182 static 
bin_tree_t
 *

2183 
	$parse_branch
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
, 
re_token_t
 *
token
,

2184 
reg_syntax_t
 
syntax
, 
Idx
 
nest
, 
reg_errcode_t
 *
err
)

2186 
bin_tree_t
 *
tree
, *
expr
;

2187 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

2188 
tree
 = 
	`parse_expression
 (
regexp
, 
preg
, 
token
, 
syntax
, 
nest
, 
err
);

2189 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2190 return 
NULL
;

2192 while (
token
->
type
 != 
OP_ALT
 && token->type != 
END_OF_RE


2193 && (
nest
 == 0 || 
token
->
type
 != 
OP_CLOSE_SUBEXP
))

2195 
expr
 = 
	`parse_expression
 (
regexp
, 
preg
, 
token
, 
syntax
, 
nest
, 
err
);

2196 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
expr
 == 
NULL
, 0))

2198 return 
NULL
;

2200 if (
tree
 != 
NULL
 && 
expr
 != NULL)

2202 
tree
 = 
	`create_tree
 (
dfa
, tree, 
expr
, 
CONCAT
);

2203 if (
tree
 == 
NULL
)

2205 *
err
 = 
REG_ESPACE
;

2206 return 
NULL
;

2209 else if (
tree
 == 
NULL
)

2210 
tree
 = 
expr
;

2213 return 
tree
;

2214 
	}
}

2222 static 
bin_tree_t
 *

2223 
	$parse_expression
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
, 
re_token_t
 *
token
,

2224 
reg_syntax_t
 
syntax
, 
Idx
 
nest
, 
reg_errcode_t
 *
err
)

2226 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

2227 
bin_tree_t
 *
tree
;

2228 switch (
token
->
type
)

2230 case 
CHARACTER
:

2231 
tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2232 if (
	`BE
 (
tree
 == 
NULL
, 0))

2234 *
err
 = 
REG_ESPACE
;

2235 return 
NULL
;

2237 #ifdef 
RE_ENABLE_I18N


2238 if (
dfa
->
mb_cur_max
 > 1)

2240 while (!
	`re_string_eoi
 (
regexp
)

2241 && !
	`re_string_first_byte
 (
regexp
, 
	`re_string_cur_idx
 (regexp)))

2243 
bin_tree_t
 *
mbc_remain
;

2244 
	`fetch_token
 (
token
, 
regexp
, 
syntax
);

2245 
mbc_remain
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2246 
tree
 = 
	`create_tree
 (
dfa
, tree, 
mbc_remain
, 
CONCAT
);

2247 if (
	`BE
 (
mbc_remain
 == 
NULL
 || 
tree
 == NULL, 0))

2249 *
err
 = 
REG_ESPACE
;

2250 return 
NULL
;

2256 case 
OP_OPEN_SUBEXP
:

2257 
tree
 = 
	`parse_sub_exp
 (
regexp
, 
preg
, 
token
, 
syntax
, 
nest
 + 1, 
err
);

2258 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2259 return 
NULL
;

2261 case 
OP_OPEN_BRACKET
:

2262 
tree
 = 
	`parse_bracket_exp
 (
regexp
, 
dfa
, 
token
, 
syntax
, 
err
);

2263 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2264 return 
NULL
;

2266 case 
OP_BACK_REF
:

2267 if (!
	`BE
 (
dfa
->
completed_bkref_map
 & (1 << 
token
->
opr
.
idx
), 1))

2269 *
err
 = 
REG_ESUBREG
;

2270 return 
NULL
;

2272 
dfa
->
used_bkref_map
 |= 1 << 
token
->
opr
.
idx
;

2273 
tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2274 if (
	`BE
 (
tree
 == 
NULL
, 0))

2276 *
err
 = 
REG_ESPACE
;

2277 return 
NULL
;

2279 ++
dfa
->
nbackref
;

2280 
dfa
->
has_mb_node
 = 1;

2282 case 
OP_OPEN_DUP_NUM
:

2283 if (
syntax
 & 
RE_CONTEXT_INVALID_DUP
)

2285 *
err
 = 
REG_BADRPT
;

2286 return 
NULL
;

2289 case 
OP_DUP_ASTERISK
:

2290 case 
OP_DUP_PLUS
:

2291 case 
OP_DUP_QUESTION
:

2292 if (
syntax
 & 
RE_CONTEXT_INVALID_OPS
)

2294 *
err
 = 
REG_BADRPT
;

2295 return 
NULL
;

2297 else if (
syntax
 & 
RE_CONTEXT_INDEP_OPS
)

2299 
	`fetch_token
 (
token
, 
regexp
, 
syntax
);

2300 return 
	`parse_expression
 (
regexp
, 
preg
, 
token
, 
syntax
, 
nest
, 
err
);

2303 case 
OP_CLOSE_SUBEXP
:

2304 if ((
token
->
type
 == 
OP_CLOSE_SUBEXP
) &&

2305 !(
syntax
 & 
RE_UNMATCHED_RIGHT_PAREN_ORD
))

2307 *
err
 = 
REG_ERPAREN
;

2308 return 
NULL
;

2311 case 
OP_CLOSE_DUP_NUM
:

2315 
token
->
type
 = 
CHARACTER
;

2318 
tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2319 if (
	`BE
 (
tree
 == 
NULL
, 0))

2321 *
err
 = 
REG_ESPACE
;

2322 return 
NULL
;

2325 case 
ANCHOR
:

2326 if ((
token
->
opr
.
ctx_type


2327 & (
WORD_DELIM
 | 
NOT_WORD_DELIM
 | 
WORD_FIRST
 | 
WORD_LAST
))

2328 && 
dfa
->
word_ops_used
 == 0)

2329 
	`init_word_char
 (
dfa
);

2330 if (
token
->
opr
.
ctx_type
 == 
WORD_DELIM


2331 || 
token
->
opr
.
ctx_type
 == 
NOT_WORD_DELIM
)

2333 
bin_tree_t
 *
tree_first
, *
tree_last
;

2334 if (
token
->
opr
.
ctx_type
 == 
WORD_DELIM
)

2336 
token
->
opr
.
ctx_type
 = 
WORD_FIRST
;

2337 
tree_first
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2338 
token
->
opr
.
ctx_type
 = 
WORD_LAST
;

2342 
token
->
opr
.
ctx_type
 = 
INSIDE_WORD
;

2343 
tree_first
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2344 
token
->
opr
.
ctx_type
 = 
INSIDE_NOTWORD
;

2346 
tree_last
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2347 
tree
 = 
	`create_tree
 (
dfa
, 
tree_first
, 
tree_last
, 
OP_ALT
);

2348 if (
	`BE
 (
tree_first
 == 
NULL
 || 
tree_last
 == NULL || 
tree
 == NULL, 0))

2350 *
err
 = 
REG_ESPACE
;

2351 return 
NULL
;

2356 
tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2357 if (
	`BE
 (
tree
 == 
NULL
, 0))

2359 *
err
 = 
REG_ESPACE
;

2360 return 
NULL
;

2367 
	`fetch_token
 (
token
, 
regexp
, 
syntax
);

2368 return 
tree
;

2369 case 
OP_PERIOD
:

2370 
tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, 
token
);

2371 if (
	`BE
 (
tree
 == 
NULL
, 0))

2373 *
err
 = 
REG_ESPACE
;

2374 return 
NULL
;

2376 if (
dfa
->
mb_cur_max
 > 1)

2377 
dfa
->
has_mb_node
 = 1;

2379 case 
OP_WORD
:

2380 case 
OP_NOTWORD
:

2381 
tree
 = 
	`build_charclass_op
 (
dfa
, 
regexp
->
trans
,

2384 
token
->
type
 == 
OP_NOTWORD
, 
err
);

2385 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2386 return 
NULL
;

2388 case 
OP_SPACE
:

2389 case 
OP_NOTSPACE
:

2390 
tree
 = 
	`build_charclass_op
 (
dfa
, 
regexp
->
trans
,

2393 
token
->
type
 == 
OP_NOTSPACE
, 
err
);

2394 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2395 return 
NULL
;

2397 case 
OP_ALT
:

2398 case 
END_OF_RE
:

2399 return 
NULL
;

2400 case 
BACK_SLASH
:

2401 *
err
 = 
REG_EESCAPE
;

2402 return 
NULL
;

2405 #ifdef 
DEBUG


2406 
	`assert
 (0);

2408 return 
NULL
;

2410 
	`fetch_token
 (
token
, 
regexp
, 
syntax
);

2412 while (
token
->
type
 == 
OP_DUP_ASTERISK
 || token->type == 
OP_DUP_PLUS


2413 || 
token
->
type
 == 
OP_DUP_QUESTION
 || token->type == 
OP_OPEN_DUP_NUM
)

2415 
tree
 = 
	`parse_dup_op
 (tree, 
regexp
, 
dfa
, 
token
, 
syntax
, 
err
);

2416 if (
	`BE
 (*
err
 != 
REG_NOERROR
 && 
tree
 == 
NULL
, 0))

2417 return 
NULL
;

2419 if ((
syntax
 & 
RE_CONTEXT_INVALID_DUP
)

2420 && (
token
->
type
 == 
OP_DUP_ASTERISK


2421 || 
token
->
type
 == 
OP_OPEN_DUP_NUM
))

2423 *
err
 = 
REG_BADRPT
;

2424 return 
NULL
;

2428 return 
tree
;

2429 
	}
}

2438 static 
bin_tree_t
 *

2439 
	$parse_sub_exp
 (
re_string_t
 *
regexp
, 
regex_t
 *
preg
, 
re_token_t
 *
token
,

2440 
reg_syntax_t
 
syntax
, 
Idx
 
nest
, 
reg_errcode_t
 *
err
)

2442 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

2443 
bin_tree_t
 *
tree
;

2444 
size_t
 
cur_nsub
;

2445 
cur_nsub
 = 
preg
->
re_nsub
++;

2447 
	`fetch_token
 (
token
, 
regexp
, 
syntax
 | 
RE_CARET_ANCHORS_HERE
);

2450 if (
token
->
type
 == 
OP_CLOSE_SUBEXP
)

2451 
tree
 = 
NULL
;

2454 
tree
 = 
	`parse_reg_exp
 (
regexp
, 
preg
, 
token
, 
syntax
, 
nest
, 
err
);

2455 if (
	`BE
 (*
err
 == 
REG_NOERROR
 && 
token
->
type
 != 
OP_CLOSE_SUBEXP
, 0))

2456 *
err
 = 
REG_EPAREN
;

2457 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

2458 return 
NULL
;

2461 if (
cur_nsub
 <= '9' - '1')

2462 
dfa
->
completed_bkref_map
 |= 1 << 
cur_nsub
;

2464 
tree
 = 
	`create_tree
 (
dfa
, tree, 
NULL
, 
SUBEXP
);

2465 if (
	`BE
 (
tree
 == 
NULL
, 0))

2467 *
err
 = 
REG_ESPACE
;

2468 return 
NULL
;

2470 
tree
->
token
.
opr
.
idx
 = 
cur_nsub
;

2471 return 
tree
;

2472 
	}
}

2476 static 
bin_tree_t
 *

2477 
	$parse_dup_op
 (
bin_tree_t
 *
elem
, 
re_string_t
 *
regexp
, 
re_dfa_t
 *
dfa
,

2478 
re_token_t
 *
token
, 
reg_syntax_t
 
syntax
, 
reg_errcode_t
 *
err
)

2480 
bin_tree_t
 *
tree
 = 
NULL
, *
old_tree
 = NULL;

2481 
Idx
 
i
, 
start
, 
end
, 
start_idx
 = 
	`re_string_cur_idx
 (
regexp
);

2482 
re_token_t
 
start_token
 = *
token
;

2484 if (
token
->
type
 == 
OP_OPEN_DUP_NUM
)

2486 
end
 = 0;

2487 
start
 = 
	`fetch_number
 (
regexp
, 
token
, 
syntax
);

2488 if (
start
 == 
REG_MISSING
)

2490 if (
token
->
type
 == 
CHARACTER
 && token->
opr
.
c
 == ',')

2491 
start
 = 0;

2494 *
err
 = 
REG_BADBR
;

2495 return 
NULL
;

2498 if (
	`BE
 (
start
 != 
REG_ERROR
, 1))

2501 
end
 = ((
token
->
type
 == 
OP_CLOSE_DUP_NUM
) ? 
start


2502 : ((
token
->
type
 == 
CHARACTER
 && token->
opr
.
c
 == ',')

2503 ? 
	`fetch_number
 (
regexp
, 
token
, 
syntax
) : 
REG_ERROR
));

2505 if (
	`BE
 (
start
 == 
REG_ERROR
 || 
end
 == REG_ERROR, 0))

2508 if (
	`BE
 (!(
syntax
 & 
RE_INVALID_INTERVAL_ORD
), 0))

2510 if (
token
->
type
 == 
END_OF_RE
)

2511 *
err
 = 
REG_EBRACE
;

2513 *
err
 = 
REG_BADBR
;

2515 return 
NULL
;

2519 
	`re_string_set_index
 (
regexp
, 
start_idx
);

2520 *
token
 = 
start_token
;

2521 
token
->
type
 = 
CHARACTER
;

2524 return 
elem
;

2527 if (
	`BE
 ((
end
 != 
REG_MISSING
 && 
start
 > end)

2528 || 
token
->
type
 != 
OP_CLOSE_DUP_NUM
, 0))

2531 *
err
 = 
REG_BADBR
;

2532 return 
NULL
;

2537 
start
 = (
token
->
type
 == 
OP_DUP_PLUS
) ? 1 : 0;

2538 
end
 = (
token
->
type
 == 
OP_DUP_QUESTION
) ? 1 : 
REG_MISSING
;

2541 
	`fetch_token
 (
token
, 
regexp
, 
syntax
);

2543 if (
	`BE
 (
elem
 == 
NULL
, 0))

2544 return 
NULL
;

2545 if (
	`BE
 (
start
 == 0 && 
end
 == 0, 0))

2547 
	`postorder
 (
elem
, 
free_tree
, 
NULL
);

2548 return 
NULL
;

2552 if (
	`BE
 (
start
 > 0, 0))

2554 
tree
 = 
elem
;

2555 for (
i
 = 2; i <= 
start
; ++i)

2557 
elem
 = 
	`duplicate_tree
 (elem, 
dfa
);

2558 
tree
 = 
	`create_tree
 (
dfa
, tree, 
elem
, 
CONCAT
);

2559 if (
	`BE
 (
elem
 == 
NULL
 || 
tree
 == NULL, 0))

2560 goto 
parse_dup_op_espace
;

2563 if (
start
 == 
end
)

2564 return 
tree
;

2567 
elem
 = 
	`duplicate_tree
 (elem, 
dfa
);

2568 
old_tree
 = 
tree
;

2571 
old_tree
 = 
NULL
;

2573 if (
elem
->
token
.
type
 == 
SUBEXP
)

2574 
	`postorder
 (
elem
, 
mark_opt_subexp
, (void *) (long) elem->
token
.
opr
.
idx
);

2576 
tree
 = 
	`create_tree
 (
dfa
, 
elem
, 
NULL
,

2577 (
end
 == 
REG_MISSING
 ? 
OP_DUP_ASTERISK
 : 
OP_ALT
));

2578 if (
	`BE
 (
tree
 == 
NULL
, 0))

2579 goto 
parse_dup_op_espace
;

2583 #define 
	#TYPE_SIGNED
(
t
) (! ((t) 0 < (t) -1))

	)

2588 if (
	`TYPE_SIGNED
 (
Idx
) || 
end
 != 
REG_MISSING
)

2589 for (
i
 = 
start
 + 2; i <= 
end
; ++i)

2591 
elem
 = 
	`duplicate_tree
 (elem, 
dfa
);

2592 
tree
 = 
	`create_tree
 (
dfa
, tree, 
elem
, 
CONCAT
);

2593 if (
	`BE
 (
elem
 == 
NULL
 || 
tree
 == NULL, 0))

2594 goto 
parse_dup_op_espace
;

2596 
tree
 = 
	`create_tree
 (
dfa
, tree, 
NULL
, 
OP_ALT
);

2597 if (
	`BE
 (
tree
 == 
NULL
, 0))

2598 goto 
parse_dup_op_espace
;

2601 if (
old_tree
)

2602 
tree
 = 
	`create_tree
 (
dfa
, 
old_tree
, tree, 
CONCAT
);

2604 return 
tree
;

2606 
parse_dup_op_espace
:

2607 *
err
 = 
REG_ESPACE
;

2608 return 
NULL
;

2609 
	}
}

2613 #define 
	#BRACKET_NAME_BUF_SIZE
 32

	)

2615 #ifndef 
_LIBC


2623 static 
reg_errcode_t


2624 
	ginternal_function


2625 #ifdef 
RE_ENABLE_I18N


2626 
	$build_range_exp
 (const 
reg_syntax_t
 
syntax
,

2627 
bitset_t
 
sbcset
,

2628 
re_charset_t
 *
mbcset
,

2629 
Idx
 *
range_alloc
,

2630 const 
bracket_elem_t
 *
start_elem
,

2631 const 
bracket_elem_t
 *
end_elem
)

2633 
	$build_range_exp
 (const 
reg_syntax_t
 
syntax
,

2634 
bitset_t
 
sbcset
,

2635 const 
bracket_elem_t
 *
start_elem
,

2636 const 
bracket_elem_t
 *
end_elem
)

2639 unsigned int 
start_ch
, 
end_ch
;

2641 if (
	`BE
 (
start_elem
->
type
 == 
EQUIV_CLASS
 || start_elem->type == 
CHAR_CLASS


2642 || 
end_elem
->
type
 == 
EQUIV_CLASS
 || end_elem->type == 
CHAR_CLASS
,

2644 return 
REG_ERANGE
;

2648 if (
	`BE
 ((
start_elem
->
type
 == 
COLL_SYM


2649 && 
	`strlen
 ((char *) 
start_elem
->
opr
.
name
) > 1)

2650 || (
end_elem
->
type
 == 
COLL_SYM


2651 && 
	`strlen
 ((char *) 
end_elem
->
opr
.
name
) > 1), 0))

2652 return 
REG_ECOLLATE
;

2654 #ifdef 
RE_ENABLE_I18N


2656 
wchar_t
 
wc
;

2657 
wint_t
 
start_wc
;

2658 
wint_t
 
end_wc
;

2659 
wchar_t
 
cmp_buf
[6] = {
L
'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};

2661 
start_ch
 = ((
start_elem
->
type
 == 
SB_CHAR
) ? start_elem->
opr
.
ch


2662 : ((
start_elem
->
type
 == 
COLL_SYM
) ? start_elem->
opr
.
name
[0]

2664 
end_ch
 = ((
end_elem
->
type
 == 
SB_CHAR
) ? end_elem->
opr
.
ch


2665 : ((
end_elem
->
type
 == 
COLL_SYM
) ? end_elem->
opr
.
name
[0]

2667 
start_wc
 = ((
start_elem
->
type
 == 
SB_CHAR
 || start_elem->type == 
COLL_SYM
)

2668 ? 
	`__btowc
 (
start_ch
) : 
start_elem
->
opr
.
wch
);

2669 
end_wc
 = ((
end_elem
->
type
 == 
SB_CHAR
 || end_elem->type == 
COLL_SYM
)

2670 ? 
	`__btowc
 (
end_ch
) : 
end_elem
->
opr
.
wch
);

2671 if (
start_wc
 == 
WEOF
 || 
end_wc
 == WEOF)

2672 return 
REG_ECOLLATE
;

2673 
cmp_buf
[0] = 
start_wc
;

2674 
cmp_buf
[4] = 
end_wc
;

2676 if (
	`BE
 ((
syntax
 & 
RE_NO_EMPTY_RANGES
)

2677 && 
	`wcscoll
 (
cmp_buf
, cmp_buf + 4) > 0, 0))

2678 return 
REG_ERANGE
;

2685 if (
mbcset
)

2688 if (
	`BE
 (*
range_alloc
 == 
mbcset
->
nranges
, 0))

2691 
wchar_t
 *
new_array_start
, *
new_array_end
;

2692 
Idx
 
new_nranges
;

2695 
new_nranges
 = 2 * 
mbcset
->
nranges
 + 1;

2698 
new_array_start
 = 
	`re_realloc
 (
mbcset
->
range_starts
, 
wchar_t
,

2699 
new_nranges
);

2700 
new_array_end
 = 
	`re_realloc
 (
mbcset
->
range_ends
, 
wchar_t
,

2701 
new_nranges
);

2703 if (
	`BE
 (
new_array_start
 == 
NULL
 || 
new_array_end
 == NULL, 0))

2704 return 
REG_ESPACE
;

2706 
mbcset
->
range_starts
 = 
new_array_start
;

2707 
mbcset
->
range_ends
 = 
new_array_end
;

2708 *
range_alloc
 = 
new_nranges
;

2711 
mbcset
->
range_starts
[mbcset->
nranges
] = 
start_wc
;

2712 
mbcset
->
range_ends
[mbcset->
nranges
++] = 
end_wc
;

2716 for (
wc
 = 0; wc < 
SBC_MAX
; ++wc)

2718 
cmp_buf
[2] = 
wc
;

2719 if (
	`wcscoll
 (
cmp_buf
, cmp_buf + 2) <= 0

2720 && 
	`wcscoll
 (
cmp_buf
 + 2, cmp_buf + 4) <= 0)

2721 
	`bitset_set
 (
sbcset
, 
wc
);

2726 unsigned int 
ch
;

2727 
start_ch
 = ((
start_elem
->
type
 == 
SB_CHAR
 ) ? start_elem->
opr
.
ch


2728 : ((
start_elem
->
type
 == 
COLL_SYM
) ? start_elem->
opr
.
name
[0]

2730 
end_ch
 = ((
end_elem
->
type
 == 
SB_CHAR
 ) ? end_elem->
opr
.
ch


2731 : ((
end_elem
->
type
 == 
COLL_SYM
) ? end_elem->
opr
.
name
[0]

2733 if (
start_ch
 > 
end_ch
)

2734 return 
REG_ERANGE
;

2736 for (
ch
 = 0; ch < 
SBC_MAX
; ++ch)

2737 if (
start_ch
 <= 
ch
 && ch <= 
end_ch
)

2738 
	`bitset_set
 (
sbcset
, 
ch
);

2741 return 
REG_NOERROR
;

2742 
	}
}

2745 #ifndef 
_LIBC


2752 static 
reg_errcode_t


2753 
internal_function


2754 
build_collating_symbol
 (
bitset_t
 
sbcset
,

2755 #ifdef 
RE_ENABLE_I18N


2756 
re_charset_t
 *
mbcset
 
_UNUSED_PARAMETER_
,

2757 
Idx
 *
coll_sym_alloc
 
_UNUSED_PARAMETER_
,

2759 const unsigned char *
name
)

2761 
size_t
 
	gname_len
 = 
strlen
 ((const char *) 
name
);

2762 if (
BE
 (
name_len
 != 1, 0))

2763 return 
	gREG_ECOLLATE
;

2766 
bitset_set
 (
sbcset
, 
name
[0]);

2767 return 
	gREG_NOERROR
;

2775 static 
bin_tree_t
 *

2776 
	$parse_bracket_exp
 (
re_string_t
 *
regexp
, 
re_dfa_t
 *
dfa
, 
re_token_t
 *
token
,

2777 
reg_syntax_t
 
syntax
, 
reg_errcode_t
 *
err
)

2779 #ifdef 
_LIBC


2780 const unsigned char *
collseqmb
;

2781 const char *
collseqwc
;

2782 
uint32_t
 
nrules
;

2783 
int32_t
 
table_size
;

2784 const 
int32_t
 *
symb_table
;

2785 const unsigned char *
extra
;

2791 auto 
inline
 
int32_t


2792 
	`__attribute
 ((
always_inline
))

2793 
	`seek_collating_symbol_entry
 (
name
, 
name_len
)

2794 const unsigned char *
name
;

2795 
size_t
 
name_len
;

2797 
int32_t
 
hash
 = 
	`elem_hash
 ((const char *) 
name
, 
name_len
);

2798 
int32_t
 
elem
 = 
hash
 % 
table_size
;

2799 if (
symb_table
[2 * 
elem
] != 0)

2801 
int32_t
 
second
 = 
hash
 % (
table_size
 - 2) + 1;

2806 if (
symb_table
[2 * 
elem
] == 
hash


2808 && 
name_len
 == 
extra
[
symb_table
[2 * 
elem
 + 1]]

2810 && 
	`memcmp
 (
name
, &
extra
[
symb_table
[2 * 
elem
 + 1] + 1],

2811 
name_len
) == 0)

2818 
elem
 += 
second
;

2820 while (
symb_table
[2 * 
elem
] != 0);

2822 return 
elem
;

2829 auto 
inline
 unsigned int

2830 
	`__attribute
 ((
always_inline
))

2831 
	`lookup_collation_sequence_value
 (
br_elem
)

2832 
bracket_elem_t
 *
br_elem
;

2834 if (
br_elem
->
type
 == 
SB_CHAR
)

2839 if (
nrules
 == 0)

2840 return 
collseqmb
[
br_elem
->
opr
.
ch
];

2843 
wint_t
 
wc
 = 
	`__btowc
 (
br_elem
->
opr
.
ch
);

2844 return 
	`__collseq_table_lookup
 (
collseqwc
, 
wc
);

2847 else if (
br_elem
->
type
 == 
MB_CHAR
)

2849 if (
nrules
 != 0)

2850 return 
	`__collseq_table_lookup
 (
collseqwc
, 
br_elem
->
opr
.
wch
);

2852 else if (
br_elem
->
type
 == 
COLL_SYM
)

2854 
size_t
 
sym_name_len
 = 
	`strlen
 ((char *) 
br_elem
->
opr
.
name
);

2855 if (
nrules
 != 0)

2857 
int32_t
 
elem
, 
idx
;

2858 
elem
 = 
	`seek_collating_symbol_entry
 (
br_elem
->
opr
.
name
,

2859 
sym_name_len
);

2860 if (
symb_table
[2 * 
elem
] != 0)

2863 
idx
 = 
symb_table
[2 * 
elem
 + 1];

2865 
idx
 += 1 + 
extra
[idx];

2867 
idx
 += 1 + 
extra
[idx];

2869 
idx
 = (idx + 3) & ~3;

2871 
idx
 += sizeof (unsigned int);

2873 
idx
 += sizeof (unsigned int) *

2874 (1 + *(unsigned int *) (
extra
 + 
idx
));

2876 return *(unsigned int *) (
extra
 + 
idx
);

2878 else if (
symb_table
[2 * 
elem
] == 0 && 
sym_name_len
 == 1)

2882 return 
collseqmb
[
br_elem
->
opr
.
name
[0]];

2885 else if (
sym_name_len
 == 1)

2886 return 
collseqmb
[
br_elem
->
opr
.
name
[0]];

2888 return 
UINT_MAX
;

2898 auto 
inline
 
reg_errcode_t


2899 
	`__attribute
 ((
always_inline
))

2900 
	`build_range_exp
 (
sbcset
, 
mbcset
, 
range_alloc
, 
start_elem
, 
end_elem
)

2901 
re_charset_t
 *
mbcset
;

2902 
Idx
 *
range_alloc
;

2903 
bitset_t
 
sbcset
;

2904 
bracket_elem_t
 *
start_elem
, *
end_elem
;

2906 unsigned int 
ch
;

2907 
uint32_t
 
start_collseq
;

2908 
uint32_t
 
end_collseq
;

2912 if (
	`BE
 (
start_elem
->
type
 == 
EQUIV_CLASS
 || start_elem->type == 
CHAR_CLASS


2913 || 
end_elem
->
type
 == 
EQUIV_CLASS
 || end_elem->type == 
CHAR_CLASS
,

2915 return 
REG_ERANGE
;

2917 
start_collseq
 = 
	`lookup_collation_sequence_value
 (
start_elem
);

2918 
end_collseq
 = 
	`lookup_collation_sequence_value
 (
end_elem
);

2920 if (
	`BE
 (
start_collseq
 == 
UINT_MAX
 || 
end_collseq
 == UINT_MAX, 0))

2921 return 
REG_ECOLLATE
;

2922 if (
	`BE
 ((
syntax
 & 
RE_NO_EMPTY_RANGES
) && 
start_collseq
 > 
end_collseq
, 0))

2923 return 
REG_ERANGE
;

2929 if (
nrules
 > 0 || 
dfa
->
mb_cur_max
 > 1)

2932 if (
	`BE
 (*
range_alloc
 == 
mbcset
->
nranges
, 0))

2935 
uint32_t
 *
new_array_start
;

2936 
uint32_t
 *
new_array_end
;

2937 
Idx
 
new_nranges
;

2940 
new_nranges
 = 2 * 
mbcset
->
nranges
 + 1;

2941 
new_array_start
 = 
	`re_realloc
 (
mbcset
->
range_starts
, 
uint32_t
,

2942 
new_nranges
);

2943 
new_array_end
 = 
	`re_realloc
 (
mbcset
->
range_ends
, 
uint32_t
,

2944 
new_nranges
);

2946 if (
	`BE
 (
new_array_start
 == 
NULL
 || 
new_array_end
 == NULL, 0))

2947 return 
REG_ESPACE
;

2949 
mbcset
->
range_starts
 = 
new_array_start
;

2950 
mbcset
->
range_ends
 = 
new_array_end
;

2951 *
range_alloc
 = 
new_nranges
;

2954 
mbcset
->
range_starts
[mbcset->
nranges
] = 
start_collseq
;

2955 
mbcset
->
range_ends
[mbcset->
nranges
++] = 
end_collseq
;

2959 for (
ch
 = 0; ch < 
SBC_MAX
; ch++)

2961 
uint32_t
 
ch_collseq
;

2965 if (
nrules
 == 0)

2966 
ch_collseq
 = 
collseqmb
[
ch
];

2968 
ch_collseq
 = 
	`__collseq_table_lookup
 (
collseqwc
, 
	`__btowc
 (
ch
));

2969 if (
start_collseq
 <= 
ch_collseq
 && ch_collseq <= 
end_collseq
)

2970 
	`bitset_set
 (
sbcset
, 
ch
);

2972 return 
REG_NOERROR
;

2981 auto 
inline
 
reg_errcode_t


2982 
	`__attribute
 ((
always_inline
))

2983 
	`build_collating_symbol
 (
sbcset
, 
mbcset
, 
coll_sym_alloc
, 
name
)

2984 
re_charset_t
 *
mbcset
;

2985 
Idx
 *
coll_sym_alloc
;

2986 
bitset_t
 
sbcset
;

2987 const unsigned char *
name
;

2989 
int32_t
 
elem
, 
idx
;

2990 
size_t
 
name_len
 = 
	`strlen
 ((const char *) 
name
);

2991 if (
nrules
 != 0)

2993 
elem
 = 
	`seek_collating_symbol_entry
 (
name
, 
name_len
);

2994 if (
symb_table
[2 * 
elem
] != 0)

2997 
idx
 = 
symb_table
[2 * 
elem
 + 1];

2999 
idx
 += 1 + 
extra
[idx];

3001 else if (
symb_table
[2 * 
elem
] == 0 && 
name_len
 == 1)

3005 
	`bitset_set
 (
sbcset
, 
name
[0]);

3006 return 
REG_NOERROR
;

3009 return 
REG_ECOLLATE
;

3013 if (
	`BE
 (*
coll_sym_alloc
 == 
mbcset
->
ncoll_syms
, 0))

3017 
Idx
 
new_coll_sym_alloc
 = 2 * 
mbcset
->
ncoll_syms
 + 1;

3020 
int32_t
 *
new_coll_syms
 = 
	`re_realloc
 (
mbcset
->
coll_syms
, int32_t,

3021 
new_coll_sym_alloc
);

3022 if (
	`BE
 (
new_coll_syms
 == 
NULL
, 0))

3023 return 
REG_ESPACE
;

3024 
mbcset
->
coll_syms
 = 
new_coll_syms
;

3025 *
coll_sym_alloc
 = 
new_coll_sym_alloc
;

3027 
mbcset
->
coll_syms
[mbcset->
ncoll_syms
++] = 
idx
;

3028 return 
REG_NOERROR
;

3032 if (
	`BE
 (
name_len
 != 1, 0))

3033 return 
REG_ECOLLATE
;

3036 
	`bitset_set
 (
sbcset
, 
name
[0]);

3037 return 
REG_NOERROR
;

3043 
re_token_t
 
br_token
;

3044 
re_bitset_ptr_t
 
sbcset
;

3045 #ifdef 
RE_ENABLE_I18N


3046 
re_charset_t
 *
mbcset
;

3047 
Idx
 
coll_sym_alloc
 = 0, 
range_alloc
 = 0, 
mbchar_alloc
 = 0;

3048 
Idx
 
equiv_class_alloc
 = 0, 
char_class_alloc
 = 0;

3050 
bool
 
non_match
 = 
false
;

3051 
bin_tree_t
 *
work_tree
;

3052 int 
token_len
;

3053 
bool
 
first_round
 = 
true
;

3054 #ifdef 
_LIBC


3055 
collseqmb
 = (const unsigned char *)

3056 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_COLLSEQMB
);

3057 
nrules
 = 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
);

3058 if (
nrules
)

3063 
collseqwc
 = 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_COLLSEQWC
);

3064 
table_size
 = 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_SYMB_HASH_SIZEMB
);

3065 
symb_table
 = (const 
int32_t
 *) 
	`_NL_CURRENT
 (
LC_COLLATE
,

3066 
_NL_COLLATE_SYMB_TABLEMB
);

3067 
extra
 = (const unsigned char *) 
	`_NL_CURRENT
 (
LC_COLLATE
,

3068 
_NL_COLLATE_SYMB_EXTRAMB
);

3071 
sbcset
 = (
re_bitset_ptr_t
) 
	`calloc
 (sizeof (
bitset_t
), 1);

3072 #ifdef 
RE_ENABLE_I18N


3073 
mbcset
 = (
re_charset_t
 *) 
	`calloc
 (sizeof (re_charset_t), 1);

3075 #ifdef 
RE_ENABLE_I18N


3076 if (
	`BE
 (
sbcset
 == 
NULL
 || 
mbcset
 == NULL, 0))

3078 if (
	`BE
 (
sbcset
 == 
NULL
, 0))

3081 *
err
 = 
REG_ESPACE
;

3082 return 
NULL
;

3085 
token_len
 = 
	`peek_token_bracket
 (
token
, 
regexp
, 
syntax
);

3086 if (
	`BE
 (
token
->
type
 == 
END_OF_RE
, 0))

3088 *
err
 = 
REG_BADPAT
;

3089 goto 
parse_bracket_exp_free_return
;

3091 if (
token
->
type
 == 
OP_NON_MATCH_LIST
)

3093 #ifdef 
RE_ENABLE_I18N


3094 
mbcset
->
non_match
 = 1;

3096 
non_match
 = 
true
;

3097 if (
syntax
 & 
RE_HAT_LISTS_NOT_NEWLINE
)

3098 
	`bitset_set
 (
sbcset
, '\n');

3099 
	`re_string_skip_bytes
 (
regexp
, 
token_len
);

3100 
token_len
 = 
	`peek_token_bracket
 (
token
, 
regexp
, 
syntax
);

3101 if (
	`BE
 (
token
->
type
 == 
END_OF_RE
, 0))

3103 *
err
 = 
REG_BADPAT
;

3104 goto 
parse_bracket_exp_free_return
;

3109 if (
token
->
type
 == 
OP_CLOSE_BRACKET
)

3110 
token
->
type
 = 
CHARACTER
;

3114 
bracket_elem_t
 
start_elem
, 
end_elem
;

3115 unsigned char 
start_name_buf
[
BRACKET_NAME_BUF_SIZE
];

3116 unsigned char 
end_name_buf
[
BRACKET_NAME_BUF_SIZE
];

3117 
reg_errcode_t
 
ret
;

3118 int 
token_len2
 = 0;

3119 
bool
 
is_range_exp
 = 
false
;

3120 
re_token_t
 
token2
;

3122 
start_elem
.
opr
.
name
 = 
start_name_buf
;

3123 
ret
 = 
	`parse_bracket_element
 (&
start_elem
, 
regexp
, 
token
, 
token_len
, 
dfa
,

3124 
syntax
, 
first_round
);

3125 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

3127 *
err
 = 
ret
;

3128 goto 
parse_bracket_exp_free_return
;

3130 
first_round
 = 
false
;

3133 
token_len
 = 
	`peek_token_bracket
 (
token
, 
regexp
, 
syntax
);

3136 if (
start_elem
.
type
 != 
CHAR_CLASS
 && start_elem.type != 
EQUIV_CLASS
)

3138 if (
	`BE
 (
token
->
type
 == 
END_OF_RE
, 0))

3140 *
err
 = 
REG_EBRACK
;

3141 goto 
parse_bracket_exp_free_return
;

3143 if (
token
->
type
 == 
OP_CHARSET_RANGE
)

3145 
	`re_string_skip_bytes
 (
regexp
, 
token_len
);

3146 
token_len2
 = 
	`peek_token_bracket
 (&
token2
, 
regexp
, 
syntax
);

3147 if (
	`BE
 (
token2
.
type
 == 
END_OF_RE
, 0))

3149 *
err
 = 
REG_EBRACK
;

3150 goto 
parse_bracket_exp_free_return
;

3152 if (
token2
.
type
 == 
OP_CLOSE_BRACKET
)

3155 
	`re_string_skip_bytes
 (
regexp
, -
token_len
);

3156 
token
->
type
 = 
CHARACTER
;

3159 
is_range_exp
 = 
true
;

3163 if (
is_range_exp
 == 
true
)

3165 
end_elem
.
opr
.
name
 = 
end_name_buf
;

3166 
ret
 = 
	`parse_bracket_element
 (&
end_elem
, 
regexp
, &
token2
, 
token_len2
,

3167 
dfa
, 
syntax
, 
true
);

3168 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

3170 *
err
 = 
ret
;

3171 goto 
parse_bracket_exp_free_return
;

3174 
token_len
 = 
	`peek_token_bracket
 (
token
, 
regexp
, 
syntax
);

3176 #ifdef 
_LIBC


3177 *
err
 = 
	`build_range_exp
 (
sbcset
, 
mbcset
, &
range_alloc
,

3178 &
start_elem
, &
end_elem
);

3180 #ifdef 
RE_ENABLE_I18N


3181 *
err
 = 
	`build_range_exp
 (
syntax
, 
sbcset
,

3182 
dfa
->
mb_cur_max
 > 1 ? 
mbcset
 : 
NULL
,

3183 &
range_alloc
, &
start_elem
, &
end_elem
);

3185 *
err
 = 
	`build_range_exp
 (
syntax
, 
sbcset
, &
start_elem
, &
end_elem
);

3188 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

3189 goto 
parse_bracket_exp_free_return
;

3193 switch (
start_elem
.
type
)

3195 case 
SB_CHAR
:

3196 
	`bitset_set
 (
sbcset
, 
start_elem
.
opr
.
ch
);

3198 #ifdef 
RE_ENABLE_I18N


3199 case 
MB_CHAR
:

3201 if (
	`BE
 (
mbchar_alloc
 == 
mbcset
->
nmbchars
, 0))

3203 
wchar_t
 *
new_mbchars
;

3206 
mbchar_alloc
 = 2 * 
mbcset
->
nmbchars
 + 1;

3208 
new_mbchars
 = 
	`re_realloc
 (
mbcset
->
mbchars
, 
wchar_t
,

3209 
mbchar_alloc
);

3210 if (
	`BE
 (
new_mbchars
 == 
NULL
, 0))

3211 goto 
parse_bracket_exp_espace
;

3212 
mbcset
->
mbchars
 = 
new_mbchars
;

3214 
mbcset
->
mbchars
[mbcset->
nmbchars
++] = 
start_elem
.
opr
.
wch
;

3217 case 
EQUIV_CLASS
:

3218 *
err
 = 
	`build_equiv_class
 (
sbcset
,

3219 #ifdef 
RE_ENABLE_I18N


3220 
mbcset
, &
equiv_class_alloc
,

3222 
start_elem
.
opr
.
name
);

3223 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

3224 goto 
parse_bracket_exp_free_return
;

3226 case 
COLL_SYM
:

3227 *
err
 = 
	`build_collating_symbol
 (
sbcset
,

3228 #ifdef 
RE_ENABLE_I18N


3229 
mbcset
, &
coll_sym_alloc
,

3231 
start_elem
.
opr
.
name
);

3232 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

3233 goto 
parse_bracket_exp_free_return
;

3235 case 
CHAR_CLASS
:

3236 *
err
 = 
	`build_charclass
 (
regexp
->
trans
, 
sbcset
,

3237 #ifdef 
RE_ENABLE_I18N


3238 
mbcset
, &
char_class_alloc
,

3240 
start_elem
.
opr
.
name
, 
syntax
);

3241 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

3242 goto 
parse_bracket_exp_free_return
;

3245 
	`assert
 (0);

3249 if (
	`BE
 (
token
->
type
 == 
END_OF_RE
, 0))

3251 *
err
 = 
REG_EBRACK
;

3252 goto 
parse_bracket_exp_free_return
;

3254 if (
token
->
type
 == 
OP_CLOSE_BRACKET
)

3258 
	`re_string_skip_bytes
 (
regexp
, 
token_len
);

3261 if (
non_match
)

3262 
	`bitset_not
 (
sbcset
);

3264 #ifdef 
RE_ENABLE_I18N


3266 if (
dfa
->
mb_cur_max
 > 1)

3267 
	`bitset_mask
 (
sbcset
, 
dfa
->
sb_char
);

3269 if (
mbcset
->
nmbchars
 || mbcset->
ncoll_syms
 || mbcset->
nequiv_classes


3270 || 
mbcset
->
nranges
 || (
dfa
->
mb_cur_max
 > 1 && (mbcset->
nchar_classes


3271 || 
mbcset
->
non_match
)))

3273 
bin_tree_t
 *
mbc_tree
;

3274 int 
sbc_idx
;

3276 
dfa
->
has_mb_node
 = 1;

3277 
br_token
.
type
 = 
COMPLEX_BRACKET
;

3278 
br_token
.
opr
.
mbcset
 = mbcset;

3279 
mbc_tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, &
br_token
);

3280 if (
	`BE
 (
mbc_tree
 == 
NULL
, 0))

3281 goto 
parse_bracket_exp_espace
;

3282 for (
sbc_idx
 = 0; sbc_idx < 
BITSET_WORDS
; ++sbc_idx)

3283 if (
sbcset
[
sbc_idx
])

3287 if (
sbc_idx
 < 
BITSET_WORDS
)

3290 
br_token
.
type
 = 
SIMPLE_BRACKET
;

3291 
br_token
.
opr
.
sbcset
 = sbcset;

3292 
work_tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, &
br_token
);

3293 if (
	`BE
 (
work_tree
 == 
NULL
, 0))

3294 goto 
parse_bracket_exp_espace
;

3297 
work_tree
 = 
	`create_tree
 (
dfa
, work_tree, 
mbc_tree
, 
OP_ALT
);

3298 if (
	`BE
 (
work_tree
 == 
NULL
, 0))

3299 goto 
parse_bracket_exp_espace
;

3303 
	`re_free
 (
sbcset
);

3304 
work_tree
 = 
mbc_tree
;

3310 #ifdef 
RE_ENABLE_I18N


3311 
	`free_charset
 (
mbcset
);

3314 
br_token
.
type
 = 
SIMPLE_BRACKET
;

3315 
br_token
.
opr
.
sbcset
 = sbcset;

3316 
work_tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, &
br_token
);

3317 if (
	`BE
 (
work_tree
 == 
NULL
, 0))

3318 goto 
parse_bracket_exp_espace
;

3320 return 
work_tree
;

3322 
parse_bracket_exp_espace
:

3323 *
err
 = 
REG_ESPACE
;

3324 
parse_bracket_exp_free_return
:

3325 
	`re_free
 (
sbcset
);

3326 #ifdef 
RE_ENABLE_I18N


3327 
	`free_charset
 (
mbcset
);

3329 return 
NULL
;

3330 
	}
}

3334 static 
reg_errcode_t


3335 
	$parse_bracket_element
 (
bracket_elem_t
 *
elem
, 
re_string_t
 *
regexp
,

3336 
re_token_t
 *
token
, int 
token_len
,

3337 
re_dfa_t
 *
dfa
 
_UNUSED_PARAMETER_
,

3338 
reg_syntax_t
 
syntax
, 
bool
 
accept_hyphen
)

3340 #ifdef 
RE_ENABLE_I18N


3341 int 
cur_char_size
;

3342 
cur_char_size
 = 
	`re_string_char_size_at
 (
regexp
, 
	`re_string_cur_idx
 (regexp));

3343 if (
cur_char_size
 > 1)

3345 
elem
->
type
 = 
MB_CHAR
;

3346 
elem
->
opr
.
wch
 = 
	`re_string_wchar_at
 (
regexp
, 
	`re_string_cur_idx
 (regexp));

3347 
	`re_string_skip_bytes
 (
regexp
, 
cur_char_size
);

3348 return 
REG_NOERROR
;

3351 
	`re_string_skip_bytes
 (
regexp
, 
token_len
);

3352 if (
token
->
type
 == 
OP_OPEN_COLL_ELEM
 || token->type == 
OP_OPEN_CHAR_CLASS


3353 || 
token
->
type
 == 
OP_OPEN_EQUIV_CLASS
)

3354 return 
	`parse_bracket_symbol
 (
elem
, 
regexp
, 
token
);

3355 if (
	`BE
 (
token
->
type
 == 
OP_CHARSET_RANGE
, 0) && !
accept_hyphen
)

3359 
re_token_t
 
token2
;

3360 (void) 
	`peek_token_bracket
 (&
token2
, 
regexp
, 
syntax
);

3361 if (
token2
.
type
 != 
OP_CLOSE_BRACKET
)

3364 return 
REG_ERANGE
;

3366 
elem
->
type
 = 
SB_CHAR
;

3367 
elem
->
opr
.
ch
 = 
token
->opr.
c
;

3368 return 
REG_NOERROR
;

3369 
	}
}

3375 static 
reg_errcode_t


3376 
	$parse_bracket_symbol
 (
bracket_elem_t
 *
elem
, 
re_string_t
 *
regexp
,

3377 
re_token_t
 *
token
)

3379 unsigned char 
ch
, 
delim
 = 
token
->
opr
.
c
;

3380 int 
i
 = 0;

3381 if (
	`re_string_eoi
(
regexp
))

3382 return 
REG_EBRACK
;

3383 for (;; ++
i
)

3385 if (
i
 >= 
BRACKET_NAME_BUF_SIZE
)

3386 return 
REG_EBRACK
;

3387 if (
token
->
type
 == 
OP_OPEN_CHAR_CLASS
)

3388 
ch
 = 
	`re_string_fetch_byte_case
 (
regexp
);

3390 
ch
 = 
	`re_string_fetch_byte
 (
regexp
);

3391 if (
	`re_string_eoi
(
regexp
))

3392 return 
REG_EBRACK
;

3393 if (
ch
 == 
delim
 && 
	`re_string_peek_byte
 (
regexp
, 0) == ']')

3395 
elem
->
opr
.
name
[
i
] = 
ch
;

3397 
	`re_string_skip_bytes
 (
regexp
, 1);

3398 
elem
->
opr
.
name
[
i
] = '\0';

3399 switch (
token
->
type
)

3401 case 
OP_OPEN_COLL_ELEM
:

3402 
elem
->
type
 = 
COLL_SYM
;

3404 case 
OP_OPEN_EQUIV_CLASS
:

3405 
elem
->
type
 = 
EQUIV_CLASS
;

3407 case 
OP_OPEN_CHAR_CLASS
:

3408 
elem
->
type
 = 
CHAR_CLASS
;

3413 return 
REG_NOERROR
;

3414 
	}
}

3422 static 
	greg_errcode_t


3423 #ifdef 
RE_ENABLE_I18N


3424 
	$build_equiv_class
 (
bitset_t
 
sbcset
, 
re_charset_t
 *
mbcset
 
_UNUSED_PARAMETER_
,

3425 
Idx
 *
equiv_class_alloc
 
_UNUSED_PARAMETER_
,

3426 const unsigned char *
name
)

3428 
	$build_equiv_class
 (
bitset_t
 
sbcset
, const unsigned char *
name
)

3431 #ifdef 
_LIBC


3432 
uint32_t
 
nrules
 = 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
);

3433 if (
nrules
 != 0)

3435 const 
int32_t
 *
table
, *
indirect
;

3436 const unsigned char *
weights
, *
extra
, *
cp
;

3437 unsigned char 
char_buf
[2];

3438 
int32_t
 
idx1
, 
idx2
;

3439 unsigned int 
ch
;

3440 
size_t
 
len
;

3442 #include 
	~<locale/weight.h
>

3444 
cp
 = 
name
;

3445 
table
 = (const 
int32_t
 *) 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_TABLEMB
);

3446 
weights
 = (const unsigned char *) 
	`_NL_CURRENT
 (
LC_COLLATE
,

3447 
_NL_COLLATE_WEIGHTMB
);

3448 
extra
 = (const unsigned char *) 
	`_NL_CURRENT
 (
LC_COLLATE
,

3449 
_NL_COLLATE_EXTRAMB
);

3450 
indirect
 = (const 
int32_t
 *) 
	`_NL_CURRENT
 (
LC_COLLATE
,

3451 
_NL_COLLATE_INDIRECTMB
);

3452 
idx1
 = 
	`findidx
 (&
cp
);

3453 if (
	`BE
 (
idx1
 == 0 || 
cp
 < 
name
 + 
	`strlen
 ((const char *) name), 0))

3455 return 
REG_ECOLLATE
;

3458 
char_buf
[1] = (unsigned char) '\0';

3459 
len
 = 
weights
[
idx1
 & 0xffffff];

3460 for (
ch
 = 0; ch < 
SBC_MAX
; ++ch)

3462 
char_buf
[0] = 
ch
;

3463 
cp
 = 
char_buf
;

3464 
idx2
 = 
	`findidx
 (&
cp
);

3468 if (
idx2
 == 0)

3473 if (
len
 == 
weights
[
idx2
 & 0xffffff] && (
idx1
 >> 24) == (idx2 >> 24))

3475 int 
cnt
 = 0;

3477 while (
cnt
 <= 
len
 &&

3478 
weights
[(
idx1
 & 0xffffff) + 1 + 
cnt
]

3479 == 
weights
[(
idx2
 & 0xffffff) + 1 + 
cnt
])

3480 ++
cnt
;

3482 if (
cnt
 > 
len
)

3483 
	`bitset_set
 (
sbcset
, 
ch
);

3487 if (
	`BE
 (*
equiv_class_alloc
 == 
mbcset
->
nequiv_classes
, 0))

3491 
Idx
 
new_equiv_class_alloc
 = 2 * 
mbcset
->
nequiv_classes
 + 1;

3493 
int32_t
 *
new_equiv_classes
 = 
	`re_realloc
 (
mbcset
->
equiv_classes
,

3494 
int32_t
,

3495 
new_equiv_class_alloc
);

3496 if (
	`BE
 (
new_equiv_classes
 == 
NULL
, 0))

3497 return 
REG_ESPACE
;

3498 
mbcset
->
equiv_classes
 = 
new_equiv_classes
;

3499 *
equiv_class_alloc
 = 
new_equiv_class_alloc
;

3501 
mbcset
->
equiv_classes
[mbcset->
nequiv_classes
++] = 
idx1
;

3506 if (
	`BE
 (
	`strlen
 ((const char *) 
name
) != 1, 0))

3507 return 
REG_ECOLLATE
;

3508 
	`bitset_set
 (
sbcset
, *
name
);

3510 return 
REG_NOERROR
;

3511 
	}
}

3519 static 
	greg_errcode_t


3520 #ifdef 
RE_ENABLE_I18N


3521 
	$build_charclass
 (
RE_TRANSLATE_TYPE
 
trans
, 
bitset_t
 
sbcset
,

3522 
re_charset_t
 *
mbcset
, 
Idx
 *
char_class_alloc
,

3523 const unsigned char *
class_name
, 
reg_syntax_t
 
syntax
)

3525 
	$build_charclass
 (
RE_TRANSLATE_TYPE
 
trans
, 
bitset_t
 
sbcset
,

3526 const unsigned char *
class_name
, 
reg_syntax_t
 
syntax
)

3529 int 
i
;

3530 const char *
name
 = (const char *) 
class_name
;

3534 if ((
syntax
 & 
RE_ICASE
)

3535 && (
	`strcmp
 (
name
, "upper") == 0 || strcmp (name, "lower") == 0))

3536 
name
 = "alpha";

3538 #ifdef 
RE_ENABLE_I18N


3540 if (
	`BE
 (*
char_class_alloc
 == 
mbcset
->
nchar_classes
, 0))

3544 
Idx
 
new_char_class_alloc
 = 2 * 
mbcset
->
nchar_classes
 + 1;

3546 
wctype_t
 *
new_char_classes
 = 
	`re_realloc
 (
mbcset
->
char_classes
, wctype_t,

3547 
new_char_class_alloc
);

3548 if (
	`BE
 (
new_char_classes
 == 
NULL
, 0))

3549 return 
REG_ESPACE
;

3550 
mbcset
->
char_classes
 = 
new_char_classes
;

3551 *
char_class_alloc
 = 
new_char_class_alloc
;

3553 
mbcset
->
char_classes
[mbcset->
nchar_classes
++] = 
	`__wctype
 (
name
);

3556 #define 
	#BUILD_CHARCLASS_LOOP
(
ctype_func
) \

3558 if (
	`BE
 (
trans
 != 
NULL
, 0)) \

3560 for (
i
 = 0; i < 
SBC_MAX
; ++i) \

3561 if (
	`ctype_func
 (
i
)) \

3562 
	`bitset_set
 (
sbcset
, 
trans
[
i
]); \

3566 for (
i
 = 0; i < 
SBC_MAX
; ++i) \

3567 if (
	`ctype_func
 (
i
)) \

3568 
	`bitset_set
 (
sbcset
, 
i
); \

3570 } while (0)

	)

3572 if (
	`strcmp
 (
name
, "alnum") == 0)

3573 
	`BUILD_CHARCLASS_LOOP
 (
isalnum
);

3574 else if (
	`strcmp
 (
name
, "cntrl") == 0)

3575 
	`BUILD_CHARCLASS_LOOP
 (
iscntrl
);

3576 else if (
	`strcmp
 (
name
, "lower") == 0)

3577 
	`BUILD_CHARCLASS_LOOP
 (
islower
);

3578 else if (
	`strcmp
 (
name
, "space") == 0)

3579 
	`BUILD_CHARCLASS_LOOP
 (
isspace
);

3580 else if (
	`strcmp
 (
name
, "alpha") == 0)

3581 
	`BUILD_CHARCLASS_LOOP
 (
isalpha
);

3582 else if (
	`strcmp
 (
name
, "digit") == 0)

3583 
	`BUILD_CHARCLASS_LOOP
 (
isdigit
);

3584 else if (
	`strcmp
 (
name
, "print") == 0)

3585 
	`BUILD_CHARCLASS_LOOP
 (
isprint
);

3586 else if (
	`strcmp
 (
name
, "upper") == 0)

3587 
	`BUILD_CHARCLASS_LOOP
 (
isupper
);

3588 else if (
	`strcmp
 (
name
, "blank") == 0)

3589 
	`BUILD_CHARCLASS_LOOP
 (
isblank
);

3590 else if (
	`strcmp
 (
name
, "graph") == 0)

3591 
	`BUILD_CHARCLASS_LOOP
 (
isgraph
);

3592 else if (
	`strcmp
 (
name
, "punct") == 0)

3593 
	`BUILD_CHARCLASS_LOOP
 (
ispunct
);

3594 else if (
	`strcmp
 (
name
, "xdigit") == 0)

3595 
	`BUILD_CHARCLASS_LOOP
 (
isxdigit
);

3597 return 
REG_ECTYPE
;

3599 return 
REG_NOERROR
;

3600 
	}
}

3602 static 
bin_tree_t
 *

3603 
	$build_charclass_op
 (
re_dfa_t
 *
dfa
, 
RE_TRANSLATE_TYPE
 
trans
,

3604 const unsigned char *
class_name
,

3605 const unsigned char *
extra
, 
bool
 
non_match
,

3606 
reg_errcode_t
 *
err
)

3608 
re_bitset_ptr_t
 
sbcset
;

3609 #ifdef 
RE_ENABLE_I18N


3610 
re_charset_t
 *
mbcset
;

3611 
Idx
 
alloc
 = 0;

3613 
reg_errcode_t
 
ret
;

3614 
re_token_t
 
br_token
;

3615 
bin_tree_t
 *
tree
;

3617 
sbcset
 = (
re_bitset_ptr_t
) 
	`calloc
 (sizeof (
bitset_t
), 1);

3618 #ifdef 
RE_ENABLE_I18N


3619 
mbcset
 = (
re_charset_t
 *) 
	`calloc
 (sizeof (re_charset_t), 1);

3622 #ifdef 
RE_ENABLE_I18N


3623 if (
	`BE
 (
sbcset
 == 
NULL
 || 
mbcset
 == NULL, 0))

3625 if (
	`BE
 (
sbcset
 == 
NULL
, 0))

3628 *
err
 = 
REG_ESPACE
;

3629 return 
NULL
;

3632 if (
non_match
)

3634 #ifdef 
RE_ENABLE_I18N


3635 
mbcset
->
non_match
 = 1;

3640 
ret
 = 
	`build_charclass
 (
trans
, 
sbcset
,

3641 #ifdef 
RE_ENABLE_I18N


3642 
mbcset
, &
alloc
,

3644 
class_name
, 0);

3646 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

3648 
	`re_free
 (
sbcset
);

3649 #ifdef 
RE_ENABLE_I18N


3650 
	`free_charset
 (
mbcset
);

3652 *
err
 = 
ret
;

3653 return 
NULL
;

3656 for (; *
extra
; extra++)

3657 
	`bitset_set
 (
sbcset
, *
extra
);

3660 if (
non_match
)

3661 
	`bitset_not
 (
sbcset
);

3663 #ifdef 
RE_ENABLE_I18N


3665 if (
dfa
->
mb_cur_max
 > 1)

3666 
	`bitset_mask
 (
sbcset
, 
dfa
->
sb_char
);

3670 
br_token
.
type
 = 
SIMPLE_BRACKET
;

3671 
br_token
.
opr
.
sbcset
 = sbcset;

3672 
tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, &
br_token
);

3673 if (
	`BE
 (
tree
 == 
NULL
, 0))

3674 goto 
build_word_op_espace
;

3676 #ifdef 
RE_ENABLE_I18N


3677 if (
dfa
->
mb_cur_max
 > 1)

3679 
bin_tree_t
 *
mbc_tree
;

3681 
br_token
.
type
 = 
COMPLEX_BRACKET
;

3682 
br_token
.
opr
.
mbcset
 = mbcset;

3683 
dfa
->
has_mb_node
 = 1;

3684 
mbc_tree
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, &
br_token
);

3685 if (
	`BE
 (
mbc_tree
 == 
NULL
, 0))

3686 goto 
build_word_op_espace
;

3688 
tree
 = 
	`create_tree
 (
dfa
, tree, 
mbc_tree
, 
OP_ALT
);

3689 if (
	`BE
 (
mbc_tree
 != 
NULL
, 1))

3690 return 
tree
;

3694 
	`free_charset
 (
mbcset
);

3695 return 
tree
;

3698 return 
tree
;

3701 
build_word_op_espace
:

3702 
	`re_free
 (
sbcset
);

3703 #ifdef 
RE_ENABLE_I18N


3704 
	`free_charset
 (
mbcset
);

3706 *
err
 = 
REG_ESPACE
;

3707 return 
NULL
;

3708 
	}
}

3715 static 
Idx


3716 
	$fetch_number
 (
re_string_t
 *
input
, 
re_token_t
 *
token
, 
reg_syntax_t
 
syntax
)

3718 
Idx
 
num
 = 
REG_MISSING
;

3719 unsigned char 
c
;

3722 
	`fetch_token
 (
token
, 
input
, 
syntax
);

3723 
c
 = 
token
->
opr
.c;

3724 if (
	`BE
 (
token
->
type
 == 
END_OF_RE
, 0))

3725 return 
REG_ERROR
;

3726 if (
token
->
type
 == 
OP_CLOSE_DUP_NUM
 || 
c
 == ',')

3728 
num
 = ((
token
->
type
 != 
CHARACTER
 || 
c
 < '0' || '9' < c

3729 || 
num
 == 
REG_ERROR
)

3730 ? 
REG_ERROR


3731 : ((
num
 == 
REG_MISSING
) ? 
c
 - '0' : num * 10 + c - '0'));

3732 
num
 = (num > 
RE_DUP_MAX
) ? 
REG_ERROR
 : num;

3734 return 
num
;

3735 
	}
}

3737 #ifdef 
RE_ENABLE_I18N


3739 
	$free_charset
 (
re_charset_t
 *
cset
)

3741 
	`re_free
 (
cset
->
mbchars
);

3742 #ifdef 
_LIBC


3743 
	`re_free
 (
cset
->
coll_syms
);

3744 
	`re_free
 (
cset
->
equiv_classes
);

3745 
	`re_free
 (
cset
->
range_starts
);

3746 
	`re_free
 (
cset
->
range_ends
);

3748 
	`re_free
 (
cset
->
char_classes
);

3749 
	`re_free
 (
cset
);

3750 
	}
}

3757 static 
bin_tree_t
 *

3758 
	$create_tree
 (
re_dfa_t
 *
dfa
, 
bin_tree_t
 *
left
, bin_tree_t *
right
,

3759 
re_token_type_t
 
type
)

3761 
re_token_t
 
t
;

3762 
t
.
type
 = type;

3763 return 
	`create_token_tree
 (
dfa
, 
left
, 
right
, &
t
);

3764 
	}
}

3766 static 
bin_tree_t
 *

3767 
	$create_token_tree
 (
re_dfa_t
 *
dfa
, 
bin_tree_t
 *
left
, bin_tree_t *
right
,

3768 const 
re_token_t
 *
token
)

3770 
bin_tree_t
 *
tree
;

3771 if (
	`BE
 (
dfa
->
str_tree_storage_idx
 == 
BIN_TREE_STORAGE_SIZE
, 0))

3773 
bin_tree_storage_t
 *
storage
 = 
	`re_malloc
 (bin_tree_storage_t, 1);

3775 if (
storage
 == 
NULL
)

3776 return 
NULL
;

3777 
storage
->
next
 = 
dfa
->
str_tree_storage
;

3778 
dfa
->
str_tree_storage
 = 
storage
;

3779 
dfa
->
str_tree_storage_idx
 = 0;

3781 
tree
 = &
dfa
->
str_tree_storage
->
data
[dfa->
str_tree_storage_idx
++];

3783 
tree
->
parent
 = 
NULL
;

3784 
tree
->
left
 = left;

3785 
tree
->
right
 = right;

3786 
tree
->
token
 = *token;

3787 
tree
->
token
.
duplicated
 = 0;

3788 
tree
->
token
.
opt_subexp
 = 0;

3789 
tree
->
first
 = 
NULL
;

3790 
tree
->
next
 = 
NULL
;

3791 
tree
->
node_idx
 = 
REG_MISSING
;

3793 if (
left
 != 
NULL
)

3794 
left
->
parent
 = 
tree
;

3795 if (
right
 != 
NULL
)

3796 
right
->
parent
 = 
tree
;

3797 return 
tree
;

3798 
	}
}

3803 static 
reg_errcode_t


3804 
	$mark_opt_subexp
 (void *
extra
, 
bin_tree_t
 *
node
)

3806 
Idx
 
idx
 = (Idx) (long) 
extra
;

3807 if (
node
->
token
.
type
 == 
SUBEXP
 && node->token.
opr
.
idx
 == idx)

3808 
node
->
token
.
opt_subexp
 = 1;

3810 return 
REG_NOERROR
;

3811 
	}
}

3816 
	$free_token
 (
re_token_t
 *
node
)

3818 #ifdef 
RE_ENABLE_I18N


3819 if (
node
->
type
 == 
COMPLEX_BRACKET
 && node->
duplicated
 == 0)

3820 
	`free_charset
 (
node
->
opr
.
mbcset
);

3823 if (
node
->
type
 == 
SIMPLE_BRACKET
 && node->
duplicated
 == 0)

3824 
	`re_free
 (
node
->
opr
.
sbcset
);

3825 
	}
}

3830 static 
reg_errcode_t


3831 
	$free_tree
 (void *
extra
 
_UNUSED_PARAMETER_
, 
bin_tree_t
 *
node
)

3833 
	`free_token
 (&
node
->
token
);

3834 return 
REG_NOERROR
;

3835 
	}
}

3843 static 
bin_tree_t
 *

3844 
	$duplicate_tree
 (const 
bin_tree_t
 *
root
, 
re_dfa_t
 *
dfa
)

3846 const 
bin_tree_t
 *
node
;

3847 
bin_tree_t
 *
dup_root
;

3848 
bin_tree_t
 **
p_new
 = &
dup_root
, *
dup_node
 = 
root
->
parent
;

3850 for (
node
 = 
root
; ; )

3853 *
p_new
 = 
	`create_token_tree
 (
dfa
, 
NULL
, NULL, &
node
->
token
);

3854 if (*
p_new
 == 
NULL
)

3855 return 
NULL
;

3856 (*
p_new
)->
parent
 = 
dup_node
;

3857 (*
p_new
)->
token
.
duplicated
 = 1;

3858 
dup_node
 = *
p_new
;

3861 if (
node
->
left
)

3863 
node
 = node->
left
;

3864 
p_new
 = &
dup_node
->
left
;

3868 const 
bin_tree_t
 *
prev
 = 
NULL
;

3869 while (
node
->
right
 == 
prev
 || node->right == 
NULL
)

3871 
prev
 = 
node
;

3872 
node
 = node->
parent
;

3873 
dup_node
 = dup_node->
parent
;

3874 if (!
node
)

3875 return 
dup_root
;

3877 
node
 = node->
right
;

3878 
p_new
 = &
dup_node
->
right
;

3881 
	}
}

	@lib/regex.c

22 #include 
	~<config.h
>

25 #if 
defined
 
__cplusplus
 && defined 
_LIBC


29 #ifdef 
_LIBC


31 #define 
	#regfree
(
preg
) 
	`__regfree
 (preg)

	)

32 #define 
	#regexec
(
pr
, 
st
, 
nm
, 
pm
, 
ef
) 
	`__regexec
 (pr, st, nm, pm, ef)

	)

33 #define 
	#regcomp
(
preg
, 
pattern
, 
cflags
) 
	`__regcomp
 (preg, pattern, cflags)

	)

34 #define 
	#regerror
(
errcode
, 
preg
, 
errbuf
, 
errbuf_size
) \

35 
	`__regerror
(
errcode
, 
preg
, 
errbuf
, 
errbuf_size
)

	)

36 #define 
	#re_set_registers
(
bu
, 
re
, 
nu
, 
st
, 
en
) \

37 
	`__re_set_registers
 (
bu
, 
re
, 
nu
, 
st
, 
en
)

	)

38 #define 
	#re_match_2
(
bufp
, 
string1
, 
size1
, 
string2
, 
size2
, 
pos
, 
regs
, 
stop
) \

39 
	`__re_match_2
 (
bufp
, 
string1
, 
size1
, 
string2
, 
size2
, 
pos
, 
regs
, 
stop
)

	)

40 #define 
	#re_match
(
bufp
, 
string
, 
size
, 
pos
, 
regs
) \

41 
	`__re_match
 (
bufp
, 
string
, 
size
, 
pos
, 
regs
)

	)

42 #define 
	#re_search
(
bufp
, 
string
, 
size
, 
startpos
, 
range
, 
regs
) \

43 
	`__re_search
 (
bufp
, 
string
, 
size
, 
startpos
, 
range
, 
regs
)

	)

44 #define 
	#re_compile_pattern
(
pattern
, 
length
, 
bufp
) \

45 
	`__re_compile_pattern
 (
pattern
, 
length
, 
bufp
)

	)

46 #define 
	#re_set_syntax
(
syntax
) 
	`__re_set_syntax
 (syntax)

	)

47 #define 
	#re_search_2
(
bufp
, 
st1
, 
s1
, 
st2
, 
s2
, 
startpos
, 
range
, 
regs
, 
stop
) \

48 
	`__re_search_2
 (
bufp
, 
st1
, 
s1
, 
st2
, 
s2
, 
startpos
, 
range
, 
regs
, 
stop
)

	)

49 #define 
	#re_compile_fastmap
(
bufp
) 
	`__re_compile_fastmap
 (bufp)

	)

51 #include 
	~"../locale/localeinfo.h
"

57 #include 
	~<limits.h
>

58 #include 
	~<strings.h
>

60 #include 
	~<regex.h
>

61 #include 
	~"regex_internal.h
"

63 #include 
	~"regex_internal.c
"

64 #include 
	~"regcomp.c
"

65 #include 
	~"regexec.c
"

68 #if 
_LIBC


69 #include 
	~<shlib-compat.h
>

70 #if 
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_3
)

71 
link_warning
 (
re_max_failures
, "the 're_max_failures' variable is obsolete and will go away.")

72 int 
	gre_max_failures
 = 2000;

	@lib/regex.h

23 #ifndef 
_REGEX_H


24 #define 
	#_REGEX_H
 1

	)

26 #include 
	~<sys/types.h
>

29 #ifdef 
__cplusplus


35 #undef 
__USE_GNU_REGEX


36 #if (
defined
 
_GNU_SOURCE
 \

37 || (!
defined
 
_POSIX_C_SOURCE
 && !defined 
_POSIX_SOURCE
 \

38 && !
defined
 
_XOPEN_SOURCE
))

39 #define 
	#__USE_GNU_REGEX
 1

	)

42 #ifdef 
_REGEX_LARGE_OFFSETS


58 typedef 
ssize_t
 
	tregoff_t
;

63 typedef 
size_t
 
	t__re_idx_t
;

66 typedef 
size_t
 
	t__re_size_t
;

70 typedef 
size_t
 
	t__re_long_size_t
;

77 typedef int 
	tregoff_t
;

78 typedef int 
	t__re_idx_t
;

79 typedef unsigned int 
	t__re_size_t
;

80 typedef unsigned long int 
	t__re_long_size_t
;

88 typedef long int 
	ts_reg_t
;

89 typedef unsigned long int 
	tactive_reg_t
;

96 typedef unsigned long int 
	treg_syntax_t
;

98 #ifdef 
__USE_GNU_REGEX


102 #define 
	#RE_BACKSLASH_ESCAPE_IN_LISTS
 ((unsigned long int) 1)

	)

107 #define 
	#RE_BK_PLUS_QM
 (
RE_BACKSLASH_ESCAPE_IN_LISTS
 << 1)

	)

113 #define 
	#RE_CHAR_CLASSES
 (
RE_BK_PLUS_QM
 << 1)

	)

127 #define 
	#RE_CONTEXT_INDEP_ANCHORS
 (
RE_CHAR_CLASSES
 << 1)

	)

135 #define 
	#RE_CONTEXT_INDEP_OPS
 (
RE_CONTEXT_INDEP_ANCHORS
 << 1)

	)

139 #define 
	#RE_CONTEXT_INVALID_OPS
 (
RE_CONTEXT_INDEP_OPS
 << 1)

	)

143 #define 
	#RE_DOT_NEWLINE
 (
RE_CONTEXT_INVALID_OPS
 << 1)

	)

147 #define 
	#RE_DOT_NOT_NULL
 (
RE_DOT_NEWLINE
 << 1)

	)

151 #define 
	#RE_HAT_LISTS_NOT_NEWLINE
 (
RE_DOT_NOT_NULL
 << 1)

	)

156 #define 
	#RE_INTERVALS
 (
RE_HAT_LISTS_NOT_NEWLINE
 << 1)

	)

160 #define 
	#RE_LIMITED_OPS
 (
RE_INTERVALS
 << 1)

	)

164 #define 
	#RE_NEWLINE_ALT
 (
RE_LIMITED_OPS
 << 1)

	)

169 #define 
	#RE_NO_BK_BRACES
 (
RE_NEWLINE_ALT
 << 1)

	)

173 #define 
	#RE_NO_BK_PARENS
 (
RE_NO_BK_BRACES
 << 1)

	)

177 #define 
	#RE_NO_BK_REFS
 (
RE_NO_BK_PARENS
 << 1)

	)

181 #define 
	#RE_NO_BK_VBAR
 (
RE_NO_BK_REFS
 << 1)

	)

187 #define 
	#RE_NO_EMPTY_RANGES
 (
RE_NO_BK_VBAR
 << 1)

	)

191 #define 
	#RE_UNMATCHED_RIGHT_PAREN_ORD
 (
RE_NO_EMPTY_RANGES
 << 1)

	)

195 #define 
	#RE_NO_POSIX_BACKTRACKING
 (
RE_UNMATCHED_RIGHT_PAREN_ORD
 << 1)

	)

199 #define 
	#RE_NO_GNU_OPS
 (
RE_NO_POSIX_BACKTRACKING
 << 1)

	)

207 #define 
	#RE_DEBUG
 (
RE_NO_GNU_OPS
 << 1)

	)

212 #define 
	#RE_INVALID_INTERVAL_ORD
 (
RE_DEBUG
 << 1)

	)

216 #define 
	#RE_ICASE
 (
RE_INVALID_INTERVAL_ORD
 << 1)

	)

221 #define 
	#RE_CARET_ANCHORS_HERE
 (
RE_ICASE
 << 1)

	)

225 #define 
	#RE_CONTEXT_INVALID_DUP
 (
RE_CARET_ANCHORS_HERE
 << 1)

	)

229 #define 
	#RE_NO_SUB
 (
RE_CONTEXT_INVALID_DUP
 << 1)

	)

237 extern 
reg_syntax_t
 
re_syntax_options
;

239 #ifdef 
__USE_GNU_REGEX


244 #define 
	#RE_SYNTAX_EMACS
 0

	)

246 #define 
	#RE_SYNTAX_AWK
 \

247 (
RE_BACKSLASH_ESCAPE_IN_LISTS
 | 
RE_DOT_NOT_NULL
 \

248 | 
RE_NO_BK_PARENS
 | 
RE_NO_BK_REFS
 \

249 | 
RE_NO_BK_VBAR
 | 
RE_NO_EMPTY_RANGES
 \

250 | 
RE_DOT_NEWLINE
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

251 | 
RE_UNMATCHED_RIGHT_PAREN_ORD
 | 
RE_NO_GNU_OPS
)

	)

253 #define 
	#RE_SYNTAX_GNU_AWK
 \

254 ((
RE_SYNTAX_POSIX_EXTENDED
 | 
RE_BACKSLASH_ESCAPE_IN_LISTS
 | 
RE_DEBUG
) \

255 & ~(
RE_DOT_NOT_NULL
 | 
RE_INTERVALS
 | 
RE_CONTEXT_INDEP_OPS
 \

256 | 
RE_CONTEXT_INVALID_OPS
 ))

	)

258 #define 
	#RE_SYNTAX_POSIX_AWK
 \

259 (
RE_SYNTAX_POSIX_EXTENDED
 | 
RE_BACKSLASH_ESCAPE_IN_LISTS
 \

260 | 
RE_INTERVALS
 | 
RE_NO_GNU_OPS
)

	)

262 #define 
	#RE_SYNTAX_GREP
 \

263 (
RE_BK_PLUS_QM
 | 
RE_CHAR_CLASSES
 \

264 | 
RE_HAT_LISTS_NOT_NEWLINE
 | 
RE_INTERVALS
 \

265 | 
RE_NEWLINE_ALT
)

	)

267 #define 
	#RE_SYNTAX_EGREP
 \

268 (
RE_CHAR_CLASSES
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

269 | 
RE_CONTEXT_INDEP_OPS
 | 
RE_HAT_LISTS_NOT_NEWLINE
 \

270 | 
RE_NEWLINE_ALT
 | 
RE_NO_BK_PARENS
 \

271 | 
RE_NO_BK_VBAR
)

	)

273 #define 
	#RE_SYNTAX_POSIX_EGREP
 \

274 (
RE_SYNTAX_EGREP
 | 
RE_INTERVALS
 | 
RE_NO_BK_BRACES
 \

275 | 
RE_INVALID_INTERVAL_ORD
)

	)

278 #define 
	#RE_SYNTAX_ED
 
RE_SYNTAX_POSIX_BASIC


	)

280 #define 
	#RE_SYNTAX_SED
 
RE_SYNTAX_POSIX_BASIC


	)

283 #define 
	#_RE_SYNTAX_POSIX_COMMON
 \

284 (
RE_CHAR_CLASSES
 | 
RE_DOT_NEWLINE
 | 
RE_DOT_NOT_NULL
 \

285 | 
RE_INTERVALS
 | 
RE_NO_EMPTY_RANGES
)

	)

287 #define 
	#RE_SYNTAX_POSIX_BASIC
 \

288 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_BK_PLUS_QM
 | 
RE_CONTEXT_INVALID_DUP
)

	)

293 #define 
	#RE_SYNTAX_POSIX_MINIMAL_BASIC
 \

294 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_LIMITED_OPS
)

	)

296 #define 
	#RE_SYNTAX_POSIX_EXTENDED
 \

297 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

298 | 
RE_CONTEXT_INDEP_OPS
 | 
RE_NO_BK_BRACES
 \

299 | 
RE_NO_BK_PARENS
 | 
RE_NO_BK_VBAR
 \

300 | 
RE_CONTEXT_INVALID_OPS
 | 
RE_UNMATCHED_RIGHT_PAREN_ORD
)

	)

304 #define 
	#RE_SYNTAX_POSIX_MINIMAL_EXTENDED
 \

305 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

306 | 
RE_CONTEXT_INVALID_OPS
 | 
RE_NO_BK_BRACES
 \

307 | 
RE_NO_BK_PARENS
 | 
RE_NO_BK_REFS
 \

308 | 
RE_NO_BK_VBAR
 | 
RE_UNMATCHED_RIGHT_PAREN_ORD
)

	)

313 #ifdef 
__USE_GNU_REGEX


318 #ifdef 
RE_DUP_MAX


319 #undef 
RE_DUP_MAX


329 #define 
	#RE_DUP_MAX
 (0x7fff)

	)

338 #define 
	#REG_EXTENDED
 1

	)

342 #define 
	#REG_ICASE
 (1 << 1)

	)

347 #define 
	#REG_NEWLINE
 (1 << 2)

	)

351 #define 
	#REG_NOSUB
 (1 << 3)

	)

361 #define 
	#REG_NOTBOL
 1

	)

364 #define 
	#REG_NOTEOL
 (1 << 1)

	)

368 #define 
	#REG_STARTEND
 (1 << 2)

	)

376 
	g_REG_ENOSYS
 = -1,

377 
	g_REG_NOERROR
 = 0,

378 
	g_REG_NOMATCH
,

382 
	g_REG_BADPAT
,

383 
	g_REG_ECOLLATE
,

384 
	g_REG_ECTYPE
,

385 
	g_REG_EESCAPE
,

386 
	g_REG_ESUBREG
,

387 
	g_REG_EBRACK
,

388 
	g_REG_EPAREN
,

389 
	g_REG_EBRACE
,

390 
	g_REG_BADBR
,

391 
	g_REG_ERANGE
,

392 
	g_REG_ESPACE
,

393 
	g_REG_BADRPT
,

396 
	g_REG_EEND
,

397 
	g_REG_ESIZE
,

398 
	g_REG_ERPAREN


399 } 
	treg_errcode_t
;

401 #ifdef 
_XOPEN_SOURCE


402 #define 
	#REG_ENOSYS
 
_REG_ENOSYS


	)

404 #define 
	#REG_NOERROR
 
_REG_NOERROR


	)

405 #define 
	#REG_NOMATCH
 
_REG_NOMATCH


	)

406 #define 
	#REG_BADPAT
 
_REG_BADPAT


	)

407 #define 
	#REG_ECOLLATE
 
_REG_ECOLLATE


	)

408 #define 
	#REG_ECTYPE
 
_REG_ECTYPE


	)

409 #define 
	#REG_EESCAPE
 
_REG_EESCAPE


	)

410 #define 
	#REG_ESUBREG
 
_REG_ESUBREG


	)

411 #define 
	#REG_EBRACK
 
_REG_EBRACK


	)

412 #define 
	#REG_EPAREN
 
_REG_EPAREN


	)

413 #define 
	#REG_EBRACE
 
_REG_EBRACE


	)

414 #define 
	#REG_BADBR
 
_REG_BADBR


	)

415 #define 
	#REG_ERANGE
 
_REG_ERANGE


	)

416 #define 
	#REG_ESPACE
 
_REG_ESPACE


	)

417 #define 
	#REG_BADRPT
 
_REG_BADRPT


	)

418 #define 
	#REG_EEND
 
_REG_EEND


	)

419 #define 
	#REG_ESIZE
 
_REG_ESIZE


	)

420 #define 
	#REG_ERPAREN
 
_REG_ERPAREN


	)

425 #ifdef 
__USE_GNU_REGEX


426 #define 
	#_REG_RE_NAME
(
id
) 
	)
id

427 #define 
	#_REG_RM_NAME
(
id
) 
	)
id

429 #define 
	#_REG_RE_NAME
(
id
) 
re_
##
	)
id

430 #define 
	#_REG_RM_NAME
(
id
) 
rm_
##
	)
id

437 #ifdef 
__USE_GNU_REGEX


438 #ifndef 
RE_TRANSLATE_TYPE


439 #define 
	#RE_TRANSLATE_TYPE
 unsigned char *

	)

441 #define 
	#REG_TRANSLATE_TYPE
 
RE_TRANSLATE_TYPE


	)

443 #define 
	#REG_TRANSLATE_TYPE
 unsigned char *

	)

452 struct 
	sre_pattern_buffer


457 unsigned char *
_REG_RE_NAME
 (
buffer
);

460 
__re_long_size_t
 
_REG_RE_NAME
 (
allocated
);

463 
__re_long_size_t
 
_REG_RE_NAME
 (
used
);

466 
reg_syntax_t
 
_REG_RE_NAME
 (
syntax
);

471 char *
_REG_RE_NAME
 (
fastmap
);

477 
REG_TRANSLATE_TYPE
 
_REG_RE_NAME
 (
translate
);

480 
size_t
 
	gre_nsub
;

486 unsigned int 
_REG_RE_NAME
 (
can_be_null
) : 1;

492 #ifdef 
__USE_GNU_REGEX


493 #define 
	#REGS_UNALLOCATED
 0

	)

494 #define 
	#REGS_REALLOCATE
 1

	)

495 #define 
	#REGS_FIXED
 2

	)

497 unsigned int 
_REG_RE_NAME
 (
regs_allocated
) : 2;

501 unsigned int 
_REG_RE_NAME
 (
fastmap_accurate
) : 1;

505 unsigned int 
_REG_RE_NAME
 (
no_sub
) : 1;

509 unsigned int 
_REG_RE_NAME
 (
not_bol
) : 1;

512 unsigned int 
_REG_RE_NAME
 (
not_eol
) : 1;

515 unsigned int 
_REG_RE_NAME
 (
newline_anchor
) : 1;

520 typedef struct 
re_pattern_buffer
 
	tregex_t
;

524 struct 
	sre_registers


526 
__re_size_t
 
_REG_RM_NAME
 (
num_regs
);

527 
regoff_t
 *
_REG_RM_NAME
 (
start
);

528 
regoff_t
 *
_REG_RM_NAME
 (
end
);

535 #if !
defined
 
RE_NREGS
 && defined 
__USE_GNU_REGEX


536 #define 
	#RE_NREGS
 30

	)

545 
regoff_t
 
	grm_so
;

546 
regoff_t
 
	grm_eo
;

547 } 
	tregmatch_t
;

553 extern 
reg_syntax_t
 
re_set_syntax
 (reg_syntax_t 
__syntax
);

558 extern const char *
re_compile_pattern
 (const char *
__pattern
, 
size_t
 
__length
,

559 struct 
re_pattern_buffer
 *
__buffer
);

565 extern int 
re_compile_fastmap
 (struct 
re_pattern_buffer
 *
__buffer
);

573 extern 
regoff_t
 
re_search
 (struct 
re_pattern_buffer
 *
__buffer
,

574 const char *
__string
, 
__re_idx_t
 
__length
,

575 
__re_idx_t
 
__start
, 
regoff_t
 
__range
,

576 struct 
re_registers
 *
__regs
);

581 extern 
regoff_t
 
re_search_2
 (struct 
re_pattern_buffer
 *
__buffer
,

582 const char *
__string1
, 
__re_idx_t
 
__length1
,

583 const char *
__string2
, 
__re_idx_t
 
__length2
,

584 
__re_idx_t
 
__start
, 
regoff_t
 
__range
,

585 struct 
re_registers
 *
__regs
,

586 
__re_idx_t
 
__stop
);

591 extern 
regoff_t
 
re_match
 (struct 
re_pattern_buffer
 *
__buffer
,

592 const char *
__string
, 
__re_idx_t
 
__length
,

593 
__re_idx_t
 
__start
, struct 
re_registers
 *
__regs
);

597 extern 
regoff_t
 
re_match_2
 (struct 
re_pattern_buffer
 *
__buffer
,

598 const char *
__string1
, 
__re_idx_t
 
__length1
,

599 const char *
__string2
, 
__re_idx_t
 
__length2
,

600 
__re_idx_t
 
__start
, struct 
re_registers
 *
__regs
,

601 
__re_idx_t
 
__stop
);

616 extern void 
re_set_registers
 (struct 
re_pattern_buffer
 *
__buffer
,

617 struct 
re_registers
 *
__regs
,

618 
__re_size_t
 
__num_regs
,

619 
regoff_t
 *
__starts
, regoff_t *
__ends
);

621 #if 
defined
 
_REGEX_RE_COMP
 || defined 
_LIBC


622 #ifndef 
_CRAY


624 extern char *
re_comp
 (const char *);

625 extern int 
re_exec
 (const char *);

634 #ifndef 
_Restrict_


635 #if 199901L <= 
__STDC_VERSION__


636 #define 
	#_Restrict_
 
restrict


	)

637 #elif 2 < 
__GNUC__
 || (2 == __GNUC__ && 95 <= 
__GNUC_MINOR__
)

638 #define 
	#_Restrict_
 
__restrict


	)

640 #define 
	#_Restrict_


	)

646 #ifndef 
_Restrict_arr_


647 #if ((199901L <= 
__STDC_VERSION__
 \

648 || ((3 < 
	g__GNUC__
 || (3 == 
__GNUC__
 && 1 <= 
__GNUC_MINOR__
)) \

649 && !
defined
 
__STRICT_ANSI__
)) \

650 && !
defined
 
__GNUG__
)

651 #define 
	#_Restrict_arr_
 
_Restrict_


	)

653 #define 
	#_Restrict_arr_


	)

658 extern int 
regcomp
 (
regex_t
 *
_Restrict_
 
__preg
,

659 const char *
_Restrict_
 
__pattern
,

660 int 
__cflags
);

662 extern int 
regexec
 (const 
regex_t
 *
_Restrict_
 
__preg
,

663 const char *
_Restrict_
 
__string
, 
size_t
 
__nmatch
,

664 
regmatch_t
 
__pmatch
[
_Restrict_arr_
],

665 int 
__eflags
);

667 extern 
size_t
 
regerror
 (int 
__errcode
, const 
regex_t
 *
_Restrict_
 
__preg
,

668 char *
_Restrict_
 
__errbuf
, 
size_t
 
__errbuf_size
);

670 extern void 
regfree
 (
regex_t
 *
__preg
);

673 #ifdef 
__cplusplus


	@lib/regex_internal.c

22 #include 
	~"verify.h
"

23 #include 
	~"intprops.h
"

24 static void 
	$re_string_construct_common
 (const char *
str
, 
Idx
 
len
,

25 
re_string_t
 *
pstr
,

26 
RE_TRANSLATE_TYPE
 
trans
, 
bool
 
icase
,

27 const 
re_dfa_t
 *
dfa
) 
internal_function
;

28 static 
re_dfastate_t
 *
	$create_ci_newstate
 (const 
re_dfa_t
 *
dfa
,

29 const 
re_node_set
 *
nodes
,

30 
re_hashval_t
 
hash
) 
internal_function
;

31 static 
re_dfastate_t
 *
	$create_cd_newstate
 (const 
re_dfa_t
 *
dfa
,

32 const 
re_node_set
 *
nodes
,

33 unsigned int 
context
,

34 
re_hashval_t
 
hash
) 
internal_function
;

41 static 
reg_errcode_t


42 
internal_function
 
__attribute_warn_unused_result__


43 
	$re_string_allocate
 (
re_string_t
 *
pstr
, const char *
str
, 
Idx
 
len
, Idx 
init_len
,

44 
RE_TRANSLATE_TYPE
 
trans
, 
bool
 
icase
, const 
re_dfa_t
 *
dfa
)

46 
reg_errcode_t
 
ret
;

47 
Idx
 
init_buf_len
;

50 if (
init_len
 < 
dfa
->
mb_cur_max
)

51 
init_len
 = 
dfa
->
mb_cur_max
;

52 
init_buf_len
 = (
len
 + 1 < 
init_len
) ? len + 1: init_len;

53 
	`re_string_construct_common
 (
str
, 
len
, 
pstr
, 
trans
, 
icase
, 
dfa
);

55 
ret
 = 
	`re_string_realloc_buffers
 (
pstr
, 
init_buf_len
);

56 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

57 return 
ret
;

59 
pstr
->
word_char
 = 
dfa
->word_char;

60 
pstr
->
word_ops_used
 = 
dfa
->word_ops_used;

61 
pstr
->
mbs
 = pstr->
mbs_allocated
 ? pstr->mbs : (unsigned char *) 
str
;

62 
pstr
->
valid_len
 = (pstr->
mbs_allocated
 || 
dfa
->
mb_cur_max
 > 1) ? 0 : 
len
;

63 
pstr
->
valid_raw_len
 = pstr->
valid_len
;

64 return 
REG_NOERROR
;

65 
	}
}

69 static 
reg_errcode_t


70 
internal_function
 
__attribute_warn_unused_result__


71 
	$re_string_construct
 (
re_string_t
 *
pstr
, const char *
str
, 
Idx
 
len
,

72 
RE_TRANSLATE_TYPE
 
trans
, 
bool
 
icase
, const 
re_dfa_t
 *
dfa
)

74 
reg_errcode_t
 
ret
;

75 
	`memset
 (
pstr
, '\0', sizeof (
re_string_t
));

76 
	`re_string_construct_common
 (
str
, 
len
, 
pstr
, 
trans
, 
icase
, 
dfa
);

78 if (
len
 > 0)

80 
ret
 = 
	`re_string_realloc_buffers
 (
pstr
, 
len
 + 1);

81 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

82 return 
ret
;

84 
pstr
->
mbs
 = pstr->
mbs_allocated
 ? pstr->mbs : (unsigned char *) 
str
;

86 if (
icase
)

88 #ifdef 
RE_ENABLE_I18N


89 if (
dfa
->
mb_cur_max
 > 1)

93 
ret
 = 
	`build_wcs_upper_buffer
 (
pstr
);

94 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

95 return 
ret
;

96 if (
pstr
->
valid_raw_len
 >= 
len
)

98 if (
pstr
->
bufs_len
 > pstr->
valid_len
 + 
dfa
->
mb_cur_max
)

100 
ret
 = 
	`re_string_realloc_buffers
 (
pstr
, pstr->
bufs_len
 * 2);

101 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

102 return 
ret
;

107 
	`build_upper_buffer
 (
pstr
);

111 #ifdef 
RE_ENABLE_I18N


112 if (
dfa
->
mb_cur_max
 > 1)

113 
	`build_wcs_buffer
 (
pstr
);

117 if (
trans
 != 
NULL
)

118 
	`re_string_translate_buffer
 (
pstr
);

121 
pstr
->
valid_len
 = pstr->
bufs_len
;

122 
pstr
->
valid_raw_len
 = pstr->
bufs_len
;

127 return 
REG_NOERROR
;

128 
	}
}

132 static 
reg_errcode_t


133 
internal_function
 
__attribute_warn_unused_result__


134 
	$re_string_realloc_buffers
 (
re_string_t
 *
pstr
, 
Idx
 
new_buf_len
)

136 #ifdef 
RE_ENABLE_I18N


137 if (
pstr
->
mb_cur_max
 > 1)

139 
wint_t
 *
new_wcs
;

142 
size_t
 
max_object_size
 = 
	`MAX
 (sizeof (
wint_t
), sizeof (
Idx
));

143 if (
	`BE
 (
SIZE_MAX
 / 
max_object_size
 < 
new_buf_len
, 0))

144 return 
REG_ESPACE
;

146 
new_wcs
 = 
	`re_realloc
 (
pstr
->
wcs
, 
wint_t
, 
new_buf_len
);

147 if (
	`BE
 (
new_wcs
 == 
NULL
, 0))

148 return 
REG_ESPACE
;

149 
pstr
->
wcs
 = 
new_wcs
;

150 if (
pstr
->
offsets
 != 
NULL
)

152 
Idx
 *
new_offsets
 = 
	`re_realloc
 (
pstr
->
offsets
, Idx, 
new_buf_len
);

153 if (
	`BE
 (
new_offsets
 == 
NULL
, 0))

154 return 
REG_ESPACE
;

155 
pstr
->
offsets
 = 
new_offsets
;

159 if (
pstr
->
mbs_allocated
)

161 unsigned char *
new_mbs
 = 
	`re_realloc
 (
pstr
->
mbs
, unsigned char,

162 
new_buf_len
);

163 if (
	`BE
 (
new_mbs
 == 
NULL
, 0))

164 return 
REG_ESPACE
;

165 
pstr
->
mbs
 = 
new_mbs
;

167 
pstr
->
bufs_len
 = 
new_buf_len
;

168 return 
REG_NOERROR
;

169 
	}
}

173 
internal_function


174 
	$re_string_construct_common
 (const char *
str
, 
Idx
 
len
, 
re_string_t
 *
pstr
,

175 
RE_TRANSLATE_TYPE
 
trans
, 
bool
 
icase
,

176 const 
re_dfa_t
 *
dfa
)

178 
pstr
->
raw_mbs
 = (const unsigned char *) 
str
;

179 
pstr
->
len
 = len;

180 
pstr
->
raw_len
 = 
len
;

181 
pstr
->
trans
 = trans;

182 
pstr
->
icase
 = icase;

183 
pstr
->
mbs_allocated
 = (
trans
 != 
NULL
 || 
icase
);

184 
pstr
->
mb_cur_max
 = 
dfa
->mb_cur_max;

185 
pstr
->
is_utf8
 = 
dfa
->is_utf8;

186 
pstr
->
map_notascii
 = 
dfa
->map_notascii;

187 
pstr
->
stop
 = pstr->
len
;

188 
pstr
->
raw_stop
 = pstr->
stop
;

189 
	}
}

191 #ifdef 
RE_ENABLE_I18N


205 
internal_function


206 
	$build_wcs_buffer
 (
re_string_t
 *
pstr
)

208 #ifdef 
_LIBC


209 unsigned char 
buf
[
MB_LEN_MAX
];

210 
	`assert
 (
MB_LEN_MAX
 >= 
pstr
->
mb_cur_max
);

212 unsigned char 
buf
[64];

214 
mbstate_t
 
prev_st
;

215 
Idx
 
byte_idx
, 
end_idx
, 
remain_len
;

216 
size_t
 
mbclen
;

220 
end_idx
 = (
pstr
->
bufs_len
 > pstr->
len
) ? pstr->len : pstr->bufs_len;

221 for (
byte_idx
 = 
pstr
->
valid_len
; byte_idx < 
end_idx
;)

223 
wchar_t
 
wc
;

224 const char *
p
;

226 
remain_len
 = 
end_idx
 - 
byte_idx
;

227 
prev_st
 = 
pstr
->
cur_state
;

229 if (
	`BE
 (
pstr
->
trans
 != 
NULL
, 0))

231 int 
i
, 
ch
;

233 for (
i
 = 0; i < 
pstr
->
mb_cur_max
 && i < 
remain_len
; ++i)

235 
ch
 = 
pstr
->
raw_mbs
 [pstr->
raw_mbs_idx
 + 
byte_idx
 + 
i
];

236 
buf
[
i
] = 
pstr
->
mbs
[
byte_idx
 + i] = pstr->
trans
[
ch
];

238 
p
 = (const char *) 
buf
;

241 
p
 = (const char *) 
pstr
->
raw_mbs
 + pstr->
raw_mbs_idx
 + 
byte_idx
;

242 
mbclen
 = 
	`__mbrtowc
 (&
wc
, 
p
, 
remain_len
, &
pstr
->
cur_state
);

243 if (
	`BE
 (
mbclen
 == (
size_t
) -2, 0))

246 
pstr
->
cur_state
 = 
prev_st
;

249 else if (
	`BE
 (
mbclen
 == (
size_t
) -1 || mbclen == 0, 0))

252 
mbclen
 = 1;

253 
wc
 = (
wchar_t
) 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
byte_idx
];

254 if (
	`BE
 (
pstr
->
trans
 != 
NULL
, 0))

255 
wc
 = 
pstr
->
trans
[wc];

256 
pstr
->
cur_state
 = 
prev_st
;

260 
pstr
->
wcs
[
byte_idx
++] = 
wc
;

262 for (
remain_len
 = 
byte_idx
 + 
mbclen
 - 1; byte_idx < remain_len ;)

263 
pstr
->
wcs
[
byte_idx
++] = 
WEOF
;

265 
pstr
->
valid_len
 = 
byte_idx
;

266 
pstr
->
valid_raw_len
 = 
byte_idx
;

267 
	}
}

272 static 
reg_errcode_t


273 
internal_function
 
__attribute_warn_unused_result__


274 
	$build_wcs_upper_buffer
 (
re_string_t
 *
pstr
)

276 
mbstate_t
 
prev_st
;

277 
Idx
 
src_idx
, 
byte_idx
, 
end_idx
, 
remain_len
;

278 
size_t
 
mbclen
;

279 #ifdef 
_LIBC


280 char 
buf
[
MB_LEN_MAX
];

281 
	`assert
 (
MB_LEN_MAX
 >= 
pstr
->
mb_cur_max
);

283 char 
buf
[64];

286 
byte_idx
 = 
pstr
->
valid_len
;

287 
end_idx
 = (
pstr
->
bufs_len
 > pstr->
len
) ? pstr->len : pstr->bufs_len;

291 if (! 
pstr
->
map_notascii
 && pstr->
trans
 == 
NULL
 && !pstr->
offsets_needed
)

293 while (
byte_idx
 < 
end_idx
)

295 
wchar_t
 
wc
;

297 if (
	`isascii
 (
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
byte_idx
])

298 && 
	`mbsinit
 (&
pstr
->
cur_state
))

301 
pstr
->
mbs
[
byte_idx
]

302 = 
	`toupper
 (
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
byte_idx
]);

305 
pstr
->
wcs
[
byte_idx
] = (
wchar_t
) pstr->
mbs
[byte_idx];

306 ++
byte_idx
;

310 
remain_len
 = 
end_idx
 - 
byte_idx
;

311 
prev_st
 = 
pstr
->
cur_state
;

312 
mbclen
 = 
	`__mbrtowc
 (&
wc
,

313 ((const char *) 
pstr
->
raw_mbs
 + pstr->
raw_mbs_idx


314 + 
byte_idx
), 
remain_len
, &
pstr
->
cur_state
);

315 if (
	`BE
 (
mbclen
 < (
size_t
) -2, 1))

317 
wchar_t
 
wcu
 = 
wc
;

318 if (
	`iswlower
 (
wc
))

320 
size_t
 
mbcdlen
;

322 
wcu
 = 
	`towupper
 (
wc
);

323 
mbcdlen
 = 
	`wcrtomb
 (
buf
, 
wcu
, &
prev_st
);

324 if (
	`BE
 (
mbclen
 == 
mbcdlen
, 1))

325 
	`memcpy
 (
pstr
->
mbs
 + 
byte_idx
, 
buf
, 
mbclen
);

328 
src_idx
 = 
byte_idx
;

329 goto 
offsets_needed
;

333 
	`memcpy
 (
pstr
->
mbs
 + 
byte_idx
,

334 
pstr
->
raw_mbs
 + pstr->
raw_mbs_idx
 + 
byte_idx
, 
mbclen
);

335 
pstr
->
wcs
[
byte_idx
++] = 
wcu
;

337 for (
remain_len
 = 
byte_idx
 + 
mbclen
 - 1; byte_idx < remain_len ;)

338 
pstr
->
wcs
[
byte_idx
++] = 
WEOF
;

340 else if (
mbclen
 == (
size_t
) -1 || mbclen == 0)

343 int 
ch
 = 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
byte_idx
];

344 
pstr
->
mbs
[
byte_idx
] = 
ch
;

346 
pstr
->
wcs
[
byte_idx
++] = (
wchar_t
) 
ch
;

347 if (
	`BE
 (
mbclen
 == (
size_t
) -1, 0))

348 
pstr
->
cur_state
 = 
prev_st
;

353 
pstr
->
cur_state
 = 
prev_st
;

357 
pstr
->
valid_len
 = 
byte_idx
;

358 
pstr
->
valid_raw_len
 = 
byte_idx
;

359 return 
REG_NOERROR
;

362 for (
src_idx
 = 
pstr
->
valid_raw_len
; 
byte_idx
 < 
end_idx
;)

364 
wchar_t
 
wc
;

365 const char *
p
;

366 
offsets_needed
:

367 
remain_len
 = 
end_idx
 - 
byte_idx
;

368 
prev_st
 = 
pstr
->
cur_state
;

369 if (
	`BE
 (
pstr
->
trans
 != 
NULL
, 0))

371 int 
i
, 
ch
;

373 for (
i
 = 0; i < 
pstr
->
mb_cur_max
 && i < 
remain_len
; ++i)

375 
ch
 = 
pstr
->
raw_mbs
 [pstr->
raw_mbs_idx
 + 
src_idx
 + 
i
];

376 
buf
[
i
] = 
pstr
->
trans
[
ch
];

378 
p
 = (const char *) 
buf
;

381 
p
 = (const char *) 
pstr
->
raw_mbs
 + pstr->
raw_mbs_idx
 + 
src_idx
;

382 
mbclen
 = 
	`__mbrtowc
 (&
wc
, 
p
, 
remain_len
, &
pstr
->
cur_state
);

383 if (
	`BE
 (
mbclen
 < (
size_t
) -2, 1))

385 
wchar_t
 
wcu
 = 
wc
;

386 if (
	`iswlower
 (
wc
))

388 
size_t
 
mbcdlen
;

390 
wcu
 = 
	`towupper
 (
wc
);

391 
mbcdlen
 = 
	`wcrtomb
 ((char *) 
buf
, 
wcu
, &
prev_st
);

392 if (
	`BE
 (
mbclen
 == 
mbcdlen
, 1))

393 
	`memcpy
 (
pstr
->
mbs
 + 
byte_idx
, 
buf
, 
mbclen
);

394 else if (
mbcdlen
 != (
size_t
) -1)

396 
size_t
 
i
;

398 if (
byte_idx
 + 
mbcdlen
 > 
pstr
->
bufs_len
)

400 
pstr
->
cur_state
 = 
prev_st
;

404 if (
pstr
->
offsets
 == 
NULL
)

406 
pstr
->
offsets
 = 
	`re_malloc
 (
Idx
, pstr->
bufs_len
);

408 if (
pstr
->
offsets
 == 
NULL
)

409 return 
REG_ESPACE
;

411 if (!
pstr
->
offsets_needed
)

413 for (
i
 = 0; i < (
size_t
) 
byte_idx
; ++i)

414 
pstr
->
offsets
[
i
] = i;

415 
pstr
->
offsets_needed
 = 1;

418 
	`memcpy
 (
pstr
->
mbs
 + 
byte_idx
, 
buf
, 
mbcdlen
);

419 
pstr
->
wcs
[
byte_idx
] = 
wcu
;

420 
pstr
->
offsets
[
byte_idx
] = 
src_idx
;

421 for (
i
 = 1; i < 
mbcdlen
; ++i)

423 
pstr
->
offsets
[
byte_idx
 + 
i
]

424 = 
src_idx
 + (
i
 < 
mbclen
 ? i : mbclen - 1);

425 
pstr
->
wcs
[
byte_idx
 + 
i
] = 
WEOF
;

427 
pstr
->
len
 += 
mbcdlen
 - 
mbclen
;

428 if (
pstr
->
raw_stop
 > 
src_idx
)

429 
pstr
->
stop
 += 
mbcdlen
 - 
mbclen
;

430 
end_idx
 = (
pstr
->
bufs_len
 > pstr->
len
)

431 ? 
pstr
->
len
 : pstr->
bufs_len
;

432 
byte_idx
 += 
mbcdlen
;

433 
src_idx
 += 
mbclen
;

437 
	`memcpy
 (
pstr
->
mbs
 + 
byte_idx
, 
p
, 
mbclen
);

440 
	`memcpy
 (
pstr
->
mbs
 + 
byte_idx
, 
p
, 
mbclen
);

442 if (
	`BE
 (
pstr
->
offsets_needed
 != 0, 0))

444 
size_t
 
i
;

445 for (
i
 = 0; i < 
mbclen
; ++i)

446 
pstr
->
offsets
[
byte_idx
 + 
i
] = 
src_idx
 + i;

448 
src_idx
 += 
mbclen
;

450 
pstr
->
wcs
[
byte_idx
++] = 
wcu
;

452 for (
remain_len
 = 
byte_idx
 + 
mbclen
 - 1; byte_idx < remain_len ;)

453 
pstr
->
wcs
[
byte_idx
++] = 
WEOF
;

455 else if (
mbclen
 == (
size_t
) -1 || mbclen == 0)

458 int 
ch
 = 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
src_idx
];

460 if (
	`BE
 (
pstr
->
trans
 != 
NULL
, 0))

461 
ch
 = 
pstr
->
trans
 [ch];

462 
pstr
->
mbs
[
byte_idx
] = 
ch
;

464 if (
	`BE
 (
pstr
->
offsets_needed
 != 0, 0))

465 
pstr
->
offsets
[
byte_idx
] = 
src_idx
;

466 ++
src_idx
;

469 
pstr
->
wcs
[
byte_idx
++] = (
wchar_t
) 
ch
;

470 if (
	`BE
 (
mbclen
 == (
size_t
) -1, 0))

471 
pstr
->
cur_state
 = 
prev_st
;

476 
pstr
->
cur_state
 = 
prev_st
;

480 
pstr
->
valid_len
 = 
byte_idx
;

481 
pstr
->
valid_raw_len
 = 
src_idx
;

482 return 
REG_NOERROR
;

483 
	}
}

488 static 
Idx


489 
internal_function


490 
	$re_string_skip_chars
 (
re_string_t
 *
pstr
, 
Idx
 
new_raw_idx
, 
wint_t
 *
last_wc
)

492 
mbstate_t
 
prev_st
;

493 
Idx
 
rawbuf_idx
;

494 
size_t
 
mbclen
;

495 
wint_t
 
wc
 = 
WEOF
;

498 for (
rawbuf_idx
 = 
pstr
->
raw_mbs_idx
 + pstr->
valid_raw_len
;

499 
rawbuf_idx
 < 
new_raw_idx
;)

501 
wchar_t
 
wc2
;

502 
Idx
 
remain_len
;

503 
remain_len
 = 
pstr
->
len
 - 
rawbuf_idx
;

504 
prev_st
 = 
pstr
->
cur_state
;

505 
mbclen
 = 
	`__mbrtowc
 (&
wc2
, (const char *) 
pstr
->
raw_mbs
 + 
rawbuf_idx
,

506 
remain_len
, &
pstr
->
cur_state
);

507 if (
	`BE
 (
mbclen
 == (
size_t
) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))

510 if (
mbclen
 == 0 || 
remain_len
 == 0)

511 
wc
 = 
L
'\0';

513 
wc
 = *(unsigned char *) (
pstr
->
raw_mbs
 + 
rawbuf_idx
);

514 
mbclen
 = 1;

515 
pstr
->
cur_state
 = 
prev_st
;

518 
wc
 = 
wc2
;

520 
rawbuf_idx
 += 
mbclen
;

522 *
last_wc
 = 
wc
;

523 return 
rawbuf_idx
;

524 
	}
}

531 
internal_function


532 
	$build_upper_buffer
 (
re_string_t
 *
pstr
)

534 
Idx
 
char_idx
, 
end_idx
;

535 
end_idx
 = (
pstr
->
bufs_len
 > pstr->
len
) ? pstr->len : pstr->bufs_len;

537 for (
char_idx
 = 
pstr
->
valid_len
; char_idx < 
end_idx
; ++char_idx)

539 int 
ch
 = 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
char_idx
];

540 if (
	`BE
 (
pstr
->
trans
 != 
NULL
, 0))

541 
ch
 = 
pstr
->
trans
[ch];

542 if (
	`islower
 (
ch
))

543 
pstr
->
mbs
[
char_idx
] = 
	`toupper
 (
ch
);

545 
pstr
->
mbs
[
char_idx
] = 
ch
;

547 
pstr
->
valid_len
 = 
char_idx
;

548 
pstr
->
valid_raw_len
 = 
char_idx
;

549 
	}
}

554 
internal_function


555 
	$re_string_translate_buffer
 (
re_string_t
 *
pstr
)

557 
Idx
 
buf_idx
, 
end_idx
;

558 
end_idx
 = (
pstr
->
bufs_len
 > pstr->
len
) ? pstr->len : pstr->bufs_len;

560 for (
buf_idx
 = 
pstr
->
valid_len
; buf_idx < 
end_idx
; ++buf_idx)

562 int 
ch
 = 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
buf_idx
];

563 
pstr
->
mbs
[
buf_idx
] = pstr->
trans
[
ch
];

566 
pstr
->
valid_len
 = 
buf_idx
;

567 
pstr
->
valid_raw_len
 = 
buf_idx
;

568 
	}
}

574 static 
reg_errcode_t


575 
internal_function
 
__attribute_warn_unused_result__


576 
	$re_string_reconstruct
 (
re_string_t
 *
pstr
, 
Idx
 
idx
, int 
eflags
)

578 
Idx
 
offset
;

580 if (
	`BE
 (
pstr
->
raw_mbs_idx
 <= 
idx
, 0))

581 
offset
 = 
idx
 - 
pstr
->
raw_mbs_idx
;

585 #ifdef 
RE_ENABLE_I18N


586 if (
pstr
->
mb_cur_max
 > 1)

587 
	`memset
 (&
pstr
->
cur_state
, '\0', sizeof (
mbstate_t
));

589 
pstr
->
len
 = pstr->
raw_len
;

590 
pstr
->
stop
 = pstr->
raw_stop
;

591 
pstr
->
valid_len
 = 0;

592 
pstr
->
raw_mbs_idx
 = 0;

593 
pstr
->
valid_raw_len
 = 0;

594 
pstr
->
offsets_needed
 = 0;

595 
pstr
->
tip_context
 = ((
eflags
 & 
REG_NOTBOL
) ? 
CONTEXT_BEGBUF


596 : 
CONTEXT_NEWLINE
 | 
CONTEXT_BEGBUF
);

597 if (!
pstr
->
mbs_allocated
)

598 
pstr
->
mbs
 = (unsigned char *) pstr->
raw_mbs
;

599 
offset
 = 
idx
;

602 if (
	`BE
 (
offset
 != 0, 1))

605 if (
	`BE
 (
offset
 < 
pstr
->
valid_raw_len
, 1))

608 #ifdef 
RE_ENABLE_I18N


609 if (
	`BE
 (
pstr
->
offsets_needed
, 0))

611 
Idx
 
low
 = 0, 
high
 = 
pstr
->
valid_len
, 
mid
;

614 
mid
 = (
high
 + 
low
) / 2;

615 if (
pstr
->
offsets
[
mid
] > 
offset
)

616 
high
 = 
mid
;

617 else if (
pstr
->
offsets
[
mid
] < 
offset
)

618 
low
 = 
mid
 + 1;

622 while (
low
 < 
high
);

623 if (
pstr
->
offsets
[
mid
] < 
offset
)

624 ++
mid
;

625 
pstr
->
tip_context
 = 
	`re_string_context_at
 (pstr, 
mid
 - 1,

626 
eflags
);

631 if (
pstr
->
valid_len
 > 
offset


632 && 
mid
 == 
offset
 && 
pstr
->
offsets
[mid] == offset)

634 
	`memmove
 (
pstr
->
wcs
, pstr->wcs + 
offset
,

635 (
pstr
->
valid_len
 - 
offset
) * sizeof (
wint_t
));

636 
	`memmove
 (
pstr
->
mbs
, pstr->mbs + 
offset
, pstr->
valid_len
 - offset);

637 
pstr
->
valid_len
 -= 
offset
;

638 
pstr
->
valid_raw_len
 -= 
offset
;

639 for (
low
 = 0; low < 
pstr
->
valid_len
; low++)

640 
pstr
->
offsets
[
low
] = pstr->offsets[low + 
offset
] - offset;

646 
pstr
->
len
 = pstr->
raw_len
 - 
idx
 + 
offset
;

647 
pstr
->
stop
 = pstr->
raw_stop
 - 
idx
 + 
offset
;

648 
pstr
->
offsets_needed
 = 0;

649 while (
mid
 > 0 && 
pstr
->
offsets
[mid - 1] == 
offset
)

650 --
mid
;

651 while (
mid
 < 
pstr
->
valid_len
)

652 if (
pstr
->
wcs
[
mid
] != 
WEOF
)

655 ++
mid
;

656 if (
mid
 == 
pstr
->
valid_len
)

657 
pstr
->
valid_len
 = 0;

660 
pstr
->
valid_len
 = pstr->
offsets
[
mid
] - 
offset
;

661 if (
pstr
->
valid_len
)

663 for (
low
 = 0; low < 
pstr
->
valid_len
; ++low)

664 
pstr
->
wcs
[
low
] = 
WEOF
;

665 
	`memset
 (
pstr
->
mbs
, 255, pstr->
valid_len
);

668 
pstr
->
valid_raw_len
 = pstr->
valid_len
;

674 
pstr
->
tip_context
 = 
	`re_string_context_at
 (pstr, 
offset
 - 1,

675 
eflags
);

676 #ifdef 
RE_ENABLE_I18N


677 if (
pstr
->
mb_cur_max
 > 1)

678 
	`memmove
 (
pstr
->
wcs
, pstr->wcs + 
offset
,

679 (
pstr
->
valid_len
 - 
offset
) * sizeof (
wint_t
));

681 if (
	`BE
 (
pstr
->
mbs_allocated
, 0))

682 
	`memmove
 (
pstr
->
mbs
, pstr->mbs + 
offset
,

683 
pstr
->
valid_len
 - 
offset
);

684 
pstr
->
valid_len
 -= 
offset
;

685 
pstr
->
valid_raw_len
 -= 
offset
;

686 #if 
DEBUG


687 
	`assert
 (
pstr
->
valid_len
 > 0);

693 #ifdef 
RE_ENABLE_I18N


695 
Idx
 
prev_valid_len
 = 
pstr
->
valid_len
;

697 if (
	`BE
 (
pstr
->
offsets_needed
, 0))

699 
pstr
->
len
 = pstr->
raw_len
 - 
idx
 + 
offset
;

700 
pstr
->
stop
 = pstr->
raw_stop
 - 
idx
 + 
offset
;

701 
pstr
->
offsets_needed
 = 0;

704 
pstr
->
valid_len
 = 0;

705 #ifdef 
RE_ENABLE_I18N


706 if (
pstr
->
mb_cur_max
 > 1)

708 
Idx
 
wcs_idx
;

709 
wint_t
 
wc
 = 
WEOF
;

711 if (
pstr
->
is_utf8
)

713 const unsigned char *
raw
, *
p
, *
end
;

717 
raw
 = 
pstr
->
raw_mbs
 + pstr->
raw_mbs_idx
;

718 
end
 = 
raw
 + (
offset
 - 
pstr
->
mb_cur_max
);

719 if (
end
 < 
pstr
->
raw_mbs
)

720 
end
 = 
pstr
->
raw_mbs
;

721 
p
 = 
raw
 + 
offset
 - 1;

722 #ifdef 
_LIBC


725 if (
	`isascii
 (*
p
) && 
	`BE
 (
pstr
->
trans
 == 
NULL
, 1))

727 
	`memset
 (&
pstr
->
cur_state
, '\0', sizeof (
mbstate_t
));

729 
wc
 = (
wchar_t
) *
p
;

733 for (; 
p
 >= 
end
; --p)

734 if ((*
p
 & 0xc0) != 0x80)

736 
mbstate_t
 
cur_state
;

737 
wchar_t
 
wc2
;

738 
Idx
 
mlen
 = 
raw
 + 
pstr
->
len
 - 
p
;

739 
size_t
 
mbclen
;

742 unsigned char 
buf
[6];

743 if (
	`BE
 (
pstr
->
trans
 != 
NULL
, 0))

745 int 
i
 = 
mlen
 < 6 ? mlen : 6;

746 while (--
i
 >= 0)

747 
buf
[
i
] = 
pstr
->
trans
[
p
[i]];

752 
	`memset
 (&
cur_state
, 0, sizeof (cur_state));

753 
mbclen
 = 
	`__mbrtowc
 (&
wc2
, (const char *) 
p
, 
mlen
,

754 &
cur_state
);

755 if (
raw
 + 
offset
 - 
p
 <= 
mbclen


756 && 
mbclen
 < (
size_t
) -2)

758 
	`memset
 (&
pstr
->
cur_state
, '\0',

759 sizeof (
mbstate_t
));

760 
pstr
->
valid_len
 = 
mbclen
 - (
raw
 + 
offset
 - 
p
);

761 
wc
 = 
wc2
;

767 if (
wc
 == 
WEOF
)

768 
pstr
->
valid_len
 = 
	`re_string_skip_chars
 (pstr, 
idx
, &
wc
) - idx;

769 if (
wc
 == 
WEOF
)

770 
pstr
->
tip_context


771 = 
	`re_string_context_at
 (
pstr
, 
prev_valid_len
 - 1, 
eflags
);

773 
pstr
->
tip_context
 = ((
	`BE
 (pstr->
word_ops_used
 != 0, 0)

774 && 
	`IS_WIDE_WORD_CHAR
 (
wc
))

775 ? 
CONTEXT_WORD


776 : ((
	`IS_WIDE_NEWLINE
 (
wc
)

777 && 
pstr
->
newline_anchor
)

778 ? 
CONTEXT_NEWLINE
 : 0));

779 if (
	`BE
 (
pstr
->
valid_len
, 0))

781 for (
wcs_idx
 = 0; wcs_idx < 
pstr
->
valid_len
; ++wcs_idx)

782 
pstr
->
wcs
[
wcs_idx
] = 
WEOF
;

783 if (
pstr
->
mbs_allocated
)

784 
	`memset
 (
pstr
->
mbs
, 255, pstr->
valid_len
);

786 
pstr
->
valid_raw_len
 = pstr->
valid_len
;

791 int 
c
 = 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
offset
 - 1];

792 
pstr
->
valid_raw_len
 = 0;

793 if (
pstr
->
trans
)

794 
c
 = 
pstr
->
trans
[c];

795 
pstr
->
tip_context
 = (
	`bitset_contain
 (pstr->
word_char
, 
c
)

796 ? 
CONTEXT_WORD


797 : ((
	`IS_NEWLINE
 (
c
) && 
pstr
->
newline_anchor
)

798 ? 
CONTEXT_NEWLINE
 : 0));

801 if (!
	`BE
 (
pstr
->
mbs_allocated
, 0))

802 
pstr
->
mbs
 += 
offset
;

804 
pstr
->
raw_mbs_idx
 = 
idx
;

805 
pstr
->
len
 -= 
offset
;

806 
pstr
->
stop
 -= 
offset
;

809 #ifdef 
RE_ENABLE_I18N


810 if (
pstr
->
mb_cur_max
 > 1)

812 if (
pstr
->
icase
)

814 
reg_errcode_t
 
ret
 = 
	`build_wcs_upper_buffer
 (
pstr
);

815 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

816 return 
ret
;

819 
	`build_wcs_buffer
 (
pstr
);

823 if (
	`BE
 (
pstr
->
mbs_allocated
, 0))

825 if (
pstr
->
icase
)

826 
	`build_upper_buffer
 (
pstr
);

827 else if (
pstr
->
trans
 != 
NULL
)

828 
	`re_string_translate_buffer
 (
pstr
);

831 
pstr
->
valid_len
 = pstr->
len
;

833 
pstr
->
cur_idx
 = 0;

834 return 
REG_NOERROR
;

835 
	}
}

838 
internal_function
 
__attribute
 ((
pure
))

839 
	$re_string_peek_byte_case
 (const 
re_string_t
 *
pstr
, 
Idx
 
idx
)

841 int 
ch
;

842 
Idx
 
off
;

845 if (
	`BE
 (!
pstr
->
mbs_allocated
, 1))

846 return 
	`re_string_peek_byte
 (
pstr
, 
idx
);

848 #ifdef 
RE_ENABLE_I18N


849 if (
pstr
->
mb_cur_max
 > 1

850 && ! 
	`re_string_is_single_byte_char
 (
pstr
, pstr->
cur_idx
 + 
idx
))

851 return 
	`re_string_peek_byte
 (
pstr
, 
idx
);

854 
off
 = 
pstr
->
cur_idx
 + 
idx
;

855 #ifdef 
RE_ENABLE_I18N


856 if (
pstr
->
offsets_needed
)

857 
off
 = 
pstr
->
offsets
[off];

860 
ch
 = 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
off
];

862 #ifdef 
RE_ENABLE_I18N


867 if (
pstr
->
offsets_needed
 && !
	`isascii
 (
ch
))

868 return 
	`re_string_peek_byte
 (
pstr
, 
idx
);

871 return 
ch
;

872 
	}
}

875 
internal_function
 
__attribute
 ((
pure
))

876 
	$re_string_fetch_byte_case
 (
re_string_t
 *
pstr
)

878 if (
	`BE
 (!
pstr
->
mbs_allocated
, 1))

879 return 
	`re_string_fetch_byte
 (
pstr
);

881 #ifdef 
RE_ENABLE_I18N


882 if (
pstr
->
offsets_needed
)

884 
Idx
 
off
;

885 int 
ch
;

894 if (!
	`re_string_first_byte
 (
pstr
, pstr->
cur_idx
))

895 return 
	`re_string_fetch_byte
 (
pstr
);

897 
off
 = 
pstr
->
offsets
[pstr->
cur_idx
];

898 
ch
 = 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + 
off
];

900 if (! 
	`isascii
 (
ch
))

901 return 
	`re_string_fetch_byte
 (
pstr
);

903 
	`re_string_skip_bytes
 (
pstr
,

904 
	`re_string_char_size_at
 (
pstr
, pstr->
cur_idx
));

905 return 
ch
;

909 return 
pstr
->
raw_mbs
[pstr->
raw_mbs_idx
 + pstr->
cur_idx
++];

910 
	}
}

913 
internal_function


914 
	$re_string_destruct
 (
re_string_t
 *
pstr
)

916 #ifdef 
RE_ENABLE_I18N


917 
	`re_free
 (
pstr
->
wcs
);

918 
	`re_free
 (
pstr
->
offsets
);

920 if (
pstr
->
mbs_allocated
)

921 
	`re_free
 (
pstr
->
mbs
);

922 
	}
}

927 
internal_function


928 
	$re_string_context_at
 (const 
re_string_t
 *
input
, 
Idx
 
idx
, int 
eflags
)

930 int 
c
;

931 if (
	`BE
 (! 
	`REG_VALID_INDEX
 (
idx
), 0))

934 return 
input
->
tip_context
;

935 if (
	`BE
 (
idx
 == 
input
->
len
, 0))

936 return ((
eflags
 & 
REG_NOTEOL
) ? 
CONTEXT_ENDBUF


937 : 
CONTEXT_NEWLINE
 | 
CONTEXT_ENDBUF
);

938 #ifdef 
RE_ENABLE_I18N


939 if (
input
->
mb_cur_max
 > 1)

941 
wint_t
 
wc
;

942 
Idx
 
wc_idx
 = 
idx
;

943 while(
input
->
wcs
[
wc_idx
] == 
WEOF
)

945 #ifdef 
DEBUG


947 
	`assert
 (
	`REG_VALID_INDEX
 (
wc_idx
));

949 --
wc_idx
;

950 if (! 
	`REG_VALID_INDEX
 (
wc_idx
))

951 return 
input
->
tip_context
;

953 
wc
 = 
input
->
wcs
[
wc_idx
];

954 if (
	`BE
 (
input
->
word_ops_used
 != 0, 0) && 
	`IS_WIDE_WORD_CHAR
 (
wc
))

955 return 
CONTEXT_WORD
;

956 return (
	`IS_WIDE_NEWLINE
 (
wc
) && 
input
->
newline_anchor


957 ? 
CONTEXT_NEWLINE
 : 0);

962 
c
 = 
	`re_string_byte_at
 (
input
, 
idx
);

963 if (
	`bitset_contain
 (
input
->
word_char
, 
c
))

964 return 
CONTEXT_WORD
;

965 return 
	`IS_NEWLINE
 (
c
) && 
input
->
newline_anchor
 ? 
CONTEXT_NEWLINE
 : 0;

967 
	}
}

971 static 
reg_errcode_t


972 
internal_function
 
__attribute_warn_unused_result__


973 
	$re_node_set_alloc
 (
re_node_set
 *
set
, 
Idx
 
size
)

975 
set
->
alloc
 = 
size
;

976 
set
->
nelem
 = 0;

977 
set
->
elems
 = 
	`re_malloc
 (
Idx
, 
size
);

978 if (
	`BE
 (
set
->
elems
 == 
NULL
, 0))

979 return 
REG_ESPACE
;

980 return 
REG_NOERROR
;

981 
	}
}

983 static 
reg_errcode_t


984 
internal_function
 
__attribute_warn_unused_result__


985 
	$re_node_set_init_1
 (
re_node_set
 *
set
, 
Idx
 
elem
)

987 
set
->
alloc
 = 1;

988 
set
->
nelem
 = 1;

989 
set
->
elems
 = 
	`re_malloc
 (
Idx
, 1);

990 if (
	`BE
 (
set
->
elems
 == 
NULL
, 0))

992 
set
->
alloc
 = set->
nelem
 = 0;

993 return 
REG_ESPACE
;

995 
set
->
elems
[0] = 
elem
;

996 return 
REG_NOERROR
;

997 
	}
}

999 static 
reg_errcode_t


1000 
internal_function
 
__attribute_warn_unused_result__


1001 
	$re_node_set_init_2
 (
re_node_set
 *
set
, 
Idx
 
elem1
, Idx 
elem2
)

1003 
set
->
alloc
 = 2;

1004 
set
->
elems
 = 
	`re_malloc
 (
Idx
, 2);

1005 if (
	`BE
 (
set
->
elems
 == 
NULL
, 0))

1006 return 
REG_ESPACE
;

1007 if (
elem1
 == 
elem2
)

1009 
set
->
nelem
 = 1;

1010 
set
->
elems
[0] = 
elem1
;

1014 
set
->
nelem
 = 2;

1015 if (
elem1
 < 
elem2
)

1017 
set
->
elems
[0] = 
elem1
;

1018 
set
->
elems
[1] = 
elem2
;

1022 
set
->
elems
[0] = 
elem2
;

1023 
set
->
elems
[1] = 
elem1
;

1026 return 
REG_NOERROR
;

1027 
	}
}

1029 static 
reg_errcode_t


1030 
internal_function
 
__attribute_warn_unused_result__


1031 
	$re_node_set_init_copy
 (
re_node_set
 *
dest
, const re_node_set *
src
)

1033 
dest
->
nelem
 = 
src
->nelem;

1034 if (
src
->
nelem
 > 0)

1036 
dest
->
alloc
 = dest->
nelem
;

1037 
dest
->
elems
 = 
	`re_malloc
 (
Idx
, dest->
alloc
);

1038 if (
	`BE
 (
dest
->
elems
 == 
NULL
, 0))

1040 
dest
->
alloc
 = dest->
nelem
 = 0;

1041 return 
REG_ESPACE
;

1043 
	`memcpy
 (
dest
->
elems
, 
src
->elems, src->
nelem
 * sizeof (
Idx
));

1046 
	`re_node_set_init_empty
 (
dest
);

1047 return 
REG_NOERROR
;

1048 
	}
}

1054 static 
reg_errcode_t


1055 
internal_function
 
__attribute_warn_unused_result__


1056 
	$re_node_set_add_intersect
 (
re_node_set
 *
dest
, const re_node_set *
src1
,

1057 const 
re_node_set
 *
src2
)

1059 
Idx
 
i1
, 
i2
, 
is
, 
id
, 
delta
, 
sbase
;

1060 if (
src1
->
nelem
 == 0 || 
src2
->nelem == 0)

1061 return 
REG_NOERROR
;

1065 if (
src1
->
nelem
 + 
src2
->nelem + 
dest
->nelem > dest->
alloc
)

1067 
Idx
 
new_alloc
 = 
src1
->
nelem
 + 
src2
->nelem + 
dest
->
alloc
;

1068 
Idx
 *
new_elems
 = 
	`re_realloc
 (
dest
->
elems
, Idx, 
new_alloc
);

1069 if (
	`BE
 (
new_elems
 == 
NULL
, 0))

1070 return 
REG_ESPACE
;

1071 
dest
->
elems
 = 
new_elems
;

1072 
dest
->
alloc
 = 
new_alloc
;

1077 
sbase
 = 
dest
->
nelem
 + 
src1
->nelem + 
src2
->nelem;

1078 
i1
 = 
src1
->
nelem
 - 1;

1079 
i2
 = 
src2
->
nelem
 - 1;

1080 
id
 = 
dest
->
nelem
 - 1;

1083 if (
src1
->
elems
[
i1
] == 
src2
->elems[
i2
])

1086 while (
	`REG_VALID_INDEX
 (
id
) && 
dest
->
elems
[id] > 
src1
->elems[
i1
])

1087 --
id
;

1089 if (! 
	`REG_VALID_INDEX
 (
id
) || 
dest
->
elems
[id] != 
src1
->elems[
i1
])

1090 
dest
->
elems
[--
sbase
] = 
src1
->elems[
i1
];

1092 if (! 
	`REG_VALID_INDEX
 (--
i1
) || ! REG_VALID_INDEX (--
i2
))

1097 else if (
src1
->
elems
[
i1
] < 
src2
->elems[
i2
])

1099 if (! 
	`REG_VALID_INDEX
 (--
i2
))

1104 if (! 
	`REG_VALID_INDEX
 (--
i1
))

1109 
id
 = 
dest
->
nelem
 - 1;

1110 
is
 = 
dest
->
nelem
 + 
src1
->nelem + 
src2
->nelem - 1;

1111 
delta
 = 
is
 - 
sbase
 + 1;

1116 
dest
->
nelem
 += 
delta
;

1117 if (
delta
 > 0 && 
	`REG_VALID_INDEX
 (
id
))

1120 if (
dest
->
elems
[
is
] > dest->elems[
id
])

1123 
dest
->
elems
[
id
 + 
delta
--] = dest->elems[
is
--];

1124 if (
delta
 == 0)

1130 
dest
->
elems
[
id
 + 
delta
] = dest->elems[id];

1131 if (! 
	`REG_VALID_INDEX
 (--
id
))

1137 
	`memcpy
 (
dest
->
elems
, dest->elems + 
sbase
, 
delta
 * sizeof (
Idx
));

1139 return 
REG_NOERROR
;

1140 
	}
}

1145 static 
reg_errcode_t


1146 
internal_function
 
__attribute_warn_unused_result__


1147 
	$re_node_set_init_union
 (
re_node_set
 *
dest
, const re_node_set *
src1
,

1148 const 
re_node_set
 *
src2
)

1150 
Idx
 
i1
, 
i2
, 
id
;

1151 if (
src1
 != 
NULL
 && src1->
nelem
 > 0 && 
src2
 != NULL && src2->nelem > 0)

1153 
dest
->
alloc
 = 
src1
->
nelem
 + 
src2
->nelem;

1154 
dest
->
elems
 = 
	`re_malloc
 (
Idx
, dest->
alloc
);

1155 if (
	`BE
 (
dest
->
elems
 == 
NULL
, 0))

1156 return 
REG_ESPACE
;

1160 if (
src1
 != 
NULL
 && src1->
nelem
 > 0)

1161 return 
	`re_node_set_init_copy
 (
dest
, 
src1
);

1162 else if (
src2
 != 
NULL
 && src2->
nelem
 > 0)

1163 return 
	`re_node_set_init_copy
 (
dest
, 
src2
);

1165 
	`re_node_set_init_empty
 (
dest
);

1166 return 
REG_NOERROR
;

1168 for (
i1
 = 
i2
 = 
id
 = 0 ; i1 < 
src1
->
nelem
 && i2 < 
src2
->nelem ;)

1170 if (
src1
->
elems
[
i1
] > 
src2
->elems[
i2
])

1172 
dest
->
elems
[
id
++] = 
src2
->elems[
i2
++];

1175 if (
src1
->
elems
[
i1
] == 
src2
->elems[
i2
])

1176 ++
i2
;

1177 
dest
->
elems
[
id
++] = 
src1
->elems[
i1
++];

1179 if (
i1
 < 
src1
->
nelem
)

1181 
	`memcpy
 (
dest
->
elems
 + 
id
, 
src1
->elems + 
i1
,

1182 (
src1
->
nelem
 - 
i1
) * sizeof (
Idx
));

1183 
id
 += 
src1
->
nelem
 - 
i1
;

1185 else if (
i2
 < 
src2
->
nelem
)

1187 
	`memcpy
 (
dest
->
elems
 + 
id
, 
src2
->elems + 
i2
,

1188 (
src2
->
nelem
 - 
i2
) * sizeof (
Idx
));

1189 
id
 += 
src2
->
nelem
 - 
i2
;

1191 
dest
->
nelem
 = 
id
;

1192 return 
REG_NOERROR
;

1193 
	}
}

1198 static 
reg_errcode_t


1199 
internal_function
 
__attribute_warn_unused_result__


1200 
	$re_node_set_merge
 (
re_node_set
 *
dest
, const re_node_set *
src
)

1202 
Idx
 
is
, 
id
, 
sbase
, 
delta
;

1203 if (
src
 == 
NULL
 || src->
nelem
 == 0)

1204 return 
REG_NOERROR
;

1205 if (
dest
->
alloc
 < 2 * 
src
->
nelem
 + dest->nelem)

1207 
Idx
 
new_alloc
 = 2 * (
src
->
nelem
 + 
dest
->
alloc
);

1208 
Idx
 *
new_buffer
 = 
	`re_realloc
 (
dest
->
elems
, Idx, 
new_alloc
);

1209 if (
	`BE
 (
new_buffer
 == 
NULL
, 0))

1210 return 
REG_ESPACE
;

1211 
dest
->
elems
 = 
new_buffer
;

1212 
dest
->
alloc
 = 
new_alloc
;

1215 if (
	`BE
 (
dest
->
nelem
 == 0, 0))

1217 
dest
->
nelem
 = 
src
->nelem;

1218 
	`memcpy
 (
dest
->
elems
, 
src
->elems, src->
nelem
 * sizeof (
Idx
));

1219 return 
REG_NOERROR
;

1224 for (
sbase
 = 
dest
->
nelem
 + 2 * 
src
->nelem,

1225 
is
 = 
src
->
nelem
 - 1, 
id
 = 
dest
->nelem - 1;

1226 
	`REG_VALID_INDEX
 (
is
) && REG_VALID_INDEX (
id
); )

1228 if (
dest
->
elems
[
id
] == 
src
->elems[
is
])

1229 
is
--, 
id
--;

1230 else if (
dest
->
elems
[
id
] < 
src
->elems[
is
])

1231 
dest
->
elems
[--
sbase
] = 
src
->elems[
is
--];

1233 --
id
;

1236 if (
	`REG_VALID_INDEX
 (
is
))

1239 
sbase
 -= 
is
 + 1;

1240 
	`memcpy
 (
dest
->
elems
 + 
sbase
, 
src
->elems, (
is
 + 1) * sizeof (
Idx
));

1243 
id
 = 
dest
->
nelem
 - 1;

1244 
is
 = 
dest
->
nelem
 + 2 * 
src
->nelem - 1;

1245 
delta
 = 
is
 - 
sbase
 + 1;

1246 if (
delta
 == 0)

1247 return 
REG_NOERROR
;

1251 
dest
->
nelem
 += 
delta
;

1254 if (
dest
->
elems
[
is
] > dest->elems[
id
])

1257 
dest
->
elems
[
id
 + 
delta
--] = dest->elems[
is
--];

1258 if (
delta
 == 0)

1264 
dest
->
elems
[
id
 + 
delta
] = dest->elems[id];

1265 if (! 
	`REG_VALID_INDEX
 (--
id
))

1268 
	`memcpy
 (
dest
->
elems
, dest->elems + 
sbase
,

1269 
delta
 * sizeof (
Idx
));

1275 return 
REG_NOERROR
;

1276 
	}
}

1282 static 
bool


1283 
internal_function
 
__attribute_warn_unused_result__


1284 
	$re_node_set_insert
 (
re_node_set
 *
set
, 
Idx
 
elem
)

1286 
Idx
 
idx
;

1288 if (
set
->
alloc
 == 0)

1289 return 
	`BE
 (
	`re_node_set_init_1
 (
set
, 
elem
) == 
REG_NOERROR
, 1);

1291 if (
	`BE
 (
set
->
nelem
, 0) == 0)

1294 
set
->
elems
[0] = 
elem
;

1295 ++
set
->
nelem
;

1296 return 
true
;

1300 if (
set
->
alloc
 == set->
nelem
)

1302 
Idx
 *
new_elems
;

1303 
set
->
alloc
 = set->alloc * 2;

1304 
new_elems
 = 
	`re_realloc
 (
set
->
elems
, 
Idx
, set->
alloc
);

1305 if (
	`BE
 (
new_elems
 == 
NULL
, 0))

1306 return 
false
;

1307 
set
->
elems
 = 
new_elems
;

1312 if (
elem
 < 
set
->
elems
[0])

1314 
idx
 = 0;

1315 for (
idx
 = 
set
->
nelem
; idx > 0; idx--)

1316 
set
->
elems
[
idx
] = set->elems[idx - 1];

1320 for (
idx
 = 
set
->
nelem
; set->
elems
[idx - 1] > 
elem
; idx--)

1321 
set
->
elems
[
idx
] = set->elems[idx - 1];

1325 
set
->
elems
[
idx
] = 
elem
;

1326 ++
set
->
nelem
;

1327 return 
true
;

1328 
	}
}

1334 static 
bool


1335 
internal_function
 
__attribute_warn_unused_result__


1336 
	$re_node_set_insert_last
 (
re_node_set
 *
set
, 
Idx
 
elem
)

1339 if (
set
->
alloc
 == set->
nelem
)

1341 
Idx
 *
new_elems
;

1342 
set
->
alloc
 = (set->alloc + 1) * 2;

1343 
new_elems
 = 
	`re_realloc
 (
set
->
elems
, 
Idx
, set->
alloc
);

1344 if (
	`BE
 (
new_elems
 == 
NULL
, 0))

1345 return 
false
;

1346 
set
->
elems
 = 
new_elems
;

1350 
set
->
elems
[set->
nelem
++] = 
elem
;

1351 return 
true
;

1352 
	}
}

1357 static 
bool


1358 
internal_function
 
__attribute
 ((
pure
))

1359 
	$re_node_set_compare
 (const 
re_node_set
 *
set1
, const re_node_set *
set2
)

1361 
Idx
 
i
;

1362 if (
set1
 == 
NULL
 || 
set2
 == NULL || set1->
nelem
 != set2->nelem)

1363 return 
false
;

1364 for (
i
 = 
set1
->
nelem
 ; 
	`REG_VALID_INDEX
 (--i) ; )

1365 if (
set1
->
elems
[
i
] != 
set2
->elems[i])

1366 return 
false
;

1367 return 
true
;

1368 
	}
}

1372 static 
Idx


1373 
internal_function
 
__attribute
 ((
pure
))

1374 
	$re_node_set_contains
 (const 
re_node_set
 *
set
, 
Idx
 
elem
)

1376 
__re_size_t
 
idx
, 
right
, 
mid
;

1377 if (! 
	`REG_VALID_NONZERO_INDEX
 (
set
->
nelem
))

1381 
idx
 = 0;

1382 
right
 = 
set
->
nelem
 - 1;

1383 while (
idx
 < 
right
)

1385 
mid
 = (
idx
 + 
right
) / 2;

1386 if (
set
->
elems
[
mid
] < 
elem
)

1387 
idx
 = 
mid
 + 1;

1389 
right
 = 
mid
;

1391 return 
set
->
elems
[
idx
] == 
elem
 ? idx + 1 : 0;

1392 
	}
}

1395 
internal_function


1396 
	$re_node_set_remove_at
 (
re_node_set
 *
set
, 
Idx
 
idx
)

1398 
	`verify
 (! 
	`TYPE_SIGNED
 (
Idx
));

1401 if (
idx
 >= 
set
->
nelem
)

1403 --
set
->
nelem
;

1404 for (; 
idx
 < 
set
->
nelem
; idx++)

1405 
set
->
elems
[
idx
] = set->elems[idx + 1];

1406 
	}
}

1412 static 
Idx


1413 
internal_function


1414 
	$re_dfa_add_node
 (
re_dfa_t
 *
dfa
, 
re_token_t
 
token
)

1416 if (
	`BE
 (
dfa
->
nodes_len
 >= dfa->
nodes_alloc
, 0))

1418 
size_t
 
new_nodes_alloc
 = 
dfa
->
nodes_alloc
 * 2;

1419 
Idx
 *
new_nexts
, *
new_indices
;

1420 
re_node_set
 *
new_edests
, *
new_eclosures
;

1421 
re_token_t
 *
new_nodes
;

1422 
size_t
 
max_object_size
 =

1423 
	`MAX
 (sizeof (
re_token_t
),

1424 
	`MAX
 (sizeof (
re_node_set
),

1425 sizeof (
Idx
)));

1428 if (
	`BE
 (
SIZE_MAX
 / 2 / 
max_object_size
 < 
dfa
->
nodes_alloc
, 0))

1429 return 
REG_MISSING
;

1431 
new_nodes
 = 
	`re_realloc
 (
dfa
->
nodes
, 
re_token_t
, 
new_nodes_alloc
);

1432 if (
	`BE
 (
new_nodes
 == 
NULL
, 0))

1433 return 
REG_MISSING
;

1434 
dfa
->
nodes
 = 
new_nodes
;

1435 
new_nexts
 = 
	`re_realloc
 (
dfa
->
nexts
, 
Idx
, 
new_nodes_alloc
);

1436 
new_indices
 = 
	`re_realloc
 (
dfa
->
org_indices
, 
Idx
, 
new_nodes_alloc
);

1437 
new_edests
 = 
	`re_realloc
 (
dfa
->
edests
, 
re_node_set
, 
new_nodes_alloc
);

1438 
new_eclosures
 = 
	`re_realloc
 (
dfa
->
eclosures
, 
re_node_set
, 
new_nodes_alloc
);

1439 if (
	`BE
 (
new_nexts
 == 
NULL
 || 
new_indices
 == NULL

1440 || 
new_edests
 == 
NULL
 || 
new_eclosures
 == NULL, 0))

1441 return 
REG_MISSING
;

1442 
dfa
->
nexts
 = 
new_nexts
;

1443 
dfa
->
org_indices
 = 
new_indices
;

1444 
dfa
->
edests
 = 
new_edests
;

1445 
dfa
->
eclosures
 = 
new_eclosures
;

1446 
dfa
->
nodes_alloc
 = 
new_nodes_alloc
;

1448 
dfa
->
nodes
[dfa->
nodes_len
] = 
token
;

1449 
dfa
->
nodes
[dfa->
nodes_len
].
constraint
 = 0;

1450 #ifdef 
RE_ENABLE_I18N


1452 int 
type
 = 
token
.type;

1453 
dfa
->
nodes
[dfa->
nodes_len
].
accept_mb
 =

1454 (
type
 == 
OP_PERIOD
 && 
dfa
->
mb_cur_max
 > 1) || type == 
COMPLEX_BRACKET
;

1457 
dfa
->
nexts
[dfa->
nodes_len
] = 
REG_MISSING
;

1458 
	`re_node_set_init_empty
 (
dfa
->
edests
 + dfa->
nodes_len
);

1459 
	`re_node_set_init_empty
 (
dfa
->
eclosures
 + dfa->
nodes_len
);

1460 return 
dfa
->
nodes_len
++;

1461 
	}
}

1463 static 
inline
 
re_hashval_t


1464 
internal_function


1465 
	$calc_state_hash
 (const 
re_node_set
 *
nodes
, unsigned int 
context
)

1467 
re_hashval_t
 
hash
 = 
nodes
->
nelem
 + 
context
;

1468 
Idx
 
i
;

1469 for (
i
 = 0 ; i < 
nodes
->
nelem
 ; i++)

1470 
hash
 += 
nodes
->
elems
[
i
];

1471 return 
hash
;

1472 
	}
}

1483 static 
re_dfastate_t
 *

1484 
internal_function
 
__attribute_warn_unused_result__


1485 
	$re_acquire_state
 (
reg_errcode_t
 *
err
, const 
re_dfa_t
 *
dfa
,

1486 const 
re_node_set
 *
nodes
)

1488 
re_hashval_t
 
hash
;

1489 
re_dfastate_t
 *
new_state
;

1490 struct 
re_state_table_entry
 *
spot
;

1491 
Idx
 
i
;

1492 #ifdef 
lint


1494 *
err
 = 
REG_NOERROR
;

1496 if (
	`BE
 (
nodes
->
nelem
 == 0, 0))

1498 *
err
 = 
REG_NOERROR
;

1499 return 
NULL
;

1501 
hash
 = 
	`calc_state_hash
 (
nodes
, 0);

1502 
spot
 = 
dfa
->
state_table
 + (
hash
 & dfa->
state_hash_mask
);

1504 for (
i
 = 0 ; i < 
spot
->
num
 ; i++)

1506 
re_dfastate_t
 *
state
 = 
spot
->
array
[
i
];

1507 if (
hash
 != 
state
->hash)

1509 if (
	`re_node_set_compare
 (&
state
->
nodes
, nodes))

1510 return 
state
;

1514 
new_state
 = 
	`create_ci_newstate
 (
dfa
, 
nodes
, 
hash
);

1515 if (
	`BE
 (
new_state
 == 
NULL
, 0))

1516 *
err
 = 
REG_ESPACE
;

1518 return 
new_state
;

1519 
	}
}

1531 static 
re_dfastate_t
 *

1532 
internal_function
 
__attribute_warn_unused_result__


1533 
	$re_acquire_state_context
 (
reg_errcode_t
 *
err
, const 
re_dfa_t
 *
dfa
,

1534 const 
re_node_set
 *
nodes
, unsigned int 
context
)

1536 
re_hashval_t
 
hash
;

1537 
re_dfastate_t
 *
new_state
;

1538 struct 
re_state_table_entry
 *
spot
;

1539 
Idx
 
i
;

1540 #ifdef 
lint


1542 *
err
 = 
REG_NOERROR
;

1544 if (
nodes
->
nelem
 == 0)

1546 *
err
 = 
REG_NOERROR
;

1547 return 
NULL
;

1549 
hash
 = 
	`calc_state_hash
 (
nodes
, 
context
);

1550 
spot
 = 
dfa
->
state_table
 + (
hash
 & dfa->
state_hash_mask
);

1552 for (
i
 = 0 ; i < 
spot
->
num
 ; i++)

1554 
re_dfastate_t
 *
state
 = 
spot
->
array
[
i
];

1555 if (
state
->
hash
 == hash

1556 && 
state
->
context
 == context

1557 && 
	`re_node_set_compare
 (
state
->
entrance_nodes
, 
nodes
))

1558 return 
state
;

1561 
new_state
 = 
	`create_cd_newstate
 (
dfa
, 
nodes
, 
context
, 
hash
);

1562 if (
	`BE
 (
new_state
 == 
NULL
, 0))

1563 *
err
 = 
REG_ESPACE
;

1565 return 
new_state
;

1566 
	}
}

1572 static 
reg_errcode_t


1573 
__attribute_warn_unused_result__


1574 
	$register_state
 (const 
re_dfa_t
 *
dfa
, 
re_dfastate_t
 *
newstate
,

1575 
re_hashval_t
 
hash
)

1577 struct 
re_state_table_entry
 *
spot
;

1578 
reg_errcode_t
 
err
;

1579 
Idx
 
i
;

1581 
newstate
->
hash
 = hash;

1582 
err
 = 
	`re_node_set_alloc
 (&
newstate
->
non_eps_nodes
, newstate->
nodes
.
nelem
);

1583 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1584 return 
REG_ESPACE
;

1585 for (
i
 = 0; i < 
newstate
->
nodes
.
nelem
; i++)

1587 
Idx
 
elem
 = 
newstate
->
nodes
.
elems
[
i
];

1588 if (!
	`IS_EPSILON_NODE
 (
dfa
->
nodes
[
elem
].
type
))

1589 if (
	`BE
 (! 
	`re_node_set_insert_last
 (&
newstate
->
non_eps_nodes
, 
elem
), 0))

1590 return 
REG_ESPACE
;

1593 
spot
 = 
dfa
->
state_table
 + (
hash
 & dfa->
state_hash_mask
);

1594 if (
	`BE
 (
spot
->
alloc
 <= spot->
num
, 0))

1596 
Idx
 
new_alloc
 = 2 * 
spot
->
num
 + 2;

1597 
re_dfastate_t
 **
new_array
 = 
	`re_realloc
 (
spot
->
array
, re_dfastate_t *,

1598 
new_alloc
);

1599 if (
	`BE
 (
new_array
 == 
NULL
, 0))

1600 return 
REG_ESPACE
;

1601 
spot
->
array
 = 
new_array
;

1602 
spot
->
alloc
 = 
new_alloc
;

1604 
spot
->
array
[spot->
num
++] = 
newstate
;

1605 return 
REG_NOERROR
;

1606 
	}
}

1609 
	$free_state
 (
re_dfastate_t
 *
state
)

1611 
	`re_node_set_free
 (&
state
->
non_eps_nodes
);

1612 
	`re_node_set_free
 (&
state
->
inveclosure
);

1613 if (
state
->
entrance_nodes
 != &state->
nodes
)

1615 
	`re_node_set_free
 (
state
->
entrance_nodes
);

1616 
	`re_free
 (
state
->
entrance_nodes
);

1618 
	`re_node_set_free
 (&
state
->
nodes
);

1619 
	`re_free
 (
state
->
word_trtable
);

1620 
	`re_free
 (
state
->
trtable
);

1621 
	`re_free
 (
state
);

1622 
	}
}

1627 static 
re_dfastate_t
 *

1628 
internal_function
 
__attribute_warn_unused_result__


1629 
	$create_ci_newstate
 (const 
re_dfa_t
 *
dfa
, const 
re_node_set
 *
nodes
,

1630 
re_hashval_t
 
hash
)

1632 
Idx
 
i
;

1633 
reg_errcode_t
 
err
;

1634 
re_dfastate_t
 *
newstate
;

1636 
newstate
 = (
re_dfastate_t
 *) 
	`calloc
 (sizeof (re_dfastate_t), 1);

1637 if (
	`BE
 (
newstate
 == 
NULL
, 0))

1638 return 
NULL
;

1639 
err
 = 
	`re_node_set_init_copy
 (&
newstate
->
nodes
, nodes);

1640 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1642 
	`re_free
 (
newstate
);

1643 return 
NULL
;

1646 
newstate
->
entrance_nodes
 = &newstate->
nodes
;

1647 for (
i
 = 0 ; i < 
nodes
->
nelem
 ; i++)

1649 
re_token_t
 *
node
 = 
dfa
->
nodes
 + nodes->
elems
[
i
];

1650 
re_token_type_t
 
type
 = 
node
->type;

1651 if (
type
 == 
CHARACTER
 && !
node
->
constraint
)

1653 #ifdef 
RE_ENABLE_I18N


1654 
newstate
->
accept_mb
 |= 
node
->accept_mb;

1658 if (
type
 == 
END_OF_RE
)

1659 
newstate
->
halt
 = 1;

1660 else if (
type
 == 
OP_BACK_REF
)

1661 
newstate
->
has_backref
 = 1;

1662 else if (
type
 == 
ANCHOR
 || 
node
->
constraint
)

1663 
newstate
->
has_constraint
 = 1;

1665 
err
 = 
	`register_state
 (
dfa
, 
newstate
, 
hash
);

1666 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1668 
	`free_state
 (
newstate
);

1669 
newstate
 = 
NULL
;

1671 return 
newstate
;

1672 
	}
}

1677 static 
re_dfastate_t
 *

1678 
internal_function
 
__attribute_warn_unused_result__


1679 
	$create_cd_newstate
 (const 
re_dfa_t
 *
dfa
, const 
re_node_set
 *
nodes
,

1680 unsigned int 
context
, 
re_hashval_t
 
hash
)

1682 
Idx
 
i
, 
nctx_nodes
 = 0;

1683 
reg_errcode_t
 
err
;

1684 
re_dfastate_t
 *
newstate
;

1686 
newstate
 = (
re_dfastate_t
 *) 
	`calloc
 (sizeof (re_dfastate_t), 1);

1687 if (
	`BE
 (
newstate
 == 
NULL
, 0))

1688 return 
NULL
;

1689 
err
 = 
	`re_node_set_init_copy
 (&
newstate
->
nodes
, nodes);

1690 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1692 
	`re_free
 (
newstate
);

1693 return 
NULL
;

1696 
newstate
->
context
 = context;

1697 
newstate
->
entrance_nodes
 = &newstate->
nodes
;

1699 for (
i
 = 0 ; i < 
nodes
->
nelem
 ; i++)

1701 
re_token_t
 *
node
 = 
dfa
->
nodes
 + nodes->
elems
[
i
];

1702 
re_token_type_t
 
type
 = 
node
->type;

1703 unsigned int 
constraint
 = 
node
->constraint;

1705 if (
type
 == 
CHARACTER
 && !
constraint
)

1707 #ifdef 
RE_ENABLE_I18N


1708 
newstate
->
accept_mb
 |= 
node
->accept_mb;

1712 if (
type
 == 
END_OF_RE
)

1713 
newstate
->
halt
 = 1;

1714 else if (
type
 == 
OP_BACK_REF
)

1715 
newstate
->
has_backref
 = 1;

1717 if (
constraint
)

1719 if (
newstate
->
entrance_nodes
 == &newstate->
nodes
)

1721 
newstate
->
entrance_nodes
 = 
	`re_malloc
 (
re_node_set
, 1);

1722 if (
	`BE
 (
newstate
->
entrance_nodes
 == 
NULL
, 0))

1724 
	`free_state
 (
newstate
);

1725 return 
NULL
;

1727 if (
	`re_node_set_init_copy
 (
newstate
->
entrance_nodes
, 
nodes
)

1728 != 
REG_NOERROR
)

1729 return 
NULL
;

1730 
nctx_nodes
 = 0;

1731 
newstate
->
has_constraint
 = 1;

1734 if (
	`NOT_SATISFY_PREV_CONSTRAINT
 (
constraint
,
context
))

1736 
	`re_node_set_remove_at
 (&
newstate
->
nodes
, 
i
 - 
nctx_nodes
);

1737 ++
nctx_nodes
;

1741 
err
 = 
	`register_state
 (
dfa
, 
newstate
, 
hash
);

1742 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1744 
	`free_state
 (
newstate
);

1745 
newstate
 = 
NULL
;

1747 return 
newstate
;

1748 
	}
}

	@lib/regex_internal.h

22 #ifndef 
_REGEX_INTERNAL_H


23 #define 
	#_REGEX_INTERNAL_H
 1

	)

25 #include 
	~<assert.h
>

26 #include 
	~<ctype.h
>

27 #include 
	~<stdbool.h
>

28 #include 
	~<stdio.h
>

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

32 #include 
	~<langinfo.h
>

33 #ifndef 
_LIBC


34 #include 
	~"localcharset.h
"

36 #include 
	~<locale.h
>

38 #include 
	~<wchar.h
>

39 #include 
	~<wctype.h
>

40 #include 
	~<stdint.h
>

41 #if 
defined
 
_LIBC


42 #include 
	~<bits/libc-lock.h
>

44 #define 
	#__libc_lock_init
(
NAME
) do { } while (0)

	)

45 #define 
	#__libc_lock_lock
(
NAME
) do { } while (0)

	)

46 #define 
	#__libc_lock_unlock
(
NAME
) do { } while (0)

	)

50 #if !
defined
 
_LIBC
 && ! (defined 
isblank
 || (
HAVE_ISBLANK
 && 
HAVE_DECL_ISBLANK
))

51 #define 
	#isblank
(
ch
) ((ch) == ' ' || (ch) == '\t')

	)

54 #ifdef 
_LIBC


55 #ifndef 
_RE_DEFINE_LOCALE_FUNCTIONS


56 #define 
	#_RE_DEFINE_LOCALE_FUNCTIONS
 1

	)

57 #include 
	~<locale/localeinfo.h
>

58 #include 
	~<locale/elem-hash.h
>

59 #include 
	~<locale/coll-lookup.h
>

64 #if (
HAVE_LIBINTL_H
 && 
ENABLE_NLS
) || 
defined
 
_LIBC


65 #include 
	~<libintl.h
>

66 #ifdef 
_LIBC


67 #undef 
gettext


68 #define 
	#gettext
(
msgid
) \

69 
	`INTUSE
(
__dcgettext
) (
_libc_intl_domainname
, 
msgid
, 
LC_MESSAGES
)

	)

72 #define 
	#gettext
(
msgid
) (msgid)

	)

75 #ifndef 
gettext_noop


78 #define 
	#gettext_noop
(
String
) 
	)
String

82 #ifndef 
SIZE_MAX


83 #define 
	#SIZE_MAX
 ((
size_t
) -1)

	)

86 #if (
defined
 
MB_CUR_MAX
 && 
HAVE_WCTYPE_H
 && 
HAVE_ISWCTYPE
 && 
HAVE_WCSCOLL
) || 
_LIBC


87 #define 
	#RE_ENABLE_I18N


	)

90 #if 
__GNUC__
 >= 3

91 #define 
	#BE
(
expr
, 
val
) 
	`__builtin_expect
 (expr, val)

	)

93 #define 
	#BE
(
expr
, 
val
) (expr)

	)

94 #ifdef 
_LIBC


95 #define 
	#inline


	)

100 #define 
	#ASCII_CHARS
 0x80

	)

103 #define 
	#SBC_MAX
 (
UCHAR_MAX
 + 1)

	)

105 #define 
	#COLL_ELEM_LEN_MAX
 8

	)

108 #define 
	#NEWLINE_CHAR
 '\n'

	)

109 #define 
	#WIDE_NEWLINE_CHAR
 
L
'\n'

	)

112 #ifndef 
_LIBC


113 #define 
	#__wctype
 
wctype


	)

114 #define 
	#__iswctype
 
iswctype


	)

115 #define 
	#__btowc
 
btowc


	)

116 #define 
	#__wcrtomb
 
wcrtomb


	)

117 #define 
	#__mbrtowc
 
mbrtowc


	)

118 #define 
	#__regfree
 
regfree


	)

119 #define 
	#attribute_hidden


	)

122 #if 
__GNUC__
 >= 4 || (__GNUC__ == 3 && 
__GNUC_MINOR__
 >= 1)

123 #define 
	#__attribute
(
arg
) 
	`__attribute__
 (arg)

	)

125 #define 
	#__attribute
(
arg
)

	)

128 typedef 
__re_idx_t
 
	tIdx
;

131 #define 
	#REG_MISSING
 ((
Idx
) -1)

	)

134 #define 
	#REG_ERROR
 ((
Idx
) -2)

	)

137 #ifdef 
_REGEX_LARGE_OFFSETS


138 #define 
	#REG_VALID_INDEX
(
n
) ((
Idx
) (n) < 
REG_ERROR
)

	)

140 #define 
	#REG_VALID_INDEX
(
n
) (0 <= (n))

	)

144 #ifdef 
_REGEX_LARGE_OFFSETS


145 #define 
	#REG_VALID_NONZERO_INDEX
(
n
) ((
Idx
) ((n) - 1) < (Idx) (
REG_ERROR
 - 1))

	)

147 #define 
	#REG_VALID_NONZERO_INDEX
(
n
) (0 < (n))

	)

151 typedef 
__re_size_t
 
	tre_hashval_t
;

155 typedef unsigned long int 
	tbitset_word_t
;

157 #define 
	#BITSET_WORD_MAX
 
ULONG_MAX


	)

164 #if 
BITSET_WORD_MAX
 == 0xffffffffUL

165 #define 
	#BITSET_WORD_BITS
 32

	)

166 #elif 
BITSET_WORD_MAX
 >> 31 >> 4 == 1

167 #define 
	#BITSET_WORD_BITS
 36

	)

168 #elif 
BITSET_WORD_MAX
 >> 31 >> 16 == 1

169 #define 
	#BITSET_WORD_BITS
 48

	)

170 #elif 
BITSET_WORD_MAX
 >> 31 >> 28 == 1

171 #define 
	#BITSET_WORD_BITS
 60

	)

172 #elif 
BITSET_WORD_MAX
 >> 31 >> 31 >> 1 == 1

173 #define 
	#BITSET_WORD_BITS
 64

	)

174 #elif 
BITSET_WORD_MAX
 >> 31 >> 31 >> 9 == 1

175 #define 
	#BITSET_WORD_BITS
 72

	)

176 #elif 
BITSET_WORD_MAX
 >> 31 >> 31 >> 31 >> 31 >> 3 == 1

177 #define 
	#BITSET_WORD_BITS
 128

	)

178 #elif 
BITSET_WORD_MAX
 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 7 == 1

179 #define 
	#BITSET_WORD_BITS
 256

	)

180 #elif 
BITSET_WORD_MAX
 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 7 > 1

181 #define 
	#BITSET_WORD_BITS
 257

	)

182 #if 
BITSET_WORD_BITS
 <= 
SBC_MAX


190 #define 
	#BITSET_WORDS
 ((
SBC_MAX
 + 
BITSET_WORD_BITS
 - 1) / BITSET_WORD_BITS)

	)

192 typedef 
bitset_word_t
 
	tbitset_t
[
BITSET_WORDS
];

193 typedef 
bitset_word_t
 *
	tre_bitset_ptr_t
;

194 typedef const 
	tbitset_word_t
 *
	tre_const_bitset_ptr_t
;

196 #define 
	#PREV_WORD_CONSTRAINT
 0x0001

	)

197 #define 
	#PREV_NOTWORD_CONSTRAINT
 0x0002

	)

198 #define 
	#NEXT_WORD_CONSTRAINT
 0x0004

	)

199 #define 
	#NEXT_NOTWORD_CONSTRAINT
 0x0008

	)

200 #define 
	#PREV_NEWLINE_CONSTRAINT
 0x0010

	)

201 #define 
	#NEXT_NEWLINE_CONSTRAINT
 0x0020

	)

202 #define 
	#PREV_BEGBUF_CONSTRAINT
 0x0040

	)

203 #define 
	#NEXT_ENDBUF_CONSTRAINT
 0x0080

	)

204 #define 
	#WORD_DELIM_CONSTRAINT
 0x0100

	)

205 #define 
	#NOT_WORD_DELIM_CONSTRAINT
 0x0200

	)

209 
	mINSIDE_WORD
 = 
PREV_WORD_CONSTRAINT
 | 
NEXT_WORD_CONSTRAINT
,

210 
	mWORD_FIRST
 = 
PREV_NOTWORD_CONSTRAINT
 | 
NEXT_WORD_CONSTRAINT
,

211 
	mWORD_LAST
 = 
PREV_WORD_CONSTRAINT
 | 
NEXT_NOTWORD_CONSTRAINT
,

212 
	mINSIDE_NOTWORD
 = 
PREV_NOTWORD_CONSTRAINT
 | 
NEXT_NOTWORD_CONSTRAINT
,

213 
	mLINE_FIRST
 = 
PREV_NEWLINE_CONSTRAINT
,

214 
	mLINE_LAST
 = 
NEXT_NEWLINE_CONSTRAINT
,

215 
	mBUF_FIRST
 = 
PREV_BEGBUF_CONSTRAINT
,

216 
	mBUF_LAST
 = 
NEXT_ENDBUF_CONSTRAINT
,

217 
	mWORD_DELIM
 = 
WORD_DELIM_CONSTRAINT
,

218 
	mNOT_WORD_DELIM
 = 
NOT_WORD_DELIM_CONSTRAINT


219 } 
	tre_context_type
;

223 
Idx
 
	malloc
;

224 
Idx
 
	mnelem
;

225 
Idx
 *
	melems
;

226 } 
	tre_node_set
;

230 
	mNON_TYPE
 = 0,

233 
	mCHARACTER
 = 1,

234 
	mEND_OF_RE
 = 2,

235 
	mSIMPLE_BRACKET
 = 3,

236 
	mOP_BACK_REF
 = 4,

237 
	mOP_PERIOD
 = 5,

238 #ifdef 
RE_ENABLE_I18N


239 
	mCOMPLEX_BRACKET
 = 6,

240 
	mOP_UTF8_PERIOD
 = 7,

245 #define 
	#EPSILON_BIT
 8

	)

246 
	mOP_OPEN_SUBEXP
 = 
EPSILON_BIT
 | 0,

247 
	mOP_CLOSE_SUBEXP
 = 
EPSILON_BIT
 | 1,

248 
	mOP_ALT
 = 
EPSILON_BIT
 | 2,

249 
	mOP_DUP_ASTERISK
 = 
EPSILON_BIT
 | 3,

250 
	mANCHOR
 = 
EPSILON_BIT
 | 4,

253 
	mCONCAT
 = 16,

254 
	mSUBEXP
 = 17,

257 
	mOP_DUP_PLUS
 = 18,

258 
	mOP_DUP_QUESTION
,

259 
	mOP_OPEN_BRACKET
,

260 
	mOP_CLOSE_BRACKET
,

261 
	mOP_CHARSET_RANGE
,

262 
	mOP_OPEN_DUP_NUM
,

263 
	mOP_CLOSE_DUP_NUM
,

264 
	mOP_NON_MATCH_LIST
,

265 
	mOP_OPEN_COLL_ELEM
,

266 
	mOP_CLOSE_COLL_ELEM
,

267 
	mOP_OPEN_EQUIV_CLASS
,

268 
	mOP_CLOSE_EQUIV_CLASS
,

269 
	mOP_OPEN_CHAR_CLASS
,

270 
	mOP_CLOSE_CHAR_CLASS
,

271 
	mOP_WORD
,

272 
	mOP_NOTWORD
,

273 
	mOP_SPACE
,

274 
	mOP_NOTSPACE
,

275 
	mBACK_SLASH


277 } 
	tre_token_type_t
;

279 #ifdef 
RE_ENABLE_I18N


283 
wchar_t
 *
	mmbchars
;

286 #ifdef 
_LIBC


287 
int32_t
 *
	mcoll_syms
;

291 #ifdef 
_LIBC


292 
int32_t
 *
	mequiv_classes
;

296 #ifdef 
_LIBC


297 
uint32_t
 *
	mrange_starts
;

298 
uint32_t
 *
	mrange_ends
;

300 
wchar_t
 *
	mrange_starts
;

301 
wchar_t
 *
	mrange_ends
;

305 
wctype_t
 *
	mchar_classes
;

308 unsigned int 
	mnon_match
 : 1;

311 
Idx
 
	mnmbchars
;

314 
Idx
 
	mncoll_syms
;

317 
Idx
 
	mnequiv_classes
;

320 
Idx
 
	mnranges
;

323 
Idx
 
	mnchar_classes
;

324 } 
	tre_charset_t
;

331 unsigned char 
	mc
;

332 
re_bitset_ptr_t
 
	msbcset
;

333 #ifdef 
RE_ENABLE_I18N


334 
re_charset_t
 *
	mmbcset
;

336 
Idx
 
	midx
;

337 
re_context_type
 
	mctx_type
;

338 } 
	mopr
;

339 #if 
__GNUC__
 >= 2 && !
defined
 
__STRICT_ANSI__


340 
re_token_type_t
 
	mtype
 : 8;

342 
re_token_type_t
 
	mtype
;

344 unsigned int 
	mconstraint
 : 10;

345 unsigned int 
	mduplicated
 : 1;

346 unsigned int 
	mopt_subexp
 : 1;

347 #ifdef 
RE_ENABLE_I18N


348 unsigned int 
	maccept_mb
 : 1;

351 unsigned int 
	mmb_partial
 : 1;

353 unsigned int 
	mword_char
 : 1;

354 } 
	tre_token_t
;

356 #define 
	#IS_EPSILON_NODE
(
type
) ((type) & 
EPSILON_BIT
)

	)

358 struct 
	sre_string_t


362 const unsigned char *
	mraw_mbs
;

366 unsigned char *
	mmbs
;

367 #ifdef 
RE_ENABLE_I18N


369 
wint_t
 *
	mwcs
;

370 
Idx
 *
	moffsets
;

371 
mbstate_t
 
	mcur_state
;

375 
Idx
 
	mraw_mbs_idx
;

377 
Idx
 
	mvalid_len
;

379 
Idx
 
	mvalid_raw_len
;

381 
Idx
 
	mbufs_len
;

383 
Idx
 
	mcur_idx
;

385 
Idx
 
	mraw_len
;

387 
Idx
 
	mlen
;

391 
Idx
 
	mraw_stop
;

393 
Idx
 
	mstop
;

398 unsigned int 
	mtip_context
;

400 
RE_TRANSLATE_TYPE
 
	mtrans
;

402 
re_const_bitset_ptr_t
 
	mword_char
;

404 unsigned char 
	micase
;

405 unsigned char 
	mis_utf8
;

406 unsigned char 
	mmap_notascii
;

407 unsigned char 
	mmbs_allocated
;

408 unsigned char 
	moffsets_needed
;

409 unsigned char 
	mnewline_anchor
;

410 unsigned char 
	mword_ops_used
;

411 int 
	mmb_cur_max
;

413 typedef struct 
re_string_t
 
	tre_string_t
;

416 struct 
	gre_dfa_t
;

417 typedef struct 
re_dfa_t
 
	tre_dfa_t
;

419 #ifndef 
_LIBC


420 #define 
	#internal_function


	)

423 static 
reg_errcode_t
 
	$re_string_realloc_buffers
 (
re_string_t
 *
pstr
,

424 
Idx
 
new_buf_len
)

425 
internal_function
;

426 #ifdef 
RE_ENABLE_I18N


427 static void 
	$build_wcs_buffer
 (
re_string_t
 *
pstr
) 
internal_function
;

428 static 
reg_errcode_t
 
	$build_wcs_upper_buffer
 (
re_string_t
 *
pstr
)

429 
internal_function
;

431 static void 
	$build_upper_buffer
 (
re_string_t
 *
pstr
) 
internal_function
;

432 static void 
	$re_string_translate_buffer
 (
re_string_t
 *
pstr
) 
internal_function
;

433 static unsigned int 
	$re_string_context_at
 (const 
re_string_t
 *
input
, 
Idx
 
idx
,

434 int 
eflags
)

435 
internal_function
 
	`__attribute
 ((
pure
));

436 #define 
	#re_string_peek_byte
(
pstr
, 
offset
) \

437 ((
pstr
)->
mbs
[(pstr)->
cur_idx
 + 
offset
])

	)

438 #define 
	#re_string_fetch_byte
(
pstr
) \

439 ((
pstr
)->
mbs
[(pstr)->
cur_idx
++])

	)

440 #define 
	#re_string_first_byte
(
pstr
, 
idx
) \

441 ((
idx
) == (
pstr
)->
valid_len
 || (pstr)->
wcs
[idx] != 
WEOF
)

	)

442 #define 
	#re_string_is_single_byte_char
(
pstr
, 
idx
) \

443 ((
pstr
)->
wcs
[
idx
] != 
WEOF
 && ((pstr)->
valid_len
 == (idx) + 1 \

444 || (
pstr
)->
wcs
[(
idx
) + 1] != 
WEOF
))

	)

445 #define 
	#re_string_eoi
(
pstr
) ((pstr)->
stop
 <= (pstr)->
cur_idx
)

	)

446 #define 
	#re_string_cur_idx
(
pstr
) ((pstr)->
cur_idx
)

	)

447 #define 
	#re_string_get_buffer
(
pstr
) ((pstr)->
mbs
)

	)

448 #define 
	#re_string_length
(
pstr
) ((pstr)->
len
)

	)

449 #define 
	#re_string_byte_at
(
pstr
,
idx
) ((pstr)->
mbs
[idx])

	)

450 #define 
	#re_string_skip_bytes
(
pstr
,
idx
) ((pstr)->
cur_idx
 += (idx))

	)

451 #define 
	#re_string_set_index
(
pstr
,
idx
) ((pstr)->
cur_idx
 = (idx))

	)

453 #include 
	~<alloca.h
>

455 #ifndef 
_LIBC


456 #if 
HAVE_ALLOCA


461 #define 
	#__libc_use_alloca
(
n
) ((n) < 4032)

	)

464 #define 
	#__libc_use_alloca
(
n
) 0

	)

465 #undef 
alloca


466 #define 
	#alloca
(
n
) 
	`malloc
 (n)

	)

470 #ifndef 
MAX


471 #define 
	#MAX
(
a
,
b
) ((a) < (b) ? (b) : (a))

	)

474 #define 
	#re_malloc
(
t
,
n
) ((t *) 
	`malloc
 ((n) * sizeof (t)))

	)

475 #define 
	#re_realloc
(
p
,
t
,
n
) ((t *) 
	`realloc
 (p, (n) * sizeof (t)))

	)

476 #define 
	#re_free
(
p
) 
	`free
 (p)

	)

478 struct 
	sbin_tree_t


480 struct 
bin_tree_t
 *
parent
;

481 struct 
bin_tree_t
 *
left
;

482 struct 
bin_tree_t
 *
right
;

483 struct 
bin_tree_t
 *
first
;

484 struct 
bin_tree_t
 *
next
;

486 
re_token_t
 
token
;

490 
Idx
 
node_idx
;

492 typedef struct 
bin_tree_t
 
	tbin_tree_t
;

494 #define 
	#BIN_TREE_STORAGE_SIZE
 \

495 ((1024 - sizeof (void *)) / sizeof (
bin_tree_t
))

	)

497 struct 
	sbin_tree_storage_t


499 struct 
bin_tree_storage_t
 *
next
;

500 
bin_tree_t
 
data
[
BIN_TREE_STORAGE_SIZE
];

502 typedef struct 
bin_tree_storage_t
 
	tbin_tree_storage_t
;

504 #define 
	#CONTEXT_WORD
 1

	)

505 #define 
	#CONTEXT_NEWLINE
 (
CONTEXT_WORD
 << 1)

	)

506 #define 
	#CONTEXT_BEGBUF
 (
CONTEXT_NEWLINE
 << 1)

	)

507 #define 
	#CONTEXT_ENDBUF
 (
CONTEXT_BEGBUF
 << 1)

	)

509 #define 
	#IS_WORD_CONTEXT
(
c
) ((c) & 
CONTEXT_WORD
)

	)

510 #define 
	#IS_NEWLINE_CONTEXT
(
c
) ((c) & 
CONTEXT_NEWLINE
)

	)

511 #define 
	#IS_BEGBUF_CONTEXT
(
c
) ((c) & 
CONTEXT_BEGBUF
)

	)

512 #define 
	#IS_ENDBUF_CONTEXT
(
c
) ((c) & 
CONTEXT_ENDBUF
)

	)

513 #define 
	#IS_ORDINARY_CONTEXT
(
c
) ((c) == 0)

	)

515 #define 
	#IS_WORD_CHAR
(
ch
) (
	`isalnum
 (ch) || (ch) == '_')

	)

516 #define 
	#IS_NEWLINE
(
ch
) ((ch) == 
NEWLINE_CHAR
)

	)

517 #define 
	#IS_WIDE_WORD_CHAR
(
ch
) (
	`iswalnum
 (ch) || (ch) == 
L
'_')

	)

518 #define 
	#IS_WIDE_NEWLINE
(
ch
) ((ch) == 
WIDE_NEWLINE_CHAR
)

	)

520 #define 
	#NOT_SATISFY_PREV_CONSTRAINT
(
constraint
,
context
) \

521 ((((
constraint
) & 
PREV_WORD_CONSTRAINT
) && !
	`IS_WORD_CONTEXT
 (
context
)) \

522 || ((
constraint
 & 
PREV_NOTWORD_CONSTRAINT
) && 
	`IS_WORD_CONTEXT
 (
context
)) \

523 || ((
constraint
 & 
PREV_NEWLINE_CONSTRAINT
) && !
	`IS_NEWLINE_CONTEXT
 (
context
))\

524 || ((
constraint
 & 
PREV_BEGBUF_CONSTRAINT
) && !
	`IS_BEGBUF_CONTEXT
 (
context
)))

	)

526 #define 
	#NOT_SATISFY_NEXT_CONSTRAINT
(
constraint
,
context
) \

527 ((((
constraint
) & 
NEXT_WORD_CONSTRAINT
) && !
	`IS_WORD_CONTEXT
 (
context
)) \

528 || (((
constraint
) & 
NEXT_NOTWORD_CONSTRAINT
) && 
	`IS_WORD_CONTEXT
 (
context
)) \

529 || (((
constraint
) & 
NEXT_NEWLINE_CONSTRAINT
) && !
	`IS_NEWLINE_CONTEXT
 (
context
)) \

530 || (((
constraint
) & 
NEXT_ENDBUF_CONSTRAINT
) && !
	`IS_ENDBUF_CONTEXT
 (
context
)))

	)

532 struct 
	sre_dfastate_t


534 
re_hashval_t
 
hash
;

535 
re_node_set
 
nodes
;

536 
re_node_set
 
non_eps_nodes
;

537 
re_node_set
 
inveclosure
;

538 
re_node_set
 *
entrance_nodes
;

539 struct 
re_dfastate_t
 **
trtable
, **
word_trtable
;

540 unsigned int 
context
 : 4;

541 unsigned int 
halt
 : 1;

545 unsigned int 
accept_mb
 : 1;

547 unsigned int 
has_backref
 : 1;

548 unsigned int 
has_constraint
 : 1;

550 typedef struct 
re_dfastate_t
 
	tre_dfastate_t
;

552 struct 
	sre_state_table_entry


554 
Idx
 
num
;

555 
Idx
 
alloc
;

556 
re_dfastate_t
 **
array
;

563 
Idx
 
next_idx
;

564 
Idx
 
alloc
;

565 
re_dfastate_t
 **
array
;

566 } 
	tstate_array_t
;

572 
Idx
 
node
;

573 
Idx
 
str_idx
;

574 
state_array_t
 
path
;

575 } 
	tre_sub_match_last_t
;

583 
Idx
 
str_idx
;

584 
Idx
 
node
;

585 
state_array_t
 *
path
;

586 
Idx
 
alasts
;

587 
Idx
 
nlasts
;

588 
re_sub_match_last_t
 **
lasts
;

589 } 
	tre_sub_match_top_t
;

591 struct 
	sre_backref_cache_entry


593 
Idx
 
node
;

594 
Idx
 
str_idx
;

595 
Idx
 
subexp_from
;

596 
Idx
 
subexp_to
;

597 char 
more
;

598 char 
unused
;

599 unsigned short int 
eps_reachable_subexps_map
;

605 
re_string_t
 
input
;

606 #if 
defined
 
_LIBC
 || (defined 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L)

607 const 
re_dfa_t
 *const 
dfa
;

609 const 
re_dfa_t
 *
dfa
;

612 int 
eflags
;

614 
Idx
 
match_last
;

615 
Idx
 
last_node
;

617 
re_dfastate_t
 **
state_log
;

618 
Idx
 
state_log_top
;

620 
Idx
 
nbkref_ents
;

621 
Idx
 
abkref_ents
;

622 struct 
re_backref_cache_entry
 *
bkref_ents
;

623 int 
max_mb_elem_len
;

624 
Idx
 
nsub_tops
;

625 
Idx
 
asub_tops
;

626 
re_sub_match_top_t
 **
sub_tops
;

627 } 
	tre_match_context_t
;

631 
re_dfastate_t
 **
sifted_states
;

632 
re_dfastate_t
 **
limited_states
;

633 
Idx
 
last_node
;

634 
Idx
 
last_str_idx
;

635 
re_node_set
 
limits
;

636 } 
	tre_sift_context_t
;

638 struct 
	sre_fail_stack_ent_t


640 
Idx
 
idx
;

641 
Idx
 
node
;

642 
regmatch_t
 *
regs
;

643 
re_node_set
 
eps_via_nodes
;

646 struct 
	sre_fail_stack_t


648 
Idx
 
num
;

649 
Idx
 
alloc
;

650 struct 
re_fail_stack_ent_t
 *
stack
;

653 struct 
	sre_dfa_t


655 
re_token_t
 *
nodes
;

656 
size_t
 
nodes_alloc
;

657 
size_t
 
nodes_len
;

658 
Idx
 *
nexts
;

659 
Idx
 *
org_indices
;

660 
re_node_set
 *
edests
;

661 
re_node_set
 *
eclosures
;

662 
re_node_set
 *
inveclosures
;

663 struct 
re_state_table_entry
 *
state_table
;

664 
re_dfastate_t
 *
init_state
;

665 
re_dfastate_t
 *
init_state_word
;

666 
re_dfastate_t
 *
init_state_nl
;

667 
re_dfastate_t
 *
init_state_begbuf
;

668 
bin_tree_t
 *
str_tree
;

669 
bin_tree_storage_t
 *
str_tree_storage
;

670 
re_bitset_ptr_t
 
sb_char
;

671 int 
str_tree_storage_idx
;

674 
re_hashval_t
 
state_hash_mask
;

675 
Idx
 
init_node
;

676 
Idx
 
nbackref
;

679 
bitset_word_t
 
used_bkref_map
;

680 
bitset_word_t
 
completed_bkref_map
;

682 unsigned int 
has_plural_match
 : 1;

686 unsigned int 
has_mb_node
 : 1;

687 unsigned int 
is_utf8
 : 1;

688 unsigned int 
map_notascii
 : 1;

689 unsigned int 
word_ops_used
 : 1;

690 int 
mb_cur_max
;

691 
bitset_t
 
word_char
;

692 
reg_syntax_t
 
syntax
;

693 
Idx
 *
subexp_map
;

694 #ifdef 
DEBUG


695 char* 
re_str
;

697 #ifdef 
_LIBC


698 
	`__libc_lock_define
 (, 
lock
)

702 #define 
	#re_node_set_init_empty
(
set
) 
	`memset
 (set, '\0', sizeof (
re_node_set
))

	)

703 #define 
	#re_node_set_remove
(
set
,
id
) \

704 (
	`re_node_set_remove_at
 (
set
, 
	`re_node_set_contains
 (set, 
id
) - 1))

	)

705 #define 
	#re_node_set_empty
(
p
) ((p)->
nelem
 = 0)

	)

706 #define 
	#re_node_set_free
(
set
) 
	`re_free
 ((set)->
elems
)

	)

711 
SB_CHAR
,

712 
MB_CHAR
,

713 
EQUIV_CLASS
,

714 
COLL_SYM
,

715 
CHAR_CLASS


716 } 
	tbracket_elem_type
;

720 
bracket_elem_type
 
type
;

723 unsigned char 
ch
;

724 unsigned char *
name
;

725 
wchar_t
 
wch
;

726 } 
opr
;

727 } 
	tbracket_elem_t
;

732 static 
inline
 void

733 
	$bitset_set
 (
bitset_t
 
set
, 
Idx
 
i
)

735 
set
[
i
 / 
BITSET_WORD_BITS
] |= (
bitset_word_t
) 1 << i % BITSET_WORD_BITS;

736 
	}
}

738 static 
inline
 void

739 
	$bitset_clear
 (
bitset_t
 
set
, 
Idx
 
i
)

741 
set
[
i
 / 
BITSET_WORD_BITS
] &= ~ ((
bitset_word_t
) 1 << i % BITSET_WORD_BITS);

742 
	}
}

744 static 
inline
 
bool


745 
	$bitset_contain
 (const 
bitset_t
 
set
, 
Idx
 
i
)

747 return (
set
[
i
 / 
BITSET_WORD_BITS
] >> i % BITSET_WORD_BITS) & 1;

748 
	}
}

750 static 
inline
 void

751 
	$bitset_empty
 (
bitset_t
 
set
)

753 
	`memset
 (
set
, '\0', sizeof (
bitset_t
));

754 
	}
}

756 static 
inline
 void

757 
	$bitset_set_all
 (
bitset_t
 
set
)

759 
	`memset
 (
set
, -1, sizeof (
bitset_word_t
) * (
SBC_MAX
 / 
BITSET_WORD_BITS
));

760 if (
SBC_MAX
 % 
BITSET_WORD_BITS
 != 0)

761 
set
[
BITSET_WORDS
 - 1] =

762 ((
bitset_word_t
) 1 << 
SBC_MAX
 % 
BITSET_WORD_BITS
) - 1;

763 
	}
}

765 static 
inline
 void

766 
	$bitset_copy
 (
bitset_t
 
dest
, const bitset_t 
src
)

768 
	`memcpy
 (
dest
, 
src
, sizeof (
bitset_t
));

769 
	}
}

771 static 
inline
 void

772 
	$bitset_not
 (
bitset_t
 
set
)

774 int 
bitset_i
;

775 for (
bitset_i
 = 0; bitset_i < 
SBC_MAX
 / 
BITSET_WORD_BITS
; ++bitset_i)

776 
set
[
bitset_i
] = ~set[bitset_i];

777 if (
SBC_MAX
 % 
BITSET_WORD_BITS
 != 0)

778 
set
[
BITSET_WORDS
 - 1] =

779 ((((
bitset_word_t
) 1 << 
SBC_MAX
 % 
BITSET_WORD_BITS
) - 1)

780 & ~
set
[
BITSET_WORDS
 - 1]);

781 
	}
}

783 static 
inline
 void

784 
	$bitset_merge
 (
bitset_t
 
dest
, const bitset_t 
src
)

786 int 
bitset_i
;

787 for (
bitset_i
 = 0; bitset_i < 
BITSET_WORDS
; ++bitset_i)

788 
dest
[
bitset_i
] |= 
src
[bitset_i];

789 
	}
}

791 static 
inline
 void

792 
	$bitset_mask
 (
bitset_t
 
dest
, const bitset_t 
src
)

794 int 
bitset_i
;

795 for (
bitset_i
 = 0; bitset_i < 
BITSET_WORDS
; ++bitset_i)

796 
dest
[
bitset_i
] &= 
src
[bitset_i];

797 
	}
}

799 #ifdef 
RE_ENABLE_I18N


801 static 
inline
 int

802 
internal_function
 
__attribute
 ((
pure
))

803 
	$re_string_char_size_at
 (const 
re_string_t
 *
pstr
, 
Idx
 
idx
)

805 int 
byte_idx
;

806 if (
pstr
->
mb_cur_max
 == 1)

808 for (
byte_idx
 = 1; 
idx
 + byte_idx < 
pstr
->
valid_len
; ++byte_idx)

809 if (
pstr
->
wcs
[
idx
 + 
byte_idx
] != 
WEOF
)

811 return 
byte_idx
;

812 
	}
}

814 static 
inline
 
wint_t


815 
internal_function
 
__attribute
 ((
pure
))

816 
	$re_string_wchar_at
 (const 
re_string_t
 *
pstr
, 
Idx
 
idx
)

818 if (
pstr
->
mb_cur_max
 == 1)

819 return (
wint_t
) 
pstr
->
mbs
[
idx
];

820 return (
wint_t
) 
pstr
->
wcs
[
idx
];

821 
	}
}

824 
internal_function
 
__attribute
 ((
pure
))

825 
	$re_string_elem_size_at
 (const 
re_string_t
 *
pstr
 
_UNUSED_PARAMETER_
,

826 
Idx
 
idx
 
_UNUSED_PARAMETER_
)

828 #ifdef 
_LIBC


829 const unsigned char *
p
, *
extra
;

830 const 
int32_t
 *
table
, *
indirect
;

831 
int32_t
 
tmp
;

832 #include 
	~<locale/weight.h
>

833 
uint_fast32_t
 
nrules
 = 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
);

835 if (
nrules
 != 0)

837 
table
 = (const 
int32_t
 *) 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_TABLEMB
);

838 
extra
 = (const unsigned char *)

839 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_EXTRAMB
);

840 
indirect
 = (const 
int32_t
 *) 
	`_NL_CURRENT
 (
LC_COLLATE
,

841 
_NL_COLLATE_INDIRECTMB
);

842 
p
 = 
pstr
->
mbs
 + 
idx
;

843 
tmp
 = 
	`findidx
 (&
p
);

844 return 
p
 - 
pstr
->
mbs
 - 
idx
;

849 
	}
}

852 #ifndef 
__GNUC_PREREQ


853 #if 
defined
 
__GNUC__
 && defined 
__GNUC_MINOR__


854 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) \

855 ((
__GNUC__
 << 16) + 
__GNUC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

857 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) 0

	)

861 #if 
__GNUC_PREREQ
 (3,4)

862 #undef 
__attribute_warn_unused_result__


863 #define 
	#__attribute_warn_unused_result__
 \

864 
	`__attribute__
 ((
__warn_unused_result__
))

	)

866 #define 
	#__attribute_warn_unused_result__


	)

	@lib/regexec.c

22 #include 
	~"verify.h
"

23 #include 
	~"intprops.h
"

24 static 
reg_errcode_t
 
	$match_ctx_init
 (
re_match_context_t
 *
cache
, int 
eflags
,

25 
Idx
 
n
) 
internal_function
;

26 static void 
	$match_ctx_clean
 (
re_match_context_t
 *
mctx
) 
internal_function
;

27 static void 
	$match_ctx_free
 (
re_match_context_t
 *
cache
) 
internal_function
;

28 static 
reg_errcode_t
 
	$match_ctx_add_entry
 (
re_match_context_t
 *
cache
, 
Idx
 
node
,

29 
Idx
 
str_idx
, Idx 
from
, Idx 
to
)

30 
internal_function
;

31 static 
Idx
 
	$search_cur_bkref_entry
 (const 
re_match_context_t
 *
mctx
, 
Idx
 
str_idx
)

32 
internal_function
;

33 static 
reg_errcode_t
 
	$match_ctx_add_subtop
 (
re_match_context_t
 *
mctx
, 
Idx
 
node
,

34 
Idx
 
str_idx
) 
internal_function
;

35 static 
re_sub_match_last_t
 * 
	$match_ctx_add_sublast
 (
re_sub_match_top_t
 *
subtop
,

36 
Idx
 
node
, Idx 
str_idx
)

37 
internal_function
;

38 static void 
	$sift_ctx_init
 (
re_sift_context_t
 *
sctx
, 
re_dfastate_t
 **
sifted_sts
,

39 
re_dfastate_t
 **
limited_sts
, 
Idx
 
last_node
,

40 
Idx
 
last_str_idx
)

41 
internal_function
;

42 static 
reg_errcode_t
 
	$re_search_internal
 (const 
regex_t
 *
preg
,

43 const char *
string
, 
Idx
 
length
,

44 
Idx
 
start
, Idx 
last_start
, Idx 
stop
,

45 
size_t
 
nmatch
, 
regmatch_t
 
pmatch
[],

46 int 
eflags
) 
internal_function
;

47 static 
regoff_t
 
	$re_search_2_stub
 (struct 
re_pattern_buffer
 *
bufp
,

48 const char *
string1
, 
Idx
 
length1
,

49 const char *
string2
, 
Idx
 
length2
,

50 
Idx
 
start
, 
regoff_t
 
range
,

51 struct 
re_registers
 *
regs
,

52 
Idx
 
stop
, 
bool
 
ret_len
) 
internal_function
;

53 static 
regoff_t
 
	$re_search_stub
 (struct 
re_pattern_buffer
 *
bufp
,

54 const char *
string
, 
Idx
 
length
, Idx 
start
,

55 
regoff_t
 
range
, 
Idx
 
stop
,

56 struct 
re_registers
 *
regs
,

57 
bool
 
ret_len
) 
internal_function
;

58 static unsigned int 
	$re_copy_regs
 (struct 
re_registers
 *
regs
, 
regmatch_t
 *
pmatch
,

59 
Idx
 
nregs
, int 
regs_allocated
)

60 
internal_function
;

61 static 
reg_errcode_t
 
	$prune_impossible_nodes
 (
re_match_context_t
 *
mctx
)

62 
internal_function
;

63 static 
Idx
 
	$check_matching
 (
re_match_context_t
 *
mctx
, 
bool
 
fl_longest_match
,

64 
Idx
 *
p_match_first
) 
internal_function
;

65 static 
Idx
 
	$check_halt_state_context
 (const 
re_match_context_t
 *
mctx
,

66 const 
re_dfastate_t
 *
state
, 
Idx
 
idx
)

67 
internal_function
;

68 static void 
	$update_regs
 (const 
re_dfa_t
 *
dfa
, 
regmatch_t
 *
pmatch
,

69 
regmatch_t
 *
prev_idx_match
, 
Idx
 
cur_node
,

70 
Idx
 
cur_idx
, Idx 
nmatch
) 
internal_function
;

71 static 
reg_errcode_t
 
	$push_fail_stack
 (struct 
re_fail_stack_t
 *
fs
,

72 
Idx
 
str_idx
, Idx 
dest_node
, Idx 
nregs
,

73 
regmatch_t
 *
regs
,

74 
re_node_set
 *
eps_via_nodes
)

75 
internal_function
;

76 static 
reg_errcode_t
 
	$set_regs
 (const 
regex_t
 *
preg
,

77 const 
re_match_context_t
 *
mctx
,

78 
size_t
 
nmatch
, 
regmatch_t
 *
pmatch
,

79 
bool
 
fl_backtrack
) 
internal_function
;

80 static 
reg_errcode_t
 
	$free_fail_stack_return
 (struct 
re_fail_stack_t
 *
fs
)

81 
internal_function
;

83 #ifdef 
RE_ENABLE_I18N


84 static int 
	$sift_states_iter_mb
 (const 
re_match_context_t
 *
mctx
,

85 
re_sift_context_t
 *
sctx
,

86 
Idx
 
node_idx
, Idx 
str_idx
, Idx 
max_str_idx
)

87 
internal_function
;

89 static 
reg_errcode_t
 
	$sift_states_backward
 (const 
re_match_context_t
 *
mctx
,

90 
re_sift_context_t
 *
sctx
)

91 
internal_function
;

92 static 
reg_errcode_t
 
	$build_sifted_states
 (const 
re_match_context_t
 *
mctx
,

93 
re_sift_context_t
 *
sctx
, 
Idx
 
str_idx
,

94 
re_node_set
 *
cur_dest
)

95 
internal_function
;

96 static 
reg_errcode_t
 
	$update_cur_sifted_state
 (const 
re_match_context_t
 *
mctx
,

97 
re_sift_context_t
 *
sctx
,

98 
Idx
 
str_idx
,

99 
re_node_set
 *
dest_nodes
)

100 
internal_function
;

101 static 
reg_errcode_t
 
	$add_epsilon_src_nodes
 (const 
re_dfa_t
 *
dfa
,

102 
re_node_set
 *
dest_nodes
,

103 const 
re_node_set
 *
candidates
)

104 
internal_function
;

105 static 
bool
 
	$check_dst_limits
 (const 
re_match_context_t
 *
mctx
,

106 const 
re_node_set
 *
limits
,

107 
Idx
 
dst_node
, Idx 
dst_idx
, Idx 
src_node
,

108 
Idx
 
src_idx
) 
internal_function
;

109 static int 
	$check_dst_limits_calc_pos_1
 (const 
re_match_context_t
 *
mctx
,

110 int 
boundaries
, 
Idx
 
subexp_idx
,

111 
Idx
 
from_node
, Idx 
bkref_idx
)

112 
internal_function
;

113 static int 
	$check_dst_limits_calc_pos
 (const 
re_match_context_t
 *
mctx
,

114 
Idx
 
limit
, Idx 
subexp_idx
,

115 
Idx
 
node
, Idx 
str_idx
,

116 
Idx
 
bkref_idx
) 
internal_function
;

117 static 
reg_errcode_t
 
	$check_subexp_limits
 (const 
re_dfa_t
 *
dfa
,

118 
re_node_set
 *
dest_nodes
,

119 const 
re_node_set
 *
candidates
,

120 
re_node_set
 *
limits
,

121 struct 
re_backref_cache_entry
 *
bkref_ents
,

122 
Idx
 
str_idx
) 
internal_function
;

123 static 
reg_errcode_t
 
	$sift_states_bkref
 (const 
re_match_context_t
 *
mctx
,

124 
re_sift_context_t
 *
sctx
,

125 
Idx
 
str_idx
, const 
re_node_set
 *
candidates
)

126 
internal_function
;

127 static 
reg_errcode_t
 
	$merge_state_array
 (const 
re_dfa_t
 *
dfa
,

128 
re_dfastate_t
 **
dst
,

129 
re_dfastate_t
 **
src
, 
Idx
 
num
)

130 
internal_function
;

131 static 
re_dfastate_t
 *
	$find_recover_state
 (
reg_errcode_t
 *
err
,

132 
re_match_context_t
 *
mctx
) 
internal_function
;

133 static 
re_dfastate_t
 *
	$transit_state
 (
reg_errcode_t
 *
err
,

134 
re_match_context_t
 *
mctx
,

135 
re_dfastate_t
 *
state
) 
internal_function
;

136 static 
re_dfastate_t
 *
	$merge_state_with_log
 (
reg_errcode_t
 *
err
,

137 
re_match_context_t
 *
mctx
,

138 
re_dfastate_t
 *
next_state
)

139 
internal_function
;

140 static 
reg_errcode_t
 
	$check_subexp_matching_top
 (
re_match_context_t
 *
mctx
,

141 
re_node_set
 *
cur_nodes
,

142 
Idx
 
str_idx
) 
internal_function
;

144 static 
re_dfastate_t
 *
	$transit_state_sb
 (
reg_errcode_t
 *
err
,

145 
re_match_context_t
 *
mctx
,

146 
re_dfastate_t
 *
pstate
)

147 
internal_function
;

149 #ifdef 
RE_ENABLE_I18N


150 static 
reg_errcode_t
 
	$transit_state_mb
 (
re_match_context_t
 *
mctx
,

151 
re_dfastate_t
 *
pstate
)

152 
internal_function
;

154 static 
reg_errcode_t
 
	$transit_state_bkref
 (
re_match_context_t
 *
mctx
,

155 const 
re_node_set
 *
nodes
)

156 
internal_function
;

157 static 
reg_errcode_t
 
	$get_subexp
 (
re_match_context_t
 *
mctx
,

158 
Idx
 
bkref_node
, Idx 
bkref_str_idx
)

159 
internal_function
;

160 static 
reg_errcode_t
 
	$get_subexp_sub
 (
re_match_context_t
 *
mctx
,

161 const 
re_sub_match_top_t
 *
sub_top
,

162 
re_sub_match_last_t
 *
sub_last
,

163 
Idx
 
bkref_node
, Idx 
bkref_str
)

164 
internal_function
;

165 static 
Idx
 
	$find_subexp_node
 (const 
re_dfa_t
 *
dfa
, const 
re_node_set
 *
nodes
,

166 
Idx
 
subexp_idx
, int 
type
) 
internal_function
;

167 static 
reg_errcode_t
 
	$check_arrival
 (
re_match_context_t
 *
mctx
,

168 
state_array_t
 *
path
, 
Idx
 
top_node
,

169 
Idx
 
top_str
, Idx 
last_node
, Idx 
last_str
,

170 int 
type
) 
internal_function
;

171 static 
reg_errcode_t
 
	$check_arrival_add_next_nodes
 (
re_match_context_t
 *
mctx
,

172 
Idx
 
str_idx
,

173 
re_node_set
 *
cur_nodes
,

174 
re_node_set
 *
next_nodes
)

175 
internal_function
;

176 static 
reg_errcode_t
 
	$check_arrival_expand_ecl
 (const 
re_dfa_t
 *
dfa
,

177 
re_node_set
 *
cur_nodes
,

178 
Idx
 
ex_subexp
, int 
type
)

179 
internal_function
;

180 static 
reg_errcode_t
 
	$check_arrival_expand_ecl_sub
 (const 
re_dfa_t
 *
dfa
,

181 
re_node_set
 *
dst_nodes
,

182 
Idx
 
target
, Idx 
ex_subexp
,

183 int 
type
) 
internal_function
;

184 static 
reg_errcode_t
 
	$expand_bkref_cache
 (
re_match_context_t
 *
mctx
,

185 
re_node_set
 *
cur_nodes
, 
Idx
 
cur_str
,

186 
Idx
 
subexp_num
, int 
type
)

187 
internal_function
;

188 static 
bool
 
	$build_trtable
 (const 
re_dfa_t
 *
dfa
,

189 
re_dfastate_t
 *
state
) 
internal_function
;

190 #ifdef 
RE_ENABLE_I18N


191 static int 
	$check_node_accept_bytes
 (const 
re_dfa_t
 *
dfa
, 
Idx
 
node_idx
,

192 const 
re_string_t
 *
input
, 
Idx
 
idx
)

193 
internal_function
;

194 #ifdef 
_LIBC


195 static unsigned int 
	$find_collation_sequence_value
 (const unsigned char *
mbs
,

196 
size_t
 
name_len
)

197 
internal_function
;

200 static 
Idx
 
	$group_nodes_into_DFAstates
 (const 
re_dfa_t
 *
dfa
,

201 const 
re_dfastate_t
 *
state
,

202 
re_node_set
 *
states_node
,

203 
bitset_t
 *
states_ch
) 
internal_function
;

204 static 
bool
 
	$check_node_accept
 (const 
re_match_context_t
 *
mctx
,

205 const 
re_token_t
 *
node
, 
Idx
 
idx
)

206 
internal_function
;

207 static 
reg_errcode_t
 
	$extend_buffers
 (
re_match_context_t
 *
mctx
)

208 
internal_function
;

227 
	$regexec
 (
preg
, 
string
, 
nmatch
, 
pmatch
, 
eflags
)

228 const 
regex_t
 *
_Restrict_
 
preg
;

229 const char *
_Restrict_
 
string
;

230 
size_t
 
nmatch
;

231 
regmatch_t
 
pmatch
[
_Restrict_arr_
];

232 int 
eflags
;

234 
reg_errcode_t
 
err
;

235 
Idx
 
start
, 
length
;

236 #ifdef 
_LIBC


237 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
preg
->
buffer
;

240 if (
eflags
 & ~(
REG_NOTBOL
 | 
REG_NOTEOL
 | 
REG_STARTEND
))

241 return 
REG_BADPAT
;

243 if (
eflags
 & 
REG_STARTEND
)

245 
start
 = 
pmatch
[0].
rm_so
;

246 
length
 = 
pmatch
[0].
rm_eo
;

250 
start
 = 0;

251 
length
 = 
	`strlen
 (
string
);

254 
	`__libc_lock_lock
 (
dfa
->
lock
);

255 if (
preg
->
no_sub
)

256 
err
 = 
	`re_search_internal
 (
preg
, 
string
, 
length
, 
start
, length,

257 
length
, 0, 
NULL
, 
eflags
);

259 
err
 = 
	`re_search_internal
 (
preg
, 
string
, 
length
, 
start
, length,

260 
length
, 
nmatch
, 
pmatch
, 
eflags
);

261 
	`__libc_lock_unlock
 (
dfa
->
lock
);

262 return 
err
 != 
REG_NOERROR
;

263 
	}
}

265 #ifdef 
_LIBC


266 #include 
	~<shlib-compat.h
>

267 
versioned_symbol
 (
libc
, 
__regexec
, 
regexec
, 
GLIBC_2_3_4
);

269 #if 
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_3_4
)

270 
	$__typeof__
 (
__regexec
) 
__compat_regexec
;

273 
attribute_compat_text_section


274 
	$__compat_regexec
 (const 
regex_t
 *
_Restrict_
 
preg
,

275 const char *
_Restrict_
 
string
, 
size_t
 
nmatch
,

276 
regmatch_t
 
pmatch
[], int 
eflags
)

278 return 
	`regexec
 (
preg
, 
string
, 
nmatch
, 
pmatch
,

279 
eflags
 & (
REG_NOTBOL
 | 
REG_NOTEOL
));

280 
	}
}

281 
compat_symbol
 (
libc
, 
__compat_regexec
, 
regexec
, 
GLIBC_2_0
);

314 
regoff_t


315 
	$re_match
 (
bufp
, 
string
, 
length
, 
start
, 
regs
)

316 struct 
re_pattern_buffer
 *
bufp
;

317 const char *
string
;

318 
Idx
 
length
, 
start
;

319 struct 
re_registers
 *
regs
;

321 return 
	`re_search_stub
 (
bufp
, 
string
, 
length
, 
start
, 0, length, 
regs
, 
true
);

322 
	}
}

323 #ifdef 
_LIBC


324 
	$weak_alias
 (
__re_match
, 
re_match
)

327 
regoff_t


328 
	$re_search
 (
bufp
, 
string
, 
length
, 
start
, 
range
, 
regs
)

329 struct 
re_pattern_buffer
 *
bufp
;

330 const char *
string
;

331 
Idx
 
length
, 
start
;

332 
regoff_t
 
range
;

333 struct 
re_registers
 *
regs
;

335 return 
	`re_search_stub
 (
bufp
, 
string
, 
length
, 
start
, 
range
, length, 
regs
,

336 
false
);

337 
	}
}

338 #ifdef 
_LIBC


339 
	$weak_alias
 (
__re_search
, 
re_search
)

342 
regoff_t


343 
	$re_match_2
 (
bufp
, 
string1
, 
length1
, 
string2
, 
length2
, 
start
, 
regs
, 
stop
)

344 struct 
re_pattern_buffer
 *
bufp
;

345 const char *
string1
, *
string2
;

346 
Idx
 
length1
, 
length2
, 
start
, 
stop
;

347 struct 
re_registers
 *
regs
;

349 return 
	`re_search_2_stub
 (
bufp
, 
string1
, 
length1
, 
string2
, 
length2
,

350 
start
, 0, 
regs
, 
stop
, 
true
);

351 
	}
}

352 #ifdef 
_LIBC


353 
	$weak_alias
 (
__re_match_2
, 
re_match_2
)

356 
regoff_t


357 
	$re_search_2
 (
bufp
, 
string1
, 
length1
, 
string2
, 
length2
, 
start
, 
range
, 
regs
, 
stop
)

358 struct 
re_pattern_buffer
 *
bufp
;

359 const char *
string1
, *
string2
;

360 
Idx
 
length1
, 
length2
, 
start
, 
stop
;

361 
regoff_t
 
range
;

362 struct 
re_registers
 *
regs
;

364 return 
	`re_search_2_stub
 (
bufp
, 
string1
, 
length1
, 
string2
, 
length2
,

365 
start
, 
range
, 
regs
, 
stop
, 
false
);

366 
	}
}

367 #ifdef 
_LIBC


368 
	$weak_alias
 (
__re_search_2
, 
re_search_2
)

371 static 
regoff_t


372 
internal_function


373 
	$re_search_2_stub
 (struct 
re_pattern_buffer
 *
bufp
,

374 const char *
string1
, 
Idx
 
length1
,

375 const char *
string2
, 
Idx
 
length2
,

376 
Idx
 
start
, 
regoff_t
 
range
, struct 
re_registers
 *
regs
,

377 
Idx
 
stop
, 
bool
 
ret_len
)

379 const char *
str
;

380 
regoff_t
 
rval
;

381 
Idx
 
len
 = 
length1
 + 
length2
;

382 char *
s
 = 
NULL
;

384 
	`verify
 (! 
	`TYPE_SIGNED
 (
Idx
));

385 if (
	`BE
 (
len
 < 
length1
, 0))

391 if (
length2
 > 0)

392 if (
length1
 > 0)

394 
s
 = 
	`re_malloc
 (char, 
len
);

396 if (
	`BE
 (
s
 == 
NULL
, 0))

398 #ifdef 
_LIBC


399 
	`memcpy
 (
	`__mempcpy
 (
s
, 
string1
, 
length1
), 
string2
, 
length2
);

401 
	`memcpy
 (
s
, 
string1
, 
length1
);

402 
	`memcpy
 (
s
 + 
length1
, 
string2
, 
length2
);

404 
str
 = 
s
;

407 
str
 = 
string2
;

409 
str
 = 
string1
;

411 
rval
 = 
	`re_search_stub
 (
bufp
, 
str
, 
len
, 
start
, 
range
, 
stop
, 
regs
,

412 
ret_len
);

413 
	`re_free
 (
s
);

414 return 
rval
;

415 
	}
}

422 static 
regoff_t


423 
internal_function


424 
	$re_search_stub
 (struct 
re_pattern_buffer
 *
bufp
,

425 const char *
string
, 
Idx
 
length
,

426 
Idx
 
start
, 
regoff_t
 
range
, Idx 
stop
, struct 
re_registers
 *
regs
,

427 
bool
 
ret_len
)

429 
reg_errcode_t
 
result
;

430 
regmatch_t
 *
pmatch
;

431 
Idx
 
nregs
;

432 
regoff_t
 
rval
;

433 int 
eflags
 = 0;

434 #ifdef 
_LIBC


435 
re_dfa_t
 *
dfa
 = (re_dfa_t *) 
bufp
->
buffer
;

437 
Idx
 
last_start
 = 
start
 + 
range
;

440 
	`verify
 (! 
	`TYPE_SIGNED
 (
Idx
));

443 if (
	`BE
 (
start
 > 
length
, 0))

445 if (
	`BE
 (
length
 < 
last_start
 || (0 <= 
range
 && last_start < 
start
), 0))

446 
last_start
 = 
length
;

447 else if (
	`BE
 ( (
range
 < 0 && 
start
 <= 
last_start
), 0))

448 
last_start
 = 0;

450 
	`__libc_lock_lock
 (
dfa
->
lock
);

452 
eflags
 |= (
bufp
->
not_bol
) ? 
REG_NOTBOL
 : 0;

453 
eflags
 |= (
bufp
->
not_eol
) ? 
REG_NOTEOL
 : 0;

456 if (
start
 < 
last_start
 && 
bufp
->
fastmap
 != 
NULL
 && !bufp->
fastmap_accurate
)

457 
	`re_compile_fastmap
 (
bufp
);

459 if (
	`BE
 (
bufp
->
no_sub
, 0))

460 
regs
 = 
NULL
;

463 if (
regs
 == 
NULL
)

464 
nregs
 = 1;

465 else if (
	`BE
 (
bufp
->
regs_allocated
 == 
REGS_FIXED


466 && 
regs
->
num_regs
 <= 
bufp
->
re_nsub
, 0))

468 
nregs
 = 
regs
->
num_regs
;

469 if (
	`BE
 (
nregs
 < 1, 0))

472 
regs
 = 
NULL
;

473 
nregs
 = 1;

477 
nregs
 = 
bufp
->
re_nsub
 + 1;

478 
pmatch
 = 
	`re_malloc
 (
regmatch_t
, 
nregs
);

479 if (
	`BE
 (
pmatch
 == 
NULL
, 0))

481 
rval
 = -2;

482 goto 
out
;

485 
result
 = 
	`re_search_internal
 (
bufp
, 
string
, 
length
, 
start
, 
last_start
, 
stop
,

486 
nregs
, 
pmatch
, 
eflags
);

488 
rval
 = 0;

491 if (
result
 != 
REG_NOERROR
)

492 
rval
 = -1;

493 else if (
regs
 != 
NULL
)

496 
bufp
->
regs_allocated
 = 
	`re_copy_regs
 (
regs
, 
pmatch
, 
nregs
,

497 
bufp
->
regs_allocated
);

498 if (
	`BE
 (
bufp
->
regs_allocated
 == 
REGS_UNALLOCATED
, 0))

499 
rval
 = -2;

502 if (
	`BE
 (
rval
 == 0, 1))

504 if (
ret_len
)

506 
	`assert
 (
pmatch
[0].
rm_so
 == 
start
);

507 
rval
 = 
pmatch
[0].
rm_eo
 - 
start
;

510 
rval
 = 
pmatch
[0].
rm_so
;

512 
	`re_free
 (
pmatch
);

513 
out
:

514 
	`__libc_lock_unlock
 (
dfa
->
lock
);

515 return 
rval
;

516 
	}
}

519 
internal_function


520 
	$re_copy_regs
 (struct 
re_registers
 *
regs
, 
regmatch_t
 *
pmatch
, 
Idx
 
nregs
,

521 int 
regs_allocated
)

523 int 
rval
 = 
REGS_REALLOCATE
;

524 
Idx
 
i
;

525 
Idx
 
need_regs
 = 
nregs
 + 1;

530 if (
regs_allocated
 == 
REGS_UNALLOCATED
)

532 
regs
->
start
 = 
	`re_malloc
 (
regoff_t
, 
need_regs
);

533 if (
	`BE
 (
regs
->
start
 == 
NULL
, 0))

534 return 
REGS_UNALLOCATED
;

535 
regs
->
end
 = 
	`re_malloc
 (
regoff_t
, 
need_regs
);

536 if (
	`BE
 (
regs
->
end
 == 
NULL
, 0))

538 
	`re_free
 (
regs
->
start
);

539 return 
REGS_UNALLOCATED
;

541 
regs
->
num_regs
 = 
need_regs
;

543 else if (
regs_allocated
 == 
REGS_REALLOCATE
)

547 if (
	`BE
 (
need_regs
 > 
regs
->
num_regs
, 0))

549 
regoff_t
 *
new_start
 = 
	`re_realloc
 (
regs
->
start
, regoff_t, 
need_regs
);

550 
regoff_t
 *
new_end
;

551 if (
	`BE
 (
new_start
 == 
NULL
, 0))

552 return 
REGS_UNALLOCATED
;

553 
new_end
 = 
	`re_realloc
 (
regs
->
end
, 
regoff_t
, 
need_regs
);

554 if (
	`BE
 (
new_end
 == 
NULL
, 0))

556 
	`re_free
 (
new_start
);

557 return 
REGS_UNALLOCATED
;

559 
regs
->
start
 = 
new_start
;

560 
regs
->
end
 = 
new_end
;

561 
regs
->
num_regs
 = 
need_regs
;

566 
	`assert
 (
regs_allocated
 == 
REGS_FIXED
);

568 
	`assert
 (
regs
->
num_regs
 >= 
nregs
);

569 
rval
 = 
REGS_FIXED
;

573 for (
i
 = 0; i < 
nregs
; ++i)

575 
regs
->
start
[
i
] = 
pmatch
[i].
rm_so
;

576 
regs
->
end
[
i
] = 
pmatch
[i].
rm_eo
;

578 for ( ; 
i
 < 
regs
->
num_regs
; ++i)

579 
regs
->
start
[
i
] = regs->
end
[i] = -1;

581 return 
rval
;

582 
	}
}

598 
	$re_set_registers
 (
bufp
, 
regs
, 
num_regs
, 
starts
, 
ends
)

599 struct 
re_pattern_buffer
 *
bufp
;

600 struct 
re_registers
 *
regs
;

601 
__re_size_t
 
num_regs
;

602 
regoff_t
 *
starts
, *
ends
;

604 if (
num_regs
)

606 
bufp
->
regs_allocated
 = 
REGS_REALLOCATE
;

607 
regs
->
num_regs
 = num_regs;

608 
regs
->
start
 = 
starts
;

609 
regs
->
end
 = 
ends
;

613 
bufp
->
regs_allocated
 = 
REGS_UNALLOCATED
;

614 
regs
->
num_regs
 = 0;

615 
regs
->
start
 = regs->
end
 = 
NULL
;

617 
	}
}

618 #ifdef 
_LIBC


619 
	$weak_alias
 (
__re_set_registers
, 
re_set_registers
)

625 #if 
defined
 
_REGEX_RE_COMP
 || defined 
_LIBC


627 #ifdef 
_LIBC


628 
weak_function


630 
	$re_exec
 (
s
)

631 const char *
s
;

633 return 0 == 
	`regexec
 (&
re_comp_buf
, 
s
, 0, 
NULL
, 0);

634 
	}
}

648 static 
reg_errcode_t


649 
internal_function
 
__attribute_warn_unused_result__


650 
	$re_search_internal
 (const 
regex_t
 *
preg
,

651 const char *
string
, 
Idx
 
length
,

652 
Idx
 
start
, Idx 
last_start
, Idx 
stop
,

653 
size_t
 
nmatch
, 
regmatch_t
 
pmatch
[],

654 int 
eflags
)

656 
reg_errcode_t
 
err
;

657 const 
re_dfa_t
 *
dfa
 = (const re_dfa_t *) 
preg
->
buffer
;

658 
Idx
 
left_lim
, 
right_lim
;

659 int 
incr
;

660 
bool
 
fl_longest_match
;

661 int 
match_kind
;

662 
Idx
 
match_first
;

663 
Idx
 
match_last
 = 
REG_MISSING
;

664 
Idx
 
extra_nmatch
;

665 
bool
 
sb
;

666 int 
ch
;

667 #if 
defined
 
_LIBC
 || (defined 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L)

668 
re_match_context_t
 
mctx
 = { .
dfa
 = dfa };

670 
re_match_context_t
 
mctx
;

672 char *
fastmap
 = ((
preg
->fastmap != 
NULL
 && preg->
fastmap_accurate


673 && 
start
 != 
last_start
 && !
preg
->
can_be_null
)

674 ? 
preg
->
fastmap
 : 
NULL
);

675 
RE_TRANSLATE_TYPE
 
t
 = 
preg
->
translate
;

677 #if !(
defined
 
_LIBC
 || (defined 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

678 
	`memset
 (&
mctx
, '\0', sizeof (
re_match_context_t
));

679 
mctx
.
dfa
 = dfa;

682 
extra_nmatch
 = (
nmatch
 > 
preg
->
re_nsub
) ? nmatch - (preg->re_nsub + 1) : 0;

683 
nmatch
 -= 
extra_nmatch
;

686 if (
	`BE
 (
preg
->
used
 == 0 || 
dfa
->
init_state
 == 
NULL


687 || 
dfa
->
init_state_word
 == 
NULL
 || dfa->
init_state_nl
 == NULL

688 || 
dfa
->
init_state_begbuf
 == 
NULL
, 0))

689 return 
REG_NOMATCH
;

691 #ifdef 
DEBUG


693 
	`assert
 (0 <= 
last_start
 && last_start <= 
length
);

699 if (
dfa
->
init_state
->
nodes
.
nelem
 == 0

700 && 
dfa
->
init_state_word
->
nodes
.
nelem
 == 0

701 && (
dfa
->
init_state_nl
->
nodes
.
nelem
 == 0

702 || !
preg
->
newline_anchor
))

704 if (
start
 != 0 && 
last_start
 != 0)

705 return 
REG_NOMATCH
;

706 
start
 = 
last_start
 = 0;

710 
fl_longest_match
 = (
nmatch
 != 0 || 
dfa
->
nbackref
);

712 
err
 = 
	`re_string_allocate
 (&
mctx
.
input
, 
string
, 
length
, 
dfa
->
nodes_len
 + 1,

713 
preg
->
translate
, (preg->
syntax
 & 
RE_ICASE
) != 0,

714 
dfa
);

715 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

716 goto 
free_return
;

717 
mctx
.
input
.
stop
 = stop;

718 
mctx
.
input
.
raw_stop
 = 
stop
;

719 
mctx
.
input
.
newline_anchor
 = 
preg
->newline_anchor;

721 
err
 = 
	`match_ctx_init
 (&
mctx
, 
eflags
, 
dfa
->
nbackref
 * 2);

722 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

723 goto 
free_return
;

729 if (
nmatch
 > 1 || 
dfa
->
has_mb_node
)

732 if (
	`BE
 (
SIZE_MAX
 / sizeof (
re_dfastate_t
 *) <= 
mctx
.
input
.
bufs_len
, 0))

734 
err
 = 
REG_ESPACE
;

735 goto 
free_return
;

738 
mctx
.
state_log
 = 
	`re_malloc
 (
re_dfastate_t
 *, mctx.
input
.
bufs_len
 + 1);

739 if (
	`BE
 (
mctx
.
state_log
 == 
NULL
, 0))

741 
err
 = 
REG_ESPACE
;

742 goto 
free_return
;

746 
mctx
.
state_log
 = 
NULL
;

748 
match_first
 = 
start
;

749 
mctx
.
input
.
tip_context
 = (
eflags
 & 
REG_NOTBOL
) ? 
CONTEXT_BEGBUF


750 : 
CONTEXT_NEWLINE
 | 
CONTEXT_BEGBUF
;

753 
incr
 = (
last_start
 < 
start
) ? -1 : 1;

754 
left_lim
 = (
last_start
 < 
start
) ? last_start : start;

755 
right_lim
 = (
last_start
 < 
start
) ? start : last_start;

756 
sb
 = 
dfa
->
mb_cur_max
 == 1;

757 
match_kind
 =

758 (
fastmap


759 ? ((
sb
 || !(
preg
->
syntax
 & 
RE_ICASE
 || 
t
) ? 4 : 0)

760 | (
start
 <= 
last_start
 ? 2 : 0)

761 | (
t
 != 
NULL
 ? 1 : 0))

764 for (;; 
match_first
 += 
incr
)

766 
err
 = 
REG_NOMATCH
;

767 if (
match_first
 < 
left_lim
 || 
right_lim
 < match_first)

768 goto 
free_return
;

775 switch (
match_kind
)

783 while (
	`BE
 (
match_first
 < 
right_lim
, 1)

784 && !
fastmap
[
t
[(unsigned char) 
string
[
match_first
]]])

785 ++
match_first
;

786 goto 
forward_match_found_start_or_reached_end
;

790 while (
	`BE
 (
match_first
 < 
right_lim
, 1)

791 && !
fastmap
[(unsigned char) 
string
[
match_first
]])

792 ++
match_first
;

794 
forward_match_found_start_or_reached_end
:

795 if (
	`BE
 (
match_first
 == 
right_lim
, 0))

797 
ch
 = 
match_first
 >= 
length


798 ? 0 : (unsigned char) 
string
[
match_first
];

799 if (!
fastmap
[
t
 ? t[
ch
] : ch])

800 goto 
free_return
;

807 while (
match_first
 >= 
left_lim
)

809 
ch
 = 
match_first
 >= 
length


810 ? 0 : (unsigned char) 
string
[
match_first
];

811 if (
fastmap
[
t
 ? t[
ch
] : ch])

813 --
match_first
;

815 if (
match_first
 < 
left_lim
)

816 goto 
free_return
;

827 
__re_size_t
 
offset
 = 
match_first
 - 
mctx
.
input
.
raw_mbs_idx
;

828 if (
	`BE
 (
offset
 >= (
__re_size_t
) 
mctx
.
input
.
valid_raw_len
, 0))

830 
err
 = 
	`re_string_reconstruct
 (&
mctx
.
input
, 
match_first
,

831 
eflags
);

832 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

833 goto 
free_return
;

835 
offset
 = 
match_first
 - 
mctx
.
input
.
raw_mbs_idx
;

839 
ch
 = (
match_first
 >= 
length


840 ? 0 : 
	`re_string_byte_at
 (&
mctx
.
input
, 
offset
));

841 if (
fastmap
[
ch
])

843 
match_first
 += 
incr
;

844 if (
match_first
 < 
left_lim
 || match_first > 
right_lim
)

846 
err
 = 
REG_NOMATCH
;

847 goto 
free_return
;

855 
err
 = 
	`re_string_reconstruct
 (&
mctx
.
input
, 
match_first
, 
eflags
);

856 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

857 goto 
free_return
;

859 #ifdef 
RE_ENABLE_I18N


862 if (!
sb
 && !
	`re_string_first_byte
 (&
mctx
.
input
, 0))

868 
mctx
.
state_log_top
 = mctx.
nbkref_ents
 = mctx.
max_mb_elem_len
 = 0;

869 
match_last
 = 
	`check_matching
 (&
mctx
, 
fl_longest_match
,

870 
start
 <= 
last_start
 ? &
match_first
 : 
NULL
);

871 if (
match_last
 != 
REG_MISSING
)

873 if (
	`BE
 (
match_last
 == 
REG_ERROR
, 0))

875 
err
 = 
REG_ESPACE
;

876 goto 
free_return
;

880 
mctx
.
match_last
 = match_last;

881 if ((!
preg
->
no_sub
 && 
nmatch
 > 1) || 
dfa
->
nbackref
)

883 
re_dfastate_t
 *
pstate
 = 
mctx
.
state_log
[
match_last
];

884 
mctx
.
last_node
 = 
	`check_halt_state_context
 (&mctx, 
pstate
,

885 
match_last
);

887 if ((!
preg
->
no_sub
 && 
nmatch
 > 1 && 
dfa
->
has_plural_match
)

888 || 
dfa
->
nbackref
)

890 
err
 = 
	`prune_impossible_nodes
 (&
mctx
);

891 if (
err
 == 
REG_NOERROR
)

893 if (
	`BE
 (
err
 != 
REG_NOMATCH
, 0))

894 goto 
free_return
;

895 
match_last
 = 
REG_MISSING
;

902 
	`match_ctx_clean
 (&
mctx
);

905 #ifdef 
DEBUG


906 
	`assert
 (
match_last
 != 
REG_MISSING
);

907 
	`assert
 (
err
 == 
REG_NOERROR
);

911 if (
nmatch
 > 0)

913 
Idx
 
reg_idx
;

916 for (
reg_idx
 = 1; reg_idx < 
nmatch
; ++reg_idx)

917 
pmatch
[
reg_idx
].
rm_so
 = pmatch[reg_idx].
rm_eo
 = -1;

920 
pmatch
[0].
rm_so
 = 0;

921 
pmatch
[0].
rm_eo
 = 
mctx
.
match_last
;

926 if (!
preg
->
no_sub
 && 
nmatch
 > 1)

928 
err
 = 
	`set_regs
 (
preg
, &
mctx
, 
nmatch
, 
pmatch
,

929 
dfa
->
has_plural_match
 && dfa->
nbackref
 > 0);

930 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

931 goto 
free_return
;

937 for (
reg_idx
 = 0; reg_idx < 
nmatch
; ++reg_idx)

938 if (
pmatch
[
reg_idx
].
rm_so
 != -1)

940 #ifdef 
RE_ENABLE_I18N


941 if (
	`BE
 (
mctx
.
input
.
offsets_needed
 != 0, 0))

943 
pmatch
[
reg_idx
].
rm_so
 =

944 (
pmatch
[
reg_idx
].
rm_so
 == 
mctx
.
input
.
valid_len


945 ? 
mctx
.
input
.
valid_raw_len


946 : 
mctx
.
input
.
offsets
[
pmatch
[
reg_idx
].
rm_so
]);

947 
pmatch
[
reg_idx
].
rm_eo
 =

948 (
pmatch
[
reg_idx
].
rm_eo
 == 
mctx
.
input
.
valid_len


949 ? 
mctx
.
input
.
valid_raw_len


950 : 
mctx
.
input
.
offsets
[
pmatch
[
reg_idx
].
rm_eo
]);

953 
	`assert
 (
mctx
.
input
.
offsets_needed
 == 0);

955 
pmatch
[
reg_idx
].
rm_so
 += 
match_first
;

956 
pmatch
[
reg_idx
].
rm_eo
 += 
match_first
;

958 for (
reg_idx
 = 0; reg_idx < 
extra_nmatch
; ++reg_idx)

960 
pmatch
[
nmatch
 + 
reg_idx
].
rm_so
 = -1;

961 
pmatch
[
nmatch
 + 
reg_idx
].
rm_eo
 = -1;

964 if (
dfa
->
subexp_map
)

965 for (
reg_idx
 = 0; reg_idx + 1 < 
nmatch
; reg_idx++)

966 if (
dfa
->
subexp_map
[
reg_idx
] != reg_idx)

968 
pmatch
[
reg_idx
 + 1].
rm_so


969 = 
pmatch
[
dfa
->
subexp_map
[
reg_idx
] + 1].
rm_so
;

970 
pmatch
[
reg_idx
 + 1].
rm_eo


971 = 
pmatch
[
dfa
->
subexp_map
[
reg_idx
] + 1].
rm_eo
;

975 
free_return
:

976 
	`re_free
 (
mctx
.
state_log
);

977 if (
dfa
->
nbackref
)

978 
	`match_ctx_free
 (&
mctx
);

979 
	`re_string_destruct
 (&
mctx
.
input
);

980 return 
err
;

981 
	}
}

983 static 
reg_errcode_t


984 
internal_function
 
__attribute_warn_unused_result__


985 
	$prune_impossible_nodes
 (
re_match_context_t
 *
mctx
)

987 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

988 
Idx
 
halt_node
, 
match_last
;

989 
reg_errcode_t
 
ret
;

990 
re_dfastate_t
 **
sifted_states
;

991 
re_dfastate_t
 **
lim_states
 = 
NULL
;

992 
re_sift_context_t
 
sctx
;

993 #ifdef 
DEBUG


994 
	`assert
 (
mctx
->
state_log
 != 
NULL
);

996 
match_last
 = 
mctx
->match_last;

997 
halt_node
 = 
mctx
->
last_node
;

1000 if (
	`BE
 (
SIZE_MAX
 / sizeof (
re_dfastate_t
 *) <= 
match_last
, 0))

1001 return 
REG_ESPACE
;

1003 
sifted_states
 = 
	`re_malloc
 (
re_dfastate_t
 *, 
match_last
 + 1);

1004 if (
	`BE
 (
sifted_states
 == 
NULL
, 0))

1006 
ret
 = 
REG_ESPACE
;

1007 goto 
free_return
;

1009 if (
dfa
->
nbackref
)

1011 
lim_states
 = 
	`re_malloc
 (
re_dfastate_t
 *, 
match_last
 + 1);

1012 if (
	`BE
 (
lim_states
 == 
NULL
, 0))

1014 
ret
 = 
REG_ESPACE
;

1015 goto 
free_return
;

1019 
	`memset
 (
lim_states
, '\0',

1020 sizeof (
re_dfastate_t
 *) * (
match_last
 + 1));

1021 
	`sift_ctx_init
 (&
sctx
, 
sifted_states
, 
lim_states
, 
halt_node
,

1022 
match_last
);

1023 
ret
 = 
	`sift_states_backward
 (
mctx
, &
sctx
);

1024 
	`re_node_set_free
 (&
sctx
.
limits
);

1025 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

1026 goto 
free_return
;

1027 if (
sifted_states
[0] != 
NULL
 || 
lim_states
[0] != NULL)

1031 --
match_last
;

1032 if (! 
	`REG_VALID_INDEX
 (
match_last
))

1034 
ret
 = 
REG_NOMATCH
;

1035 goto 
free_return
;

1037 } while (
mctx
->
state_log
[
match_last
] == 
NULL


1038 || !
mctx
->
state_log
[
match_last
]->
halt
);

1039 
halt_node
 = 
	`check_halt_state_context
 (
mctx
,

1040 
mctx
->
state_log
[
match_last
],

1041 
match_last
);

1043 
ret
 = 
	`merge_state_array
 (
dfa
, 
sifted_states
, 
lim_states
,

1044 
match_last
 + 1);

1045 
	`re_free
 (
lim_states
);

1046 
lim_states
 = 
NULL
;

1047 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

1048 goto 
free_return
;

1052 
	`sift_ctx_init
 (&
sctx
, 
sifted_states
, 
lim_states
, 
halt_node
, 
match_last
);

1053 
ret
 = 
	`sift_states_backward
 (
mctx
, &
sctx
);

1054 
	`re_node_set_free
 (&
sctx
.
limits
);

1055 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

1056 goto 
free_return
;

1057 if (
sifted_states
[0] == 
NULL
)

1059 
ret
 = 
REG_NOMATCH
;

1060 goto 
free_return
;

1063 
	`re_free
 (
mctx
->
state_log
);

1064 
mctx
->
state_log
 = 
sifted_states
;

1065 
sifted_states
 = 
NULL
;

1066 
mctx
->
last_node
 = 
halt_node
;

1067 
mctx
->
match_last
 = match_last;

1068 
ret
 = 
REG_NOERROR
;

1069 
free_return
:

1070 
	`re_free
 (
sifted_states
);

1071 
	`re_free
 (
lim_states
);

1072 return 
ret
;

1073 
	}
}

1079 static 
inline
 
re_dfastate_t
 *

1080 
__attribute
 ((
always_inline
)) 
internal_function


1081 
	$acquire_init_state_context
 (
reg_errcode_t
 *
err
, const 
re_match_context_t
 *
mctx
,

1082 
Idx
 
idx
)

1084 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

1085 if (
dfa
->
init_state
->
has_constraint
)

1087 unsigned int 
context
;

1088 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
idx
 - 1, mctx->
eflags
);

1089 if (
	`IS_WORD_CONTEXT
 (
context
))

1090 return 
dfa
->
init_state_word
;

1091 else if (
	`IS_ORDINARY_CONTEXT
 (
context
))

1092 return 
dfa
->
init_state
;

1093 else if (
	`IS_BEGBUF_CONTEXT
 (
context
) && 
	`IS_NEWLINE_CONTEXT
 (context))

1094 return 
dfa
->
init_state_begbuf
;

1095 else if (
	`IS_NEWLINE_CONTEXT
 (
context
))

1096 return 
dfa
->
init_state_nl
;

1097 else if (
	`IS_BEGBUF_CONTEXT
 (
context
))

1100 return 
	`re_acquire_state_context
 (
err
, 
dfa
,

1101 
dfa
->
init_state
->
entrance_nodes
,

1102 
context
);

1106 return 
dfa
->
init_state
;

1109 return 
dfa
->
init_state
;

1110 
	}
}

1121 static 
Idx


1122 
internal_function
 
__attribute_warn_unused_result__


1123 
	$check_matching
 (
re_match_context_t
 *
mctx
, 
bool
 
fl_longest_match
,

1124 
Idx
 *
p_match_first
)

1126 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

1127 
reg_errcode_t
 
err
;

1128 
Idx
 
match
 = 0;

1129 
Idx
 
match_last
 = 
REG_MISSING
;

1130 
Idx
 
cur_str_idx
 = 
	`re_string_cur_idx
 (&
mctx
->
input
);

1131 
re_dfastate_t
 *
cur_state
;

1132 
bool
 
at_init_state
 = 
p_match_first
 != 
NULL
;

1133 
Idx
 
next_start_idx
 = 
cur_str_idx
;

1135 
err
 = 
REG_NOERROR
;

1136 
cur_state
 = 
	`acquire_init_state_context
 (&
err
, 
mctx
, 
cur_str_idx
);

1138 if (
	`BE
 (
cur_state
 == 
NULL
, 0))

1140 
	`assert
 (
err
 == 
REG_ESPACE
);

1141 return 
REG_ERROR
;

1144 if (
mctx
->
state_log
 != 
NULL
)

1146 
mctx
->
state_log
[
cur_str_idx
] = 
cur_state
;

1150 if (
	`BE
 (
dfa
->
nbackref
, 0))

1152 
at_init_state
 = 
false
;

1153 
err
 = 
	`check_subexp_matching_top
 (
mctx
, &
cur_state
->
nodes
, 0);

1154 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1155 return 
err
;

1157 if (
cur_state
->
has_backref
)

1159 
err
 = 
	`transit_state_bkref
 (
mctx
, &
cur_state
->
nodes
);

1160 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1161 return 
err
;

1167 if (
	`BE
 (
cur_state
->
halt
, 0))

1169 if (!
cur_state
->
has_constraint


1170 || 
	`check_halt_state_context
 (
mctx
, 
cur_state
, 
cur_str_idx
))

1172 if (!
fl_longest_match
)

1173 return 
cur_str_idx
;

1176 
match_last
 = 
cur_str_idx
;

1177 
match
 = 1;

1182 while (!
	`re_string_eoi
 (&
mctx
->
input
))

1184 
re_dfastate_t
 *
old_state
 = 
cur_state
;

1185 
Idx
 
next_char_idx
 = 
	`re_string_cur_idx
 (&
mctx
->
input
) + 1;

1187 if (
	`BE
 (
next_char_idx
 >= 
mctx
->
input
.
bufs_len
, 0)

1188 || (
	`BE
 (
next_char_idx
 >= 
mctx
->
input
.
valid_len
, 0)

1189 && 
mctx
->
input
.
valid_len
 < mctx->input.
len
))

1191 
err
 = 
	`extend_buffers
 (
mctx
);

1192 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1194 
	`assert
 (
err
 == 
REG_ESPACE
);

1195 return 
REG_ERROR
;

1199 
cur_state
 = 
	`transit_state
 (&
err
, 
mctx
, cur_state);

1200 if (
mctx
->
state_log
 != 
NULL
)

1201 
cur_state
 = 
	`merge_state_with_log
 (&
err
, 
mctx
, cur_state);

1203 if (
cur_state
 == 
NULL
)

1208 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1209 return 
REG_ERROR
;

1211 if (
mctx
->
state_log
 == 
NULL


1212 || (
match
 && !
fl_longest_match
)

1213 || (
cur_state
 = 
	`find_recover_state
 (&
err
, 
mctx
)) == 
NULL
)

1217 if (
	`BE
 (
at_init_state
, 0))

1219 if (
old_state
 == 
cur_state
)

1220 
next_start_idx
 = 
next_char_idx
;

1222 
at_init_state
 = 
false
;

1225 if (
cur_state
->
halt
)

1229 if (!
cur_state
->
has_constraint


1230 || 
	`check_halt_state_context
 (
mctx
, 
cur_state
,

1231 
	`re_string_cur_idx
 (&
mctx
->
input
)))

1234 
match_last
 = 
	`re_string_cur_idx
 (&
mctx
->
input
);

1235 
match
 = 1;

1238 
p_match_first
 = 
NULL
;

1239 if (!
fl_longest_match
)

1245 if (
p_match_first
)

1246 *
p_match_first
 += 
next_start_idx
;

1248 return 
match_last
;

1249 
	}
}

1253 static 
bool


1254 
internal_function


1255 
	$check_halt_node_context
 (const 
re_dfa_t
 *
dfa
, 
Idx
 
node
, unsigned int 
context
)

1257 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
node
].type;

1258 unsigned int 
constraint
 = 
dfa
->
nodes
[
node
].constraint;

1259 if (
type
 != 
END_OF_RE
)

1260 return 
false
;

1261 if (!
constraint
)

1262 return 
true
;

1263 if (
	`NOT_SATISFY_NEXT_CONSTRAINT
 (
constraint
, 
context
))

1264 return 
false
;

1265 return 
true
;

1266 
	}
}

1272 static 
Idx


1273 
internal_function


1274 
	$check_halt_state_context
 (const 
re_match_context_t
 *
mctx
,

1275 const 
re_dfastate_t
 *
state
, 
Idx
 
idx
)

1277 
Idx
 
i
;

1278 unsigned int 
context
;

1279 #ifdef 
DEBUG


1280 
	`assert
 (
state
->
halt
);

1282 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
idx
, mctx->
eflags
);

1283 for (
i
 = 0; i < 
state
->
nodes
.
nelem
; ++i)

1284 if (
	`check_halt_node_context
 (
mctx
->
dfa
, 
state
->
nodes
.
elems
[
i
], 
context
))

1285 return 
state
->
nodes
.
elems
[
i
];

1287 
	}
}

1294 static 
Idx


1295 
internal_function


1296 
	$proceed_next_node
 (const 
re_match_context_t
 *
mctx
, 
Idx
 
nregs
, 
regmatch_t
 *
regs
,

1297 
Idx
 *
pidx
, Idx 
node
, 
re_node_set
 *
eps_via_nodes
,

1298 struct 
re_fail_stack_t
 *
fs
)

1300 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

1301 
Idx
 
i
;

1302 
bool
 
ok
;

1303 if (
	`IS_EPSILON_NODE
 (
dfa
->
nodes
[
node
].
type
))

1305 
re_node_set
 *
cur_nodes
 = &
mctx
->
state_log
[*
pidx
]->
nodes
;

1306 
re_node_set
 *
edests
 = &
dfa
->edests[
node
];

1307 
Idx
 
dest_node
;

1308 
ok
 = 
	`re_node_set_insert
 (
eps_via_nodes
, 
node
);

1309 if (
	`BE
 (! 
ok
, 0))

1310 return 
REG_ERROR
;

1313 for (
dest_node
 = 
REG_MISSING
, 
i
 = 0; i < 
edests
->
nelem
; ++i)

1315 
Idx
 
candidate
 = 
edests
->
elems
[
i
];

1316 if (!
	`re_node_set_contains
 (
cur_nodes
, 
candidate
))

1318 if (
dest_node
 == 
REG_MISSING
)

1319 
dest_node
 = 
candidate
;

1325 if (
	`re_node_set_contains
 (
eps_via_nodes
, 
dest_node
))

1326 return 
candidate
;

1329 else if (
fs
 != 
NULL


1330 && 
	`push_fail_stack
 (
fs
, *
pidx
, 
candidate
, 
nregs
, 
regs
,

1331 
eps_via_nodes
))

1332 return 
REG_ERROR
;

1338 return 
dest_node
;

1342 
Idx
 
naccepted
 = 0;

1343 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
node
].type;

1345 #ifdef 
RE_ENABLE_I18N


1346 if (
dfa
->
nodes
[
node
].
accept_mb
)

1347 
naccepted
 = 
	`check_node_accept_bytes
 (
dfa
, 
node
, &
mctx
->
input
, *
pidx
);

1350 if (
type
 == 
OP_BACK_REF
)

1352 
Idx
 
subexp_idx
 = 
dfa
->
nodes
[
node
].
opr
.
idx
 + 1;

1353 
naccepted
 = 
regs
[
subexp_idx
].
rm_eo
 - regs[subexp_idx].
rm_so
;

1354 if (
fs
 != 
NULL
)

1356 if (
regs
[
subexp_idx
].
rm_so
 == -1 || regs[subexp_idx].
rm_eo
 == -1)

1357 return 
REG_MISSING
;

1358 else if (
naccepted
)

1360 char *
buf
 = (char *) 
	`re_string_get_buffer
 (&
mctx
->
input
);

1361 if (
	`memcmp
 (
buf
 + 
regs
[
subexp_idx
].
rm_so
, buf + *
pidx
,

1362 
naccepted
) != 0)

1363 return 
REG_MISSING
;

1367 if (
naccepted
 == 0)

1369 
Idx
 
dest_node
;

1370 
ok
 = 
	`re_node_set_insert
 (
eps_via_nodes
, 
node
);

1371 if (
	`BE
 (! 
ok
, 0))

1372 return 
REG_ERROR
;

1373 
dest_node
 = 
dfa
->
edests
[
node
].
elems
[0];

1374 if (
	`re_node_set_contains
 (&
mctx
->
state_log
[*
pidx
]->
nodes
,

1375 
dest_node
))

1376 return 
dest_node
;

1380 if (
naccepted
 != 0

1381 || 
	`check_node_accept
 (
mctx
, 
dfa
->
nodes
 + 
node
, *
pidx
))

1383 
Idx
 
dest_node
 = 
dfa
->
nexts
[
node
];

1384 *
pidx
 = (
naccepted
 == 0) ? *pidx + 1 : *pidx + naccepted;

1385 if (
fs
 && (*
pidx
 > 
mctx
->
match_last
 || mctx->
state_log
[*pidx] == 
NULL


1386 || !
	`re_node_set_contains
 (&
mctx
->
state_log
[*
pidx
]->
nodes
,

1387 
dest_node
)))

1388 return 
REG_MISSING
;

1389 
	`re_node_set_empty
 (
eps_via_nodes
);

1390 return 
dest_node
;

1393 return 
REG_MISSING
;

1394 
	}
}

1396 static 
reg_errcode_t


1397 
internal_function
 
__attribute_warn_unused_result__


1398 
	$push_fail_stack
 (struct 
re_fail_stack_t
 *
fs
, 
Idx
 
str_idx
, Idx 
dest_node
,

1399 
Idx
 
nregs
, 
regmatch_t
 *
regs
, 
re_node_set
 *
eps_via_nodes
)

1401 
reg_errcode_t
 
err
;

1402 
Idx
 
num
 = 
fs
->num++;

1403 if (
fs
->
num
 == fs->
alloc
)

1405 struct 
re_fail_stack_ent_t
 *
new_array
;

1406 
new_array
 = 
	`realloc
 (
fs
->
stack
, (sizeof (struct 
re_fail_stack_ent_t
)

1407 * 
fs
->
alloc
 * 2));

1408 if (
new_array
 == 
NULL
)

1409 return 
REG_ESPACE
;

1410 
fs
->
alloc
 *= 2;

1411 
fs
->
stack
 = 
new_array
;

1413 
fs
->
stack
[
num
].
idx
 = 
str_idx
;

1414 
fs
->
stack
[
num
].
node
 = 
dest_node
;

1415 
fs
->
stack
[
num
].
regs
 = 
	`re_malloc
 (
regmatch_t
, 
nregs
);

1416 if (
fs
->
stack
[
num
].
regs
 == 
NULL
)

1417 return 
REG_ESPACE
;

1418 
	`memcpy
 (
fs
->
stack
[
num
].
regs
, regs, sizeof (
regmatch_t
) * 
nregs
);

1419 
err
 = 
	`re_node_set_init_copy
 (&
fs
->
stack
[
num
].
eps_via_nodes
, eps_via_nodes);

1420 return 
err
;

1421 
	}
}

1423 static 
Idx


1424 
internal_function


1425 
	$pop_fail_stack
 (struct 
re_fail_stack_t
 *
fs
, 
Idx
 *
pidx
, Idx 
nregs
,

1426 
regmatch_t
 *
regs
, 
re_node_set
 *
eps_via_nodes
)

1428 
Idx
 
num
 = --
fs
->num;

1429 
	`assert
 (
	`REG_VALID_INDEX
 (
num
));

1430 *
pidx
 = 
fs
->
stack
[
num
].
idx
;

1431 
	`memcpy
 (
regs
, 
fs
->
stack
[
num
].regs, sizeof (
regmatch_t
) * 
nregs
);

1432 
	`re_node_set_free
 (
eps_via_nodes
);

1433 
	`re_free
 (
fs
->
stack
[
num
].
regs
);

1434 *
eps_via_nodes
 = 
fs
->
stack
[
num
].eps_via_nodes;

1435 return 
fs
->
stack
[
num
].
node
;

1436 
	}
}

1443 static 
reg_errcode_t


1444 
internal_function
 
__attribute_warn_unused_result__


1445 
	$set_regs
 (const 
regex_t
 *
preg
, const 
re_match_context_t
 *
mctx
, 
size_t
 
nmatch
,

1446 
regmatch_t
 *
pmatch
, 
bool
 
fl_backtrack
)

1448 const 
re_dfa_t
 *
dfa
 = (const re_dfa_t *) 
preg
->
buffer
;

1449 
Idx
 
idx
, 
cur_node
;

1450 
re_node_set
 
eps_via_nodes
;

1451 struct 
re_fail_stack_t
 *
fs
;

1452 struct 
re_fail_stack_t
 
fs_body
 = { 0, 2, 
NULL
 };

1453 
regmatch_t
 *
prev_idx_match
;

1454 
bool
 
prev_idx_match_malloced
 = 
false
;

1456 #ifdef 
DEBUG


1457 
	`assert
 (
nmatch
 > 1);

1458 
	`assert
 (
mctx
->
state_log
 != 
NULL
);

1460 if (
fl_backtrack
)

1462 
fs
 = &
fs_body
;

1463 
fs
->
stack
 = 
	`re_malloc
 (struct 
re_fail_stack_ent_t
, fs->
alloc
);

1464 if (
fs
->
stack
 == 
NULL
)

1465 return 
REG_ESPACE
;

1468 
fs
 = 
NULL
;

1470 
cur_node
 = 
dfa
->
init_node
;

1471 
	`re_node_set_init_empty
 (&
eps_via_nodes
);

1473 if (
	`__libc_use_alloca
 (
nmatch
 * sizeof (
regmatch_t
)))

1474 
prev_idx_match
 = (
regmatch_t
 *) 
	`alloca
 (
nmatch
 * sizeof (regmatch_t));

1477 
prev_idx_match
 = 
	`re_malloc
 (
regmatch_t
, 
nmatch
);

1478 if (
prev_idx_match
 == 
NULL
)

1480 
	`free_fail_stack_return
 (
fs
);

1481 return 
REG_ESPACE
;

1483 
prev_idx_match_malloced
 = 
true
;

1485 
	`memcpy
 (
prev_idx_match
, 
pmatch
, sizeof (
regmatch_t
) * 
nmatch
);

1487 for (
idx
 = 
pmatch
[0].
rm_so
; idx <= pmatch[0].
rm_eo
 ;)

1489 
	`update_regs
 (
dfa
, 
pmatch
, 
prev_idx_match
, 
cur_node
, 
idx
, 
nmatch
);

1491 if (
idx
 == 
pmatch
[0].
rm_eo
 && 
cur_node
 == 
mctx
->
last_node
)

1493 
Idx
 
reg_idx
;

1494 if (
fs
)

1496 for (
reg_idx
 = 0; reg_idx < 
nmatch
; ++reg_idx)

1497 if (
pmatch
[
reg_idx
].
rm_so
 > -1 && pmatch[reg_idx].
rm_eo
 == -1)

1499 if (
reg_idx
 == 
nmatch
)

1501 
	`re_node_set_free
 (&
eps_via_nodes
);

1502 if (
prev_idx_match_malloced
)

1503 
	`re_free
 (
prev_idx_match
);

1504 return 
	`free_fail_stack_return
 (
fs
);

1506 
cur_node
 = 
	`pop_fail_stack
 (
fs
, &
idx
, 
nmatch
, 
pmatch
,

1507 &
eps_via_nodes
);

1511 
	`re_node_set_free
 (&
eps_via_nodes
);

1512 if (
prev_idx_match_malloced
)

1513 
	`re_free
 (
prev_idx_match
);

1514 return 
REG_NOERROR
;

1519 
cur_node
 = 
	`proceed_next_node
 (
mctx
, 
nmatch
, 
pmatch
, &
idx
, cur_node,

1520 &
eps_via_nodes
, 
fs
);

1522 if (
	`BE
 (! 
	`REG_VALID_INDEX
 (
cur_node
), 0))

1524 if (
	`BE
 (
cur_node
 == 
REG_ERROR
, 0))

1526 
	`re_node_set_free
 (&
eps_via_nodes
);

1527 if (
prev_idx_match_malloced
)

1528 
	`re_free
 (
prev_idx_match
);

1529 
	`free_fail_stack_return
 (
fs
);

1530 return 
REG_ESPACE
;

1532 if (
fs
)

1533 
cur_node
 = 
	`pop_fail_stack
 (
fs
, &
idx
, 
nmatch
, 
pmatch
,

1534 &
eps_via_nodes
);

1537 
	`re_node_set_free
 (&
eps_via_nodes
);

1538 if (
prev_idx_match_malloced
)

1539 
	`re_free
 (
prev_idx_match
);

1540 return 
REG_NOMATCH
;

1544 
	`re_node_set_free
 (&
eps_via_nodes
);

1545 if (
prev_idx_match_malloced
)

1546 
	`re_free
 (
prev_idx_match
);

1547 return 
	`free_fail_stack_return
 (
fs
);

1548 
	}
}

1550 static 
reg_errcode_t


1551 
internal_function


1552 
	$free_fail_stack_return
 (struct 
re_fail_stack_t
 *
fs
)

1554 if (
fs
)

1556 
Idx
 
fs_idx
;

1557 for (
fs_idx
 = 0; fs_idx < 
fs
->
num
; ++fs_idx)

1559 
	`re_node_set_free
 (&
fs
->
stack
[
fs_idx
].
eps_via_nodes
);

1560 
	`re_free
 (
fs
->
stack
[
fs_idx
].
regs
);

1562 
	`re_free
 (
fs
->
stack
);

1564 return 
REG_NOERROR
;

1565 
	}
}

1568 
internal_function


1569 
	$update_regs
 (const 
re_dfa_t
 *
dfa
, 
regmatch_t
 *
pmatch
,

1570 
regmatch_t
 *
prev_idx_match
, 
Idx
 
cur_node
, Idx 
cur_idx
, Idx 
nmatch
)

1572 int 
type
 = 
dfa
->
nodes
[
cur_node
].type;

1573 if (
type
 == 
OP_OPEN_SUBEXP
)

1575 
Idx
 
reg_num
 = 
dfa
->
nodes
[
cur_node
].
opr
.
idx
 + 1;

1578 if (
reg_num
 < 
nmatch
)

1580 
pmatch
[
reg_num
].
rm_so
 = 
cur_idx
;

1581 
pmatch
[
reg_num
].
rm_eo
 = -1;

1584 else if (
type
 == 
OP_CLOSE_SUBEXP
)

1586 
Idx
 
reg_num
 = 
dfa
->
nodes
[
cur_node
].
opr
.
idx
 + 1;

1587 if (
reg_num
 < 
nmatch
)

1590 if (
pmatch
[
reg_num
].
rm_so
 < 
cur_idx
)

1592 
pmatch
[
reg_num
].
rm_eo
 = 
cur_idx
;

1595 
	`memcpy
 (
prev_idx_match
, 
pmatch
, sizeof (
regmatch_t
) * 
nmatch
);

1599 if (
dfa
->
nodes
[
cur_node
].
opt_subexp


1600 && 
prev_idx_match
[
reg_num
].
rm_so
 != -1)

1606 
	`memcpy
 (
pmatch
, 
prev_idx_match
, sizeof (
regmatch_t
) * 
nmatch
);

1610 
pmatch
[
reg_num
].
rm_eo
 = 
cur_idx
;

1614 
	}
}

1636 #define 
	#STATE_NODE_CONTAINS
(
state
,
node
) \

1637 ((
state
) != 
NULL
 && 
	`re_node_set_contains
 (&(state)->
nodes
, 
node
))

	)

1639 static 
reg_errcode_t


1640 
internal_function


1641 
	$sift_states_backward
 (const 
re_match_context_t
 *
mctx
, 
re_sift_context_t
 *
sctx
)

1643 
reg_errcode_t
 
err
;

1644 int 
null_cnt
 = 0;

1645 
Idx
 
str_idx
 = 
sctx
->
last_str_idx
;

1646 
re_node_set
 
cur_dest
;

1648 #ifdef 
DEBUG


1649 
	`assert
 (
mctx
->
state_log
 != 
NULL
 && mctx->state_log[
str_idx
] != NULL);

1654 
err
 = 
	`re_node_set_init_1
 (&
cur_dest
, 
sctx
->
last_node
);

1655 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1656 return 
err
;

1657 
err
 = 
	`update_cur_sifted_state
 (
mctx
, 
sctx
, 
str_idx
, &
cur_dest
);

1658 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1659 goto 
free_return
;

1662 while (
str_idx
 > 0)

1665 
null_cnt
 = (
sctx
->
sifted_states
[
str_idx
] == 
NULL
) ? null_cnt + 1 : 0;

1666 if (
null_cnt
 > 
mctx
->
max_mb_elem_len
)

1668 
	`memset
 (
sctx
->
sifted_states
, '\0',

1669 sizeof (
re_dfastate_t
 *) * 
str_idx
);

1670 
	`re_node_set_free
 (&
cur_dest
);

1671 return 
REG_NOERROR
;

1673 
	`re_node_set_empty
 (&
cur_dest
);

1674 --
str_idx
;

1676 if (
mctx
->
state_log
[
str_idx
])

1678 
err
 = 
	`build_sifted_states
 (
mctx
, 
sctx
, 
str_idx
, &
cur_dest
);

1679 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1680 goto 
free_return
;

1687 
err
 = 
	`update_cur_sifted_state
 (
mctx
, 
sctx
, 
str_idx
, &
cur_dest
);

1688 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1689 goto 
free_return
;

1691 
err
 = 
REG_NOERROR
;

1692 
free_return
:

1693 
	`re_node_set_free
 (&
cur_dest
);

1694 return 
err
;

1695 
	}
}

1697 static 
reg_errcode_t


1698 
internal_function
 
__attribute_warn_unused_result__


1699 
	$build_sifted_states
 (const 
re_match_context_t
 *
mctx
, 
re_sift_context_t
 *
sctx
,

1700 
Idx
 
str_idx
, 
re_node_set
 *
cur_dest
)

1702 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

1703 const 
re_node_set
 *
cur_src
 = &
mctx
->
state_log
[
str_idx
]->
non_eps_nodes
;

1704 
Idx
 
i
;

1713 for (
i
 = 0; i < 
cur_src
->
nelem
; i++)

1715 
Idx
 
prev_node
 = 
cur_src
->
elems
[
i
];

1716 int 
naccepted
 = 0;

1717 
bool
 
ok
;

1719 #ifdef 
DEBUG


1720 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
prev_node
].type;

1721 
	`assert
 (!
	`IS_EPSILON_NODE
 (
type
));

1723 #ifdef 
RE_ENABLE_I18N


1725 if (
dfa
->
nodes
[
prev_node
].
accept_mb
)

1726 
naccepted
 = 
	`sift_states_iter_mb
 (
mctx
, 
sctx
, 
prev_node
,

1727 
str_idx
, 
sctx
->
last_str_idx
);

1732 if (!
naccepted


1733 && 
	`check_node_accept
 (
mctx
, 
dfa
->
nodes
 + 
prev_node
, 
str_idx
)

1734 && 
	`STATE_NODE_CONTAINS
 (
sctx
->
sifted_states
[
str_idx
 + 1],

1735 
dfa
->
nexts
[
prev_node
]))

1736 
naccepted
 = 1;

1738 if (
naccepted
 == 0)

1741 if (
sctx
->
limits
.
nelem
)

1743 
Idx
 
to_idx
 = 
str_idx
 + 
naccepted
;

1744 if (
	`check_dst_limits
 (
mctx
, &
sctx
->
limits
,

1745 
dfa
->
nexts
[
prev_node
], 
to_idx
,

1746 
prev_node
, 
str_idx
))

1749 
ok
 = 
	`re_node_set_insert
 (
cur_dest
, 
prev_node
);

1750 if (
	`BE
 (! 
ok
, 0))

1751 return 
REG_ESPACE
;

1754 return 
REG_NOERROR
;

1755 
	}
}

1759 static 
reg_errcode_t


1760 
internal_function


1761 
	$clean_state_log_if_needed
 (
re_match_context_t
 *
mctx
, 
Idx
 
next_state_log_idx
)

1763 
Idx
 
top
 = 
mctx
->
state_log_top
;

1765 if (
next_state_log_idx
 >= 
mctx
->
input
.
bufs_len


1766 || (
next_state_log_idx
 >= 
mctx
->
input
.
valid_len


1767 && 
mctx
->
input
.
valid_len
 < mctx->input.
len
))

1769 
reg_errcode_t
 
err
;

1770 
err
 = 
	`extend_buffers
 (
mctx
);

1771 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1772 return 
err
;

1775 if (
top
 < 
next_state_log_idx
)

1777 
	`memset
 (
mctx
->
state_log
 + 
top
 + 1, '\0',

1778 sizeof (
re_dfastate_t
 *) * (
next_state_log_idx
 - 
top
));

1779 
mctx
->
state_log_top
 = 
next_state_log_idx
;

1781 return 
REG_NOERROR
;

1782 
	}
}

1784 static 
reg_errcode_t


1785 
internal_function


1786 
	$merge_state_array
 (const 
re_dfa_t
 *
dfa
, 
re_dfastate_t
 **
dst
,

1787 
re_dfastate_t
 **
src
, 
Idx
 
num
)

1789 
Idx
 
st_idx
;

1790 
reg_errcode_t
 
err
;

1791 for (
st_idx
 = 0; st_idx < 
num
; ++st_idx)

1793 if (
dst
[
st_idx
] == 
NULL
)

1794 
dst
[
st_idx
] = 
src
[st_idx];

1795 else if (
src
[
st_idx
] != 
NULL
)

1797 
re_node_set
 
merged_set
;

1798 
err
 = 
	`re_node_set_init_union
 (&
merged_set
, &
dst
[
st_idx
]->
nodes
,

1799 &
src
[
st_idx
]->
nodes
);

1800 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1801 return 
err
;

1802 
dst
[
st_idx
] = 
	`re_acquire_state
 (&
err
, 
dfa
, &
merged_set
);

1803 
	`re_node_set_free
 (&
merged_set
);

1804 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1805 return 
err
;

1808 return 
REG_NOERROR
;

1809 
	}
}

1811 static 
reg_errcode_t


1812 
internal_function


1813 
	$update_cur_sifted_state
 (const 
re_match_context_t
 *
mctx
,

1814 
re_sift_context_t
 *
sctx
, 
Idx
 
str_idx
,

1815 
re_node_set
 *
dest_nodes
)

1817 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

1818 
reg_errcode_t
 
err
 = 
REG_NOERROR
;

1819 const 
re_node_set
 *
candidates
;

1820 
candidates
 = ((
mctx
->
state_log
[
str_idx
] == 
NULL
) ? NULL

1821 : &
mctx
->
state_log
[
str_idx
]->
nodes
);

1823 if (
dest_nodes
->
nelem
 == 0)

1824 
sctx
->
sifted_states
[
str_idx
] = 
NULL
;

1827 if (
candidates
)

1831 
err
 = 
	`add_epsilon_src_nodes
 (
dfa
, 
dest_nodes
, 
candidates
);

1832 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1833 return 
err
;

1836 if (
sctx
->
limits
.
nelem
)

1838 
err
 = 
	`check_subexp_limits
 (
dfa
, 
dest_nodes
, 
candidates
, &
sctx
->
limits
,

1839 
mctx
->
bkref_ents
, 
str_idx
);

1840 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1841 return 
err
;

1845 
sctx
->
sifted_states
[
str_idx
] = 
	`re_acquire_state
 (&
err
, 
dfa
, 
dest_nodes
);

1846 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1847 return 
err
;

1850 if (
candidates
 && 
mctx
->
state_log
[
str_idx
]->
has_backref
)

1852 
err
 = 
	`sift_states_bkref
 (
mctx
, 
sctx
, 
str_idx
, 
candidates
);

1853 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1854 return 
err
;

1856 return 
REG_NOERROR
;

1857 
	}
}

1859 static 
reg_errcode_t


1860 
internal_function
 
__attribute_warn_unused_result__


1861 
	$add_epsilon_src_nodes
 (const 
re_dfa_t
 *
dfa
, 
re_node_set
 *
dest_nodes
,

1862 const 
re_node_set
 *
candidates
)

1864 
reg_errcode_t
 
err
 = 
REG_NOERROR
;

1865 
Idx
 
i
;

1867 
re_dfastate_t
 *
state
 = 
	`re_acquire_state
 (&
err
, 
dfa
, 
dest_nodes
);

1868 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1869 return 
err
;

1871 if (!
state
->
inveclosure
.
alloc
)

1873 
err
 = 
	`re_node_set_alloc
 (&
state
->
inveclosure
, 
dest_nodes
->
nelem
);

1874 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1875 return 
REG_ESPACE
;

1876 for (
i
 = 0; i < 
dest_nodes
->
nelem
; i++)

1878 
err
 = 
	`re_node_set_merge
 (&
state
->
inveclosure
,

1879 
dfa
->
inveclosures
 + 
dest_nodes
->
elems
[
i
]);

1880 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1881 return 
REG_ESPACE
;

1884 return 
	`re_node_set_add_intersect
 (
dest_nodes
, 
candidates
,

1885 &
state
->
inveclosure
);

1886 
	}
}

1888 static 
reg_errcode_t


1889 
internal_function


1890 
	$sub_epsilon_src_nodes
 (const 
re_dfa_t
 *
dfa
, 
Idx
 
node
, 
re_node_set
 *
dest_nodes
,

1891 const 
re_node_set
 *
candidates
)

1893 
Idx
 
ecl_idx
;

1894 
reg_errcode_t
 
err
;

1895 
re_node_set
 *
inv_eclosure
 = 
dfa
->
inveclosures
 + 
node
;

1896 
re_node_set
 
except_nodes
;

1897 
	`re_node_set_init_empty
 (&
except_nodes
);

1898 for (
ecl_idx
 = 0; ecl_idx < 
inv_eclosure
->
nelem
; ++ecl_idx)

1900 
Idx
 
cur_node
 = 
inv_eclosure
->
elems
[
ecl_idx
];

1901 if (
cur_node
 == 
node
)

1903 if (
	`IS_EPSILON_NODE
 (
dfa
->
nodes
[
cur_node
].
type
))

1905 
Idx
 
edst1
 = 
dfa
->
edests
[
cur_node
].
elems
[0];

1906 
Idx
 
edst2
 = ((
dfa
->
edests
[
cur_node
].
nelem
 > 1)

1907 ? 
dfa
->
edests
[
cur_node
].
elems
[1] : 
REG_MISSING
);

1908 if ((!
	`re_node_set_contains
 (
inv_eclosure
, 
edst1
)

1909 && 
	`re_node_set_contains
 (
dest_nodes
, 
edst1
))

1910 || (
	`REG_VALID_NONZERO_INDEX
 (
edst2
)

1911 && !
	`re_node_set_contains
 (
inv_eclosure
, 
edst2
)

1912 && 
	`re_node_set_contains
 (
dest_nodes
, 
edst2
)))

1914 
err
 = 
	`re_node_set_add_intersect
 (&
except_nodes
, 
candidates
,

1915 
dfa
->
inveclosures
 + 
cur_node
);

1916 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

1918 
	`re_node_set_free
 (&
except_nodes
);

1919 return 
err
;

1924 for (
ecl_idx
 = 0; ecl_idx < 
inv_eclosure
->
nelem
; ++ecl_idx)

1926 
Idx
 
cur_node
 = 
inv_eclosure
->
elems
[
ecl_idx
];

1927 if (!
	`re_node_set_contains
 (&
except_nodes
, 
cur_node
))

1929 
Idx
 
idx
 = 
	`re_node_set_contains
 (
dest_nodes
, 
cur_node
) - 1;

1930 
	`re_node_set_remove_at
 (
dest_nodes
, 
idx
);

1933 
	`re_node_set_free
 (&
except_nodes
);

1934 return 
REG_NOERROR
;

1935 
	}
}

1937 static 
bool


1938 
internal_function


1939 
	$check_dst_limits
 (const 
re_match_context_t
 *
mctx
, const 
re_node_set
 *
limits
,

1940 
Idx
 
dst_node
, Idx 
dst_idx
, Idx 
src_node
, Idx 
src_idx
)

1942 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

1943 
Idx
 
lim_idx
, 
src_pos
, 
dst_pos
;

1945 
Idx
 
dst_bkref_idx
 = 
	`search_cur_bkref_entry
 (
mctx
, 
dst_idx
);

1946 
Idx
 
src_bkref_idx
 = 
	`search_cur_bkref_entry
 (
mctx
, 
src_idx
);

1947 for (
lim_idx
 = 0; lim_idx < 
limits
->
nelem
; ++lim_idx)

1949 
Idx
 
subexp_idx
;

1950 struct 
re_backref_cache_entry
 *
ent
;

1951 
ent
 = 
mctx
->
bkref_ents
 + 
limits
->
elems
[
lim_idx
];

1952 
subexp_idx
 = 
dfa
->
nodes
[
ent
->
node
].
opr
.
idx
;

1954 
dst_pos
 = 
	`check_dst_limits_calc_pos
 (
mctx
, 
limits
->
elems
[
lim_idx
],

1955 
subexp_idx
, 
dst_node
, 
dst_idx
,

1956 
dst_bkref_idx
);

1957 
src_pos
 = 
	`check_dst_limits_calc_pos
 (
mctx
, 
limits
->
elems
[
lim_idx
],

1958 
subexp_idx
, 
src_node
, 
src_idx
,

1959 
src_bkref_idx
);

1965 if (
src_pos
 == 
dst_pos
)

1968 return 
true
;

1970 return 
false
;

1971 
	}
}

1974 
internal_function


1975 
	$check_dst_limits_calc_pos_1
 (const 
re_match_context_t
 *
mctx
, int 
boundaries
,

1976 
Idx
 
subexp_idx
, Idx 
from_node
, Idx 
bkref_idx
)

1978 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

1979 const 
re_node_set
 *
eclosures
 = 
dfa
->eclosures + 
from_node
;

1980 
Idx
 
node_idx
;

1984 for (
node_idx
 = 0; node_idx < 
eclosures
->
nelem
; ++node_idx)

1986 
Idx
 
node
 = 
eclosures
->
elems
[
node_idx
];

1987 switch (
dfa
->
nodes
[
node
].
type
)

1989 case 
OP_BACK_REF
:

1990 if (
bkref_idx
 != 
REG_MISSING
)

1992 struct 
re_backref_cache_entry
 *
ent
 = 
mctx
->
bkref_ents
 + 
bkref_idx
;

1995 
Idx
 
dst
;

1996 int 
cpos
;

1998 if (
ent
->
node
 != node)

2001 if (
subexp_idx
 < 
BITSET_WORD_BITS


2002 && !(
ent
->
eps_reachable_subexps_map


2003 & ((
bitset_word_t
) 1 << 
subexp_idx
)))

2012 
dst
 = 
dfa
->
edests
[
node
].
elems
[0];

2013 if (
dst
 == 
from_node
)

2015 if (
boundaries
 & 1)

2021 
cpos
 =

2022 
	`check_dst_limits_calc_pos_1
 (
mctx
, 
boundaries
, 
subexp_idx
,

2023 
dst
, 
bkref_idx
);

2024 if (
cpos
 == -1 )

2026 if (
cpos
 == 0 && (
boundaries
 & 2))

2029 if (
subexp_idx
 < 
BITSET_WORD_BITS
)

2030 
ent
->
eps_reachable_subexps_map


2031 &= ~((
bitset_word_t
) 1 << 
subexp_idx
);

2033 while (
ent
++->
more
);

2037 case 
OP_OPEN_SUBEXP
:

2038 if ((
boundaries
 & 1) && 
subexp_idx
 == 
dfa
->
nodes
[
node
].
opr
.
idx
)

2042 case 
OP_CLOSE_SUBEXP
:

2043 if ((
boundaries
 & 2) && 
subexp_idx
 == 
dfa
->
nodes
[
node
].
opr
.
idx
)

2052 return (
boundaries
 & 2) ? 1 : 0;

2053 
	}
}

2056 
internal_function


2057 
	$check_dst_limits_calc_pos
 (const 
re_match_context_t
 *
mctx
, 
Idx
 
limit
,

2058 
Idx
 
subexp_idx
, Idx 
from_node
, Idx 
str_idx
,

2059 
Idx
 
bkref_idx
)

2061 struct 
re_backref_cache_entry
 *
lim
 = 
mctx
->
bkref_ents
 + 
limit
;

2062 int 
boundaries
;

2065 if (
str_idx
 < 
lim
->
subexp_from
)

2068 if (
lim
->
subexp_to
 < 
str_idx
)

2072 
boundaries
 = (
str_idx
 == 
lim
->
subexp_from
);

2073 
boundaries
 |= (
str_idx
 == 
lim
->
subexp_to
) << 1;

2074 if (
boundaries
 == 0)

2078 return 
	`check_dst_limits_calc_pos_1
 (
mctx
, 
boundaries
, 
subexp_idx
,

2079 
from_node
, 
bkref_idx
);

2080 
	}
}

2085 static 
reg_errcode_t


2086 
internal_function


2087 
	$check_subexp_limits
 (const 
re_dfa_t
 *
dfa
, 
re_node_set
 *
dest_nodes
,

2088 const 
re_node_set
 *
candidates
, re_node_set *
limits
,

2089 struct 
re_backref_cache_entry
 *
bkref_ents
, 
Idx
 
str_idx
)

2091 
reg_errcode_t
 
err
;

2092 
Idx
 
node_idx
, 
lim_idx
;

2094 for (
lim_idx
 = 0; lim_idx < 
limits
->
nelem
; ++lim_idx)

2096 
Idx
 
subexp_idx
;

2097 struct 
re_backref_cache_entry
 *
ent
;

2098 
ent
 = 
bkref_ents
 + 
limits
->
elems
[
lim_idx
];

2100 if (
str_idx
 <= 
ent
->
subexp_from
 || ent->str_idx < str_idx)

2103 
subexp_idx
 = 
dfa
->
nodes
[
ent
->
node
].
opr
.
idx
;

2104 if (
ent
->
subexp_to
 == 
str_idx
)

2106 
Idx
 
ops_node
 = 
REG_MISSING
;

2107 
Idx
 
cls_node
 = 
REG_MISSING
;

2108 for (
node_idx
 = 0; node_idx < 
dest_nodes
->
nelem
; ++node_idx)

2110 
Idx
 
node
 = 
dest_nodes
->
elems
[
node_idx
];

2111 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
node
].type;

2112 if (
type
 == 
OP_OPEN_SUBEXP


2113 && 
subexp_idx
 == 
dfa
->
nodes
[
node
].
opr
.
idx
)

2114 
ops_node
 = 
node
;

2115 else if (
type
 == 
OP_CLOSE_SUBEXP


2116 && 
subexp_idx
 == 
dfa
->
nodes
[
node
].
opr
.
idx
)

2117 
cls_node
 = 
node
;

2122 if (
	`REG_VALID_INDEX
 (
ops_node
))

2124 
err
 = 
	`sub_epsilon_src_nodes
 (
dfa
, 
ops_node
, 
dest_nodes
,

2125 
candidates
);

2126 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2127 return 
err
;

2131 if (
	`REG_VALID_INDEX
 (
cls_node
))

2132 for (
node_idx
 = 0; node_idx < 
dest_nodes
->
nelem
; ++node_idx)

2134 
Idx
 
node
 = 
dest_nodes
->
elems
[
node_idx
];

2135 if (!
	`re_node_set_contains
 (
dfa
->
inveclosures
 + 
node
,

2136 
cls_node
)

2137 && !
	`re_node_set_contains
 (
dfa
->
eclosures
 + 
node
,

2138 
cls_node
))

2142 
err
 = 
	`sub_epsilon_src_nodes
 (
dfa
, 
node
, 
dest_nodes
,

2143 
candidates
);

2144 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2145 return 
err
;

2146 --
node_idx
;

2152 for (
node_idx
 = 0; node_idx < 
dest_nodes
->
nelem
; ++node_idx)

2154 
Idx
 
node
 = 
dest_nodes
->
elems
[
node_idx
];

2155 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
node
].type;

2156 if (
type
 == 
OP_CLOSE_SUBEXP
 || type == 
OP_OPEN_SUBEXP
)

2158 if (
subexp_idx
 != 
dfa
->
nodes
[
node
].
opr
.
idx
)

2162 
err
 = 
	`sub_epsilon_src_nodes
 (
dfa
, 
node
, 
dest_nodes
,

2163 
candidates
);

2164 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2165 return 
err
;

2170 return 
REG_NOERROR
;

2171 
	}
}

2173 static 
reg_errcode_t


2174 
internal_function
 
__attribute_warn_unused_result__


2175 
	$sift_states_bkref
 (const 
re_match_context_t
 *
mctx
, 
re_sift_context_t
 *
sctx
,

2176 
Idx
 
str_idx
, const 
re_node_set
 *
candidates
)

2178 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2179 
reg_errcode_t
 
err
;

2180 
Idx
 
node_idx
, 
node
;

2181 
re_sift_context_t
 
local_sctx
;

2182 
Idx
 
first_idx
 = 
	`search_cur_bkref_entry
 (
mctx
, 
str_idx
);

2184 if (
first_idx
 == 
REG_MISSING
)

2185 return 
REG_NOERROR
;

2187 
local_sctx
.
sifted_states
 = 
NULL
;

2189 for (
node_idx
 = 0; node_idx < 
candidates
->
nelem
; ++node_idx)

2191 
Idx
 
enabled_idx
;

2192 
re_token_type_t
 
type
;

2193 struct 
re_backref_cache_entry
 *
entry
;

2194 
node
 = 
candidates
->
elems
[
node_idx
];

2195 
type
 = 
dfa
->
nodes
[
node
].type;

2197 if (
node
 == 
sctx
->
last_node
 && 
str_idx
 == sctx->
last_str_idx
)

2199 if (
type
 != 
OP_BACK_REF
)

2202 
entry
 = 
mctx
->
bkref_ents
 + 
first_idx
;

2203 
enabled_idx
 = 
first_idx
;

2206 
Idx
 
subexp_len
;

2207 
Idx
 
to_idx
;

2208 
Idx
 
dst_node
;

2209 
bool
 
ok
;

2210 
re_dfastate_t
 *
cur_state
;

2212 if (
entry
->
node
 != node)

2214 
subexp_len
 = 
entry
->
subexp_to
 - entry->
subexp_from
;

2215 
to_idx
 = 
str_idx
 + 
subexp_len
;

2216 
dst_node
 = (
subexp_len
 ? 
dfa
->
nexts
[
node
]

2217 : 
dfa
->
edests
[
node
].
elems
[0]);

2219 if (
to_idx
 > 
sctx
->
last_str_idx


2220 || 
sctx
->
sifted_states
[
to_idx
] == 
NULL


2221 || !
	`STATE_NODE_CONTAINS
 (
sctx
->
sifted_states
[
to_idx
], 
dst_node
)

2222 || 
	`check_dst_limits
 (
mctx
, &
sctx
->
limits
, 
node
,

2223 
str_idx
, 
dst_node
, 
to_idx
))

2226 if (
local_sctx
.
sifted_states
 == 
NULL
)

2228 
local_sctx
 = *
sctx
;

2229 
err
 = 
	`re_node_set_init_copy
 (&
local_sctx
.
limits
, &
sctx
->limits);

2230 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2231 goto 
free_return
;

2233 
local_sctx
.
last_node
 = 
node
;

2234 
local_sctx
.
last_str_idx
 = 
str_idx
;

2235 
ok
 = 
	`re_node_set_insert
 (&
local_sctx
.
limits
, 
enabled_idx
);

2236 if (
	`BE
 (! 
ok
, 0))

2238 
err
 = 
REG_ESPACE
;

2239 goto 
free_return
;

2241 
cur_state
 = 
local_sctx
.
sifted_states
[
str_idx
];

2242 
err
 = 
	`sift_states_backward
 (
mctx
, &
local_sctx
);

2243 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2244 goto 
free_return
;

2245 if (
sctx
->
limited_states
 != 
NULL
)

2247 
err
 = 
	`merge_state_array
 (
dfa
, 
sctx
->
limited_states
,

2248 
local_sctx
.
sifted_states
,

2249 
str_idx
 + 1);

2250 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2251 goto 
free_return
;

2253 
local_sctx
.
sifted_states
[
str_idx
] = 
cur_state
;

2254 
	`re_node_set_remove
 (&
local_sctx
.
limits
, 
enabled_idx
);

2257 
entry
 = 
mctx
->
bkref_ents
 + 
enabled_idx
;

2259 while (
enabled_idx
++, 
entry
++->
more
);

2261 
err
 = 
REG_NOERROR
;

2262 
free_return
:

2263 if (
local_sctx
.
sifted_states
 != 
NULL
)

2265 
	`re_node_set_free
 (&
local_sctx
.
limits
);

2268 return 
err
;

2269 
	}
}

2272 #ifdef 
RE_ENABLE_I18N


2274 
internal_function


2275 
	$sift_states_iter_mb
 (const 
re_match_context_t
 *
mctx
, 
re_sift_context_t
 *
sctx
,

2276 
Idx
 
node_idx
, Idx 
str_idx
, Idx 
max_str_idx
)

2278 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2279 int 
naccepted
;

2281 
naccepted
 = 
	`check_node_accept_bytes
 (
dfa
, 
node_idx
, &
mctx
->
input
, 
str_idx
);

2282 if (
naccepted
 > 0 && 
str_idx
 + naccepted <= 
max_str_idx
 &&

2283 !
	`STATE_NODE_CONTAINS
 (
sctx
->
sifted_states
[
str_idx
 + 
naccepted
],

2284 
dfa
->
nexts
[
node_idx
]))

2288 
naccepted
 = 0;

2291 return 
naccepted
;

2292 
	}
}

2303 static 
re_dfastate_t
 *

2304 
internal_function
 
__attribute_warn_unused_result__


2305 
	$transit_state
 (
reg_errcode_t
 *
err
, 
re_match_context_t
 *
mctx
,

2306 
re_dfastate_t
 *
state
)

2308 
re_dfastate_t
 **
trtable
;

2309 unsigned char 
ch
;

2311 #ifdef 
RE_ENABLE_I18N


2313 if (
	`BE
 (
state
->
accept_mb
, 0))

2315 *
err
 = 
	`transit_state_mb
 (
mctx
, 
state
);

2316 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

2317 return 
NULL
;

2325 return 
	`transit_state_sb
 (
err
, 
mctx
, 
state
);

2329 
ch
 = 
	`re_string_fetch_byte
 (&
mctx
->
input
);

2332 
trtable
 = 
state
->trtable;

2333 if (
	`BE
 (
trtable
 != 
NULL
, 1))

2334 return 
trtable
[
ch
];

2336 
trtable
 = 
state
->
word_trtable
;

2337 if (
	`BE
 (
trtable
 != 
NULL
, 1))

2339 unsigned int 
context
;

2340 
context


2341 = 
	`re_string_context_at
 (&
mctx
->
input
,

2342 
	`re_string_cur_idx
 (&
mctx
->
input
) - 1,

2343 
mctx
->
eflags
);

2344 if (
	`IS_WORD_CONTEXT
 (
context
))

2345 return 
trtable
[
ch
 + 
SBC_MAX
];

2347 return 
trtable
[
ch
];

2350 if (!
	`build_trtable
 (
mctx
->
dfa
, 
state
))

2352 *
err
 = 
REG_ESPACE
;

2353 return 
NULL
;

2358 
	}
}

2361 static 
re_dfastate_t
 *

2362 
internal_function


2363 
	$merge_state_with_log
 (
reg_errcode_t
 *
err
, 
re_match_context_t
 *
mctx
,

2364 
re_dfastate_t
 *
next_state
)

2366 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2367 
Idx
 
cur_idx
 = 
	`re_string_cur_idx
 (&
mctx
->
input
);

2369 if (
cur_idx
 > 
mctx
->
state_log_top
)

2371 
mctx
->
state_log
[
cur_idx
] = 
next_state
;

2372 
mctx
->
state_log_top
 = 
cur_idx
;

2374 else if (
mctx
->
state_log
[
cur_idx
] == 0)

2376 
mctx
->
state_log
[
cur_idx
] = 
next_state
;

2380 
re_dfastate_t
 *
pstate
;

2381 unsigned int 
context
;

2382 
re_node_set
 
next_nodes
, *
log_nodes
, *
table_nodes
 = 
NULL
;

2387 
pstate
 = 
mctx
->
state_log
[
cur_idx
];

2388 
log_nodes
 = 
pstate
->
entrance_nodes
;

2389 if (
next_state
 != 
NULL
)

2391 
table_nodes
 = 
next_state
->
entrance_nodes
;

2392 *
err
 = 
	`re_node_set_init_union
 (&
next_nodes
, 
table_nodes
,

2393 
log_nodes
);

2394 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

2395 return 
NULL
;

2398 
next_nodes
 = *
log_nodes
;

2402 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
,

2403 
	`re_string_cur_idx
 (&
mctx
->
input
) - 1,

2404 
mctx
->
eflags
);

2405 
next_state
 = 
mctx
->
state_log
[
cur_idx
]

2406 = 
	`re_acquire_state_context
 (
err
, 
dfa
, &
next_nodes
, 
context
);

2410 if (
table_nodes
 != 
NULL
)

2411 
	`re_node_set_free
 (&
next_nodes
);

2414 if (
	`BE
 (
dfa
->
nbackref
, 0) && 
next_state
 != 
NULL
)

2419 *
err
 = 
	`check_subexp_matching_top
 (
mctx
, &
next_state
->
nodes
,

2420 
cur_idx
);

2421 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

2422 return 
NULL
;

2425 if (
next_state
->
has_backref
)

2427 *
err
 = 
	`transit_state_bkref
 (
mctx
, &
next_state
->
nodes
);

2428 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

2429 return 
NULL
;

2430 
next_state
 = 
mctx
->
state_log
[
cur_idx
];

2434 return 
next_state
;

2435 
	}
}

2440 static 
re_dfastate_t
 *

2441 
internal_function


2442 
	$find_recover_state
 (
reg_errcode_t
 *
err
, 
re_match_context_t
 *
mctx
)

2444 
re_dfastate_t
 *
cur_state
;

2447 
Idx
 
max
 = 
mctx
->
state_log_top
;

2448 
Idx
 
cur_str_idx
 = 
	`re_string_cur_idx
 (&
mctx
->
input
);

2452 if (++
cur_str_idx
 > 
max
)

2453 return 
NULL
;

2454 
	`re_string_skip_bytes
 (&
mctx
->
input
, 1);

2456 while (
mctx
->
state_log
[
cur_str_idx
] == 
NULL
);

2458 
cur_state
 = 
	`merge_state_with_log
 (
err
, 
mctx
, 
NULL
);

2460 while (*
err
 == 
REG_NOERROR
 && 
cur_state
 == 
NULL
);

2461 return 
cur_state
;

2462 
	}
}

2471 static 
reg_errcode_t


2472 
internal_function


2473 
	$check_subexp_matching_top
 (
re_match_context_t
 *
mctx
, 
re_node_set
 *
cur_nodes
,

2474 
Idx
 
str_idx
)

2476 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2477 
Idx
 
node_idx
;

2478 
reg_errcode_t
 
err
;

2485 for (
node_idx
 = 0; node_idx < 
cur_nodes
->
nelem
; ++node_idx)

2487 
Idx
 
node
 = 
cur_nodes
->
elems
[
node_idx
];

2488 if (
dfa
->
nodes
[
node
].
type
 == 
OP_OPEN_SUBEXP


2489 && 
dfa
->
nodes
[
node
].
opr
.
idx
 < 
BITSET_WORD_BITS


2490 && (
dfa
->
used_bkref_map


2491 & ((
bitset_word_t
) 1 << 
dfa
->
nodes
[
node
].
opr
.
idx
)))

2493 
err
 = 
	`match_ctx_add_subtop
 (
mctx
, 
node
, 
str_idx
);

2494 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2495 return 
err
;

2498 return 
REG_NOERROR
;

2499 
	}
}

2505 static 
re_dfastate_t
 *

2506 
	$transit_state_sb
 (
reg_errcode_t
 *
err
, 
re_match_context_t
 *
mctx
,

2507 
re_dfastate_t
 *
state
)

2509 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2510 
re_node_set
 
next_nodes
;

2511 
re_dfastate_t
 *
next_state
;

2512 
Idx
 
node_cnt
, 
cur_str_idx
 = 
	`re_string_cur_idx
 (&
mctx
->
input
);

2513 unsigned int 
context
;

2515 *
err
 = 
	`re_node_set_alloc
 (&
next_nodes
, 
state
->
nodes
.
nelem
 + 1);

2516 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

2517 return 
NULL
;

2518 for (
node_cnt
 = 0; node_cnt < 
state
->
nodes
.
nelem
; ++node_cnt)

2520 
Idx
 
cur_node
 = 
state
->
nodes
.
elems
[
node_cnt
];

2521 if (
	`check_node_accept
 (
mctx
, 
dfa
->
nodes
 + 
cur_node
, 
cur_str_idx
))

2523 *
err
 = 
	`re_node_set_merge
 (&
next_nodes
,

2524 
dfa
->
eclosures
 + dfa->
nexts
[
cur_node
]);

2525 if (
	`BE
 (*
err
 != 
REG_NOERROR
, 0))

2527 
	`re_node_set_free
 (&
next_nodes
);

2528 return 
NULL
;

2532 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
cur_str_idx
, mctx->
eflags
);

2533 
next_state
 = 
	`re_acquire_state_context
 (
err
, 
dfa
, &
next_nodes
, 
context
);

2537 
	`re_node_set_free
 (&
next_nodes
);

2538 
	`re_string_skip_bytes
 (&
mctx
->
input
, 1);

2539 return 
next_state
;

2540 
	}
}

2543 #ifdef 
RE_ENABLE_I18N


2544 static 
reg_errcode_t


2545 
internal_function


2546 
	$transit_state_mb
 (
re_match_context_t
 *
mctx
, 
re_dfastate_t
 *
pstate
)

2548 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2549 
reg_errcode_t
 
err
;

2550 
Idx
 
i
;

2552 for (
i
 = 0; i < 
pstate
->
nodes
.
nelem
; ++i)

2554 
re_node_set
 
dest_nodes
, *
new_nodes
;

2555 
Idx
 
cur_node_idx
 = 
pstate
->
nodes
.
elems
[
i
];

2556 int 
naccepted
;

2557 
Idx
 
dest_idx
;

2558 unsigned int 
context
;

2559 
re_dfastate_t
 *
dest_state
;

2561 if (!
dfa
->
nodes
[
cur_node_idx
].
accept_mb
)

2564 if (
dfa
->
nodes
[
cur_node_idx
].
constraint
)

2566 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
,

2567 
	`re_string_cur_idx
 (&
mctx
->
input
),

2568 
mctx
->
eflags
);

2569 if (
	`NOT_SATISFY_NEXT_CONSTRAINT
 (
dfa
->
nodes
[
cur_node_idx
].
constraint
,

2570 
context
))

2575 
naccepted
 = 
	`check_node_accept_bytes
 (
dfa
, 
cur_node_idx
, &
mctx
->
input
,

2576 
	`re_string_cur_idx
 (&
mctx
->
input
));

2577 if (
naccepted
 == 0)

2581 
dest_idx
 = 
	`re_string_cur_idx
 (&
mctx
->
input
) + 
naccepted
;

2582 
mctx
->
max_mb_elem_len
 = ((mctx->max_mb_elem_len < 
naccepted
) ? naccepted

2583 : 
mctx
->
max_mb_elem_len
);

2584 
err
 = 
	`clean_state_log_if_needed
 (
mctx
, 
dest_idx
);

2585 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2586 return 
err
;

2587 #ifdef 
DEBUG


2588 
	`assert
 (
dfa
->
nexts
[
cur_node_idx
] != 
REG_MISSING
);

2590 
new_nodes
 = 
dfa
->
eclosures
 + dfa->
nexts
[
cur_node_idx
];

2592 
dest_state
 = 
mctx
->
state_log
[
dest_idx
];

2593 if (
dest_state
 == 
NULL
)

2594 
dest_nodes
 = *
new_nodes
;

2597 
err
 = 
	`re_node_set_init_union
 (&
dest_nodes
,

2598 
dest_state
->
entrance_nodes
, 
new_nodes
);

2599 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2600 return 
err
;

2602 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
dest_idx
 - 1,

2603 
mctx
->
eflags
);

2604 
mctx
->
state_log
[
dest_idx
]

2605 = 
	`re_acquire_state_context
 (&
err
, 
dfa
, &
dest_nodes
, 
context
);

2606 if (
dest_state
 != 
NULL
)

2607 
	`re_node_set_free
 (&
dest_nodes
);

2608 if (
	`BE
 (
mctx
->
state_log
[
dest_idx
] == 
NULL
 && 
err
 != 
REG_NOERROR
, 0))

2609 return 
err
;

2611 return 
REG_NOERROR
;

2612 
	}
}

2615 static 
reg_errcode_t


2616 
internal_function


2617 
	$transit_state_bkref
 (
re_match_context_t
 *
mctx
, const 
re_node_set
 *
nodes
)

2619 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2620 
reg_errcode_t
 
err
;

2621 
Idx
 
i
;

2622 
Idx
 
cur_str_idx
 = 
	`re_string_cur_idx
 (&
mctx
->
input
);

2624 for (
i
 = 0; i < 
nodes
->
nelem
; ++i)

2626 
Idx
 
dest_str_idx
, 
prev_nelem
, 
bkc_idx
;

2627 
Idx
 
node_idx
 = 
nodes
->
elems
[
i
];

2628 unsigned int 
context
;

2629 const 
re_token_t
 *
node
 = 
dfa
->
nodes
 + 
node_idx
;

2630 
re_node_set
 *
new_dest_nodes
;

2633 if (
node
->
type
 != 
OP_BACK_REF
)

2636 if (
node
->
constraint
)

2638 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
cur_str_idx
,

2639 
mctx
->
eflags
);

2640 if (
	`NOT_SATISFY_NEXT_CONSTRAINT
 (
node
->
constraint
, 
context
))

2646 
bkc_idx
 = 
mctx
->
nbkref_ents
;

2647 
err
 = 
	`get_subexp
 (
mctx
, 
node_idx
, 
cur_str_idx
);

2648 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2649 goto 
free_return
;

2653 #ifdef 
DEBUG


2654 
	`assert
 (
dfa
->
nexts
[
node_idx
] != 
REG_MISSING
);

2656 for (; 
bkc_idx
 < 
mctx
->
nbkref_ents
; ++bkc_idx)

2658 
Idx
 
subexp_len
;

2659 
re_dfastate_t
 *
dest_state
;

2660 struct 
re_backref_cache_entry
 *
bkref_ent
;

2661 
bkref_ent
 = 
mctx
->
bkref_ents
 + 
bkc_idx
;

2662 if (
bkref_ent
->
node
 != 
node_idx
 || bkref_ent->
str_idx
 != 
cur_str_idx
)

2664 
subexp_len
 = 
bkref_ent
->
subexp_to
 - bkref_ent->
subexp_from
;

2665 
new_dest_nodes
 = (
subexp_len
 == 0

2666 ? 
dfa
->
eclosures
 + dfa->
edests
[
node_idx
].
elems
[0]

2667 : 
dfa
->
eclosures
 + dfa->
nexts
[
node_idx
]);

2668 
dest_str_idx
 = (
cur_str_idx
 + 
bkref_ent
->
subexp_to


2669 - 
bkref_ent
->
subexp_from
);

2670 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
dest_str_idx
 - 1,

2671 
mctx
->
eflags
);

2672 
dest_state
 = 
mctx
->
state_log
[
dest_str_idx
];

2673 
prev_nelem
 = ((
mctx
->
state_log
[
cur_str_idx
] == 
NULL
) ? 0

2674 : 
mctx
->
state_log
[
cur_str_idx
]->
nodes
.
nelem
);

2676 if (
dest_state
 == 
NULL
)

2678 
mctx
->
state_log
[
dest_str_idx
]

2679 = 
	`re_acquire_state_context
 (&
err
, 
dfa
, 
new_dest_nodes
,

2680 
context
);

2681 if (
	`BE
 (
mctx
->
state_log
[
dest_str_idx
] == 
NULL


2682 && 
err
 != 
REG_NOERROR
, 0))

2683 goto 
free_return
;

2687 
re_node_set
 
dest_nodes
;

2688 
err
 = 
	`re_node_set_init_union
 (&
dest_nodes
,

2689 
dest_state
->
entrance_nodes
,

2690 
new_dest_nodes
);

2691 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2693 
	`re_node_set_free
 (&
dest_nodes
);

2694 goto 
free_return
;

2696 
mctx
->
state_log
[
dest_str_idx
]

2697 = 
	`re_acquire_state_context
 (&
err
, 
dfa
, &
dest_nodes
, 
context
);

2698 
	`re_node_set_free
 (&
dest_nodes
);

2699 if (
	`BE
 (
mctx
->
state_log
[
dest_str_idx
] == 
NULL


2700 && 
err
 != 
REG_NOERROR
, 0))

2701 goto 
free_return
;

2705 if (
subexp_len
 == 0

2706 && 
mctx
->
state_log
[
cur_str_idx
]->
nodes
.
nelem
 > 
prev_nelem
)

2708 
err
 = 
	`check_subexp_matching_top
 (
mctx
, 
new_dest_nodes
,

2709 
cur_str_idx
);

2710 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2711 goto 
free_return
;

2712 
err
 = 
	`transit_state_bkref
 (
mctx
, 
new_dest_nodes
);

2713 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2714 goto 
free_return
;

2718 
err
 = 
REG_NOERROR
;

2719 
free_return
:

2720 return 
err
;

2721 
	}
}

2729 static 
reg_errcode_t


2730 
internal_function
 
__attribute_warn_unused_result__


2731 
	$get_subexp
 (
re_match_context_t
 *
mctx
, 
Idx
 
bkref_node
, Idx 
bkref_str_idx
)

2733 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2734 
Idx
 
subexp_num
, 
sub_top_idx
;

2735 const char *
buf
 = (const char *) 
	`re_string_get_buffer
 (&
mctx
->
input
);

2737 
Idx
 
cache_idx
 = 
	`search_cur_bkref_entry
 (
mctx
, 
bkref_str_idx
);

2738 if (
cache_idx
 != 
REG_MISSING
)

2740 const struct 
re_backref_cache_entry
 *
entry


2741 = 
mctx
->
bkref_ents
 + 
cache_idx
;

2743 if (
entry
->
node
 == 
bkref_node
)

2744 return 
REG_NOERROR
;

2745 while (
entry
++->
more
);

2748 
subexp_num
 = 
dfa
->
nodes
[
bkref_node
].
opr
.
idx
;

2751 for (
sub_top_idx
 = 0; sub_top_idx < 
mctx
->
nsub_tops
; ++sub_top_idx)

2753 
reg_errcode_t
 
err
;

2754 
re_sub_match_top_t
 *
sub_top
 = 
mctx
->
sub_tops
[
sub_top_idx
];

2755 
re_sub_match_last_t
 *
sub_last
;

2756 
Idx
 
sub_last_idx
, 
sl_str
, 
bkref_str_off
;

2758 if (
dfa
->
nodes
[
sub_top
->
node
].
opr
.
idx
 != 
subexp_num
)

2761 
sl_str
 = 
sub_top
->
str_idx
;

2762 
bkref_str_off
 = 
bkref_str_idx
;

2765 for (
sub_last_idx
 = 0; sub_last_idx < 
sub_top
->
nlasts
; ++sub_last_idx)

2767 
regoff_t
 
sl_str_diff
;

2768 
sub_last
 = 
sub_top
->
lasts
[
sub_last_idx
];

2769 
sl_str_diff
 = 
sub_last
->
str_idx
 - 
sl_str
;

2772 if (
sl_str_diff
 > 0)

2774 if (
	`BE
 (
bkref_str_off
 + 
sl_str_diff
 > 
mctx
->
input
.
valid_len
, 0))

2777 if (
bkref_str_off
 + 
sl_str_diff
 > 
mctx
->
input
.
len
)

2780 
err
 = 
	`clean_state_log_if_needed
 (
mctx
,

2781 
bkref_str_off


2782 + 
sl_str_diff
);

2783 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2784 return 
err
;

2785 
buf
 = (const char *) 
	`re_string_get_buffer
 (&
mctx
->
input
);

2787 if (
	`memcmp
 (
buf
 + 
bkref_str_off
, buf + 
sl_str
, 
sl_str_diff
) != 0)

2791 
bkref_str_off
 += 
sl_str_diff
;

2792 
sl_str
 += 
sl_str_diff
;

2793 
err
 = 
	`get_subexp_sub
 (
mctx
, 
sub_top
, 
sub_last
, 
bkref_node
,

2794 
bkref_str_idx
);

2798 
buf
 = (const char *) 
	`re_string_get_buffer
 (&
mctx
->
input
);

2800 if (
err
 == 
REG_NOMATCH
)

2802 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2803 return 
err
;

2806 if (
sub_last_idx
 < 
sub_top
->
nlasts
)

2808 if (
sub_last_idx
 > 0)

2809 ++
sl_str
;

2811 for (; 
sl_str
 <= 
bkref_str_idx
; ++sl_str)

2813 
Idx
 
cls_node
;

2814 
regoff_t
 
sl_str_off
;

2815 const 
re_node_set
 *
nodes
;

2816 
sl_str_off
 = 
sl_str
 - 
sub_top
->
str_idx
;

2819 if (
sl_str_off
 > 0)

2821 if (
	`BE
 (
bkref_str_off
 >= 
mctx
->
input
.
valid_len
, 0))

2824 if (
bkref_str_off
 >= 
mctx
->
input
.
len
)

2827 
err
 = 
	`extend_buffers
 (
mctx
);

2828 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2829 return 
err
;

2831 
buf
 = (const char *) 
	`re_string_get_buffer
 (&
mctx
->
input
);

2833 if (
buf
 [
bkref_str_off
++] != buf[
sl_str
 - 1])

2837 if (
mctx
->
state_log
[
sl_str
] == 
NULL
)

2840 
nodes
 = &
mctx
->
state_log
[
sl_str
]->nodes;

2841 
cls_node
 = 
	`find_subexp_node
 (
dfa
, 
nodes
, 
subexp_num
,

2842 
OP_CLOSE_SUBEXP
);

2843 if (
cls_node
 == 
REG_MISSING
)

2845 if (
sub_top
->
path
 == 
NULL
)

2847 
sub_top
->
path
 = 
	`calloc
 (sizeof (
state_array_t
),

2848 
sl_str
 - 
sub_top
->
str_idx
 + 1);

2849 if (
sub_top
->
path
 == 
NULL
)

2850 return 
REG_ESPACE
;

2854 
err
 = 
	`check_arrival
 (
mctx
, 
sub_top
->
path
, sub_top->
node
,

2855 
sub_top
->
str_idx
, 
cls_node
, 
sl_str
,

2856 
OP_CLOSE_SUBEXP
);

2857 if (
err
 == 
REG_NOMATCH
)

2859 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2860 return 
err
;

2861 
sub_last
 = 
	`match_ctx_add_sublast
 (
sub_top
, 
cls_node
, 
sl_str
);

2862 if (
	`BE
 (
sub_last
 == 
NULL
, 0))

2863 return 
REG_ESPACE
;

2864 
err
 = 
	`get_subexp_sub
 (
mctx
, 
sub_top
, 
sub_last
, 
bkref_node
,

2865 
bkref_str_idx
);

2866 if (
err
 == 
REG_NOMATCH
)

2870 return 
REG_NOERROR
;

2871 
	}
}

2879 static 
reg_errcode_t


2880 
internal_function


2881 
	$get_subexp_sub
 (
re_match_context_t
 *
mctx
, const 
re_sub_match_top_t
 *
sub_top
,

2882 
re_sub_match_last_t
 *
sub_last
, 
Idx
 
bkref_node
, Idx 
bkref_str
)

2884 
reg_errcode_t
 
err
;

2885 
Idx
 
to_idx
;

2887 
err
 = 
	`check_arrival
 (
mctx
, &
sub_last
->
path
, sub_last->
node
,

2888 
sub_last
->
str_idx
, 
bkref_node
, 
bkref_str
,

2889 
OP_OPEN_SUBEXP
);

2890 if (
err
 != 
REG_NOERROR
)

2891 return 
err
;

2892 
err
 = 
	`match_ctx_add_entry
 (
mctx
, 
bkref_node
, 
bkref_str
, 
sub_top
->
str_idx
,

2893 
sub_last
->
str_idx
);

2894 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2895 return 
err
;

2896 
to_idx
 = 
bkref_str
 + 
sub_last
->
str_idx
 - 
sub_top
->str_idx;

2897 return 
	`clean_state_log_if_needed
 (
mctx
, 
to_idx
);

2898 
	}
}

2908 static 
Idx


2909 
internal_function


2910 
	$find_subexp_node
 (const 
re_dfa_t
 *
dfa
, const 
re_node_set
 *
nodes
,

2911 
Idx
 
subexp_idx
, int 
type
)

2913 
Idx
 
cls_idx
;

2914 for (
cls_idx
 = 0; cls_idx < 
nodes
->
nelem
; ++cls_idx)

2916 
Idx
 
cls_node
 = 
nodes
->
elems
[
cls_idx
];

2917 const 
re_token_t
 *
node
 = 
dfa
->
nodes
 + 
cls_node
;

2918 if (
node
->
type
 == type

2919 && 
node
->
opr
.
idx
 == 
subexp_idx
)

2920 return 
cls_node
;

2922 return 
REG_MISSING
;

2923 
	}
}

2930 static 
reg_errcode_t


2931 
internal_function
 
__attribute_warn_unused_result__


2932 
	$check_arrival
 (
re_match_context_t
 *
mctx
, 
state_array_t
 *
path
, 
Idx
 
top_node
,

2933 
Idx
 
top_str
, Idx 
last_node
, Idx 
last_str
, int 
type
)

2935 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

2936 
reg_errcode_t
 
err
 = 
REG_NOERROR
;

2937 
Idx
 
subexp_num
, 
backup_cur_idx
, 
str_idx
, 
null_cnt
;

2938 
re_dfastate_t
 *
cur_state
 = 
NULL
;

2939 
re_node_set
 *
cur_nodes
, 
next_nodes
;

2940 
re_dfastate_t
 **
backup_state_log
;

2941 unsigned int 
context
;

2943 
subexp_num
 = 
dfa
->
nodes
[
top_node
].
opr
.
idx
;

2945 if (
	`BE
 (
path
->
alloc
 < 
last_str
 + 
mctx
->
max_mb_elem_len
 + 1, 0))

2947 
re_dfastate_t
 **
new_array
;

2948 
Idx
 
old_alloc
 = 
path
->
alloc
;

2949 
Idx
 
new_alloc
 = 
old_alloc
 + 
last_str
 + 
mctx
->
max_mb_elem_len
 + 1;

2950 if (
	`BE
 (
new_alloc
 < 
old_alloc
, 0)

2951 || 
	`BE
 (
SIZE_MAX
 / sizeof (
re_dfastate_t
 *) < 
new_alloc
, 0))

2952 return 
REG_ESPACE
;

2953 
new_array
 = 
	`re_realloc
 (
path
->
array
, 
re_dfastate_t
 *, 
new_alloc
);

2954 if (
	`BE
 (
new_array
 == 
NULL
, 0))

2955 return 
REG_ESPACE
;

2956 
path
->
array
 = 
new_array
;

2957 
path
->
alloc
 = 
new_alloc
;

2958 
	`memset
 (
new_array
 + 
old_alloc
, '\0',

2959 sizeof (
re_dfastate_t
 *) * (
path
->
alloc
 - 
old_alloc
));

2962 
str_idx
 = 
path
->
next_idx
 ? path->next_idx : 
top_str
;

2965 
backup_state_log
 = 
mctx
->
state_log
;

2966 
backup_cur_idx
 = 
mctx
->
input
.
cur_idx
;

2967 
mctx
->
state_log
 = 
path
->
array
;

2968 
mctx
->
input
.
cur_idx
 = 
str_idx
;

2971 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
str_idx
 - 1, mctx->
eflags
);

2972 if (
str_idx
 == 
top_str
)

2974 
err
 = 
	`re_node_set_init_1
 (&
next_nodes
, 
top_node
);

2975 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2976 return 
err
;

2977 
err
 = 
	`check_arrival_expand_ecl
 (
dfa
, &
next_nodes
, 
subexp_num
, 
type
);

2978 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2980 
	`re_node_set_free
 (&
next_nodes
);

2981 return 
err
;

2986 
cur_state
 = 
mctx
->
state_log
[
str_idx
];

2987 if (
cur_state
 && cur_state->
has_backref
)

2989 
err
 = 
	`re_node_set_init_copy
 (&
next_nodes
, &
cur_state
->
nodes
);

2990 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

2991 return 
err
;

2994 
	`re_node_set_init_empty
 (&
next_nodes
);

2996 if (
str_idx
 == 
top_str
 || (
cur_state
 && cur_state->
has_backref
))

2998 if (
next_nodes
.
nelem
)

3000 
err
 = 
	`expand_bkref_cache
 (
mctx
, &
next_nodes
, 
str_idx
,

3001 
subexp_num
, 
type
);

3002 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3004 
	`re_node_set_free
 (&
next_nodes
);

3005 return 
err
;

3008 
cur_state
 = 
	`re_acquire_state_context
 (&
err
, 
dfa
, &
next_nodes
, 
context
);

3009 if (
	`BE
 (
cur_state
 == 
NULL
 && 
err
 != 
REG_NOERROR
, 0))

3011 
	`re_node_set_free
 (&
next_nodes
);

3012 return 
err
;

3014 
mctx
->
state_log
[
str_idx
] = 
cur_state
;

3017 for (
null_cnt
 = 0; 
str_idx
 < 
last_str
 && null_cnt <= 
mctx
->
max_mb_elem_len
;)

3019 
	`re_node_set_empty
 (&
next_nodes
);

3020 if (
mctx
->
state_log
[
str_idx
 + 1])

3022 
err
 = 
	`re_node_set_merge
 (&
next_nodes
,

3023 &
mctx
->
state_log
[
str_idx
 + 1]->
nodes
);

3024 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3026 
	`re_node_set_free
 (&
next_nodes
);

3027 return 
err
;

3030 if (
cur_state
)

3032 
err
 = 
	`check_arrival_add_next_nodes
 (
mctx
, 
str_idx
,

3033 &
cur_state
->
non_eps_nodes
,

3034 &
next_nodes
);

3035 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3037 
	`re_node_set_free
 (&
next_nodes
);

3038 return 
err
;

3041 ++
str_idx
;

3042 if (
next_nodes
.
nelem
)

3044 
err
 = 
	`check_arrival_expand_ecl
 (
dfa
, &
next_nodes
, 
subexp_num
, 
type
);

3045 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3047 
	`re_node_set_free
 (&
next_nodes
);

3048 return 
err
;

3050 
err
 = 
	`expand_bkref_cache
 (
mctx
, &
next_nodes
, 
str_idx
,

3051 
subexp_num
, 
type
);

3052 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3054 
	`re_node_set_free
 (&
next_nodes
);

3055 return 
err
;

3058 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
str_idx
 - 1, mctx->
eflags
);

3059 
cur_state
 = 
	`re_acquire_state_context
 (&
err
, 
dfa
, &
next_nodes
, 
context
);

3060 if (
	`BE
 (
cur_state
 == 
NULL
 && 
err
 != 
REG_NOERROR
, 0))

3062 
	`re_node_set_free
 (&
next_nodes
);

3063 return 
err
;

3065 
mctx
->
state_log
[
str_idx
] = 
cur_state
;

3066 
null_cnt
 = 
cur_state
 == 
NULL
 ? null_cnt + 1 : 0;

3068 
	`re_node_set_free
 (&
next_nodes
);

3069 
cur_nodes
 = (
mctx
->
state_log
[
last_str
] == 
NULL
 ? NULL

3070 : &
mctx
->
state_log
[
last_str
]->
nodes
);

3071 
path
->
next_idx
 = 
str_idx
;

3074 
mctx
->
state_log
 = 
backup_state_log
;

3075 
mctx
->
input
.
cur_idx
 = 
backup_cur_idx
;

3078 if (
cur_nodes
 != 
NULL
 && 
	`re_node_set_contains
 (cur_nodes, 
last_node
))

3079 return 
REG_NOERROR
;

3081 return 
REG_NOMATCH
;

3082 
	}
}

3092 static 
reg_errcode_t


3093 
internal_function
 
__attribute_warn_unused_result__


3094 
	$check_arrival_add_next_nodes
 (
re_match_context_t
 *
mctx
, 
Idx
 
str_idx
,

3095 
re_node_set
 *
cur_nodes
, re_node_set *
next_nodes
)

3097 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

3098 
bool
 
ok
;

3099 
Idx
 
cur_idx
;

3100 #ifdef 
RE_ENABLE_I18N


3101 
reg_errcode_t
 
err
 = 
REG_NOERROR
;

3103 
re_node_set
 
union_set
;

3104 
	`re_node_set_init_empty
 (&
union_set
);

3105 for (
cur_idx
 = 0; cur_idx < 
cur_nodes
->
nelem
; ++cur_idx)

3107 int 
naccepted
 = 0;

3108 
Idx
 
cur_node
 = 
cur_nodes
->
elems
[
cur_idx
];

3109 #ifdef 
DEBUG


3110 
re_token_type_t
 
type
 = 
dfa
->
nodes
[
cur_node
].type;

3111 
	`assert
 (!
	`IS_EPSILON_NODE
 (
type
));

3113 #ifdef 
RE_ENABLE_I18N


3115 if (
dfa
->
nodes
[
cur_node
].
accept_mb
)

3117 
naccepted
 = 
	`check_node_accept_bytes
 (
dfa
, 
cur_node
, &
mctx
->
input
,

3118 
str_idx
);

3119 if (
naccepted
 > 1)

3121 
re_dfastate_t
 *
dest_state
;

3122 
Idx
 
next_node
 = 
dfa
->
nexts
[
cur_node
];

3123 
Idx
 
next_idx
 = 
str_idx
 + 
naccepted
;

3124 
dest_state
 = 
mctx
->
state_log
[
next_idx
];

3125 
	`re_node_set_empty
 (&
union_set
);

3126 if (
dest_state
)

3128 
err
 = 
	`re_node_set_merge
 (&
union_set
, &
dest_state
->
nodes
);

3129 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3131 
	`re_node_set_free
 (&
union_set
);

3132 return 
err
;

3135 
ok
 = 
	`re_node_set_insert
 (&
union_set
, 
next_node
);

3136 if (
	`BE
 (! 
ok
, 0))

3138 
	`re_node_set_free
 (&
union_set
);

3139 return 
REG_ESPACE
;

3141 
mctx
->
state_log
[
next_idx
] = 
	`re_acquire_state
 (&
err
, 
dfa
,

3142 &
union_set
);

3143 if (
	`BE
 (
mctx
->
state_log
[
next_idx
] == 
NULL


3144 && 
err
 != 
REG_NOERROR
, 0))

3146 
	`re_node_set_free
 (&
union_set
);

3147 return 
err
;

3152 if (
naccepted


3153 || 
	`check_node_accept
 (
mctx
, 
dfa
->
nodes
 + 
cur_node
, 
str_idx
))

3155 
ok
 = 
	`re_node_set_insert
 (
next_nodes
, 
dfa
->
nexts
[
cur_node
]);

3156 if (
	`BE
 (! 
ok
, 0))

3158 
	`re_node_set_free
 (&
union_set
);

3159 return 
REG_ESPACE
;

3163 
	`re_node_set_free
 (&
union_set
);

3164 return 
REG_NOERROR
;

3165 
	}
}

3173 static 
reg_errcode_t


3174 
internal_function


3175 
	$check_arrival_expand_ecl
 (const 
re_dfa_t
 *
dfa
, 
re_node_set
 *
cur_nodes
,

3176 
Idx
 
ex_subexp
, int 
type
)

3178 
reg_errcode_t
 
err
;

3179 
Idx
 
idx
, 
outside_node
;

3180 
re_node_set
 
new_nodes
;

3181 #ifdef 
DEBUG


3182 
	`assert
 (
cur_nodes
->
nelem
);

3184 
err
 = 
	`re_node_set_alloc
 (&
new_nodes
, 
cur_nodes
->
nelem
);

3185 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3186 return 
err
;

3190 for (
idx
 = 0; idx < 
cur_nodes
->
nelem
; ++idx)

3192 
Idx
 
cur_node
 = 
cur_nodes
->
elems
[
idx
];

3193 const 
re_node_set
 *
eclosure
 = 
dfa
->
eclosures
 + 
cur_node
;

3194 
outside_node
 = 
	`find_subexp_node
 (
dfa
, 
eclosure
, 
ex_subexp
, 
type
);

3195 if (
outside_node
 == 
REG_MISSING
)

3198 
err
 = 
	`re_node_set_merge
 (&
new_nodes
, 
eclosure
);

3199 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3201 
	`re_node_set_free
 (&
new_nodes
);

3202 return 
err
;

3208 
err
 = 
	`check_arrival_expand_ecl_sub
 (
dfa
, &
new_nodes
, 
cur_node
,

3209 
ex_subexp
, 
type
);

3210 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3212 
	`re_node_set_free
 (&
new_nodes
);

3213 return 
err
;

3217 
	`re_node_set_free
 (
cur_nodes
);

3218 *
cur_nodes
 = 
new_nodes
;

3219 return 
REG_NOERROR
;

3220 
	}
}

3226 static 
reg_errcode_t


3227 
internal_function
 
__attribute_warn_unused_result__


3228 
	$check_arrival_expand_ecl_sub
 (const 
re_dfa_t
 *
dfa
, 
re_node_set
 *
dst_nodes
,

3229 
Idx
 
target
, Idx 
ex_subexp
, int 
type
)

3231 
Idx
 
cur_node
;

3232 for (
cur_node
 = 
target
; !
	`re_node_set_contains
 (
dst_nodes
, cur_node);)

3234 
bool
 
ok
;

3236 if (
dfa
->
nodes
[
cur_node
].
type
 == type

3237 && 
dfa
->
nodes
[
cur_node
].
opr
.
idx
 == 
ex_subexp
)

3239 if (
type
 == 
OP_CLOSE_SUBEXP
)

3241 
ok
 = 
	`re_node_set_insert
 (
dst_nodes
, 
cur_node
);

3242 if (
	`BE
 (! 
ok
, 0))

3243 return 
REG_ESPACE
;

3247 
ok
 = 
	`re_node_set_insert
 (
dst_nodes
, 
cur_node
);

3248 if (
	`BE
 (! 
ok
, 0))

3249 return 
REG_ESPACE
;

3250 if (
dfa
->
edests
[
cur_node
].
nelem
 == 0)

3252 if (
dfa
->
edests
[
cur_node
].
nelem
 == 2)

3254 
reg_errcode_t
 
err
;

3255 
err
 = 
	`check_arrival_expand_ecl_sub
 (
dfa
, 
dst_nodes
,

3256 
dfa
->
edests
[
cur_node
].
elems
[1],

3257 
ex_subexp
, 
type
);

3258 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3259 return 
err
;

3261 
cur_node
 = 
dfa
->
edests
[cur_node].
elems
[0];

3263 return 
REG_NOERROR
;

3264 
	}
}

3271 static 
reg_errcode_t


3272 
internal_function
 
__attribute_warn_unused_result__


3273 
	$expand_bkref_cache
 (
re_match_context_t
 *
mctx
, 
re_node_set
 *
cur_nodes
,

3274 
Idx
 
cur_str
, Idx 
subexp_num
, int 
type
)

3276 const 
re_dfa_t
 *const 
dfa
 = 
mctx
->dfa;

3277 
reg_errcode_t
 
err
;

3278 
Idx
 
cache_idx_start
 = 
	`search_cur_bkref_entry
 (
mctx
, 
cur_str
);

3279 struct 
re_backref_cache_entry
 *
ent
;

3281 if (
cache_idx_start
 == 
REG_MISSING
)

3282 return 
REG_NOERROR
;

3284 
restart
:

3285 
ent
 = 
mctx
->
bkref_ents
 + 
cache_idx_start
;

3288 
Idx
 
to_idx
, 
next_node
;

3291 if (!
	`re_node_set_contains
 (
cur_nodes
, 
ent
->
node
))

3294 
to_idx
 = 
cur_str
 + 
ent
->
subexp_to
 - ent->
subexp_from
;

3297 if (
to_idx
 == 
cur_str
)

3301 
re_node_set
 
new_dests
;

3302 
reg_errcode_t
 
err2
, 
err3
;

3303 
next_node
 = 
dfa
->
edests
[
ent
->
node
].
elems
[0];

3304 if (
	`re_node_set_contains
 (
cur_nodes
, 
next_node
))

3306 
err
 = 
	`re_node_set_init_1
 (&
new_dests
, 
next_node
);

3307 
err2
 = 
	`check_arrival_expand_ecl
 (
dfa
, &
new_dests
, 
subexp_num
, 
type
);

3308 
err3
 = 
	`re_node_set_merge
 (
cur_nodes
, &
new_dests
);

3309 
	`re_node_set_free
 (&
new_dests
);

3310 if (
	`BE
 (
err
 != 
REG_NOERROR
 || 
err2
 != REG_NOERROR

3311 || 
err3
 != 
REG_NOERROR
, 0))

3313 
err
 = (err != 
REG_NOERROR
 ? err

3314 : (
err2
 != 
REG_NOERROR
 ? err2 : 
err3
));

3315 return 
err
;

3318 goto 
restart
;

3322 
re_node_set
 
union_set
;

3323 
next_node
 = 
dfa
->
nexts
[
ent
->
node
];

3324 if (
mctx
->
state_log
[
to_idx
])

3326 
bool
 
ok
;

3327 if (
	`re_node_set_contains
 (&
mctx
->
state_log
[
to_idx
]->
nodes
,

3328 
next_node
))

3330 
err
 = 
	`re_node_set_init_copy
 (&
union_set
,

3331 &
mctx
->
state_log
[
to_idx
]->
nodes
);

3332 
ok
 = 
	`re_node_set_insert
 (&
union_set
, 
next_node
);

3333 if (
	`BE
 (
err
 != 
REG_NOERROR
 || ! 
ok
, 0))

3335 
	`re_node_set_free
 (&
union_set
);

3336 
err
 = err != 
REG_NOERROR
 ? err : 
REG_ESPACE
;

3337 return 
err
;

3342 
err
 = 
	`re_node_set_init_1
 (&
union_set
, 
next_node
);

3343 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3344 return 
err
;

3346 
mctx
->
state_log
[
to_idx
] = 
	`re_acquire_state
 (&
err
, 
dfa
, &
union_set
);

3347 
	`re_node_set_free
 (&
union_set
);

3348 if (
	`BE
 (
mctx
->
state_log
[
to_idx
] == 
NULL


3349 && 
err
 != 
REG_NOERROR
, 0))

3350 return 
err
;

3353 while (
ent
++->
more
);

3354 return 
REG_NOERROR
;

3355 
	}
}

3360 static 
bool


3361 
internal_function


3362 
	$build_trtable
 (const 
re_dfa_t
 *
dfa
, 
re_dfastate_t
 *
state
)

3364 
reg_errcode_t
 
err
;

3365 
Idx
 
i
, 
j
;

3366 int 
ch
;

3367 
bool
 
need_word_trtable
 = 
false
;

3368 
bitset_word_t
 
elem
, 
mask
;

3369 
bool
 
dests_node_malloced
 = 
false
;

3370 
bool
 
dest_states_malloced
 = 
false
;

3371 
Idx
 
ndests
;

3372 
re_dfastate_t
 **
trtable
;

3373 
re_dfastate_t
 **
dest_states
 = 
NULL
, **
dest_states_word
, **
dest_states_nl
;

3374 
re_node_set
 
follows
, *
dests_node
;

3375 
bitset_t
 *
dests_ch
;

3376 
bitset_t
 
acceptable
;

3378 struct 
	sdests_alloc


3380 
re_node_set
 
dests_node
[
SBC_MAX
];

3381 
bitset_t
 
dests_ch
[
SBC_MAX
];

3382 } *
dests_alloc
;

3388 if (
	`__libc_use_alloca
 (sizeof (struct 
dests_alloc
)))

3389 
dests_alloc
 = (struct dests_alloc *) 
	`alloca
 (sizeof (struct dests_alloc));

3392 
dests_alloc
 = 
	`re_malloc
 (struct dests_alloc, 1);

3393 if (
	`BE
 (
dests_alloc
 == 
NULL
, 0))

3394 return 
false
;

3395 
dests_node_malloced
 = 
true
;

3397 
dests_node
 = 
dests_alloc
->dests_node;

3398 
dests_ch
 = 
dests_alloc
->dests_ch;

3401 
state
->
word_trtable
 = state->
trtable
 = 
NULL
;

3405 
ndests
 = 
	`group_nodes_into_DFAstates
 (
dfa
, 
state
, 
dests_node
, 
dests_ch
);

3406 if (
	`BE
 (! 
	`REG_VALID_NONZERO_INDEX
 (
ndests
), 0))

3408 if (
dests_node_malloced
)

3409 
	`free
 (
dests_alloc
);

3410 if (
ndests
 == 0)

3412 
state
->
trtable
 = (
re_dfastate_t
 **)

3413 
	`calloc
 (sizeof (
re_dfastate_t
 *), 
SBC_MAX
);

3414 if (
	`BE
 (
state
->
trtable
 == 
NULL
, 0))

3415 return 
false
;

3416 return 
true
;

3418 return 
false
;

3421 
err
 = 
	`re_node_set_alloc
 (&
follows
, 
ndests
 + 1);

3422 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3423 goto 
out_free
;

3426 if (
	`BE
 ((((
SIZE_MAX
 - (sizeof (
re_node_set
) + sizeof (
bitset_t
)) * 
SBC_MAX
)

3427 / (3 * sizeof (
re_dfastate_t
 *)))

3428 < 
ndests
),

3430 goto 
out_free
;

3432 if (
	`__libc_use_alloca
 ((sizeof (
re_node_set
) + sizeof (
bitset_t
)) * 
SBC_MAX


3433 + 
ndests
 * 3 * sizeof (
re_dfastate_t
 *)))

3434 
dest_states
 = (
re_dfastate_t
 **)

3435 
	`alloca
 (
ndests
 * 3 * sizeof (
re_dfastate_t
 *));

3438 
dest_states
 = (
re_dfastate_t
 **)

3439 
	`malloc
 (
ndests
 * 3 * sizeof (
re_dfastate_t
 *));

3440 if (
	`BE
 (
dest_states
 == 
NULL
, 0))

3442 
out_free
:

3443 if (
dest_states_malloced
)

3444 
	`free
 (
dest_states
);

3445 
	`re_node_set_free
 (&
follows
);

3446 for (
i
 = 0; i < 
ndests
; ++i)

3447 
	`re_node_set_free
 (
dests_node
 + 
i
);

3448 if (
dests_node_malloced
)

3449 
	`free
 (
dests_alloc
);

3450 return 
false
;

3452 
dest_states_malloced
 = 
true
;

3454 
dest_states_word
 = 
dest_states
 + 
ndests
;

3455 
dest_states_nl
 = 
dest_states_word
 + 
ndests
;

3456 
	`bitset_empty
 (
acceptable
);

3459 for (
i
 = 0; i < 
ndests
; ++i)

3461 
Idx
 
next_node
;

3462 
	`re_node_set_empty
 (&
follows
);

3464 for (
j
 = 0; j < 
dests_node
[
i
].
nelem
; ++j)

3466 
next_node
 = 
dfa
->
nexts
[
dests_node
[
i
].
elems
[
j
]];

3467 if (
next_node
 != 
REG_MISSING
)

3469 
err
 = 
	`re_node_set_merge
 (&
follows
, 
dfa
->
eclosures
 + 
next_node
);

3470 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3471 goto 
out_free
;

3474 
dest_states
[
i
] = 
	`re_acquire_state_context
 (&
err
, 
dfa
, &
follows
, 0);

3475 if (
	`BE
 (
dest_states
[
i
] == 
NULL
 && 
err
 != 
REG_NOERROR
, 0))

3476 goto 
out_free
;

3479 if (
dest_states
[
i
]->
has_constraint
)

3481 
dest_states_word
[
i
] = 
	`re_acquire_state_context
 (&
err
, 
dfa
, &
follows
,

3482 
CONTEXT_WORD
);

3483 if (
	`BE
 (
dest_states_word
[
i
] == 
NULL
 && 
err
 != 
REG_NOERROR
, 0))

3484 goto 
out_free
;

3486 if (
dest_states
[
i
] != 
dest_states_word
[i] && 
dfa
->
mb_cur_max
 > 1)

3487 
need_word_trtable
 = 
true
;

3489 
dest_states_nl
[
i
] = 
	`re_acquire_state_context
 (&
err
, 
dfa
, &
follows
,

3490 
CONTEXT_NEWLINE
);

3491 if (
	`BE
 (
dest_states_nl
[
i
] == 
NULL
 && 
err
 != 
REG_NOERROR
, 0))

3492 goto 
out_free
;

3496 
dest_states_word
[
i
] = 
dest_states
[i];

3497 
dest_states_nl
[
i
] = 
dest_states
[i];

3499 
	`bitset_merge
 (
acceptable
, 
dests_ch
[
i
]);

3502 if (!
	`BE
 (
need_word_trtable
, 0))

3508 
trtable
 = 
state
->trtable =

3509 (
re_dfastate_t
 **) 
	`calloc
 (sizeof (re_dfastate_t *), 
SBC_MAX
);

3510 if (
	`BE
 (
trtable
 == 
NULL
, 0))

3511 goto 
out_free
;

3514 for (
i
 = 0; i < 
BITSET_WORDS
; ++i)

3515 for (
ch
 = 
i
 * 
BITSET_WORD_BITS
, 
elem
 = 
acceptable
[i], 
mask
 = 1;

3516 
elem
;

3517 
mask
 <<= 1, 
elem
 >>= 1, ++
ch
)

3518 if (
	`BE
 (
elem
 & 1, 0))

3522 for (
j
 = 0; (
dests_ch
[j][
i
] & 
mask
) == 0; ++j)

3526 if (
dfa
->
word_char
[
i
] & 
mask
)

3527 
trtable
[
ch
] = 
dest_states_word
[
j
];

3529 
trtable
[
ch
] = 
dest_states
[
j
];

3539 
trtable
 = 
state
->
word_trtable
 =

3540 (
re_dfastate_t
 **) 
	`calloc
 (sizeof (re_dfastate_t *), 2 * 
SBC_MAX
);

3541 if (
	`BE
 (
trtable
 == 
NULL
, 0))

3542 goto 
out_free
;

3545 for (
i
 = 0; i < 
BITSET_WORDS
; ++i)

3546 for (
ch
 = 
i
 * 
BITSET_WORD_BITS
, 
elem
 = 
acceptable
[i], 
mask
 = 1;

3547 
elem
;

3548 
mask
 <<= 1, 
elem
 >>= 1, ++
ch
)

3549 if (
	`BE
 (
elem
 & 1, 0))

3553 for (
j
 = 0; (
dests_ch
[j][
i
] & 
mask
) == 0; ++j)

3557 
trtable
[
ch
] = 
dest_states
[
j
];

3558 
trtable
[
ch
 + 
SBC_MAX
] = 
dest_states_word
[
j
];

3563 if (
	`bitset_contain
 (
acceptable
, 
NEWLINE_CHAR
))

3566 for (
j
 = 0; j < 
ndests
; ++j)

3567 if (
	`bitset_contain
 (
dests_ch
[
j
], 
NEWLINE_CHAR
))

3570 
trtable
[
NEWLINE_CHAR
] = 
dest_states_nl
[
j
];

3571 if (
need_word_trtable
)

3572 
trtable
[
NEWLINE_CHAR
 + 
SBC_MAX
] = 
dest_states_nl
[
j
];

3579 if (
dest_states_malloced
)

3580 
	`free
 (
dest_states
);

3582 
	`re_node_set_free
 (&
follows
);

3583 for (
i
 = 0; i < 
ndests
; ++i)

3584 
	`re_node_set_free
 (
dests_node
 + 
i
);

3586 if (
dests_node_malloced
)

3587 
	`free
 (
dests_alloc
);

3589 return 
true
;

3590 
	}
}

3597 static 
Idx


3598 
internal_function


3599 
	$group_nodes_into_DFAstates
 (const 
re_dfa_t
 *
dfa
, const 
re_dfastate_t
 *
state
,

3600 
re_node_set
 *
dests_node
, 
bitset_t
 *
dests_ch
)

3602 
reg_errcode_t
 
err
;

3603 
bool
 
ok
;

3604 
Idx
 
i
, 
j
, 
k
;

3605 
Idx
 
ndests
;

3606 
bitset_t
 
accepts
;

3607 const 
re_node_set
 *
cur_nodes
 = &
state
->
nodes
;

3608 
	`bitset_empty
 (
accepts
);

3609 
ndests
 = 0;

3612 for (
i
 = 0; i < 
cur_nodes
->
nelem
; ++i)

3614 
re_token_t
 *
node
 = &
dfa
->
nodes
[
cur_nodes
->
elems
[
i
]];

3615 
re_token_type_t
 
type
 = 
node
->type;

3616 unsigned int 
constraint
 = 
node
->constraint;

3619 if (
type
 == 
CHARACTER
)

3620 
	`bitset_set
 (
accepts
, 
node
->
opr
.
c
);

3621 else if (
type
 == 
SIMPLE_BRACKET
)

3623 
	`bitset_merge
 (
accepts
, 
node
->
opr
.
sbcset
);

3625 else if (
type
 == 
OP_PERIOD
)

3627 #ifdef 
RE_ENABLE_I18N


3628 if (
dfa
->
mb_cur_max
 > 1)

3629 
	`bitset_merge
 (
accepts
, 
dfa
->
sb_char
);

3632 
	`bitset_set_all
 (
accepts
);

3633 if (!(
dfa
->
syntax
 & 
RE_DOT_NEWLINE
))

3634 
	`bitset_clear
 (
accepts
, '\n');

3635 if (
dfa
->
syntax
 & 
RE_DOT_NOT_NULL
)

3636 
	`bitset_clear
 (
accepts
, '\0');

3638 #ifdef 
RE_ENABLE_I18N


3639 else if (
type
 == 
OP_UTF8_PERIOD
)

3641 if (
ASCII_CHARS
 % 
BITSET_WORD_BITS
 == 0)

3642 
	`memset
 (
accepts
, -1, 
ASCII_CHARS
 / 
CHAR_BIT
);

3644 
	`bitset_merge
 (
accepts
, 
utf8_sb_map
);

3645 if (!(
dfa
->
syntax
 & 
RE_DOT_NEWLINE
))

3646 
	`bitset_clear
 (
accepts
, '\n');

3647 if (
dfa
->
syntax
 & 
RE_DOT_NOT_NULL
)

3648 
	`bitset_clear
 (
accepts
, '\0');

3656 if (
constraint
)

3658 if (
constraint
 & 
NEXT_NEWLINE_CONSTRAINT
)

3660 
bool
 
accepts_newline
 = 
	`bitset_contain
 (
accepts
, 
NEWLINE_CHAR
);

3661 
	`bitset_empty
 (
accepts
);

3662 if (
accepts_newline
)

3663 
	`bitset_set
 (
accepts
, 
NEWLINE_CHAR
);

3667 if (
constraint
 & 
NEXT_ENDBUF_CONSTRAINT
)

3669 
	`bitset_empty
 (
accepts
);

3673 if (
constraint
 & 
NEXT_WORD_CONSTRAINT
)

3675 
bitset_word_t
 
any_set
 = 0;

3676 if (
type
 == 
CHARACTER
 && !
node
->
word_char
)

3678 
	`bitset_empty
 (
accepts
);

3681 #ifdef 
RE_ENABLE_I18N


3682 if (
dfa
->
mb_cur_max
 > 1)

3683 for (
j
 = 0; j < 
BITSET_WORDS
; ++j)

3684 
any_set
 |= (
accepts
[
j
] &= (
dfa
->
word_char
[j] | ~dfa->
sb_char
[j]));

3687 for (
j
 = 0; j < 
BITSET_WORDS
; ++j)

3688 
any_set
 |= (
accepts
[
j
] &= 
dfa
->
word_char
[j]);

3689 if (!
any_set
)

3692 if (
constraint
 & 
NEXT_NOTWORD_CONSTRAINT
)

3694 
bitset_word_t
 
any_set
 = 0;

3695 if (
type
 == 
CHARACTER
 && 
node
->
word_char
)

3697 
	`bitset_empty
 (
accepts
);

3700 #ifdef 
RE_ENABLE_I18N


3701 if (
dfa
->
mb_cur_max
 > 1)

3702 for (
j
 = 0; j < 
BITSET_WORDS
; ++j)

3703 
any_set
 |= (
accepts
[
j
] &= ~(
dfa
->
word_char
[j] & dfa->
sb_char
[j]));

3706 for (
j
 = 0; j < 
BITSET_WORDS
; ++j)

3707 
any_set
 |= (
accepts
[
j
] &= ~
dfa
->
word_char
[j]);

3708 if (!
any_set
)

3715 for (
j
 = 0; j < 
ndests
; ++j)

3717 
bitset_t
 
intersec
;

3718 
bitset_t
 
remains
;

3720 
bitset_word_t
 
has_intersec
, 
not_subset
, 
not_consumed
;

3723 if (
type
 == 
CHARACTER
 && !
	`bitset_contain
 (
dests_ch
[
j
], 
node
->
opr
.
c
))

3727 
has_intersec
 = 0;

3728 for (
k
 = 0; k < 
BITSET_WORDS
; ++k)

3729 
has_intersec
 |= 
intersec
[
k
] = 
accepts
[k] & 
dests_ch
[
j
][k];

3731 if (!
has_intersec
)

3735 
not_subset
 = 
not_consumed
 = 0;

3736 for (
k
 = 0; k < 
BITSET_WORDS
; ++k)

3738 
not_subset
 |= 
remains
[
k
] = ~
accepts
[k] & 
dests_ch
[
j
][k];

3739 
not_consumed
 |= 
accepts
[
k
] = accepts[k] & ~
dests_ch
[
j
][k];

3744 if (
not_subset
)

3746 
	`bitset_copy
 (
dests_ch
[
ndests
], 
remains
);

3747 
	`bitset_copy
 (
dests_ch
[
j
], 
intersec
);

3748 
err
 = 
	`re_node_set_init_copy
 (
dests_node
 + 
ndests
, &dests_node[
j
]);

3749 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3750 goto 
error_return
;

3751 ++
ndests
;

3755 
ok
 = 
	`re_node_set_insert
 (&
dests_node
[
j
], 
cur_nodes
->
elems
[
i
]);

3756 if (
	`BE
 (! 
ok
, 0))

3757 goto 
error_return
;

3760 if (!
not_consumed
)

3764 if (
j
 == 
ndests
)

3766 
	`bitset_copy
 (
dests_ch
[
ndests
], 
accepts
);

3767 
err
 = 
	`re_node_set_init_1
 (
dests_node
 + 
ndests
, 
cur_nodes
->
elems
[
i
]);

3768 if (
	`BE
 (
err
 != 
REG_NOERROR
, 0))

3769 goto 
error_return
;

3770 ++
ndests
;

3771 
	`bitset_empty
 (
accepts
);

3774 return 
ndests
;

3775 
error_return
:

3776 for (
j
 = 0; j < 
ndests
; ++j)

3777 
	`re_node_set_free
 (
dests_node
 + 
j
);

3778 return 
REG_MISSING
;

3779 
	}
}

3781 #ifdef 
RE_ENABLE_I18N


3791 
internal_function


3792 
	$check_node_accept_bytes
 (const 
re_dfa_t
 *
dfa
, 
Idx
 
node_idx
,

3793 const 
re_string_t
 *
input
, 
Idx
 
str_idx
)

3795 const 
re_token_t
 *
node
 = 
dfa
->
nodes
 + 
node_idx
;

3796 int 
char_len
, 
elem_len
;

3797 
Idx
 
i
;

3799 if (
	`BE
 (
node
->
type
 == 
OP_UTF8_PERIOD
, 0))

3801 unsigned char 
c
 = 
	`re_string_byte_at
 (
input
, 
str_idx
), 
d
;

3802 if (
	`BE
 (
c
 < 0xc2, 1))

3805 if (
str_idx
 + 2 > 
input
->
len
)

3808 
d
 = 
	`re_string_byte_at
 (
input
, 
str_idx
 + 1);

3809 if (
c
 < 0xe0)

3810 return (
d
 < 0x80 || d > 0xbf) ? 0 : 2;

3811 else if (
c
 < 0xf0)

3813 
char_len
 = 3;

3814 if (
c
 == 0xe0 && 
d
 < 0xa0)

3817 else if (
c
 < 0xf8)

3819 
char_len
 = 4;

3820 if (
c
 == 0xf0 && 
d
 < 0x90)

3823 else if (
c
 < 0xfc)

3825 
char_len
 = 5;

3826 if (
c
 == 0xf8 && 
d
 < 0x88)

3829 else if (
c
 < 0xfe)

3831 
char_len
 = 6;

3832 if (
c
 == 0xfc && 
d
 < 0x84)

3838 if (
str_idx
 + 
char_len
 > 
input
->
len
)

3841 for (
i
 = 1; i < 
char_len
; ++i)

3843 
d
 = 
	`re_string_byte_at
 (
input
, 
str_idx
 + 
i
);

3844 if (
d
 < 0x80 || d > 0xbf)

3847 return 
char_len
;

3850 
char_len
 = 
	`re_string_char_size_at
 (
input
, 
str_idx
);

3851 if (
node
->
type
 == 
OP_PERIOD
)

3853 if (
char_len
 <= 1)

3858 if ((!(
dfa
->
syntax
 & 
RE_DOT_NEWLINE
) &&

3859 
	`re_string_byte_at
 (
input
, 
str_idx
) == '\n') ||

3860 ((
dfa
->
syntax
 & 
RE_DOT_NOT_NULL
) &&

3861 
	`re_string_byte_at
 (
input
, 
str_idx
) == '\0'))

3863 return 
char_len
;

3866 
elem_len
 = 
	`re_string_elem_size_at
 (
input
, 
str_idx
);

3867 if ((
elem_len
 <= 1 && 
char_len
 <= 1) || char_len == 0)

3870 if (
node
->
type
 == 
COMPLEX_BRACKET
)

3872 const 
re_charset_t
 *
cset
 = 
node
->
opr
.
mbcset
;

3873 #ifdef 
_LIBC


3874 const unsigned char *
pin


3875 = ((const unsigned char *) 
	`re_string_get_buffer
 (
input
) + 
str_idx
);

3876 
Idx
 
j
;

3877 
uint32_t
 
nrules
;

3879 int 
match_len
 = 0;

3880 
wchar_t
 
wc
 = ((
cset
->
nranges
 || cset->
nchar_classes
 || cset->
nmbchars
)

3881 ? 
	`re_string_wchar_at
 (
input
, 
str_idx
) : 0);

3884 for (
i
 = 0; i < 
cset
->
nmbchars
; ++i)

3885 if (
wc
 == 
cset
->
mbchars
[
i
])

3887 
match_len
 = 
char_len
;

3888 goto 
check_node_accept_bytes_match
;

3891 for (
i
 = 0; i < 
cset
->
nchar_classes
; ++i)

3893 
wctype_t
 
wt
 = 
cset
->
char_classes
[
i
];

3894 if (
	`__iswctype
 (
wc
, 
wt
))

3896 
match_len
 = 
char_len
;

3897 goto 
check_node_accept_bytes_match
;

3901 #ifdef 
_LIBC


3902 
nrules
 = 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
);

3903 if (
nrules
 != 0)

3905 unsigned int 
in_collseq
 = 0;

3906 const 
int32_t
 *
table
, *
indirect
;

3907 const unsigned char *
weights
, *
extra
;

3908 const char *
collseqwc
;

3909 
int32_t
 
idx
;

3911 #include 
	~<locale/weight.h
>

3914 if (
cset
->
ncoll_syms
)

3915 
extra
 = (const unsigned char *)

3916 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_SYMB_EXTRAMB
);

3917 for (
i
 = 0; i < 
cset
->
ncoll_syms
; ++i)

3919 const unsigned char *
coll_sym
 = 
extra
 + 
cset
->
coll_syms
[
i
];

3922 if (*
coll_sym
 != 
elem_len
)

3925 for (
j
 = 0; j < *
coll_sym
; j++)

3926 if (
pin
[
j
] != 
coll_sym
[1 + j])

3928 if (
j
 == *
coll_sym
)

3931 
match_len
 = 
j
;

3932 goto 
check_node_accept_bytes_match
;

3936 if (
cset
->
nranges
)

3938 if (
elem_len
 <= 
char_len
)

3940 
collseqwc
 = 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_COLLSEQWC
);

3941 
in_collseq
 = 
	`__collseq_table_lookup
 (
collseqwc
, 
wc
);

3944 
in_collseq
 = 
	`find_collation_sequence_value
 (
pin
, 
elem_len
);

3947 for (
i
 = 0; i < 
cset
->
nranges
; ++i)

3948 if (
cset
->
range_starts
[
i
] <= 
in_collseq


3949 && 
in_collseq
 <= 
cset
->
range_ends
[
i
])

3951 
match_len
 = 
elem_len
;

3952 goto 
check_node_accept_bytes_match
;

3956 if (
cset
->
nequiv_classes
)

3958 const unsigned char *
cp
 = 
pin
;

3959 
table
 = (const 
int32_t
 *)

3960 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_TABLEMB
);

3961 
weights
 = (const unsigned char *)

3962 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_WEIGHTMB
);

3963 
extra
 = (const unsigned char *)

3964 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_EXTRAMB
);

3965 
indirect
 = (const 
int32_t
 *)

3966 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_INDIRECTMB
);

3967 
int32_t
 
idx
 = 
	`findidx
 (&
cp
);

3968 if (
idx
 > 0)

3969 for (
i
 = 0; i < 
cset
->
nequiv_classes
; ++i)

3971 
int32_t
 
equiv_class_idx
 = 
cset
->
equiv_classes
[
i
];

3972 
size_t
 
weight_len
 = 
weights
[
idx
 & 0xffffff];

3973 if (
weight_len
 == 
weights
[
equiv_class_idx
 & 0xffffff]

3974 && (
idx
 >> 24) == (
equiv_class_idx
 >> 24))

3976 
Idx
 
cnt
 = 0;

3978 
idx
 &= 0xffffff;

3979 
equiv_class_idx
 &= 0xffffff;

3981 while (
cnt
 <= 
weight_len


3982 && (
weights
[
equiv_class_idx
 + 1 + 
cnt
]

3983 == 
weights
[
idx
 + 1 + 
cnt
]))

3984 ++
cnt
;

3985 if (
cnt
 > 
weight_len
)

3987 
match_len
 = 
elem_len
;

3988 goto 
check_node_accept_bytes_match
;

3998 #if 
__GNUC__
 >= 2 && ! (
__STDC_VERSION__
 < 199901L && 
defined
 
__STRICT_ANSI__
)

3999 
wchar_t
 
cmp_buf
[] = {
L
'\0', L'\0', 
wc
, L'\0', L'\0', L'\0'};

4001 
wchar_t
 
cmp_buf
[] = {
L
'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};

4002 
cmp_buf
[2] = 
wc
;

4004 for (
i
 = 0; i < 
cset
->
nranges
; ++i)

4006 
cmp_buf
[0] = 
cset
->
range_starts
[
i
];

4007 
cmp_buf
[4] = 
cset
->
range_ends
[
i
];

4008 if (
	`wcscoll
 (
cmp_buf
, cmp_buf + 2) <= 0

4009 && 
	`wcscoll
 (
cmp_buf
 + 2, cmp_buf + 4) <= 0)

4011 
match_len
 = 
char_len
;

4012 goto 
check_node_accept_bytes_match
;

4016 
check_node_accept_bytes_match
:

4017 if (!
cset
->
non_match
)

4018 return 
match_len
;

4021 if (
match_len
 > 0)

4024 return (
elem_len
 > 
char_len
) ? elem_len : char_len;

4028 
	}
}

4030 #ifdef 
_LIBC


4032 
internal_function


4033 
	$find_collation_sequence_value
 (const unsigned char *
mbs
, 
size_t
 
mbs_len
)

4035 
uint32_t
 
nrules
 = 
	`_NL_CURRENT_WORD
 (
LC_COLLATE
, 
_NL_COLLATE_NRULES
);

4036 if (
nrules
 == 0)

4038 if (
mbs_len
 == 1)

4041 const unsigned char *
collseq
 = (const unsigned char *)

4042 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_COLLSEQMB
);

4043 return 
collseq
[
mbs
[0]];

4045 return 
UINT_MAX
;

4049 
int32_t
 
idx
;

4050 const unsigned char *
extra
 = (const unsigned char *)

4051 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_SYMB_EXTRAMB
);

4052 
int32_t
 
extrasize
 = (const unsigned char *)

4053 
	`_NL_CURRENT
 (
LC_COLLATE
, 
_NL_COLLATE_SYMB_EXTRAMB
 + 1) - 
extra
;

4055 for (
idx
 = 0; idx < 
extrasize
;)

4057 int 
mbs_cnt
;

4058 
bool
 
found
 = 
false
;

4059 
int32_t
 
elem_mbs_len
;

4061 
idx
 = idx + 
extra
[idx] + 1;

4062 
elem_mbs_len
 = 
extra
[
idx
++];

4063 if (
mbs_len
 == 
elem_mbs_len
)

4065 for (
mbs_cnt
 = 0; mbs_cnt < 
elem_mbs_len
; ++mbs_cnt)

4066 if (
extra
[
idx
 + 
mbs_cnt
] != 
mbs
[mbs_cnt])

4068 if (
mbs_cnt
 == 
elem_mbs_len
)

4070 
found
 = 
true
;

4073 
idx
 += 
elem_mbs_len
;

4075 
idx
 = (idx + 3) & ~3;

4077 
idx
 += sizeof (
uint32_t
);

4079 
idx
 = idx + sizeof (
uint32_t
) * (
extra
[idx] + 1);

4081 if (
found
)

4082 return *(
uint32_t
 *) (
extra
 + 
idx
);

4084 
idx
 += sizeof (
uint32_t
);

4086 return 
UINT_MAX
;

4088 
	}
}

4095 static 
bool


4096 
internal_function


4097 
	$check_node_accept
 (const 
re_match_context_t
 *
mctx
, const 
re_token_t
 *
node
,

4098 
Idx
 
idx
)

4100 unsigned char 
ch
;

4101 
ch
 = 
	`re_string_byte_at
 (&
mctx
->
input
, 
idx
);

4102 switch (
node
->
type
)

4104 case 
CHARACTER
:

4105 if (
node
->
opr
.
c
 != 
ch
)

4106 return 
false
;

4109 case 
SIMPLE_BRACKET
:

4110 if (!
	`bitset_contain
 (
node
->
opr
.
sbcset
, 
ch
))

4111 return 
false
;

4114 #ifdef 
RE_ENABLE_I18N


4115 case 
OP_UTF8_PERIOD
:

4116 if (
ch
 >= 
ASCII_CHARS
)

4117 return 
false
;

4120 case 
OP_PERIOD
:

4121 if ((
ch
 == '\n' && !(
mctx
->
dfa
->
syntax
 & 
RE_DOT_NEWLINE
))

4122 || (
ch
 == '\0' && (
mctx
->
dfa
->
syntax
 & 
RE_DOT_NOT_NULL
)))

4123 return 
false
;

4127 return 
false
;

4130 if (
node
->
constraint
)

4134 unsigned int 
context
 = 
	`re_string_context_at
 (&
mctx
->
input
, 
idx
,

4135 
mctx
->
eflags
);

4136 if (
	`NOT_SATISFY_NEXT_CONSTRAINT
 (
node
->
constraint
, 
context
))

4137 return 
false
;

4140 return 
true
;

4141 
	}
}

4145 static 
reg_errcode_t


4146 
internal_function
 
__attribute_warn_unused_result__


4147 
	$extend_buffers
 (
re_match_context_t
 *
mctx
)

4149 
reg_errcode_t
 
ret
;

4150 
re_string_t
 *
pstr
 = &
mctx
->
input
;

4153 if (
	`BE
 (
SIZE_MAX
 / 2 / sizeof (
re_dfastate_t
 *) <= 
pstr
->
bufs_len
, 0))

4154 return 
REG_ESPACE
;

4157 
ret
 = 
	`re_string_realloc_buffers
 (
pstr
, pstr->
bufs_len
 * 2);

4158 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

4159 return 
ret
;

4161 if (
mctx
->
state_log
 != 
NULL
)

4167 
re_dfastate_t
 **
new_array
 = 
	`re_realloc
 (
mctx
->
state_log
, re_dfastate_t *,

4168 
pstr
->
bufs_len
 + 1);

4169 if (
	`BE
 (
new_array
 == 
NULL
, 0))

4170 return 
REG_ESPACE
;

4171 
mctx
->
state_log
 = 
new_array
;

4175 if (
pstr
->
icase
)

4177 #ifdef 
RE_ENABLE_I18N


4178 if (
pstr
->
mb_cur_max
 > 1)

4180 
ret
 = 
	`build_wcs_upper_buffer
 (
pstr
);

4181 if (
	`BE
 (
ret
 != 
REG_NOERROR
, 0))

4182 return 
ret
;

4186 
	`build_upper_buffer
 (
pstr
);

4190 #ifdef 
RE_ENABLE_I18N


4191 if (
pstr
->
mb_cur_max
 > 1)

4192 
	`build_wcs_buffer
 (
pstr
);

4196 if (
pstr
->
trans
 != 
NULL
)

4197 
	`re_string_translate_buffer
 (
pstr
);

4200 return 
REG_NOERROR
;

4201 
	}
}

4208 static 
reg_errcode_t


4209 
internal_function
 
__attribute_warn_unused_result__


4210 
	$match_ctx_init
 (
re_match_context_t
 *
mctx
, int 
eflags
, 
Idx
 
n
)

4212 
mctx
->
eflags
 = eflags;

4213 
mctx
->
match_last
 = 
REG_MISSING
;

4214 if (
n
 > 0)

4217 
size_t
 
max_object_size
 =

4218 
	`MAX
 (sizeof (struct 
re_backref_cache_entry
),

4219 sizeof (
re_sub_match_top_t
 *));

4220 if (
	`BE
 (
SIZE_MAX
 / 
max_object_size
 < 
n
, 0))

4221 return 
REG_ESPACE
;

4223 
mctx
->
bkref_ents
 = 
	`re_malloc
 (struct 
re_backref_cache_entry
, 
n
);

4224 
mctx
->
sub_tops
 = 
	`re_malloc
 (
re_sub_match_top_t
 *, 
n
);

4225 if (
	`BE
 (
mctx
->
bkref_ents
 == 
NULL
 || mctx->
sub_tops
 == NULL, 0))

4226 return 
REG_ESPACE
;

4233 
mctx
->
abkref_ents
 = 
n
;

4234 
mctx
->
max_mb_elem_len
 = 1;

4235 
mctx
->
asub_tops
 = 
n
;

4236 return 
REG_NOERROR
;

4237 
	}
}

4244 
internal_function


4245 
	$match_ctx_clean
 (
re_match_context_t
 *
mctx
)

4247 
Idx
 
st_idx
;

4248 for (
st_idx
 = 0; st_idx < 
mctx
->
nsub_tops
; ++st_idx)

4250 
Idx
 
sl_idx
;

4251 
re_sub_match_top_t
 *
top
 = 
mctx
->
sub_tops
[
st_idx
];

4252 for (
sl_idx
 = 0; sl_idx < 
top
->
nlasts
; ++sl_idx)

4254 
re_sub_match_last_t
 *
last
 = 
top
->
lasts
[
sl_idx
];

4255 
	`re_free
 (
last
->
path
.
array
);

4256 
	`re_free
 (
last
);

4258 
	`re_free
 (
top
->
lasts
);

4259 if (
top
->
path
)

4261 
	`re_free
 (
top
->
path
->
array
);

4262 
	`re_free
 (
top
->
path
);

4264 
	`free
 (
top
);

4267 
mctx
->
nsub_tops
 = 0;

4268 
mctx
->
nbkref_ents
 = 0;

4269 
	}
}

4274 
internal_function


4275 
	$match_ctx_free
 (
re_match_context_t
 *
mctx
)

4278 
	`match_ctx_clean
 (
mctx
);

4279 
	`re_free
 (
mctx
->
sub_tops
);

4280 
	`re_free
 (
mctx
->
bkref_ents
);

4281 
	}
}

4288 static 
reg_errcode_t


4289 
internal_function
 
__attribute_warn_unused_result__


4290 
	$match_ctx_add_entry
 (
re_match_context_t
 *
mctx
, 
Idx
 
node
, Idx 
str_idx
, Idx 
from
,

4291 
Idx
 
to
)

4293 if (
mctx
->
nbkref_ents
 >= mctx->
abkref_ents
)

4295 struct 
re_backref_cache_entry
* 
new_entry
;

4296 
new_entry
 = 
	`re_realloc
 (
mctx
->
bkref_ents
, struct 
re_backref_cache_entry
,

4297 
mctx
->
abkref_ents
 * 2);

4298 if (
	`BE
 (
new_entry
 == 
NULL
, 0))

4300 
	`re_free
 (
mctx
->
bkref_ents
);

4301 return 
REG_ESPACE
;

4303 
mctx
->
bkref_ents
 = 
new_entry
;

4304 
	`memset
 (
mctx
->
bkref_ents
 + mctx->
nbkref_ents
, '\0',

4305 sizeof (struct 
re_backref_cache_entry
) * 
mctx
->
abkref_ents
);

4306 
mctx
->
abkref_ents
 *= 2;

4308 if (
mctx
->
nbkref_ents
 > 0

4309 && 
mctx
->
bkref_ents
[mctx->
nbkref_ents
 - 1].
str_idx
 == str_idx)

4310 
mctx
->
bkref_ents
[mctx->
nbkref_ents
 - 1].
more
 = 1;

4312 
mctx
->
bkref_ents
[mctx->
nbkref_ents
].
node
 = node;

4313 
mctx
->
bkref_ents
[mctx->
nbkref_ents
].
str_idx
 = str_idx;

4314 
mctx
->
bkref_ents
[mctx->
nbkref_ents
].
subexp_from
 = 
from
;

4315 
mctx
->
bkref_ents
[mctx->
nbkref_ents
].
subexp_to
 = 
to
;

4325 
mctx
->
bkref_ents
[mctx->
nbkref_ents
].
eps_reachable_subexps_map


4326 = (
from
 == 
to
 ? -1 : 0);

4328 
mctx
->
bkref_ents
[mctx->
nbkref_ents
++].
more
 = 0;

4329 if (
mctx
->
max_mb_elem_len
 < 
to
 - 
from
)

4330 
mctx
->
max_mb_elem_len
 = 
to
 - 
from
;

4331 return 
REG_NOERROR
;

4332 
	}
}

4337 static 
Idx


4338 
internal_function


4339 
	$search_cur_bkref_entry
 (const 
re_match_context_t
 *
mctx
, 
Idx
 
str_idx
)

4341 
Idx
 
left
, 
right
, 
mid
, 
last
;

4342 
last
 = 
right
 = 
mctx
->
nbkref_ents
;

4343 for (
left
 = 0; left < 
right
;)

4345 
mid
 = (
left
 + 
right
) / 2;

4346 if (
mctx
->
bkref_ents
[
mid
].
str_idx
 < str_idx)

4347 
left
 = 
mid
 + 1;

4349 
right
 = 
mid
;

4351 if (
left
 < 
last
 && 
mctx
->
bkref_ents
[left].
str_idx
 == str_idx)

4352 return 
left
;

4354 return 
REG_MISSING
;

4355 
	}
}

4360 static 
reg_errcode_t


4361 
internal_function
 
__attribute_warn_unused_result__


4362 
	$match_ctx_add_subtop
 (
re_match_context_t
 *
mctx
, 
Idx
 
node
, Idx 
str_idx
)

4364 #ifdef 
DEBUG


4365 
	`assert
 (
mctx
->
sub_tops
 != 
NULL
);

4366 
	`assert
 (
mctx
->
asub_tops
 > 0);

4368 if (
	`BE
 (
mctx
->
nsub_tops
 == mctx->
asub_tops
, 0))

4370 
Idx
 
new_asub_tops
 = 
mctx
->
asub_tops
 * 2;

4371 
re_sub_match_top_t
 **
new_array
 = 
	`re_realloc
 (
mctx
->
sub_tops
,

4372 
re_sub_match_top_t
 *,

4373 
new_asub_tops
);

4374 if (
	`BE
 (
new_array
 == 
NULL
, 0))

4375 return 
REG_ESPACE
;

4376 
mctx
->
sub_tops
 = 
new_array
;

4377 
mctx
->
asub_tops
 = 
new_asub_tops
;

4379 
mctx
->
sub_tops
[mctx->
nsub_tops
] = 
	`calloc
 (1, sizeof (
re_sub_match_top_t
));

4380 if (
	`BE
 (
mctx
->
sub_tops
[mctx->
nsub_tops
] == 
NULL
, 0))

4381 return 
REG_ESPACE
;

4382 
mctx
->
sub_tops
[mctx->
nsub_tops
]->
node
 = node;

4383 
mctx
->
sub_tops
[mctx->
nsub_tops
++]->
str_idx
 = str_idx;

4384 return 
REG_NOERROR
;

4385 
	}
}

4390 static 
re_sub_match_last_t
 *

4391 
internal_function


4392 
	$match_ctx_add_sublast
 (
re_sub_match_top_t
 *
subtop
, 
Idx
 
node
, Idx 
str_idx
)

4394 
re_sub_match_last_t
 *
new_entry
;

4395 if (
	`BE
 (
subtop
->
nlasts
 == subtop->
alasts
, 0))

4397 
Idx
 
new_alasts
 = 2 * 
subtop
->
alasts
 + 1;

4398 
re_sub_match_last_t
 **
new_array
 = 
	`re_realloc
 (
subtop
->
lasts
,

4399 
re_sub_match_last_t
 *,

4400 
new_alasts
);

4401 if (
	`BE
 (
new_array
 == 
NULL
, 0))

4402 return 
NULL
;

4403 
subtop
->
lasts
 = 
new_array
;

4404 
subtop
->
alasts
 = 
new_alasts
;

4406 
new_entry
 = 
	`calloc
 (1, sizeof (
re_sub_match_last_t
));

4407 if (
	`BE
 (
new_entry
 != 
NULL
, 1))

4409 
subtop
->
lasts
[subtop->
nlasts
] = 
new_entry
;

4410 
new_entry
->
node
 = node;

4411 
new_entry
->
str_idx
 = str_idx;

4412 ++
subtop
->
nlasts
;

4414 return 
new_entry
;

4415 
	}
}

4418 
internal_function


4419 
	$sift_ctx_init
 (
re_sift_context_t
 *
sctx
, 
re_dfastate_t
 **
sifted_sts
,

4420 
re_dfastate_t
 **
limited_sts
, 
Idx
 
last_node
, Idx 
last_str_idx
)

4422 
sctx
->
sifted_states
 = 
sifted_sts
;

4423 
sctx
->
limited_states
 = 
limited_sts
;

4424 
sctx
->
last_node
 = last_node;

4425 
sctx
->
last_str_idx
 = last_str_idx;

4426 
	`re_node_set_init_empty
 (&
sctx
->
limits
);

4427 
	}
}

	@lib/same-inode.h

18 #ifndef 
SAME_INODE_H


19 #define 
	#SAME_INODE_H
 1

	)

21 #define 
	#SAME_INODE
(
Stat_buf_1
, 
Stat_buf_2
) \

22 ((
Stat_buf_1
).
st_ino
 == (
Stat_buf_2
).st_ino \

23 && (
Stat_buf_1
).
st_dev
 == (
Stat_buf_2
).st_dev)

	)

	@lib/savedir.c

20 #include 
	~<config.h
>

22 #include 
	~<sys/types.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<dirent.h
>

26 #ifdef 
CLOSEDIR_VOID


28 #define 
	#CLOSEDIR
(
d
) (
	`closedir
 (d), 0)

	)

30 #define 
	#CLOSEDIR
(
d
) 
	`closedir
 (d)

	)

33 #include 
	~<stdlib.h
>

34 #include 
	~<string.h
>

35 #include 
	~<fnmatch.h
>

36 #include 
	~"savedir.h
"

37 #include 
	~"xalloc.h
"

39 static char *
	gpath
;

40 static 
size_t
 
	gpathlen
;

42 extern int 
isdir
 (const char *
name
);

45 
	$isdir1
 (const char *
dir
, const char *
file
)

47 
size_t
 
dirlen
 = 
	`strlen
 (
dir
);

48 
size_t
 
filelen
 = 
	`strlen
 (
file
);

50 while (
dirlen
 && 
dir
[dirlen - 1] == '/')

51 
dirlen
--;

53 if ((
dirlen
 + 
filelen
 + 2) > 
pathlen
)

55 
pathlen
 *= 2;

56 if ((
dirlen
 + 
filelen
 + 2) > 
pathlen
)

57 
pathlen
 = 
dirlen
 + 
filelen
 + 2;

59 
path
 = 
	`xrealloc
 (path, 
pathlen
);

62 
	`memcpy
 (
path
, 
dir
, 
dirlen
);

63 
path
[
dirlen
] = '/';

64 
	`strcpy
 (
path
 + 
dirlen
 + 1, 
file
);

65 return 
	`isdir
 (
path
);

66 
	}
}

75 
	$savedir
 (const char *
dir
, 
off_t
 
name_size
, struct 
exclude
 *
included_patterns
,

76 struct 
exclude
 *
excluded_patterns
, struct exclude *
excluded_directory_patterns
 )

78 
DIR
 *
dirp
;

79 struct 
dirent
 *
dp
;

80 char *
name_space
;

81 char *
namep
;

83 
dirp
 = 
	`opendir
 (
dir
);

84 if (
dirp
 == 
NULL
)

85 return 
NULL
;

89 if (
name_size
 <= 0)

90 
name_size
 = 1;

92 
name_space
 = (char *) 
	`malloc
 (
name_size
);

93 if (
name_space
 == 
NULL
)

95 
	`closedir
 (
dirp
);

96 return 
NULL
;

98 
namep
 = 
name_space
;

100 while ((
dp
 = 
	`readdir
 (
dirp
)) != 
NULL
)

103 if (
dp
->
d_name
[0] != '.'

104 || (
dp
->
d_name
[1] != '\0'

105 && (
dp
->
d_name
[1] != '.' || dp->d_name[2] != '\0')))

107 
size_t
 
namlen
 = 
	`strlen
 (
dp
->
d_name
);

108 
size_t
 
size_needed
 = (
namep
 - 
name_space
) + 
namlen
 + 2;

110 if ((
included_patterns
 || 
excluded_patterns
)

111 && !
	`isdir1
 (
dir
, 
dp
->
d_name
))

113 if (
included_patterns


114 && 
	`excluded_file_name
 (
included_patterns
, 
dp
->
d_name
))

116 if (
excluded_patterns


117 && 
	`excluded_file_name
 (
excluded_patterns
, 
dp
->
d_name
))

121 if ( 
excluded_directory_patterns


122 && 
	`isdir1
 (
dir
, 
dp
->
d_name
) )

124 if (
excluded_directory_patterns


125 && 
	`excluded_file_name
 (
excluded_directory_patterns
, 
dp
->
d_name
))

129 if (
size_needed
 > 
name_size
)

131 char *
new_name_space
;

133 while (
size_needed
 > 
name_size
)

134 
name_size
 += 1024;

136 
new_name_space
 = 
	`realloc
 (
name_space
, 
name_size
);

137 if (
new_name_space
 == 
NULL
)

139 
	`closedir
 (
dirp
);

140 goto 
fail
;

142 
namep
 = 
new_name_space
 + (namep - 
name_space
);

143 
name_space
 = 
new_name_space
;

145 
	`strcpy
 (
namep
, 
dp
->
d_name
);

146 
namep
 += 
namlen
 + 1;

149 *
namep
 = '\0';

150 if (
	`CLOSEDIR
 (
dirp
))

152 
fail
:

153 
	`free
 (
name_space
);

154 
name_space
 = 
NULL
;

156 if (
path
)

158 
	`free
 (
path
);

159 
path
 = 
NULL
;

160 
pathlen
 = 0;

162 return 
name_space
;

163 
	}
}

	@lib/savedir.h

1 #if !
defined
 
SAVEDIR_H_


2 #define 
	#SAVEDIR_H_


	)

4 #include 
	~"exclude.h
"

7 
savedir
 (const char *
dir
, 
off_t
 
name_size
,

8 struct 
exclude
 *, struct exclude *,

9 struct 
exclude
 *);

	@lib/stat.c

22 #define 
	#__need_system_sys_stat_h


	)

23 #include 
	~<config.h
>

26 #include 
	~<sys/types.h
>

27 #include 
	~<sys/stat.h
>

28 #undef 
__need_system_sys_stat_h


30 static 
inline
 int

31 
	$orig_stat
 (const char *
filename
, struct 
stat
 *
buf
)

33 return 
	`stat
 (
filename
, 
buf
);

34 
	}
}

40 #include 
	~"sys/stat.h
"

42 #include 
	~<errno.h
>

43 #include 
	~<limits.h
>

44 #include 
	~<stdbool.h
>

45 #include 
	~<string.h
>

46 #include 
	~"dosname.h
"

47 #include 
	~"verify.h
"

49 #if 
REPLACE_FUNC_STAT_DIR


50 #include 
	~"pathmax.h
"

53 #ifndef 
PATH_MAX


65 
	$rpl_stat
 (char const *
name
, struct 
stat
 *
st
)

67 int 
result
 = 
	`orig_stat
 (
name
, 
st
);

68 #if 
REPLACE_FUNC_STAT_FILE


71 if (
result
 == 0 && !
	`S_ISDIR
 (
st
->
st_mode
))

73 
size_t
 
len
 = 
	`strlen
 (
name
);

74 if (
	`ISSLASH
 (
name
[
len
 - 1]))

76 
errno
 = 
ENOTDIR
;

81 #if 
REPLACE_FUNC_STAT_DIR


83 if (
result
 == -1 && 
errno
 == 
ENOENT
)

94 char 
fixed_name
[
PATH_MAX
 + 1] = {0};

95 
size_t
 
len
 = 
	`strlen
 (
name
);

96 
bool
 
check_dir
 = 
false
;

97 
	`verify
 (
PATH_MAX
 <= 4096);

98 if (
PATH_MAX
 <= 
len
)

99 
errno
 = 
ENAMETOOLONG
;

100 else if (
len
)

102 
	`strcpy
 (
fixed_name
, 
name
);

103 if (
	`ISSLASH
 (
fixed_name
[
len
 - 1]))

105 
check_dir
 = 
true
;

106 while (
len
 && 
	`ISSLASH
 (
fixed_name
[len - 1]))

107 
fixed_name
[--
len
] = '\0';

108 if (!
len
)

109 
fixed_name
[0] = '/';

112 
fixed_name
[
len
++] = '/';

113 
result
 = 
	`orig_stat
 (
fixed_name
, 
st
);

114 if (
result
 == 0 && 
check_dir
 && !
	`S_ISDIR
 (
st
->
st_mode
))

116 
result
 = -1;

117 
errno
 = 
ENOTDIR
;

122 return 
result
;

123 
	}
}

	@lib/stdarg.in.h

20 #ifndef 
_
@
GUARD_PREFIX
@
_STDARG_H


22 #if 
__GNUC__
 >= 3

23 @
	gPRAGMA_SYSTEM_HEADER
@

25 @
	gPRAGMA_COLUMNS
@

28 #@
INCLUDE_NEXT
@ @
NEXT_STDARG_H
@

30 #ifndef 
_
@
GUARD_PREFIX
@
_STDARG_H


31 #define 
	#_
@
GUARD_PREFIX
@
_STDARG_H


	)

33 #ifndef 
va_copy


34 #define 
	#va_copy
(
a
,
b
) ((a) = (b))

	)

	@lib/stdbool.in.h

20 #ifndef 
_GL_STDBOOL_H


21 #define 
	#_GL_STDBOOL_H


	)

66 #if 
defined
 
__BEOS__
 && !defined 
__HAIKU__


67 #include 
	~<OS.h
>

68 #undef 
false


69 #undef 
true


81 #if 
defined
 
__cplusplus
 || (defined 
__BEOS__
 && !defined 
__HAIKU__
)

85 #if !@
HAVE__BOOL
@

86 typedef 
bool
 
	t_Bool
;

89 #if !
defined
 
__GNUC__


109 #define 
	#_Bool
 signed char

	)

112 #if !@
HAVE__BOOL
@

113 typedef enum { 
	m_Bool_must_promote_to_int
 = -1, 
	mfalse
 = 0, 
	mtrue
 = 1 } 
	t_Bool
;

117 #define 
	#bool
 
_Bool


	)

120 #define 
	#false
 0

	)

121 #define 
	#true
 1

	)

122 #define 
	#__bool_true_false_are_defined
 1

	)

	@lib/stddef.in.h

28 #if 
__GNUC__
 >= 3

29 @
	gPRAGMA_SYSTEM_HEADER
@

31 @
	gPRAGMA_COLUMNS
@

33 #if 
defined
 
__need_wchar_t
 || defined 
__need_size_t
 \

34 || 
defined
 
	g__need_ptrdiff_t
 || defined 
	g__need_NULL
 \

35 || 
defined
 
	g__need_wint_t


43 #if !(
defined
 
_
@
GUARD_PREFIX
@
_STDDEF_H
 && defined 
_GL_STDDEF_WINT_T
)

44 #ifdef 
__need_wint_t


45 #undef 
_
@
GUARD_PREFIX
@
_STDDEF_H


46 #define 
	#_GL_STDDEF_WINT_T


	)

48 #@
INCLUDE_NEXT
@ @
NEXT_STDDEF_H
@

54 #ifndef 
_
@
GUARD_PREFIX
@
_STDDEF_H


58 #@
INCLUDE_NEXT
@ @
NEXT_STDDEF_H
@

60 #ifndef 
_
@
GUARD_PREFIX
@
_STDDEF_H


61 #define 
	#_
@
GUARD_PREFIX
@
_STDDEF_H


	)

64 #if @
REPLACE_NULL
@

65 #undef 
NULL


66 #ifdef 
__cplusplus


69 #if 
__GNUG__
 >= 3

73 #define 
	#NULL
 
__null


	)

75 #define 
	#NULL
 0L

	)

78 #define 
	#NULL
 ((void *) 0)

	)

83 #if !@
HAVE_WCHAR_T
@

84 #define 
	#wchar_t
 int

	)

	@lib/stdint.in.h

26 #ifndef 
_
@
GUARD_PREFIX
@
_STDINT_H


28 #if 
__GNUC__
 >= 3

29 @
	gPRAGMA_SYSTEM_HEADER
@

31 @
	gPRAGMA_COLUMNS
@

37 #define 
	#_GL_JUST_INCLUDE_SYSTEM_INTTYPES_H


	)

47 #if @
HAVE_STDINT_H
@

48 #if 
defined
 
__sgi
 && ! defined 
__c99


52 #define 
	#__STDINT_H__


	)

59 #@
INCLUDE_NEXT
@ @
NEXT_STDINT_H
@

62 #if ! 
defined
 
_
@
GUARD_PREFIX
@
_STDINT_H
 && ! defined 
_GL_JUST_INCLUDE_SYSTEM_STDINT_H


63 #define 
	#_
@
GUARD_PREFIX
@
_STDINT_H


	)

71 #if @
HAVE_SYS_TYPES_H
@ && ! 
defined
 
_AIX


72 #include 
	~<sys/types.h
>

76 #include 
	~<limits.h
>

78 #if @
HAVE_INTTYPES_H
@

82 #include 
	~<inttypes.h
>

83 #elif @
HAVE_SYS_INTTYPES_H
@

86 #include 
	~<sys/inttypes.h
>

89 #if @
HAVE_SYS_BITYPES_H
@ && ! 
defined
 
__BIT_TYPES_DEFINED__


93 #include 
	~<sys/bitypes.h
>

96 #undef 
_GL_JUST_INCLUDE_SYSTEM_INTTYPES_H


102 #define 
	#_STDINT_MIN
(signed, 
bits
, 
zero
) \

103 ((signed) ? (- ((
zero
) + 1) << ((
bits
) ? (bits) - 1 : 0)) : (zero))

	)

105 #define 
	#_STDINT_MAX
(signed, 
bits
, 
zero
) \

107 ? ~ 
	`_STDINT_MIN
 (signed, 
bits
, 
zero
) \

111 ((((
zero
) + 1) << ((
bits
) ? (bits) - 1 - (signed) : 0)) - 1) * 2 + 1)

	)

113 #if !
GNULIB_defined_stdint_types


120 #undef 
int8_t


121 #undef 
uint8_t


122 typedef signed char 
	tgl_int8_t
;

123 typedef unsigned char 
	tgl_uint8_t
;

124 #define 
	#int8_t
 
gl_int8_t


	)

125 #define 
	#uint8_t
 
gl_uint8_t


	)

127 #undef 
int16_t


128 #undef 
uint16_t


129 typedef short int 
	tgl_int16_t
;

130 typedef unsigned short int 
	tgl_uint16_t
;

131 #define 
	#int16_t
 
gl_int16_t


	)

132 #define 
	#uint16_t
 
gl_uint16_t


	)

134 #undef 
int32_t


135 #undef 
uint32_t


136 typedef int 
	tgl_int32_t
;

137 typedef unsigned int 
	tgl_uint32_t
;

138 #define 
	#int32_t
 
gl_int32_t


	)

139 #define 
	#uint32_t
 
gl_uint32_t


	)

147 #ifdef 
INT64_MAX


148 #define 
	#GL_INT64_T


	)

152 #if 
LONG_MAX
 >> 31 >> 31 == 1

153 #undef 
int64_t


154 typedef long int 
	tgl_int64_t
;

155 #define 
	#int64_t
 
gl_int64_t


	)

156 #define 
	#GL_INT64_T


	)

157 #elif 
defined
 
_MSC_VER


158 #undef 
int64_t


159 typedef 
__int64
 
	tgl_int64_t
;

160 #define 
	#int64_t
 
gl_int64_t


	)

161 #define 
	#GL_INT64_T


	)

162 #elif @
HAVE_LONG_LONG_INT
@

163 #undef 
int64_t


164 typedef long long int 
	tgl_int64_t
;

165 #define 
	#int64_t
 
gl_int64_t


	)

166 #define 
	#GL_INT64_T


	)

170 #ifdef 
UINT64_MAX


171 #define 
	#GL_UINT64_T


	)

173 #if 
ULONG_MAX
 >> 31 >> 31 >> 1 == 1

174 #undef 
uint64_t


175 typedef unsigned long int 
	tgl_uint64_t
;

176 #define 
	#uint64_t
 
gl_uint64_t


	)

177 #define 
	#GL_UINT64_T


	)

178 #elif 
defined
 
_MSC_VER


179 #undef 
uint64_t


180 typedef unsigned 
	t__int64
 
	tgl_uint64_t
;

181 #define 
	#uint64_t
 
gl_uint64_t


	)

182 #define 
	#GL_UINT64_T


	)

183 #elif @
HAVE_UNSIGNED_LONG_LONG_INT
@

184 #undef 
uint64_t


185 typedef unsigned long long int 
	tgl_uint64_t
;

186 #define 
	#uint64_t
 
gl_uint64_t


	)

187 #define 
	#GL_UINT64_T


	)

192 #define 
	#_UINT8_T


	)

193 #define 
	#_UINT32_T


	)

194 #define 
	#_UINT64_T


	)

203 #undef 
int_least8_t


204 #undef 
uint_least8_t


205 #undef 
int_least16_t


206 #undef 
uint_least16_t


207 #undef 
int_least32_t


208 #undef 
uint_least32_t


209 #undef 
int_least64_t


210 #undef 
uint_least64_t


211 #define 
	#int_least8_t
 
int8_t


	)

212 #define 
	#uint_least8_t
 
uint8_t


	)

213 #define 
	#int_least16_t
 
int16_t


	)

214 #define 
	#uint_least16_t
 
uint16_t


	)

215 #define 
	#int_least32_t
 
int32_t


	)

216 #define 
	#uint_least32_t
 
uint32_t


	)

217 #ifdef 
GL_INT64_T


218 #define 
	#int_least64_t
 
int64_t


	)

220 #ifdef 
GL_UINT64_T


221 #define 
	#uint_least64_t
 
uint64_t


	)

234 #undef 
int_fast8_t


235 #undef 
uint_fast8_t


236 #undef 
int_fast16_t


237 #undef 
uint_fast16_t


238 #undef 
int_fast32_t


239 #undef 
uint_fast32_t


240 #undef 
int_fast64_t


241 #undef 
uint_fast64_t


242 typedef long int 
	tgl_int_fast8_t
;

243 typedef unsigned long int 
	tgl_uint_fast8_t
;

244 typedef long int 
	tgl_int_fast16_t
;

245 typedef unsigned long int 
	tgl_uint_fast16_t
;

246 typedef long int 
	tgl_int_fast32_t
;

247 typedef unsigned long int 
	tgl_uint_fast32_t
;

248 #define 
	#int_fast8_t
 
gl_int_fast8_t


	)

249 #define 
	#uint_fast8_t
 
gl_uint_fast8_t


	)

250 #define 
	#int_fast16_t
 
gl_int_fast16_t


	)

251 #define 
	#uint_fast16_t
 
gl_uint_fast16_t


	)

252 #define 
	#int_fast32_t
 
gl_int_fast32_t


	)

253 #define 
	#uint_fast32_t
 
gl_uint_fast32_t


	)

254 #ifdef 
GL_INT64_T


255 #define 
	#int_fast64_t
 
int64_t


	)

257 #ifdef 
GL_UINT64_T


258 #define 
	#uint_fast64_t
 
uint64_t


	)

263 #undef 
intptr_t


264 #undef 
uintptr_t


265 typedef long int 
	tgl_intptr_t
;

266 typedef unsigned long int 
	tgl_uintptr_t
;

267 #define 
	#intptr_t
 
gl_intptr_t


	)

268 #define 
	#uintptr_t
 
gl_uintptr_t


	)

279 #ifndef 
INTMAX_MAX


280 #undef 
INTMAX_C


281 #undef 
intmax_t


282 #if @
HAVE_LONG_LONG_INT
@ && 
LONG_MAX
 >> 30 == 1

283 typedef long long int 
	tgl_intmax_t
;

284 #define 
	#intmax_t
 
gl_intmax_t


	)

285 #elif 
defined
 
GL_INT64_T


286 #define 
	#intmax_t
 
int64_t


	)

288 typedef long int 
	tgl_intmax_t
;

289 #define 
	#intmax_t
 
gl_intmax_t


	)

293 #ifndef 
UINTMAX_MAX


294 #undef 
UINTMAX_C


295 #undef 
uintmax_t


296 #if @
HAVE_UNSIGNED_LONG_LONG_INT
@ && 
ULONG_MAX
 >> 31 == 1

297 typedef unsigned long long int 
	tgl_uintmax_t
;

298 #define 
	#uintmax_t
 
gl_uintmax_t


	)

299 #elif 
defined
 
GL_UINT64_T


300 #define 
	#uintmax_t
 
uint64_t


	)

302 typedef unsigned long int 
	tgl_uintmax_t
;

303 #define 
	#uintmax_t
 
gl_uintmax_t


	)

310 typedef int 
	t_verify_intmax_size
[sizeof (
intmax_t
) == sizeof (
uintmax_t
)

313 #define 
	#GNULIB_defined_stdint_types
 1

	)

318 #if ! 
defined
 
__cplusplus
 || defined 
__STDC_LIMIT_MACROS


325 #undef 
INT8_MIN


326 #undef 
INT8_MAX


327 #undef 
UINT8_MAX


328 #define 
	#INT8_MIN
 (~ 
INT8_MAX
)

	)

329 #define 
	#INT8_MAX
 127

	)

330 #define 
	#UINT8_MAX
 255

	)

332 #undef 
INT16_MIN


333 #undef 
INT16_MAX


334 #undef 
UINT16_MAX


335 #define 
	#INT16_MIN
 (~ 
INT16_MAX
)

	)

336 #define 
	#INT16_MAX
 32767

	)

337 #define 
	#UINT16_MAX
 65535

	)

339 #undef 
INT32_MIN


340 #undef 
INT32_MAX


341 #undef 
UINT32_MAX


342 #define 
	#INT32_MIN
 (~ 
INT32_MAX
)

	)

343 #define 
	#INT32_MAX
 2147483647

	)

344 #define 
	#UINT32_MAX
 4294967295U

	)

346 #if 
defined
 
GL_INT64_T
 && ! defined 
INT64_MAX


349 #define 
	#INT64_MIN
 (- 
	`INTMAX_C
 (1) << 63)

	)

350 #define 
	#INT64_MAX
 
	`INTMAX_C
 (9223372036854775807)

	)

353 #if 
defined
 
GL_UINT64_T
 && ! defined 
UINT64_MAX


354 #define 
	#UINT64_MAX
 
	`UINTMAX_C
 (18446744073709551615)

	)

363 #undef 
INT_LEAST8_MIN


364 #undef 
INT_LEAST8_MAX


365 #undef 
UINT_LEAST8_MAX


366 #define 
	#INT_LEAST8_MIN
 
INT8_MIN


	)

367 #define 
	#INT_LEAST8_MAX
 
INT8_MAX


	)

368 #define 
	#UINT_LEAST8_MAX
 
UINT8_MAX


	)

370 #undef 
INT_LEAST16_MIN


371 #undef 
INT_LEAST16_MAX


372 #undef 
UINT_LEAST16_MAX


373 #define 
	#INT_LEAST16_MIN
 
INT16_MIN


	)

374 #define 
	#INT_LEAST16_MAX
 
INT16_MAX


	)

375 #define 
	#UINT_LEAST16_MAX
 
UINT16_MAX


	)

377 #undef 
INT_LEAST32_MIN


378 #undef 
INT_LEAST32_MAX


379 #undef 
UINT_LEAST32_MAX


380 #define 
	#INT_LEAST32_MIN
 
INT32_MIN


	)

381 #define 
	#INT_LEAST32_MAX
 
INT32_MAX


	)

382 #define 
	#UINT_LEAST32_MAX
 
UINT32_MAX


	)

384 #undef 
INT_LEAST64_MIN


385 #undef 
INT_LEAST64_MAX


386 #ifdef 
GL_INT64_T


387 #define 
	#INT_LEAST64_MIN
 
INT64_MIN


	)

388 #define 
	#INT_LEAST64_MAX
 
INT64_MAX


	)

391 #undef 
UINT_LEAST64_MAX


392 #ifdef 
GL_UINT64_T


393 #define 
	#UINT_LEAST64_MAX
 
UINT64_MAX


	)

402 #undef 
INT_FAST8_MIN


403 #undef 
INT_FAST8_MAX


404 #undef 
UINT_FAST8_MAX


405 #define 
	#INT_FAST8_MIN
 
LONG_MIN


	)

406 #define 
	#INT_FAST8_MAX
 
LONG_MAX


	)

407 #define 
	#UINT_FAST8_MAX
 
ULONG_MAX


	)

409 #undef 
INT_FAST16_MIN


410 #undef 
INT_FAST16_MAX


411 #undef 
UINT_FAST16_MAX


412 #define 
	#INT_FAST16_MIN
 
LONG_MIN


	)

413 #define 
	#INT_FAST16_MAX
 
LONG_MAX


	)

414 #define 
	#UINT_FAST16_MAX
 
ULONG_MAX


	)

416 #undef 
INT_FAST32_MIN


417 #undef 
INT_FAST32_MAX


418 #undef 
UINT_FAST32_MAX


419 #define 
	#INT_FAST32_MIN
 
LONG_MIN


	)

420 #define 
	#INT_FAST32_MAX
 
LONG_MAX


	)

421 #define 
	#UINT_FAST32_MAX
 
ULONG_MAX


	)

423 #undef 
INT_FAST64_MIN


424 #undef 
INT_FAST64_MAX


425 #ifdef 
GL_INT64_T


426 #define 
	#INT_FAST64_MIN
 
INT64_MIN


	)

427 #define 
	#INT_FAST64_MAX
 
INT64_MAX


	)

430 #undef 
UINT_FAST64_MAX


431 #ifdef 
GL_UINT64_T


432 #define 
	#UINT_FAST64_MAX
 
UINT64_MAX


	)

437 #undef 
INTPTR_MIN


438 #undef 
INTPTR_MAX


439 #undef 
UINTPTR_MAX


440 #define 
	#INTPTR_MIN
 
LONG_MIN


	)

441 #define 
	#INTPTR_MAX
 
LONG_MAX


	)

442 #define 
	#UINTPTR_MAX
 
ULONG_MAX


	)

446 #ifndef 
INTMAX_MAX


447 #undef 
INTMAX_MIN


448 #ifdef 
INT64_MAX


449 #define 
	#INTMAX_MIN
 
INT64_MIN


	)

450 #define 
	#INTMAX_MAX
 
INT64_MAX


	)

452 #define 
	#INTMAX_MIN
 
INT32_MIN


	)

453 #define 
	#INTMAX_MAX
 
INT32_MAX


	)

457 #ifndef 
UINTMAX_MAX


458 #ifdef 
UINT64_MAX


459 #define 
	#UINTMAX_MAX
 
UINT64_MAX


	)

461 #define 
	#UINTMAX_MAX
 
UINT32_MAX


	)

468 #undef 
PTRDIFF_MIN


469 #undef 
PTRDIFF_MAX


470 #if @
APPLE_UNIVERSAL_BUILD
@

471 #ifdef 
_LP64


472 #define 
	#PTRDIFF_MIN
 
	`_STDINT_MIN
 (1, 64, 0l)

	)

473 #define 
	#PTRDIFF_MAX
 
	`_STDINT_MAX
 (1, 64, 0l)

	)

475 #define 
	#PTRDIFF_MIN
 
	`_STDINT_MIN
 (1, 32, 0)

	)

476 #define 
	#PTRDIFF_MAX
 
	`_STDINT_MAX
 (1, 32, 0)

	)

479 #define 
	#PTRDIFF_MIN
 \

480 
	`_STDINT_MIN
 (1, @
BITSIZEOF_PTRDIFF_T
@, 0@
PTRDIFF_T_SUFFIX
@)

	)

481 #define 
	#PTRDIFF_MAX
 \

482 
	`_STDINT_MAX
 (1, @
BITSIZEOF_PTRDIFF_T
@, 0@
PTRDIFF_T_SUFFIX
@)

	)

486 #undef 
SIG_ATOMIC_MIN


487 #undef 
SIG_ATOMIC_MAX


488 #define 
	#SIG_ATOMIC_MIN
 \

489 
	`_STDINT_MIN
 (@
HAVE_SIGNED_SIG_ATOMIC_T
@, @
BITSIZEOF_SIG_ATOMIC_T
@, \

490 0@
SIG_ATOMIC_T_SUFFIX
@)

	)

491 #define 
	#SIG_ATOMIC_MAX
 \

492 
	`_STDINT_MAX
 (@
HAVE_SIGNED_SIG_ATOMIC_T
@, @
BITSIZEOF_SIG_ATOMIC_T
@, \

493 0@
SIG_ATOMIC_T_SUFFIX
@)

	)

497 #undef 
SIZE_MAX


498 #if @
APPLE_UNIVERSAL_BUILD
@

499 #ifdef 
_LP64


500 #define 
	#SIZE_MAX
 
	`_STDINT_MAX
 (0, 64, 0ul)

	)

502 #define 
	#SIZE_MAX
 
	`_STDINT_MAX
 (0, 32, 0ul)

	)

505 #define 
	#SIZE_MAX
 
	`_STDINT_MAX
 (0, @
BITSIZEOF_SIZE_T
@, 0@
SIZE_T_SUFFIX
@)

	)

514 #if @
HAVE_WCHAR_H
@ && ! (
defined
 
WCHAR_MIN
 && defined 
WCHAR_MAX
)

517 #include 
	~<stddef.h
>

518 #include 
	~<stdio.h
>

519 #include 
	~<time.h
>

520 #define 
	#_GL_JUST_INCLUDE_SYSTEM_WCHAR_H


	)

521 #include 
	~<wchar.h
>

522 #undef 
_GL_JUST_INCLUDE_SYSTEM_WCHAR_H


524 #undef 
WCHAR_MIN


525 #undef 
WCHAR_MAX


526 #define 
	#WCHAR_MIN
 \

527 
	`_STDINT_MIN
 (@
HAVE_SIGNED_WCHAR_T
@, @
BITSIZEOF_WCHAR_T
@, 0@
WCHAR_T_SUFFIX
@)

	)

528 #define 
	#WCHAR_MAX
 \

529 
	`_STDINT_MAX
 (@
HAVE_SIGNED_WCHAR_T
@, @
BITSIZEOF_WCHAR_T
@, 0@
WCHAR_T_SUFFIX
@)

	)

532 #undef 
WINT_MIN


533 #undef 
WINT_MAX


534 #define 
	#WINT_MIN
 \

535 
	`_STDINT_MIN
 (@
HAVE_SIGNED_WINT_T
@, @
BITSIZEOF_WINT_T
@, 0@
WINT_T_SUFFIX
@)

	)

536 #define 
	#WINT_MAX
 \

537 
	`_STDINT_MAX
 (@
HAVE_SIGNED_WINT_T
@, @
BITSIZEOF_WINT_T
@, 0@
WINT_T_SUFFIX
@)

	)

543 #if ! 
defined
 
__cplusplus
 || defined 
__STDC_CONSTANT_MACROS


551 #undef 
INT8_C


552 #undef 
UINT8_C


553 #define 
	#INT8_C
(
x
) 
	)
x

554 #define 
	#UINT8_C
(
x
) 
	)
x

556 #undef 
INT16_C


557 #undef 
UINT16_C


558 #define 
	#INT16_C
(
x
) 
	)
x

559 #define 
	#UINT16_C
(
x
) 
	)
x

561 #undef 
INT32_C


562 #undef 
UINT32_C


563 #define 
	#INT32_C
(
x
) 
	)
x

564 #define 
	#UINT32_C
(
x
) x ## 
U


	)

566 #undef 
INT64_C


567 #undef 
UINT64_C


568 #if 
LONG_MAX
 >> 31 >> 31 == 1

569 #define 
	#INT64_C
(
x
) x##
L


	)

570 #elif 
defined
 
_MSC_VER


571 #define 
	#INT64_C
(
x
) x##
i64


	)

572 #elif @
HAVE_LONG_LONG_INT
@

573 #define 
	#INT64_C
(
x
) x##
LL


	)

575 #if 
ULONG_MAX
 >> 31 >> 31 >> 1 == 1

576 #define 
	#UINT64_C
(
x
) x##
UL


	)

577 #elif 
defined
 
_MSC_VER


578 #define 
	#UINT64_C
(
x
) x##
ui64


	)

579 #elif @
HAVE_UNSIGNED_LONG_LONG_INT
@

580 #define 
	#UINT64_C
(
x
) x##
ULL


	)

585 #ifndef 
INTMAX_C


586 #if @
HAVE_LONG_LONG_INT
@ && 
LONG_MAX
 >> 30 == 1

587 #define 
	#INTMAX_C
(
x
) x##
LL


	)

588 #elif 
defined
 
GL_INT64_T


589 #define 
	#INTMAX_C
(
x
) 
	`INT64_C
(x)

	)

591 #define 
	#INTMAX_C
(
x
) x##
L


	)

595 #ifndef 
UINTMAX_C


596 #if @
HAVE_UNSIGNED_LONG_LONG_INT
@ && 
ULONG_MAX
 >> 31 == 1

597 #define 
	#UINTMAX_C
(
x
) x##
ULL


	)

598 #elif 
defined
 
GL_UINT64_T


599 #define 
	#UINTMAX_C
(
x
) 
	`UINT64_C
(x)

	)

601 #define 
	#UINTMAX_C
(
x
) x##
UL


	)

	@lib/stdlib.in.h

18 #if 
__GNUC__
 >= 3

19 @
	gPRAGMA_SYSTEM_HEADER
@

21 @
	gPRAGMA_COLUMNS
@

23 #if 
defined
 
__need_malloc_and_calloc


26 #@
INCLUDE_NEXT
@ @
NEXT_STDLIB_H
@

31 #ifndef 
_
@
GUARD_PREFIX
@
_STDLIB_H


34 #@
INCLUDE_NEXT
@ @
NEXT_STDLIB_H
@

36 #ifndef 
_
@
GUARD_PREFIX
@
_STDLIB_H


37 #define 
	#_
@
GUARD_PREFIX
@
_STDLIB_H


	)

40 #include 
	~<stddef.h
>

43 #if @
GNULIB_SYSTEM_POSIX
@ && !
defined
 
WEXITSTATUS


44 #include 
	~<sys/wait.h
>

48 #if (@
GNULIB_GETLOADAVG
@ || 
defined
 
GNULIB_POSIXCHECK
) && @
HAVE_SYS_LOADAVG_H
@

49 #include 
	~<sys/loadavg.h
>

52 #if @
GNULIB_RANDOM_R
@

57 #if @
HAVE_RANDOM_H
@

58 #include 
	~<random.h
>

61 #if !@
HAVE_STRUCT_RANDOM_DATA
@ || !@
HAVE_RANDOM_R
@

62 #include 
	~<stdint.h
>

65 #if !@
HAVE_STRUCT_RANDOM_DATA
@

68 #if !
GNULIB_defined_struct_random_data


69 struct 
	srandom_data


71 
int32_t
 *
	mfptr
;

72 
int32_t
 *
	mrptr
;

73 
int32_t
 *
	mstate
;

74 int 
	mrand_type
;

75 int 
	mrand_deg
;

76 int 
	mrand_sep
;

77 
int32_t
 *
	mend_ptr
;

79 #define 
	#GNULIB_defined_struct_random_data
 1

	)

84 #if (@
GNULIB_MKSTEMP
@ || @
GNULIB_MKSTEMPS
@ || @
GNULIB_GETSUBOPT
@ || 
defined
 
GNULIB_POSIXCHECK
) && ! defined 
__GLIBC__
 && !((defined 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__
)

89 #include 
	~<unistd.h
>

102 #ifndef 
EXIT_SUCCESS


103 #define 
	#EXIT_SUCCESS
 0

	)

107 #ifndef 
EXIT_FAILURE


108 #define 
	#EXIT_FAILURE
 1

	)

109 #elif 
EXIT_FAILURE
 != 1

110 #undef 
EXIT_FAILURE


111 #define 
	#EXIT_FAILURE
 1

	)

115 #if @
GNULIB__EXIT
@

118 #if !@
HAVE__EXIT
@

119 
_GL_FUNCDECL_SYS
 (
_Exit
, 
_Noreturn
 void, (int 
status
));

121 
_GL_CXXALIAS_SYS
 (
_Exit
, void, (int 
status
));

122 
_GL_CXXALIASWARN
 (
_Exit
);

123 #elif 
defined
 
GNULIB_POSIXCHECK


124 #undef 
_Exit


125 #if 
HAVE_RAW_DECL__EXIT


126 
_GL_WARN_ON_USE
 (
_Exit
, "_Exit is unportable - "

132 #if @
GNULIB_ATOLL
@

135 #if !@
HAVE_ATOLL
@

136 
_GL_FUNCDECL_SYS
 (
atoll
, long long, (const char *
string
) 
_GL_ARG_NONNULL
 ((1)));

138 
_GL_CXXALIAS_SYS
 (
atoll
, long long, (const char *
string
));

139 
_GL_CXXALIASWARN
 (
atoll
);

140 #elif 
defined
 
GNULIB_POSIXCHECK


141 #undef 
atoll


142 #if 
HAVE_RAW_DECL_ATOLL


143 
_GL_WARN_ON_USE
 (
atoll
, "atoll is unportable - "

148 #if @
GNULIB_CALLOC_POSIX
@

149 #if @
REPLACE_CALLOC
@

150 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

151 #undef 
calloc


152 #define 
	#calloc
 
rpl_calloc


	)

154 
_GL_FUNCDECL_RPL
 (
calloc
, void *, (
size_t
 
nmemb
, size_t 
size
));

155 
_GL_CXXALIAS_RPL
 (
calloc
, void *, (
size_t
 
nmemb
, size_t 
size
));

157 
_GL_CXXALIAS_SYS
 (
calloc
, void *, (
size_t
 
nmemb
, size_t 
size
));

159 
_GL_CXXALIASWARN
 (
calloc
);

160 #elif 
defined
 
GNULIB_POSIXCHECK


161 #undef 
calloc


163 
_GL_WARN_ON_USE
 (
calloc
, "calloc is not POSIX compliant everywhere - "

167 #if @
GNULIB_CANONICALIZE_FILE_NAME
@

168 #if @
REPLACE_CANONICALIZE_FILE_NAME
@

169 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

170 #define 
	#canonicalize_file_name
 
rpl_canonicalize_file_name


	)

172 
_GL_FUNCDECL_RPL
 (
canonicalize_file_name
, char *, (const char *
name
)

173 
_GL_ARG_NONNULL
 ((1)));

174 
_GL_CXXALIAS_RPL
 (
canonicalize_file_name
, char *, (const char *
name
));

176 #if !@
HAVE_CANONICALIZE_FILE_NAME
@

177 
_GL_FUNCDECL_SYS
 (
canonicalize_file_name
, char *, (const char *
name
)

178 
_GL_ARG_NONNULL
 ((1)));

180 
_GL_CXXALIAS_SYS
 (
canonicalize_file_name
, char *, (const char *
name
));

182 
_GL_CXXALIASWARN
 (
canonicalize_file_name
);

183 #elif 
defined
 
GNULIB_POSIXCHECK


184 #undef 
canonicalize_file_name


185 #if 
HAVE_RAW_DECL_CANONICALIZE_FILE_NAME


186 
_GL_WARN_ON_USE
 (
canonicalize_file_name
,

192 #if @
GNULIB_GETLOADAVG
@

197 #if !@
HAVE_DECL_GETLOADAVG
@

198 
_GL_FUNCDECL_SYS
 (
getloadavg
, int, (double 
loadavg
[], int 
nelem
)

199 
_GL_ARG_NONNULL
 ((1)));

201 
_GL_CXXALIAS_SYS
 (
getloadavg
, int, (double 
loadavg
[], int 
nelem
));

202 
_GL_CXXALIASWARN
 (
getloadavg
);

203 #elif 
defined
 
GNULIB_POSIXCHECK


204 #undef 
getloadavg


205 #if 
HAVE_RAW_DECL_GETLOADAVG


206 
_GL_WARN_ON_USE
 (
getloadavg
, "getloadavg is not portable - "

211 #if @
GNULIB_GETSUBOPT
@

223 #if !@
HAVE_GETSUBOPT
@

224 
_GL_FUNCDECL_SYS
 (
getsubopt
, int,

225 (char **
optionp
, char *const *
tokens
, char **
valuep
)

226 
_GL_ARG_NONNULL
 ((1, 2, 3)));

228 
_GL_CXXALIAS_SYS
 (
getsubopt
, int,

229 (char **
optionp
, char *const *
tokens
, char **
valuep
));

230 
_GL_CXXALIASWARN
 (
getsubopt
);

231 #elif 
defined
 
GNULIB_POSIXCHECK


232 #undef 
getsubopt


233 #if 
HAVE_RAW_DECL_GETSUBOPT


234 
_GL_WARN_ON_USE
 (
getsubopt
, "getsubopt is unportable - "

239 #if @
GNULIB_GRANTPT
@

242 #if !@
HAVE_GRANTPT
@

243 
_GL_FUNCDECL_SYS
 (
grantpt
, int, (int 
fd
));

245 
_GL_CXXALIAS_SYS
 (
grantpt
, int, (int 
fd
));

246 
_GL_CXXALIASWARN
 (
grantpt
);

247 #elif 
defined
 
GNULIB_POSIXCHECK


248 #undef 
grantpt


249 #if 
HAVE_RAW_DECL_GRANTPT


250 
_GL_WARN_ON_USE
 (
grantpt
, "grantpt is not portable - "

259 #if @
GNULIB_MALLOC_POSIX
@

260 #if @
REPLACE_MALLOC
@

261 #if !((
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
) \

262 || 
	g_GL_USE_STDLIB_ALLOC
)

263 #undef 
malloc


264 #define 
	#malloc
 
rpl_malloc


	)

266 
_GL_FUNCDECL_RPL
 (
malloc
, void *, (
size_t
 
size
));

267 
_GL_CXXALIAS_RPL
 (
malloc
, void *, (
size_t
 
size
));

269 
_GL_CXXALIAS_SYS
 (
malloc
, void *, (
size_t
 
size
));

271 
_GL_CXXALIASWARN
 (
malloc
);

272 #elif 
defined
 
GNULIB_POSIXCHECK
 && !
_GL_USE_STDLIB_ALLOC


273 #undef 
malloc


275 
_GL_WARN_ON_USE
 (
malloc
, "malloc is not POSIX compliant everywhere - "

280 #if @
GNULIB_MBTOWC
@

281 #if @
REPLACE_MBTOWC
@

282 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

283 #undef 
mbtowc


284 #define 
	#mbtowc
 
rpl_mbtowc


	)

286 
_GL_FUNCDECL_RPL
 (
mbtowc
, int, (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
));

287 
_GL_CXXALIAS_RPL
 (
mbtowc
, int, (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
));

289 
_GL_CXXALIAS_SYS
 (
mbtowc
, int, (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
));

291 
_GL_CXXALIASWARN
 (
mbtowc
);

294 #if @
GNULIB_MKDTEMP
@

300 #if !@
HAVE_MKDTEMP
@

301 
_GL_FUNCDECL_SYS
 (
mkdtemp
, char *, (char * ) 
_GL_ARG_NONNULL
 ((1)));

303 
_GL_CXXALIAS_SYS
 (
mkdtemp
, char *, (char * ));

304 
_GL_CXXALIASWARN
 (
mkdtemp
);

305 #elif 
defined
 
GNULIB_POSIXCHECK


306 #undef 
mkdtemp


307 #if 
HAVE_RAW_DECL_MKDTEMP


308 
_GL_WARN_ON_USE
 (
mkdtemp
, "mkdtemp is unportable - "

313 #if @
GNULIB_MKOSTEMP
@

326 #if !@
HAVE_MKOSTEMP
@

327 
_GL_FUNCDECL_SYS
 (
mkostemp
, int, (char * , int )

328 
_GL_ARG_NONNULL
 ((1)));

330 
_GL_CXXALIAS_SYS
 (
mkostemp
, int, (char * , int ));

331 
_GL_CXXALIASWARN
 (
mkostemp
);

332 #elif 
defined
 
GNULIB_POSIXCHECK


333 #undef 
mkostemp


334 #if 
HAVE_RAW_DECL_MKOSTEMP


335 
_GL_WARN_ON_USE
 (
mkostemp
, "mkostemp is unportable - "

340 #if @
GNULIB_MKOSTEMPS
@

354 #if !@
HAVE_MKOSTEMPS
@

355 
_GL_FUNCDECL_SYS
 (
mkostemps
, int,

357 
_GL_ARG_NONNULL
 ((1)));

359 
_GL_CXXALIAS_SYS
 (
mkostemps
, int,

361 
_GL_CXXALIASWARN
 (
mkostemps
);

362 #elif 
defined
 
GNULIB_POSIXCHECK


363 #undef 
mkostemps


364 #if 
HAVE_RAW_DECL_MKOSTEMPS


365 
_GL_WARN_ON_USE
 (
mkostemps
, "mkostemps is unportable - "

370 #if @
GNULIB_MKSTEMP
@

380 #if @
REPLACE_MKSTEMP
@

381 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

382 #define 
	#mkstemp
 
rpl_mkstemp


	)

384 
_GL_FUNCDECL_RPL
 (
mkstemp
, int, (char * ) 
_GL_ARG_NONNULL
 ((1)));

385 
_GL_CXXALIAS_RPL
 (
mkstemp
, int, (char * ));

387 #if ! @
HAVE_MKSTEMP
@

388 
_GL_FUNCDECL_SYS
 (
mkstemp
, int, (char * ) 
_GL_ARG_NONNULL
 ((1)));

390 
_GL_CXXALIAS_SYS
 (
mkstemp
, int, (char * ));

392 
_GL_CXXALIASWARN
 (
mkstemp
);

393 #elif 
defined
 
GNULIB_POSIXCHECK


394 #undef 
mkstemp


395 #if 
HAVE_RAW_DECL_MKSTEMP


396 
_GL_WARN_ON_USE
 (
mkstemp
, "mkstemp is unportable - "

401 #if @
GNULIB_MKSTEMPS
@

412 #if !@
HAVE_MKSTEMPS
@

413 
_GL_FUNCDECL_SYS
 (
mkstemps
, int, (char * , int )

414 
_GL_ARG_NONNULL
 ((1)));

416 
_GL_CXXALIAS_SYS
 (
mkstemps
, int, (char * , int ));

417 
_GL_CXXALIASWARN
 (
mkstemps
);

418 #elif 
defined
 
GNULIB_POSIXCHECK


419 #undef 
mkstemps


420 #if 
HAVE_RAW_DECL_MKSTEMPS


421 
_GL_WARN_ON_USE
 (
mkstemps
, "mkstemps is unportable - "

426 #if @
GNULIB_POSIX_OPENPT
@

429 #if !@
HAVE_POSIX_OPENPT
@

430 
_GL_FUNCDECL_SYS
 (
posix_openpt
, int, (int 
flags
));

432 
_GL_CXXALIAS_SYS
 (
posix_openpt
, int, (int 
flags
));

433 
_GL_CXXALIASWARN
 (
posix_openpt
);

434 #elif 
defined
 
GNULIB_POSIXCHECK


435 #undef 
posix_openpt


436 #if 
HAVE_RAW_DECL_POSIX_OPENPT


437 
_GL_WARN_ON_USE
 (
posix_openpt
, "posix_openpt is not portable - "

442 #if @
GNULIB_PTSNAME
@

445 #if !@
HAVE_PTSNAME
@

446 
_GL_FUNCDECL_SYS
 (
ptsname
, char *, (int 
fd
));

448 
_GL_CXXALIAS_SYS
 (
ptsname
, char *, (int 
fd
));

449 
_GL_CXXALIASWARN
 (
ptsname
);

450 #elif 
defined
 
GNULIB_POSIXCHECK


451 #undef 
ptsname


452 #if 
HAVE_RAW_DECL_PTSNAME


453 
_GL_WARN_ON_USE
 (
ptsname
, "ptsname is not portable - "

458 #if @
GNULIB_PTSNAME_R
@

462 #if @
REPLACE_PTSNAME_R
@

463 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

464 #undef 
ptsname_r


465 #define 
	#ptsname_r
 
rpl_ptsname_r


	)

467 
_GL_FUNCDECL_RPL
 (
ptsname_r
, int, (int 
fd
, char *
buf
, 
size_t
 
len
));

468 
_GL_CXXALIAS_RPL
 (
ptsname_r
, int, (int 
fd
, char *
buf
, 
size_t
 
len
));

470 #if !@
HAVE_PTSNAME_R
@

471 
_GL_FUNCDECL_SYS
 (
ptsname_r
, int, (int 
fd
, char *
buf
, 
size_t
 
len
));

473 
_GL_CXXALIAS_SYS
 (
ptsname_r
, int, (int 
fd
, char *
buf
, 
size_t
 
len
));

475 
_GL_CXXALIASWARN
 (
ptsname_r
);

476 #elif 
defined
 
GNULIB_POSIXCHECK


477 #undef 
ptsname_r


478 #if 
HAVE_RAW_DECL_PTSNAME_R


479 
_GL_WARN_ON_USE
 (
ptsname_r
, "ptsname_r is not portable - "

484 #if @
GNULIB_PUTENV
@

485 #if @
REPLACE_PUTENV
@

486 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

487 #undef 
putenv


488 #define 
	#putenv
 
rpl_putenv


	)

490 
_GL_FUNCDECL_RPL
 (
putenv
, int, (char *
string
) 
_GL_ARG_NONNULL
 ((1)));

491 
_GL_CXXALIAS_RPL
 (
putenv
, int, (char *
string
));

493 
_GL_CXXALIAS_SYS
 (
putenv
, int, (char *
string
));

495 
_GL_CXXALIASWARN
 (
putenv
);

499 #if @
GNULIB_RANDOM_R
@

500 #if !@
HAVE_RANDOM_R
@

501 #ifndef 
RAND_MAX


502 #define 
	#RAND_MAX
 2147483647

	)

507 #if @
GNULIB_RANDOM_R
@

508 #if !@
HAVE_RANDOM_R
@

509 
_GL_FUNCDECL_SYS
 (
random_r
, int, (struct 
random_data
 *
buf
, 
int32_t
 *
result
)

510 
_GL_ARG_NONNULL
 ((1, 2)));

512 
_GL_CXXALIAS_SYS
 (
random_r
, int, (struct 
random_data
 *
buf
, 
int32_t
 *
result
));

513 
_GL_CXXALIASWARN
 (
random_r
);

514 #elif 
defined
 
GNULIB_POSIXCHECK


515 #undef 
random_r


516 #if 
HAVE_RAW_DECL_RANDOM_R


517 
_GL_WARN_ON_USE
 (
random_r
, "random_r is unportable - "

522 #if @
GNULIB_RANDOM_R
@

523 #if !@
HAVE_RANDOM_R
@

524 
_GL_FUNCDECL_SYS
 (
srandom_r
, int,

525 (unsigned int 
seed
, struct 
random_data
 *
rand_state
)

526 
_GL_ARG_NONNULL
 ((2)));

528 
_GL_CXXALIAS_SYS
 (
srandom_r
, int,

529 (unsigned int 
seed
, struct 
random_data
 *
rand_state
));

530 
_GL_CXXALIASWARN
 (
srandom_r
);

531 #elif 
defined
 
GNULIB_POSIXCHECK


532 #undef 
srandom_r


533 #if 
HAVE_RAW_DECL_SRANDOM_R


534 
_GL_WARN_ON_USE
 (
srandom_r
, "srandom_r is unportable - "

539 #if @
GNULIB_RANDOM_R
@

540 #if !@
HAVE_RANDOM_R
@

541 
_GL_FUNCDECL_SYS
 (
initstate_r
, int,

542 (unsigned int 
seed
, char *
buf
, 
size_t
 
buf_size
,

543 struct 
random_data
 *
rand_state
)

544 
_GL_ARG_NONNULL
 ((2, 4)));

546 
_GL_CXXALIAS_SYS
 (
initstate_r
, int,

547 (unsigned int 
seed
, char *
buf
, 
size_t
 
buf_size
,

548 struct 
random_data
 *
rand_state
));

549 
_GL_CXXALIASWARN
 (
initstate_r
);

550 #elif 
defined
 
GNULIB_POSIXCHECK


551 #undef 
initstate_r


552 #if 
HAVE_RAW_DECL_INITSTATE_R


553 
_GL_WARN_ON_USE
 (
initstate_r
, "initstate_r is unportable - "

558 #if @
GNULIB_RANDOM_R
@

559 #if !@
HAVE_RANDOM_R
@

560 
_GL_FUNCDECL_SYS
 (
setstate_r
, int,

561 (char *
arg_state
, struct 
random_data
 *
rand_state
)

562 
_GL_ARG_NONNULL
 ((1, 2)));

564 
_GL_CXXALIAS_SYS
 (
setstate_r
, int,

565 (char *
arg_state
, struct 
random_data
 *
rand_state
));

566 
_GL_CXXALIASWARN
 (
setstate_r
);

567 #elif 
defined
 
GNULIB_POSIXCHECK


568 #undef 
setstate_r


569 #if 
HAVE_RAW_DECL_SETSTATE_R


570 
_GL_WARN_ON_USE
 (
setstate_r
, "setstate_r is unportable - "

576 #if @
GNULIB_REALLOC_POSIX
@

577 #if @
REPLACE_REALLOC
@

578 #if !((
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
) \

579 || 
	g_GL_USE_STDLIB_ALLOC
)

580 #undef 
realloc


581 #define 
	#realloc
 
rpl_realloc


	)

583 
_GL_FUNCDECL_RPL
 (
realloc
, void *, (void *
ptr
, 
size_t
 
size
));

584 
_GL_CXXALIAS_RPL
 (
realloc
, void *, (void *
ptr
, 
size_t
 
size
));

586 
_GL_CXXALIAS_SYS
 (
realloc
, void *, (void *
ptr
, 
size_t
 
size
));

588 
_GL_CXXALIASWARN
 (
realloc
);

589 #elif 
defined
 
GNULIB_POSIXCHECK
 && !
_GL_USE_STDLIB_ALLOC


590 #undef 
realloc


592 
_GL_WARN_ON_USE
 (
realloc
, "realloc is not POSIX compliant everywhere - "

596 #if @
GNULIB_REALPATH
@

597 #if @
REPLACE_REALPATH
@

598 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

599 #define 
	#realpath
 
rpl_realpath


	)

601 
_GL_FUNCDECL_RPL
 (
realpath
, char *, (const char *
name
, char *
resolved
)

602 
_GL_ARG_NONNULL
 ((1)));

603 
_GL_CXXALIAS_RPL
 (
realpath
, char *, (const char *
name
, char *
resolved
));

605 #if !@
HAVE_REALPATH
@

606 
_GL_FUNCDECL_SYS
 (
realpath
, char *, (const char *
name
, char *
resolved
)

607 
_GL_ARG_NONNULL
 ((1)));

609 
_GL_CXXALIAS_SYS
 (
realpath
, char *, (const char *
name
, char *
resolved
));

611 
_GL_CXXALIASWARN
 (
realpath
);

612 #elif 
defined
 
GNULIB_POSIXCHECK


613 #undef 
realpath


614 #if 
HAVE_RAW_DECL_REALPATH


615 
_GL_WARN_ON_USE
 (
realpath
, "realpath is unportable - use gnulib module "

620 #if @
GNULIB_RPMATCH
@

623 #if !@
HAVE_RPMATCH
@

624 
_GL_FUNCDECL_SYS
 (
rpmatch
, int, (const char *
response
) 
_GL_ARG_NONNULL
 ((1)));

626 
_GL_CXXALIAS_SYS
 (
rpmatch
, int, (const char *
response
));

627 
_GL_CXXALIASWARN
 (
rpmatch
);

628 #elif 
defined
 
GNULIB_POSIXCHECK


629 #undef 
rpmatch


630 #if 
HAVE_RAW_DECL_RPMATCH


631 
_GL_WARN_ON_USE
 (
rpmatch
, "rpmatch is unportable - "

636 #if @
GNULIB_SETENV
@

639 #if @
REPLACE_SETENV
@

640 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

641 #undef 
setenv


642 #define 
	#setenv
 
rpl_setenv


	)

644 
_GL_FUNCDECL_RPL
 (
setenv
, int,

645 (const char *
name
, const char *
value
, int 
replace
)

646 
_GL_ARG_NONNULL
 ((1)));

647 
_GL_CXXALIAS_RPL
 (
setenv
, int,

648 (const char *
name
, const char *
value
, int 
replace
));

650 #if !@
HAVE_DECL_SETENV
@

651 
_GL_FUNCDECL_SYS
 (
setenv
, int,

652 (const char *
name
, const char *
value
, int 
replace
)

653 
_GL_ARG_NONNULL
 ((1)));

655 
_GL_CXXALIAS_SYS
 (
setenv
, int,

656 (const char *
name
, const char *
value
, int 
replace
));

658 #if !(@
REPLACE_SETENV
@ && !@
HAVE_DECL_SETENV
@)

659 
_GL_CXXALIASWARN
 (
setenv
);

661 #elif 
defined
 
GNULIB_POSIXCHECK


662 #undef 
setenv


663 #if 
HAVE_RAW_DECL_SETENV


664 
_GL_WARN_ON_USE
 (
setenv
, "setenv is unportable - "

669 #if @
GNULIB_STRTOD
@

671 #if @
REPLACE_STRTOD
@

672 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

673 #define 
	#strtod
 
rpl_strtod


	)

675 
_GL_FUNCDECL_RPL
 (
strtod
, double, (const char *
str
, char **
endp
)

676 
_GL_ARG_NONNULL
 ((1)));

677 
_GL_CXXALIAS_RPL
 (
strtod
, double, (const char *
str
, char **
endp
));

679 #if !@
HAVE_STRTOD
@

680 
_GL_FUNCDECL_SYS
 (
strtod
, double, (const char *
str
, char **
endp
)

681 
_GL_ARG_NONNULL
 ((1)));

683 
_GL_CXXALIAS_SYS
 (
strtod
, double, (const char *
str
, char **
endp
));

685 
_GL_CXXALIASWARN
 (
strtod
);

686 #elif 
defined
 
GNULIB_POSIXCHECK


687 #undef 
strtod


688 #if 
HAVE_RAW_DECL_STRTOD


689 
_GL_WARN_ON_USE
 (
strtod
, "strtod is unportable - "

694 #if @
GNULIB_STRTOLL
@

703 #if !@
HAVE_STRTOLL
@

704 
_GL_FUNCDECL_SYS
 (
strtoll
, long long,

705 (const char *
string
, char **
endptr
, int 
base
)

706 
_GL_ARG_NONNULL
 ((1)));

708 
_GL_CXXALIAS_SYS
 (
strtoll
, long long,

709 (const char *
string
, char **
endptr
, int 
base
));

710 
_GL_CXXALIASWARN
 (
strtoll
);

711 #elif 
defined
 
GNULIB_POSIXCHECK


712 #undef 
strtoll


713 #if 
HAVE_RAW_DECL_STRTOLL


714 
_GL_WARN_ON_USE
 (
strtoll
, "strtoll is unportable - "

719 #if @
GNULIB_STRTOULL
@

728 #if !@
HAVE_STRTOULL
@

729 
_GL_FUNCDECL_SYS
 (
strtoull
, unsigned long long,

730 (const char *
string
, char **
endptr
, int 
base
)

731 
_GL_ARG_NONNULL
 ((1)));

733 
_GL_CXXALIAS_SYS
 (
strtoull
, unsigned long long,

734 (const char *
string
, char **
endptr
, int 
base
));

735 
_GL_CXXALIASWARN
 (
strtoull
);

736 #elif 
defined
 
GNULIB_POSIXCHECK


737 #undef 
strtoull


738 #if 
HAVE_RAW_DECL_STRTOULL


739 
_GL_WARN_ON_USE
 (
strtoull
, "strtoull is unportable - "

744 #if @
GNULIB_UNLOCKPT
@

747 #if !@
HAVE_UNLOCKPT
@

748 
_GL_FUNCDECL_SYS
 (
unlockpt
, int, (int 
fd
));

750 
_GL_CXXALIAS_SYS
 (
unlockpt
, int, (int 
fd
));

751 
_GL_CXXALIASWARN
 (
unlockpt
);

752 #elif 
defined
 
GNULIB_POSIXCHECK


753 #undef 
unlockpt


754 #if 
HAVE_RAW_DECL_UNLOCKPT


755 
_GL_WARN_ON_USE
 (
unlockpt
, "unlockpt is not portable - "

760 #if @
GNULIB_UNSETENV
@

762 #if @
REPLACE_UNSETENV
@

763 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

764 #undef 
unsetenv


765 #define 
	#unsetenv
 
rpl_unsetenv


	)

767 
_GL_FUNCDECL_RPL
 (
unsetenv
, int, (const char *
name
) 
_GL_ARG_NONNULL
 ((1)));

768 
_GL_CXXALIAS_RPL
 (
unsetenv
, int, (const char *
name
));

770 #if !@
HAVE_DECL_UNSETENV
@

771 
_GL_FUNCDECL_SYS
 (
unsetenv
, int, (const char *
name
) 
_GL_ARG_NONNULL
 ((1)));

773 
_GL_CXXALIAS_SYS
 (
unsetenv
, int, (const char *
name
));

775 #if !(@
REPLACE_UNSETENV
@ && !@
HAVE_DECL_UNSETENV
@)

776 
_GL_CXXALIASWARN
 (
unsetenv
);

778 #elif 
defined
 
GNULIB_POSIXCHECK


779 #undef 
unsetenv


780 #if 
HAVE_RAW_DECL_UNSETENV


781 
_GL_WARN_ON_USE
 (
unsetenv
, "unsetenv is unportable - "

787 #if @
GNULIB_WCTOMB
@

788 #if @
REPLACE_WCTOMB
@

789 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

790 #undef 
wctomb


791 #define 
	#wctomb
 
rpl_wctomb


	)

793 
_GL_FUNCDECL_RPL
 (
wctomb
, int, (char *
s
, 
wchar_t
 
wc
));

794 
_GL_CXXALIAS_RPL
 (
wctomb
, int, (char *
s
, 
wchar_t
 
wc
));

796 
_GL_CXXALIAS_SYS
 (
wctomb
, int, (char *
s
, 
wchar_t
 
wc
));

798 
_GL_CXXALIASWARN
 (
wctomb
);

	@lib/stpcpy.c

21 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #undef 
__stpcpy


26 #ifdef 
_LIBC


27 #undef 
stpcpy


30 #ifndef 
weak_alias


31 #define 
	#__stpcpy
 
stpcpy


	)

36 
	$__stpcpy
 (char *
dest
, const char *
src
)

38 register char *
d
 = 
dest
;

39 register const char *
s
 = 
src
;

42 *
d
++ = *
s
;

43 while (*
s
++ != '\0');

45 return 
d
 - 1;

46 
	}
}

47 #ifdef 
weak_alias


48 
	$weak_alias
 (
__stpcpy
, 
stpcpy
)

	@lib/str-kmp.h

37 static 
bool


38 
	$knuth_morris_pratt
 (const 
UNIT
 *
haystack
,

39 const 
UNIT
 *
needle
, 
size_t
 
needle_len
,

40 const 
UNIT
 **
resultp
)

42 
size_t
 
m
 = 
needle_len
;

45 
size_t
 *
table
 = (size_t *) 
	`nmalloca
 (
m
, sizeof (size_t));

46 if (
table
 == 
NULL
)

47 return 
false
;

64 
size_t
 
i
, 
j
;

67 
table
[1] = 1;

68 
j
 = 0;

70 for (
i
 = 2; i < 
m
; i++)

76 
UNIT
 
b
 = 
	`CANON_ELEMENT
 (
needle
[
i
 - 1]);

83 if (
b
 == 
	`CANON_ELEMENT
 (
needle
[
j
]))

86 
table
[
i
] = i - ++
j
;

92 if (
j
 == 0)

95 
table
[
i
] = i;

109 
j
 = j - 
table
[j];

117 
size_t
 
j
;

118 const 
UNIT
 *
rhaystack
;

119 const 
UNIT
 *
phaystack
;

121 *
resultp
 = 
NULL
;

122 
j
 = 0;

123 
rhaystack
 = 
haystack
;

124 
phaystack
 = 
haystack
;

126 while (*
phaystack
 != 0)

127 if (
	`CANON_ELEMENT
 (
needle
[
j
]) == CANON_ELEMENT (*
phaystack
))

129 
j
++;

130 
phaystack
++;

131 if (
j
 == 
m
)

134 *
resultp
 = 
rhaystack
;

138 else if (
j
 > 0)

141 
rhaystack
 += 
table
[
j
];

142 
j
 -= 
table
[j];

147 
rhaystack
++;

148 
phaystack
++;

152 
	`freea
 (
table
);

153 return 
true
;

154 
	}
}

156 #undef 
CANON_ELEMENT


	@lib/strcasecmp.c

20 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #include 
	~<ctype.h
>

26 #include 
	~<limits.h
>

28 #define 
	#TOLOWER
(
Ch
) (
	`isupper
 (Ch) ? 
	`tolower
 (Ch) : (Ch))

	)

36 
	$strcasecmp
 (const char *
s1
, const char *
s2
)

38 const unsigned char *
p1
 = (const unsigned char *) 
s1
;

39 const unsigned char *
p2
 = (const unsigned char *) 
s2
;

40 unsigned char 
c1
, 
c2
;

42 if (
p1
 == 
p2
)

47 
c1
 = 
	`TOLOWER
 (*
p1
);

48 
c2
 = 
	`TOLOWER
 (*
p2
);

50 if (
c1
 == '\0')

53 ++
p1
;

54 ++
p2
;

56 while (
c1
 == 
c2
);

58 if (
UCHAR_MAX
 <= 
INT_MAX
)

59 return 
c1
 - 
c2
;

64 return (
c1
 > 
c2
 ? 1 : c1 < c2 ? -1 : 0);

65 
	}
}

	@lib/streq.h

21 #ifndef 
_GL_STREQ_H


22 #define 
	#_GL_STREQ_H


	)

24 #include 
	~<string.h
>

34 #if 
defined
 (
__GNUC__
) && defined (
__OPTIMIZE__
)

36 static 
inline
 int

37 
	$streq9
 (const char *
s1
, const char *
s2
)

39 return 
	`strcmp
 (
s1
 + 9, 
s2
 + 9) == 0;

40 
	}
}

42 static 
inline
 int

43 
	$streq8
 (const char *
s1
, const char *
s2
, char 
s28
)

45 if (
s1
[8] == 
s28
)

47 if (
s28
 == 0)

50 return 
	`streq9
 (
s1
, 
s2
);

54 
	}
}

56 static 
inline
 int

57 
	$streq7
 (const char *
s1
, const char *
s2
, char 
s27
, char 
s28
)

59 if (
s1
[7] == 
s27
)

61 if (
s27
 == 0)

64 return 
	`streq8
 (
s1
, 
s2
, 
s28
);

68 
	}
}

70 static 
inline
 int

71 
	$streq6
 (const char *
s1
, const char *
s2
, char 
s26
, char 
s27
, char 
s28
)

73 if (
s1
[6] == 
s26
)

75 if (
s26
 == 0)

78 return 
	`streq7
 (
s1
, 
s2
, 
s27
, 
s28
);

82 
	}
}

84 static 
inline
 int

85 
	$streq5
 (const char *
s1
, const char *
s2
, char 
s25
, char 
s26
, char 
s27
, char 
s28
)

87 if (
s1
[5] == 
s25
)

89 if (
s25
 == 0)

92 return 
	`streq6
 (
s1
, 
s2
, 
s26
, 
s27
, 
s28
);

96 
	}
}

98 static 
inline
 int

99 
	$streq4
 (const char *
s1
, const char *
s2
, char 
s24
, char 
s25
, char 
s26
, char 
s27
, char 
s28
)

101 if (
s1
[4] == 
s24
)

103 if (
s24
 == 0)

106 return 
	`streq5
 (
s1
, 
s2
, 
s25
, 
s26
, 
s27
, 
s28
);

110 
	}
}

112 static 
inline
 int

113 
	$streq3
 (const char *
s1
, const char *
s2
, char 
s23
, char 
s24
, char 
s25
, char 
s26
, char 
s27
, char 
s28
)

115 if (
s1
[3] == 
s23
)

117 if (
s23
 == 0)

120 return 
	`streq4
 (
s1
, 
s2
, 
s24
, 
s25
, 
s26
, 
s27
, 
s28
);

124 
	}
}

126 static 
inline
 int

127 
	$streq2
 (const char *
s1
, const char *
s2
, char 
s22
, char 
s23
, char 
s24
, char 
s25
, char 
s26
, char 
s27
, char 
s28
)

129 if (
s1
[2] == 
s22
)

131 if (
s22
 == 0)

134 return 
	`streq3
 (
s1
, 
s2
, 
s23
, 
s24
, 
s25
, 
s26
, 
s27
, 
s28
);

138 
	}
}

140 static 
inline
 int

141 
	$streq1
 (const char *
s1
, const char *
s2
, char 
s21
, char 
s22
, char 
s23
, char 
s24
, char 
s25
, char 
s26
, char 
s27
, char 
s28
)

143 if (
s1
[1] == 
s21
)

145 if (
s21
 == 0)

148 return 
	`streq2
 (
s1
, 
s2
, 
s22
, 
s23
, 
s24
, 
s25
, 
s26
, 
s27
, 
s28
);

152 
	}
}

154 static 
inline
 int

155 
	$streq0
 (const char *
s1
, const char *
s2
, char 
s20
, char 
s21
, char 
s22
, char 
s23
, char 
s24
, char 
s25
, char 
s26
, char 
s27
, char 
s28
)

157 if (
s1
[0] == 
s20
)

159 if (
s20
 == 0)

162 return 
	`streq1
 (
s1
, 
s2
, 
s21
, 
s22
, 
s23
, 
s24
, 
s25
, 
s26
, 
s27
, 
s28
);

166 
	}
}

168 #define 
	#STREQ
(
s1
,
s2
,
s20
,
s21
,
s22
,
s23
,
s24
,
s25
,
s26
,
s27
,
s28
) \

169 
	`streq0
 (
s1
, 
s2
, 
s20
, 
s21
, 
s22
, 
s23
, 
s24
, 
s25
, 
s26
, 
s27
, 
s28
)

	)

173 #define 
	#STREQ
(
s1
,
s2
,
s20
,
s21
,
s22
,
s23
,
s24
,
s25
,
s26
,
s27
,
s28
) \

174 (
	`strcmp
 (
s1
, 
s2
) == 0)

	)

	@lib/strerror-override.c

20 #include 
	~<config.h
>

22 #include 
	~"strerror-override.h
"

24 #include 
	~<errno.h
>

26 #if 
GNULIB_defined_EWINSOCK


27 #if 
HAVE_WINSOCK2_H


28 #include 
	~<winsock2.h
>

35 
	$strerror_override
 (int 
errnum
)

38 switch (
errnum
)

40 #if 
REPLACE_STRERROR_0


45 #if 
GNULIB_defined_ESOCK


46 case 
EINPROGRESS
:

48 case 
EALREADY
:

50 case 
ENOTSOCK
:

52 case 
EDESTADDRREQ
:

54 case 
EMSGSIZE
:

56 case 
EPROTOTYPE
:

58 case 
ENOPROTOOPT
:

60 case 
EPROTONOSUPPORT
:

62 case 
EOPNOTSUPP
:

64 case 
EAFNOSUPPORT
:

66 case 
EADDRINUSE
:

68 case 
EADDRNOTAVAIL
:

70 case 
ENETDOWN
:

72 case 
ENETUNREACH
:

74 case 
ECONNRESET
:

76 case 
ENOBUFS
:

78 case 
EISCONN
:

80 case 
ENOTCONN
:

82 case 
ETIMEDOUT
:

84 case 
ECONNREFUSED
:

86 case 
ELOOP
:

88 case 
EHOSTUNREACH
:

90 case 
EWOULDBLOCK
:

92 case 
ETXTBSY
:

94 case 
ENODATA
:

96 case 
ENOSR
:

98 case 
ENOSTR
:

100 case 
ENOTRECOVERABLE
:

102 case 
EOWNERDEAD
:

104 case 
ETIME
:

106 case 
EOTHER
:

109 #if 
GNULIB_defined_EWINSOCK


110 case 
ESOCKTNOSUPPORT
:

112 case 
EPFNOSUPPORT
:

114 case 
ESHUTDOWN
:

116 case 
ETOOMANYREFS
:

118 case 
EHOSTDOWN
:

120 case 
EPROCLIM
:

122 case 
EUSERS
:

124 case 
EDQUOT
:

126 case 
ESTALE
:

128 case 
EREMOTE
:

130 #if 
HAVE_WINSOCK2_H


134 case 
WSA_OPERATION_ABORTED
:

136 case 
WSA_IO_INCOMPLETE
:

138 case 
WSA_IO_PENDING
:

183 case 
WSASYSNOTREADY
:

185 case 
WSAVERNOTSUPPORTED
:

187 case 
WSANOTINITIALISED
:

189 case 
WSAEDISCON
:

191 case 
WSAENOMORE
: case 
WSA_E_NO_MORE
:

193 case 
WSAECANCELLED
: case 
WSA_E_CANCELLED
:

195 case 
WSAEINVALIDPROCTABLE
:

197 case 
WSAEINVALIDPROVIDER
:

199 case 
WSAEPROVIDERFAILEDINIT
:

201 case 
WSASYSCALLFAILURE
:

203 case 
WSASERVICE_NOT_FOUND
:

205 case 
WSATYPE_NOT_FOUND
:

207 case 
WSAEREFUSED
:

209 case 
WSAHOST_NOT_FOUND
:

211 case 
WSATRY_AGAIN
:

213 case 
WSANO_RECOVERY
:

215 case 
WSANO_DATA
:

221 #if 
GNULIB_defined_ENOMSG


222 case 
ENOMSG
:

226 #if 
GNULIB_defined_EIDRM


227 case 
EIDRM
:

231 #if 
GNULIB_defined_ENOLINK


232 case 
ENOLINK
:

236 #if 
GNULIB_defined_EPROTO


237 case 
EPROTO
:

241 #if 
GNULIB_defined_EMULTIHOP


242 case 
EMULTIHOP
:

246 #if 
GNULIB_defined_EBADMSG


247 case 
EBADMSG
:

251 #if 
GNULIB_defined_EOVERFLOW


252 case 
EOVERFLOW
:

256 #if 
GNULIB_defined_ENOTSUP


257 case 
ENOTSUP
:

261 #if 
GNULIB_defined_ENETRESET


262 case 
ENETRESET
:

266 #if 
GNULIB_defined_ECONNABORTED


267 case 
ECONNABORTED
:

271 #if 
GNULIB_defined_ESTALE


272 case 
ESTALE
:

276 #if 
GNULIB_defined_EDQUOT


277 case 
EDQUOT
:

281 #if 
GNULIB_defined_ECANCELED


282 case 
ECANCELED
:

287 return 
NULL
;

289 
	}
}

	@lib/strerror-override.h

18 #ifndef 
_GL_STRERROR_OVERRIDE_H


19 #define 
	#_GL_STRERROR_OVERRIDE_H


	)

21 #include 
	~<errno.h
>

22 #include 
	~<stddef.h
>

27 #define 
	#STACKBUF_LEN
 256

	)

31 #if 
REPLACE_STRERROR_0
 \

32 || 
	gGNULIB_defined_ESOCK
 \

33 || 
	gGNULIB_defined_EWINSOCK
 \

34 || 
	gGNULIB_defined_ENOMSG
 \

35 || 
	gGNULIB_defined_EIDRM
 \

36 || 
	gGNULIB_defined_ENOLINK
 \

37 || 
	gGNULIB_defined_EPROTO
 \

38 || 
	gGNULIB_defined_EMULTIHOP
 \

39 || 
	gGNULIB_defined_EBADMSG
 \

40 || 
	gGNULIB_defined_EOVERFLOW
 \

41 || 
	gGNULIB_defined_ENOTSUP
 \

42 || 
	gGNULIB_defined_ENETRESET
 \

43 || 
	gGNULIB_defined_ECONNABORTED
 \

44 || 
	gGNULIB_defined_ESTALE
 \

45 || 
	gGNULIB_defined_EDQUOT
 \

46 || 
GNULIB_defined_ECANCELED


47 extern const char *
strerror_override
 (int 
errnum
);

49 #define 
	#strerror_override
(
ignored
) 
NULL


	)

	@lib/strerror.c

18 #include 
	~<config.h
>

21 #include 
	~<string.h
>

23 #include 
	~<errno.h
>

24 #include 
	~<stdio.h
>

25 #include 
	~<stdlib.h
>

26 #include 
	~<string.h
>

28 #include 
	~"intprops.h
"

29 #include 
	~"strerror-override.h
"

30 #include 
	~"verify.h
"

33 #undef 
sprintf


36 
	$strerror
 (int 
n
)

37 #undef 
strerror


39 static char 
buf
[
STACKBUF_LEN
];

40 
size_t
 
len
;

44 const char *
msg
 = 
	`strerror_override
 (
n
);

45 if (
msg
)

46 return (char *) 
msg
;

48 
msg
 = 
	`strerror
 (
n
);

55 if (!
msg
 || !*msg)

57 static char const 
fmt
[] = "Unknown error %d";

58 
	`verify
 (sizeof 
buf
 >= sizeof (
fmt
) + 
	`INT_STRLEN_BOUND
 (
n
));

59 
	`sprintf
 (
buf
, 
fmt
, 
n
);

60 
errno
 = 
EINVAL
;

61 return 
buf
;

65 
len
 = 
	`strlen
 (
msg
);

66 if (sizeof 
buf
 <= 
len
)

67 
	`abort
 ();

69 return 
	`memcpy
 (
buf
, 
msg
, 
len
 + 1);

70 
	}
}

	@lib/striconv.c

21 #include 
	~<config.h
>

24 #include 
	~"striconv.h
"

26 #include 
	~<errno.h
>

27 #include 
	~<stdlib.h
>

28 #include 
	~<string.h
>

30 #if 
HAVE_ICONV


31 #include 
	~<iconv.h
>

33 #include 
	~<limits.h
>

36 #include 
	~"c-strcase.h
"

38 #ifndef 
SIZE_MAX


39 #define 
	#SIZE_MAX
 ((
size_t
) -1)

	)

43 #if 
HAVE_ICONV


46 
	$mem_cd_iconv
 (const char *
src
, 
size_t
 
srclen
, 
iconv_t
 
cd
,

47 char **
resultp
, 
size_t
 *
lengthp
)

49 #define 
	#tmpbufsize
 4096

	)

50 
size_t
 
length
;

51 char *
result
;

54 #if 
defined
 
_LIBICONV_VERSION
 \

55 || !(((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 <= 1) && !
defined
 
__UCLIBC__
) \

56 || 
defined
 
__sun
)

58 
	`iconv
 (
cd
, 
NULL
, NULL, NULL, NULL);

63 
size_t
 
count
 = 0;

66 union { unsigned int 
align
; char 
buf
[
tmpbufsize
]; } 
tmp
;

67 #define 
	#tmpbuf
 
tmp
.
buf


	)

68 const char *
inptr
 = 
src
;

69 
size_t
 
insize
 = 
srclen
;

71 while (
insize
 > 0)

73 char *
outptr
 = 
tmpbuf
;

74 
size_t
 
outsize
 = 
tmpbufsize
;

75 
size_t
 
res
 = 
	`iconv
 (
cd
,

76 (
ICONV_CONST
 char **) &
inptr
, &
insize
,

77 &
outptr
, &
outsize
);

79 if (
res
 == (
size_t
)(-1))

81 if (
errno
 == 
E2BIG
)

83 else if (
errno
 == 
EINVAL
)

88 #if !
defined
 
_LIBICONV_VERSION
 && !(defined 
__GLIBC__
 && !defined 
__UCLIBC__
)

93 else if (
res
 > 0)

95 
errno
 = 
EILSEQ
;

99 
count
 += 
outptr
 - 
tmpbuf
;

102 #if 
defined
 
_LIBICONV_VERSION
 \

103 || !(((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 <= 1) && !
defined
 
__UCLIBC__
) \

104 || 
defined
 
__sun
)

106 char *
outptr
 = 
tmpbuf
;

107 
size_t
 
outsize
 = 
tmpbufsize
;

108 
size_t
 
res
 = 
	`iconv
 (
cd
, 
NULL
, NULL, &
outptr
, &
outsize
);

110 if (
res
 == (
size_t
)(-1))

112 
count
 += 
outptr
 - 
tmpbuf
;

115 
length
 = 
count
;

116 #undef 
tmpbuf


119 if (
length
 == 0)

121 *
lengthp
 = 0;

124 if (*
resultp
 != 
NULL
 && *
lengthp
 >= 
length
)

125 
result
 = *
resultp
;

128 
result
 = (char *) 
	`malloc
 (
length
);

129 if (
result
 == 
NULL
)

131 
errno
 = 
ENOMEM
;

137 #if 
defined
 
_LIBICONV_VERSION
 \

138 || !(((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 <= 1) && !
defined
 
__UCLIBC__
) \

139 || 
defined
 
__sun
)

141 
	`iconv
 (
cd
, 
NULL
, NULL, NULL, NULL);

146 const char *
inptr
 = 
src
;

147 
size_t
 
insize
 = 
srclen
;

148 char *
outptr
 = 
result
;

149 
size_t
 
outsize
 = 
length
;

151 while (
insize
 > 0)

153 
size_t
 
res
 = 
	`iconv
 (
cd
,

154 (
ICONV_CONST
 char **) &
inptr
, &
insize
,

155 &
outptr
, &
outsize
);

157 if (
res
 == (
size_t
)(-1))

159 if (
errno
 == 
EINVAL
)

162 goto 
fail
;

164 #if !
defined
 
_LIBICONV_VERSION
 && !(defined 
__GLIBC__
 && !defined 
__UCLIBC__
)

169 else if (
res
 > 0)

171 
errno
 = 
EILSEQ
;

172 goto 
fail
;

177 #if 
defined
 
_LIBICONV_VERSION
 \

178 || !(((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 <= 1) && !
defined
 
__UCLIBC__
) \

179 || 
defined
 
__sun
)

181 
size_t
 
res
 = 
	`iconv
 (
cd
, 
NULL
, NULL, &
outptr
, &
outsize
);

183 if (
res
 == (
size_t
)(-1))

184 goto 
fail
;

187 if (
outsize
 != 0)

188 
	`abort
 ();

191 *
resultp
 = 
result
;

192 *
lengthp
 = 
length
;

196 
fail
:

198 if (
result
 != *
resultp
)

200 int 
saved_errno
 = 
errno
;

201 
	`free
 (
result
);

202 
errno
 = 
saved_errno
;

206 #undef 
tmpbufsize


207 
	}
}

210 
	$str_cd_iconv
 (const char *
src
, 
iconv_t
 
cd
)

216 #if !
defined
 
_LIBICONV_VERSION
 && !(defined 
__GLIBC__
 && !defined 
__UCLIBC__
)

225 char *
result
 = 
NULL
;

226 
size_t
 
length
 = 0;

227 int 
retval
 = 
	`mem_cd_iconv
 (
src
, 
	`strlen
 (src), 
cd
, &
result
, &
length
);

228 char *
final_result
;

230 if (
retval
 < 0)

232 if (
result
 != 
NULL
)

233 
	`abort
 ();

234 return 
NULL
;

238 
final_result
 =

239 (
result
 != 
NULL
 ? 
	`realloc
 (result, 
length
 + 1) : 
	`malloc
 (length + 1));

240 if (
final_result
 == 
NULL
)

242 
	`free
 (
result
);

243 
errno
 = 
ENOMEM
;

244 return 
NULL
;

246 
final_result
[
length
] = '\0';

248 return 
final_result
;

255 char *
result
;

256 
size_t
 
result_size
;

257 
size_t
 
length
;

258 const char *
inptr
 = 
src
;

259 
size_t
 
inbytes_remaining
 = 
	`strlen
 (
src
);

264 
result_size
 = 
inbytes_remaining
;

266 
size_t
 
approx_sqrt_SIZE_MAX
 = 
SIZE_MAX
 >> (sizeof (size_t) * 
CHAR_BIT
 / 2);

267 if (
result_size
 <= 
approx_sqrt_SIZE_MAX
 / 
MB_LEN_MAX
)

268 
result_size
 *= 
MB_LEN_MAX
;

270 
result_size
 += 1;

272 
result
 = (char *) 
	`malloc
 (
result_size
);

273 if (
result
 == 
NULL
)

275 
errno
 = 
ENOMEM
;

276 return 
NULL
;

280 #if 
defined
 
_LIBICONV_VERSION
 \

281 || !(((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 <= 1) && !
defined
 
__UCLIBC__
) \

282 || 
defined
 
__sun
)

284 
	`iconv
 (
cd
, 
NULL
, NULL, NULL, NULL);

289 char *
outptr
 = 
result
;

290 
size_t
 
outbytes_remaining
 = 
result_size
 - 1;

296 
size_t
 
res
 = 
	`iconv
 (
cd
,

297 (
ICONV_CONST
 char **) &
inptr
, &
inbytes_remaining
,

298 &
outptr
, &
outbytes_remaining
);

300 if (
res
 == (
size_t
)(-1))

302 if (
errno
 == 
EINVAL
)

304 else if (
errno
 == 
E2BIG
)

306 
size_t
 
used
 = 
outptr
 - 
result
;

307 
size_t
 
newsize
 = 
result_size
 * 2;

308 char *
newresult
;

310 if (!(
newsize
 > 
result_size
))

312 
errno
 = 
ENOMEM
;

313 goto 
failed
;

315 
newresult
 = (char *) 
	`realloc
 (
result
, 
newsize
);

316 if (
newresult
 == 
NULL
)

318 
errno
 = 
ENOMEM
;

319 goto 
failed
;

321 
result
 = 
newresult
;

322 
result_size
 = 
newsize
;

323 
outptr
 = 
result
 + 
used
;

324 
outbytes_remaining
 = 
result_size
 - 1 - 
used
;

327 goto 
failed
;

333 #if 
defined
 
_LIBICONV_VERSION
 \

334 || !(((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 <= 1) && !
defined
 
__UCLIBC__
) \

335 || 
defined
 
__sun
)

339 
size_t
 
res
 = 
	`iconv
 (
cd
, 
NULL
, NULL, &
outptr
, &
outbytes_remaining
);

341 if (
res
 == (
size_t
)(-1))

343 if (
errno
 == 
E2BIG
)

345 
size_t
 
used
 = 
outptr
 - 
result
;

346 
size_t
 
newsize
 = 
result_size
 * 2;

347 char *
newresult
;

349 if (!(
newsize
 > 
result_size
))

351 
errno
 = 
ENOMEM
;

352 goto 
failed
;

354 
newresult
 = (char *) 
	`realloc
 (
result
, 
newsize
);

355 if (
newresult
 == 
NULL
)

357 
errno
 = 
ENOMEM
;

358 goto 
failed
;

360 
result
 = 
newresult
;

361 
result_size
 = 
newsize
;

362 
outptr
 = 
result
 + 
used
;

363 
outbytes_remaining
 = 
result_size
 - 1 - 
used
;

366 goto 
failed
;

374 *
outptr
++ = '\0';

376 
length
 = 
outptr
 - 
result
;

380 if (
length
 < 
result_size
)

382 char *
smaller_result
 = (char *) 
	`realloc
 (
result
, 
length
);

384 if (
smaller_result
 != 
NULL
)

385 
result
 = 
smaller_result
;

388 return 
result
;

390 
failed
:

392 int 
saved_errno
 = 
errno
;

393 
	`free
 (
result
);

394 
errno
 = 
saved_errno
;

395 return 
NULL
;

399 
	}
}

404 
	$str_iconv
 (const char *
src
, const char *
from_codeset
, const char *
to_codeset
)

406 if (*
src
 == '\0' || 
	`c_strcasecmp
 (
from_codeset
, 
to_codeset
) == 0)

408 char *
result
 = 
	`strdup
 (
src
);

410 if (
result
 == 
NULL
)

411 
errno
 = 
ENOMEM
;

412 return 
result
;

416 #if 
HAVE_ICONV


417 
iconv_t
 
cd
;

418 char *
result
;

421 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 <= 1) && !
defined
 
__UCLIBC__
) \

422 && !
defined
 
_LIBICONV_VERSION


423 if (
	`c_strcasecmp
 (
from_codeset
, "EUC-KR") == 0

424 || 
	`c_strcasecmp
 (
to_codeset
, "EUC-KR") == 0)

426 
errno
 = 
EINVAL
;

427 return 
NULL
;

430 
cd
 = 
	`iconv_open
 (
to_codeset
, 
from_codeset
);

431 if (
cd
 == (
iconv_t
) -1)

432 return 
NULL
;

434 
result
 = 
	`str_cd_iconv
 (
src
, 
cd
);

436 if (
result
 == 
NULL
)

439 int 
saved_errno
 = 
errno
;

440 
	`iconv_close
 (
cd
);

441 
errno
 = 
saved_errno
;

445 if (
	`iconv_close
 (
cd
) < 0)

449 int 
saved_errno
 = 
errno
;

450 
	`free
 (
result
);

451 
errno
 = 
saved_errno
;

452 return 
NULL
;

455 return 
result
;

462 
errno
 = 
ENOSYS
;

463 return 
NULL
;

466 
	}
}

	@lib/striconv.h

21 #ifndef 
_STRICONV_H


22 #define 
	#_STRICONV_H


	)

24 #include 
	~<stddef.h
>

25 #if 
HAVE_ICONV


26 #include 
	~<iconv.h
>

30 #ifdef 
__cplusplus


35 #if 
HAVE_ICONV


47 extern int 
mem_cd_iconv
 (const char *
src
, 
size_t
 
srclen
, 
iconv_t
 
cd
,

48 char **
resultp
, 
size_t
 *
lengthp
);

58 extern char * 
str_cd_iconv
 (const char *
src
, 
iconv_t
 
cd
);

69 extern char * 
str_iconv
 (const char *
src
,

70 const char *
from_codeset
, const char *
to_codeset
);

73 #ifdef 
__cplusplus


	@lib/string.in.h

21 #ifndef 
_
@
GUARD_PREFIX
@
_STRING_H


23 #if 
__GNUC__
 >= 3

24 @
	gPRAGMA_SYSTEM_HEADER
@

26 @
	gPRAGMA_COLUMNS
@

29 #@
INCLUDE_NEXT
@ @
NEXT_STRING_H
@

31 #ifndef 
_
@
GUARD_PREFIX
@
_STRING_H


32 #define 
	#_
@
GUARD_PREFIX
@
_STRING_H


	)

35 #include 
	~<stddef.h
>

38 #if @
GNULIB_MBSLEN
@ && 
defined
 
__MirBSD__


39 #include 
	~<wchar.h
>

44 #if 
__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 96)

45 #define 
	#_GL_ATTRIBUTE_PURE
 
	`__attribute__
 ((
__pure__
))

	)

47 #define 
	#_GL_ATTRIBUTE_PURE


	)

52 #if (@
GNULIB_STRSIGNAL
@ || 
defined
 
GNULIB_POSIXCHECK
) && defined 
__NetBSD__
 \

53 && ! 
defined
 
	g__GLIBC__


54 #include 
	~<unistd.h
>

65 #if @
GNULIB_FFSL
@

66 #if !@
HAVE_FFSL
@

67 
_GL_FUNCDECL_SYS
 (
ffsl
, int, (long int 
i
));

69 
_GL_CXXALIAS_SYS
 (
ffsl
, int, (long int 
i
));

70 
_GL_CXXALIASWARN
 (
ffsl
);

71 #elif 
defined
 
GNULIB_POSIXCHECK


72 #undef 
ffsl


73 #if 
HAVE_RAW_DECL_FFSL


74 
_GL_WARN_ON_USE
 (
ffsl
, "ffsl is not portable - use the ffsl module");

80 #if @
GNULIB_FFSLL
@

81 #if !@
HAVE_FFSLL
@

82 
_GL_FUNCDECL_SYS
 (
ffsll
, int, (long long int 
i
));

84 
_GL_CXXALIAS_SYS
 (
ffsll
, int, (long long int 
i
));

85 
_GL_CXXALIASWARN
 (
ffsll
);

86 #elif 
defined
 
GNULIB_POSIXCHECK


87 #undef 
ffsll


88 #if 
HAVE_RAW_DECL_FFSLL


89 
_GL_WARN_ON_USE
 (
ffsll
, "ffsll is not portable - use the ffsll module");

95 #if @
GNULIB_MEMCHR
@

96 #if @
REPLACE_MEMCHR
@

97 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

98 #define 
	#memchr
 
rpl_memchr


	)

100 
_GL_FUNCDECL_RPL
 (
memchr
, void *, (void const *
__s
, int 
__c
, 
size_t
 
__n
)

101 
_GL_ATTRIBUTE_PURE


102 
_GL_ARG_NONNULL
 ((1)));

103 
_GL_CXXALIAS_RPL
 (
memchr
, void *, (void const *
__s
, int 
__c
, 
size_t
 
__n
));

105 #if ! @
HAVE_MEMCHR
@

106 
_GL_FUNCDECL_SYS
 (
memchr
, void *, (void const *
__s
, int 
__c
, 
size_t
 
__n
)

107 
_GL_ATTRIBUTE_PURE


108 
_GL_ARG_NONNULL
 ((1)));

113 
_GL_CXXALIAS_SYS_CAST2
 (
memchr
,

114 void *, (void const *
__s
, int 
__c
, 
size_t
 
__n
),

115 void const *, (void const *
__s
, int 
__c
, 
size_t
 
__n
));

117 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

118 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

119 
_GL_CXXALIASWARN1
 (
memchr
, void *, (void *
__s
, int 
__c
, 
size_t
 
__n
));

120 
_GL_CXXALIASWARN1
 (
memchr
, void const *,

121 (void const *
__s
, int 
__c
, 
size_t
 
__n
));

123 
_GL_CXXALIASWARN
 (
memchr
);

125 #elif 
defined
 
GNULIB_POSIXCHECK


126 #undef 
memchr


128 
_GL_WARN_ON_USE
 (
memchr
, "memchr has platform-specific bugs - "

133 #if @
GNULIB_MEMMEM
@

134 #if @
REPLACE_MEMMEM
@

135 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

136 #define 
	#memmem
 
rpl_memmem


	)

138 
_GL_FUNCDECL_RPL
 (
memmem
, void *,

139 (void const *
__haystack
, 
size_t
 
__haystack_len
,

140 void const *
__needle
, 
size_t
 
__needle_len
)

141 
_GL_ATTRIBUTE_PURE


142 
_GL_ARG_NONNULL
 ((1, 3)));

143 
_GL_CXXALIAS_RPL
 (
memmem
, void *,

144 (void const *
__haystack
, 
size_t
 
__haystack_len
,

145 void const *
__needle
, 
size_t
 
__needle_len
));

147 #if ! @
HAVE_DECL_MEMMEM
@

148 
_GL_FUNCDECL_SYS
 (
memmem
, void *,

149 (void const *
__haystack
, 
size_t
 
__haystack_len
,

150 void const *
__needle
, 
size_t
 
__needle_len
)

151 
_GL_ATTRIBUTE_PURE


152 
_GL_ARG_NONNULL
 ((1, 3)));

154 
_GL_CXXALIAS_SYS
 (
memmem
, void *,

155 (void const *
__haystack
, 
size_t
 
__haystack_len
,

156 void const *
__needle
, 
size_t
 
__needle_len
));

158 
_GL_CXXALIASWARN
 (
memmem
);

159 #elif 
defined
 
GNULIB_POSIXCHECK


160 #undef 
memmem


161 #if 
HAVE_RAW_DECL_MEMMEM


162 
_GL_WARN_ON_USE
 (
memmem
, "memmem is unportable and often quadratic - "

170 #if @
GNULIB_MEMPCPY
@

171 #if ! @
HAVE_MEMPCPY
@

172 
_GL_FUNCDECL_SYS
 (
mempcpy
, void *,

173 (void *
restrict
 
__dest
, void const *restrict 
__src
,

174 
size_t
 
__n
)

175 
_GL_ARG_NONNULL
 ((1, 2)));

177 
_GL_CXXALIAS_SYS
 (
mempcpy
, void *,

178 (void *
restrict
 
__dest
, void const *restrict 
__src
,

179 
size_t
 
__n
));

180 
_GL_CXXALIASWARN
 (
mempcpy
);

181 #elif 
defined
 
GNULIB_POSIXCHECK


182 #undef 
mempcpy


183 #if 
HAVE_RAW_DECL_MEMPCPY


184 
_GL_WARN_ON_USE
 (
mempcpy
, "mempcpy is unportable - "

190 #if @
GNULIB_MEMRCHR
@

191 #if ! @
HAVE_DECL_MEMRCHR
@

192 
_GL_FUNCDECL_SYS
 (
memrchr
, void *, (void const *, int, 
size_t
)

193 
_GL_ATTRIBUTE_PURE


194 
_GL_ARG_NONNULL
 ((1)));

199 
_GL_CXXALIAS_SYS_CAST2
 (
memrchr
,

200 void *, (void const *, int, 
size_t
),

201 void const *, (void const *, int, 
size_t
));

202 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

203 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

204 
_GL_CXXALIASWARN1
 (
memrchr
, void *, (void *, int, 
size_t
));

205 
_GL_CXXALIASWARN1
 (
memrchr
, void const *, (void const *, int, 
size_t
));

207 
_GL_CXXALIASWARN
 (
memrchr
);

209 #elif 
defined
 
GNULIB_POSIXCHECK


210 #undef 
memrchr


211 #if 
HAVE_RAW_DECL_MEMRCHR


212 
_GL_WARN_ON_USE
 (
memrchr
, "memrchr is unportable - "

220 #if @
GNULIB_RAWMEMCHR
@

221 #if ! @
HAVE_RAWMEMCHR
@

222 
_GL_FUNCDECL_SYS
 (
rawmemchr
, void *, (void const *
__s
, int 
__c_in
)

223 
_GL_ATTRIBUTE_PURE


224 
_GL_ARG_NONNULL
 ((1)));

229 
_GL_CXXALIAS_SYS_CAST2
 (
rawmemchr
,

230 void *, (void const *
__s
, int 
__c_in
),

231 void const *, (void const *
__s
, int 
__c_in
));

232 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

233 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

234 
_GL_CXXALIASWARN1
 (
rawmemchr
, void *, (void *
__s
, int 
__c_in
));

235 
_GL_CXXALIASWARN1
 (
rawmemchr
, void const *, (void const *
__s
, int 
__c_in
));

237 
_GL_CXXALIASWARN
 (
rawmemchr
);

239 #elif 
defined
 
GNULIB_POSIXCHECK


240 #undef 
rawmemchr


241 #if 
HAVE_RAW_DECL_RAWMEMCHR


242 
_GL_WARN_ON_USE
 (
rawmemchr
, "rawmemchr is unportable - "

248 #if @
GNULIB_STPCPY
@

249 #if ! @
HAVE_STPCPY
@

250 
_GL_FUNCDECL_SYS
 (
stpcpy
, char *,

251 (char *
restrict
 
__dst
, char const *restrict 
__src
)

252 
_GL_ARG_NONNULL
 ((1, 2)));

254 
_GL_CXXALIAS_SYS
 (
stpcpy
, char *,

255 (char *
restrict
 
__dst
, char const *restrict 
__src
));

256 
_GL_CXXALIASWARN
 (
stpcpy
);

257 #elif 
defined
 
GNULIB_POSIXCHECK


258 #undef 
stpcpy


259 #if 
HAVE_RAW_DECL_STPCPY


260 
_GL_WARN_ON_USE
 (
stpcpy
, "stpcpy is unportable - "

267 #if @
GNULIB_STPNCPY
@

268 #if @
REPLACE_STPNCPY
@

269 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

270 #undef 
stpncpy


271 #define 
	#stpncpy
 
rpl_stpncpy


	)

273 
_GL_FUNCDECL_RPL
 (
stpncpy
, char *,

274 (char *
restrict
 
__dst
, char const *restrict 
__src
,

275 
size_t
 
__n
)

276 
_GL_ARG_NONNULL
 ((1, 2)));

277 
_GL_CXXALIAS_RPL
 (
stpncpy
, char *,

278 (char *
restrict
 
__dst
, char const *restrict 
__src
,

279 
size_t
 
__n
));

281 #if ! @
HAVE_STPNCPY
@

282 
_GL_FUNCDECL_SYS
 (
stpncpy
, char *,

283 (char *
restrict
 
__dst
, char const *restrict 
__src
,

284 
size_t
 
__n
)

285 
_GL_ARG_NONNULL
 ((1, 2)));

287 
_GL_CXXALIAS_SYS
 (
stpncpy
, char *,

288 (char *
restrict
 
__dst
, char const *restrict 
__src
,

289 
size_t
 
__n
));

291 
_GL_CXXALIASWARN
 (
stpncpy
);

292 #elif 
defined
 
GNULIB_POSIXCHECK


293 #undef 
stpncpy


294 #if 
HAVE_RAW_DECL_STPNCPY


295 
_GL_WARN_ON_USE
 (
stpncpy
, "stpncpy is unportable - "

300 #if 
defined
 
GNULIB_POSIXCHECK


303 #undef 
strchr


305 
_GL_WARN_ON_USE
 (
strchr
, "strchr cannot work correctly on character strings "

311 #if @
GNULIB_STRCHRNUL
@

312 #if @
REPLACE_STRCHRNUL
@

313 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

314 #define 
	#strchrnul
 
rpl_strchrnul


	)

316 
_GL_FUNCDECL_RPL
 (
strchrnul
, char *, (const char *
__s
, int 
__c_in
)

317 
_GL_ATTRIBUTE_PURE


318 
_GL_ARG_NONNULL
 ((1)));

319 
_GL_CXXALIAS_RPL
 (
strchrnul
, char *,

320 (const char *
str
, int 
ch
));

322 #if ! @
HAVE_STRCHRNUL
@

323 
_GL_FUNCDECL_SYS
 (
strchrnul
, char *, (char const *
__s
, int 
__c_in
)

324 
_GL_ATTRIBUTE_PURE


325 
_GL_ARG_NONNULL
 ((1)));

330 
_GL_CXXALIAS_SYS_CAST2
 (
strchrnul
,

331 char *, (char const *
__s
, int 
__c_in
),

332 char const *, (char const *
__s
, int 
__c_in
));

334 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

335 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

336 
_GL_CXXALIASWARN1
 (
strchrnul
, char *, (char *
__s
, int 
__c_in
));

337 
_GL_CXXALIASWARN1
 (
strchrnul
, char const *, (char const *
__s
, int 
__c_in
));

339 
_GL_CXXALIASWARN
 (
strchrnul
);

341 #elif 
defined
 
GNULIB_POSIXCHECK


342 #undef 
strchrnul


343 #if 
HAVE_RAW_DECL_STRCHRNUL


344 
_GL_WARN_ON_USE
 (
strchrnul
, "strchrnul is unportable - "

350 #if @
GNULIB_STRDUP
@

351 #if @
REPLACE_STRDUP
@

352 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

353 #undef 
strdup


354 #define 
	#strdup
 
rpl_strdup


	)

356 
_GL_FUNCDECL_RPL
 (
strdup
, char *, (char const *
__s
) 
_GL_ARG_NONNULL
 ((1)));

357 
_GL_CXXALIAS_RPL
 (
strdup
, char *, (char const *
__s
));

359 #if 
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
 && defined 
strdup


361 #undef 
strdup


363 #if !(@
HAVE_DECL_STRDUP
@ || 
defined
 
strdup
)

364 
_GL_FUNCDECL_SYS
 (
strdup
, char *, (char const *
__s
) 
_GL_ARG_NONNULL
 ((1)));

366 
_GL_CXXALIAS_SYS
 (
strdup
, char *, (char const *
__s
));

368 
_GL_CXXALIASWARN
 (
strdup
);

369 #elif 
defined
 
GNULIB_POSIXCHECK


370 #undef 
strdup


371 #if 
HAVE_RAW_DECL_STRDUP


372 
_GL_WARN_ON_USE
 (
strdup
, "strdup is unportable - "

378 #if @
GNULIB_STRNCAT
@

379 #if @
REPLACE_STRNCAT
@

380 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

381 #undef 
strncat


382 #define 
	#strncat
 
rpl_strncat


	)

384 
_GL_FUNCDECL_RPL
 (
strncat
, char *, (char *
dest
, const char *
src
, 
size_t
 
n
)

385 
_GL_ARG_NONNULL
 ((1, 2)));

386 
_GL_CXXALIAS_RPL
 (
strncat
, char *, (char *
dest
, const char *
src
, 
size_t
 
n
));

388 
_GL_CXXALIAS_SYS
 (
strncat
, char *, (char *
dest
, const char *
src
, 
size_t
 
n
));

390 
_GL_CXXALIASWARN
 (
strncat
);

391 #elif 
defined
 
GNULIB_POSIXCHECK


392 #undef 
strncat


393 #if 
HAVE_RAW_DECL_STRNCAT


394 
_GL_WARN_ON_USE
 (
strncat
, "strncat is unportable - "

400 #if @
GNULIB_STRNDUP
@

401 #if @
REPLACE_STRNDUP
@

402 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

403 #undef 
strndup


404 #define 
	#strndup
 
rpl_strndup


	)

406 
_GL_FUNCDECL_RPL
 (
strndup
, char *, (char const *
__string
, 
size_t
 
__n
)

407 
_GL_ARG_NONNULL
 ((1)));

408 
_GL_CXXALIAS_RPL
 (
strndup
, char *, (char const *
__string
, 
size_t
 
__n
));

410 #if ! @
HAVE_DECL_STRNDUP
@

411 
_GL_FUNCDECL_SYS
 (
strndup
, char *, (char const *
__string
, 
size_t
 
__n
)

412 
_GL_ARG_NONNULL
 ((1)));

414 
_GL_CXXALIAS_SYS
 (
strndup
, char *, (char const *
__string
, 
size_t
 
__n
));

416 
_GL_CXXALIASWARN
 (
strndup
);

417 #elif 
defined
 
GNULIB_POSIXCHECK


418 #undef 
strndup


419 #if 
HAVE_RAW_DECL_STRNDUP


420 
_GL_WARN_ON_USE
 (
strndup
, "strndup is unportable - "

428 #if @
GNULIB_STRNLEN
@

429 #if @
REPLACE_STRNLEN
@

430 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

431 #undef 
strnlen


432 #define 
	#strnlen
 
rpl_strnlen


	)

434 
_GL_FUNCDECL_RPL
 (
strnlen
, 
size_t
, (char const *
__string
, size_t 
__maxlen
)

435 
_GL_ATTRIBUTE_PURE


436 
_GL_ARG_NONNULL
 ((1)));

437 
_GL_CXXALIAS_RPL
 (
strnlen
, 
size_t
, (char const *
__string
, size_t 
__maxlen
));

439 #if ! @
HAVE_DECL_STRNLEN
@

440 
_GL_FUNCDECL_SYS
 (
strnlen
, 
size_t
, (char const *
__string
, size_t 
__maxlen
)

441 
_GL_ATTRIBUTE_PURE


442 
_GL_ARG_NONNULL
 ((1)));

444 
_GL_CXXALIAS_SYS
 (
strnlen
, 
size_t
, (char const *
__string
, size_t 
__maxlen
));

446 
_GL_CXXALIASWARN
 (
strnlen
);

447 #elif 
defined
 
GNULIB_POSIXCHECK


448 #undef 
strnlen


449 #if 
HAVE_RAW_DECL_STRNLEN


450 
_GL_WARN_ON_USE
 (
strnlen
, "strnlen is unportable - "

455 #if 
defined
 
GNULIB_POSIXCHECK


460 #undef 
strcspn


462 
_GL_WARN_ON_USE
 (
strcspn
, "strcspn cannot work correctly on character strings "

468 #if @
GNULIB_STRPBRK
@

469 #if ! @
HAVE_STRPBRK
@

470 
_GL_FUNCDECL_SYS
 (
strpbrk
, char *, (char const *
__s
, char const *
__accept
)

471 
_GL_ATTRIBUTE_PURE


472 
_GL_ARG_NONNULL
 ((1, 2)));

477 
_GL_CXXALIAS_SYS_CAST2
 (
strpbrk
,

478 char *, (char const *
__s
, char const *
__accept
),

479 const char *, (char const *
__s
, char const *
__accept
));

480 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

481 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

482 
_GL_CXXALIASWARN1
 (
strpbrk
, char *, (char *
__s
, char const *
__accept
));

483 
_GL_CXXALIASWARN1
 (
strpbrk
, char const *,

484 (char const *
__s
, char const *
__accept
));

486 
_GL_CXXALIASWARN
 (
strpbrk
);

488 #if 
defined
 
GNULIB_POSIXCHECK


493 #undef 
strpbrk


494 
_GL_WARN_ON_USE
 (
strpbrk
, "strpbrk cannot work correctly on character strings "

498 #elif 
defined
 
GNULIB_POSIXCHECK


499 #undef 
strpbrk


500 #if 
HAVE_RAW_DECL_STRPBRK


501 
_GL_WARN_ON_USE
 (
strpbrk
, "strpbrk is unportable - "

506 #if 
defined
 
GNULIB_POSIXCHECK


509 #undef 
strspn


511 
_GL_WARN_ON_USE
 (
strspn
, "strspn cannot work correctly on character strings "

516 #if 
defined
 
GNULIB_POSIXCHECK


519 #undef 
strrchr


521 
_GL_WARN_ON_USE
 (
strrchr
, "strrchr cannot work correctly on character strings "

542 #if @
GNULIB_STRSEP
@

543 #if ! @
HAVE_STRSEP
@

544 
_GL_FUNCDECL_SYS
 (
strsep
, char *,

545 (char **
restrict
 
__stringp
, char const *restrict 
__delim
)

546 
_GL_ARG_NONNULL
 ((1, 2)));

548 
_GL_CXXALIAS_SYS
 (
strsep
, char *,

549 (char **
restrict
 
__stringp
, char const *restrict 
__delim
));

550 
_GL_CXXALIASWARN
 (
strsep
);

551 #if 
defined
 
GNULIB_POSIXCHECK


552 #undef 
strsep


553 
_GL_WARN_ON_USE
 (
strsep
, "strsep cannot work correctly on character strings "

557 #elif 
defined
 
GNULIB_POSIXCHECK


558 #undef 
strsep


559 #if 
HAVE_RAW_DECL_STRSEP


560 
_GL_WARN_ON_USE
 (
strsep
, "strsep is unportable - "

565 #if @
GNULIB_STRSTR
@

566 #if @
REPLACE_STRSTR
@

567 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

568 #define 
	#strstr
 
rpl_strstr


	)

570 
_GL_FUNCDECL_RPL
 (
strstr
, char *, (const char *
haystack
, const char *
needle
)

571 
_GL_ATTRIBUTE_PURE


572 
_GL_ARG_NONNULL
 ((1, 2)));

573 
_GL_CXXALIAS_RPL
 (
strstr
, char *, (const char *
haystack
, const char *
needle
));

578 
_GL_CXXALIAS_SYS_CAST2
 (
strstr
,

579 char *, (const char *
haystack
, const char *
needle
),

580 const char *, (const char *
haystack
, const char *
needle
));

582 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

583 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

584 
_GL_CXXALIASWARN1
 (
strstr
, char *, (char *
haystack
, const char *
needle
));

585 
_GL_CXXALIASWARN1
 (
strstr
, const char *,

586 (const char *
haystack
, const char *
needle
));

588 
_GL_CXXALIASWARN
 (
strstr
);

590 #elif 
defined
 
GNULIB_POSIXCHECK


595 #undef 
strstr


597 
_GL_WARN_ON_USE
 (
strstr
, "strstr is quadratic on many systems, and cannot "

606 #if @
GNULIB_STRCASESTR
@

607 #if @
REPLACE_STRCASESTR
@

608 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

609 #define 
	#strcasestr
 
rpl_strcasestr


	)

611 
_GL_FUNCDECL_RPL
 (
strcasestr
, char *,

612 (const char *
haystack
, const char *
needle
)

613 
_GL_ATTRIBUTE_PURE


614 
_GL_ARG_NONNULL
 ((1, 2)));

615 
_GL_CXXALIAS_RPL
 (
strcasestr
, char *,

616 (const char *
haystack
, const char *
needle
));

618 #if ! @
HAVE_STRCASESTR
@

619 
_GL_FUNCDECL_SYS
 (
strcasestr
, char *,

620 (const char *
haystack
, const char *
needle
)

621 
_GL_ATTRIBUTE_PURE


622 
_GL_ARG_NONNULL
 ((1, 2)));

627 
_GL_CXXALIAS_SYS_CAST2
 (
strcasestr
,

628 char *, (const char *
haystack
, const char *
needle
),

629 const char *, (const char *
haystack
, const char *
needle
));

631 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

632 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

633 
_GL_CXXALIASWARN1
 (
strcasestr
, char *, (char *
haystack
, const char *
needle
));

634 
_GL_CXXALIASWARN1
 (
strcasestr
, const char *,

635 (const char *
haystack
, const char *
needle
));

637 
_GL_CXXALIASWARN
 (
strcasestr
);

639 #elif 
defined
 
GNULIB_POSIXCHECK


643 #undef 
strcasestr


644 #if 
HAVE_RAW_DECL_STRCASESTR


645 
_GL_WARN_ON_USE
 (
strcasestr
, "strcasestr does work correctly on character "

675 #if @
GNULIB_STRTOK_R
@

676 #if @
REPLACE_STRTOK_R
@

677 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

678 #undef 
strtok_r


679 #define 
	#strtok_r
 
rpl_strtok_r


	)

681 
_GL_FUNCDECL_RPL
 (
strtok_r
, char *,

682 (char *
restrict
 
s
, char const *restrict 
delim
,

683 char **
restrict
 
save_ptr
)

684 
_GL_ARG_NONNULL
 ((2, 3)));

685 
_GL_CXXALIAS_RPL
 (
strtok_r
, char *,

686 (char *
restrict
 
s
, char const *restrict 
delim
,

687 char **
restrict
 
save_ptr
));

689 #if @
UNDEFINE_STRTOK_R
@ || 
defined
 
GNULIB_POSIXCHECK


690 #undef 
strtok_r


692 #if ! @
HAVE_DECL_STRTOK_R
@

693 
_GL_FUNCDECL_SYS
 (
strtok_r
, char *,

694 (char *
restrict
 
s
, char const *restrict 
delim
,

695 char **
restrict
 
save_ptr
)

696 
_GL_ARG_NONNULL
 ((2, 3)));

698 
_GL_CXXALIAS_SYS
 (
strtok_r
, char *,

699 (char *
restrict
 
s
, char const *restrict 
delim
,

700 char **
restrict
 
save_ptr
));

702 
_GL_CXXALIASWARN
 (
strtok_r
);

703 #if 
defined
 
GNULIB_POSIXCHECK


704 
_GL_WARN_ON_USE
 (
strtok_r
, "strtok_r cannot work correctly on character "

708 #elif 
defined
 
GNULIB_POSIXCHECK


709 #undef 
strtok_r


710 #if 
HAVE_RAW_DECL_STRTOK_R


711 
_GL_WARN_ON_USE
 (
strtok_r
, "strtok_r is unportable - "

720 #if @
GNULIB_MBSLEN
@

723 #ifdef 
__MirBSD__


724 #undef 
mbslen


726 #if @
HAVE_MBSLEN
@

727 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

728 #define 
	#mbslen
 
rpl_mbslen


	)

730 
_GL_FUNCDECL_RPL
 (
mbslen
, 
size_t
, (const char *
string
) 
_GL_ARG_NONNULL
 ((1)));

731 
_GL_CXXALIAS_RPL
 (
mbslen
, 
size_t
, (const char *
string
));

733 
_GL_FUNCDECL_SYS
 (
mbslen
, 
size_t
, (const char *
string
) 
_GL_ARG_NONNULL
 ((1)));

734 
_GL_CXXALIAS_SYS
 (
mbslen
, 
size_t
, (const char *
string
));

736 
_GL_CXXALIASWARN
 (
mbslen
);

739 #if @
GNULIB_MBSNLEN
@

742 
_GL_EXTERN_C
 
size_t
 
	$mbsnlen
 (const char *
string
, 
size_t
 
len
)

743 
	`_GL_ARG_NONNULL
 ((1));

746 #if @
GNULIB_MBSCHR
@

751 #if 
defined
 
__hpux


752 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

753 #define 
	#mbschr
 
rpl_mbschr


	)

755 
	`_GL_FUNCDECL_RPL
 (
mbschr
, char *, (const char *
string
, int 
c
)

756 
	`_GL_ARG_NONNULL
 ((1)));

757 
	`_GL_CXXALIAS_RPL
 (
mbschr
, char *, (const char *
string
, int 
c
));

759 
	`_GL_FUNCDECL_SYS
 (
mbschr
, char *, (const char *
string
, int 
c
)

760 
	`_GL_ARG_NONNULL
 ((1)));

761 
	`_GL_CXXALIAS_SYS
 (
mbschr
, char *, (const char *
string
, int 
c
));

763 
	`_GL_CXXALIASWARN
 (
mbschr
);

766 #if @
GNULIB_MBSRCHR
@

771 #if 
defined
 
__hpux
 || defined 
__INTERIX


772 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

773 #define 
	#mbsrchr
 
rpl_mbsrchr


	)

775 
	`_GL_FUNCDECL_RPL
 (
mbsrchr
, char *, (const char *
string
, int 
c
)

776 
	`_GL_ARG_NONNULL
 ((1)));

777 
	`_GL_CXXALIAS_RPL
 (
mbsrchr
, char *, (const char *
string
, int 
c
));

779 
	`_GL_FUNCDECL_SYS
 (
mbsrchr
, char *, (const char *
string
, int 
c
)

780 
	`_GL_ARG_NONNULL
 ((1)));

781 
	`_GL_CXXALIAS_SYS
 (
mbsrchr
, char *, (const char *
string
, int 
c
));

783 
	`_GL_CXXALIASWARN
 (
mbsrchr
);

786 #if @
GNULIB_MBSSTR
@

791 
_GL_EXTERN_C
 char * 
	$mbsstr
 (const char *
haystack
, const char *
needle
)

792 
	`_GL_ARG_NONNULL
 ((1, 2));

795 #if @
GNULIB_MBSCASECMP
@

802 
_GL_EXTERN_C
 int 
	$mbscasecmp
 (const char *
s1
, const char *
s2
)

803 
	`_GL_ARG_NONNULL
 ((1, 2));

806 #if @
GNULIB_MBSNCASECMP
@

816 
_GL_EXTERN_C
 int 
	$mbsncasecmp
 (const char *
s1
, const char *
s2
, 
size_t
 
n
)

817 
	`_GL_ARG_NONNULL
 ((1, 2));

820 #if @
GNULIB_MBSPCASECMP
@

829 
_GL_EXTERN_C
 char * 
	$mbspcasecmp
 (const char *
string
, const char *
prefix
)

830 
	`_GL_ARG_NONNULL
 ((1, 2));

833 #if @
GNULIB_MBSCASESTR
@

839 
_GL_EXTERN_C
 char * 
	$mbscasestr
 (const char *
haystack
, const char *
needle
)

840 
	`_GL_ARG_NONNULL
 ((1, 2));

843 #if @
GNULIB_MBSCSPN
@

849 
_GL_EXTERN_C
 
size_t
 
	$mbscspn
 (const char *
string
, const char *
accept
)

850 
	`_GL_ARG_NONNULL
 ((1, 2));

853 #if @
GNULIB_MBSPBRK
@

858 #if 
defined
 
__hpux


859 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

860 #define 
	#mbspbrk
 
rpl_mbspbrk


	)

862 
	`_GL_FUNCDECL_RPL
 (
mbspbrk
, char *, (const char *
string
, const char *
accept
)

863 
	`_GL_ARG_NONNULL
 ((1, 2)));

864 
	`_GL_CXXALIAS_RPL
 (
mbspbrk
, char *, (const char *
string
, const char *
accept
));

866 
	`_GL_FUNCDECL_SYS
 (
mbspbrk
, char *, (const char *
string
, const char *
accept
)

867 
	`_GL_ARG_NONNULL
 ((1, 2)));

868 
	`_GL_CXXALIAS_SYS
 (
mbspbrk
, char *, (const char *
string
, const char *
accept
));

870 
	`_GL_CXXALIASWARN
 (
mbspbrk
);

873 #if @
GNULIB_MBSSPN
@

879 
_GL_EXTERN_C
 
size_t
 
	$mbsspn
 (const char *
string
, const char *
reject
)

880 
	`_GL_ARG_NONNULL
 ((1, 2));

883 #if @
GNULIB_MBSSEP
@

898 
_GL_EXTERN_C
 char * 
	$mbssep
 (char **
stringp
, const char *
delim
)

899 
	`_GL_ARG_NONNULL
 ((1, 2));

902 #if @
GNULIB_MBSTOK_R
@

919 
_GL_EXTERN_C
 char * 
	$mbstok_r
 (char *
string
, const char *
delim
, char **
save_ptr
)

920 
	`_GL_ARG_NONNULL
 ((2, 3));

924 #if @
GNULIB_STRERROR
@

925 #if @
REPLACE_STRERROR
@

926 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

927 #undef 
strerror


928 #define 
	#strerror
 
rpl_strerror


	)

930 
	`_GL_FUNCDECL_RPL
 (
strerror
, char *, (int));

931 
	`_GL_CXXALIAS_RPL
 (
strerror
, char *, (int));

933 
	`_GL_CXXALIAS_SYS
 (
strerror
, char *, (int));

935 
	`_GL_CXXALIASWARN
 (
strerror
);

936 #elif 
defined
 
GNULIB_POSIXCHECK


937 #undef 
strerror


939 
	`_GL_WARN_ON_USE
 (
strerror
, "strerror is unportable - "

945 #if @
GNULIB_STRERROR_R
@

946 #if @
REPLACE_STRERROR_R
@

947 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

948 #undef 
strerror_r


949 #define 
	#strerror_r
 
rpl_strerror_r


	)

951 
	`_GL_FUNCDECL_RPL
 (
strerror_r
, int, (int 
errnum
, char *
buf
, 
size_t
 
buflen
)

952 
	`_GL_ARG_NONNULL
 ((2)));

953 
	`_GL_CXXALIAS_RPL
 (
strerror_r
, int, (int 
errnum
, char *
buf
, 
size_t
 
buflen
));

955 #if !@
HAVE_DECL_STRERROR_R
@

956 
	`_GL_FUNCDECL_SYS
 (
strerror_r
, int, (int 
errnum
, char *
buf
, 
size_t
 
buflen
)

957 
	`_GL_ARG_NONNULL
 ((2)));

959 
	`_GL_CXXALIAS_SYS
 (
strerror_r
, int, (int 
errnum
, char *
buf
, 
size_t
 
buflen
));

961 #if @
HAVE_DECL_STRERROR_R
@

962 
	`_GL_CXXALIASWARN
 (
strerror_r
);

964 #elif 
defined
 
GNULIB_POSIXCHECK


965 #undef 
strerror_r


966 #if 
HAVE_RAW_DECL_STRERROR_R


967 
	`_GL_WARN_ON_USE
 (
strerror_r
, "strerror_r is unportable - "

972 #if @
GNULIB_STRSIGNAL
@

973 #if @
REPLACE_STRSIGNAL
@

974 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

975 #define 
	#strsignal
 
rpl_strsignal


	)

977 
	`_GL_FUNCDECL_RPL
 (
strsignal
, char *, (int 
__sig
));

978 
	`_GL_CXXALIAS_RPL
 (
strsignal
, char *, (int 
__sig
));

980 #if ! @
HAVE_DECL_STRSIGNAL
@

981 
	`_GL_FUNCDECL_SYS
 (
strsignal
, char *, (int 
__sig
));

985 
	`_GL_CXXALIAS_SYS_CAST
 (
strsignal
, char *, (int 
__sig
));

987 
	`_GL_CXXALIASWARN
 (
strsignal
);

988 #elif 
defined
 
GNULIB_POSIXCHECK


989 #undef 
strsignal


990 #if 
HAVE_RAW_DECL_STRSIGNAL


991 
	`_GL_WARN_ON_USE
 (
strsignal
, "strsignal is unportable - "

996 #if @
GNULIB_STRVERSCMP
@

997 #if !@
HAVE_STRVERSCMP
@

998 
	`_GL_FUNCDECL_SYS
 (
strverscmp
, int, (const char *, const char *)

999 
	`_GL_ARG_NONNULL
 ((1, 2)));

1001 
	`_GL_CXXALIAS_SYS
 (
strverscmp
, int, (const char *, const char *));

1002 
	`_GL_CXXALIASWARN
 (
strverscmp
);

1003 #elif 
defined
 
GNULIB_POSIXCHECK


1004 #undef 
strverscmp


1005 #if 
HAVE_RAW_DECL_STRVERSCMP


1006 
	`_GL_WARN_ON_USE
 (
strverscmp
, "strverscmp is unportable - "

	@lib/strings.in.h

21 #ifndef 
_
@
GUARD_PREFIX
@
_STRINGS_H


23 #if 
__GNUC__
 >= 3

24 @
	gPRAGMA_SYSTEM_HEADER
@

26 @
	gPRAGMA_COLUMNS
@

30 #if 
defined
 
__minix
 && !defined 
__GLIBC__


31 #include 
	~<sys/types.h
>

35 #if @
HAVE_STRINGS_H
@

36 #@
INCLUDE_NEXT
@ @
NEXT_STRINGS_H
@

39 #ifndef 
_
@
GUARD_PREFIX
@
_STRINGS_H


40 #define 
	#_
@
GUARD_PREFIX
@
_STRINGS_H


	)

42 #if ! @
HAVE_DECL_STRNCASECMP
@

44 #include 
	~<stddef.h
>

54 #ifdef 
__cplusplus


60 #if @
GNULIB_FFS
@

61 #if !@
HAVE_FFS
@

62 
_GL_FUNCDECL_SYS
 (
ffs
, int, (int 
i
));

64 
_GL_CXXALIAS_SYS
 (
ffs
, int, (int 
i
));

65 
_GL_CXXALIASWARN
 (
ffs
);

66 #elif 
defined
 
GNULIB_POSIXCHECK


67 #undef 
ffs


68 #if 
HAVE_RAW_DECL_FFS


69 
_GL_WARN_ON_USE
 (
ffs
, "ffs is not portable - use the ffs module");

77 #if ! @
HAVE_STRCASECMP
@

78 extern int 
	$strcasecmp
 (char const *
s1
, char const *
s2
)

79 
	`_GL_ARG_NONNULL
 ((1, 2));

81 #if 
defined
 
GNULIB_POSIXCHECK


85 #undef 
strcasecmp


86 #if 
HAVE_RAW_DECL_STRCASECMP


87 
	`_GL_WARN_ON_USE
 (
strcasecmp
, "strcasecmp cannot work correctly on character "

100 #if ! @
HAVE_DECL_STRNCASECMP
@

101 extern int 
	$strncasecmp
 (char const *
s1
, char const *
s2
, 
size_t
 
n
)

102 
	`_GL_ARG_NONNULL
 ((1, 2));

104 #if 
defined
 
GNULIB_POSIXCHECK


108 #undef 
strncasecmp


109 #if 
HAVE_RAW_DECL_STRNCASECMP


110 
	`_GL_WARN_ON_USE
 (
strncasecmp
, "strncasecmp cannot work correctly on character "

120 #ifdef 
__cplusplus


121 
	}
}

	@lib/stripslash.c

19 #include 
	~<config.h
>

21 #include 
	~"dirname.h
"

30 
bool


31 
	$strip_trailing_slashes
 (char *
file
)

33 char *
base
 = 
	`last_component
 (
file
);

34 char *
base_lim
;

35 
bool
 
had_slash
;

39 if (! *
base
)

40 
base
 = 
file
;

41 
base_lim
 = 
base
 + 
	`base_len
 (base);

42 
had_slash
 = (*
base_lim
 != '\0');

43 *
base_lim
 = '\0';

44 return 
had_slash
;

45 
	}
}

	@lib/strncasecmp.c

20 #include 
	~<config.h
>

23 #include 
	~<string.h
>

25 #include 
	~<ctype.h
>

26 #include 
	~<limits.h
>

28 #define 
	#TOLOWER
(
Ch
) (
	`isupper
 (Ch) ? 
	`tolower
 (Ch) : (Ch))

	)

36 
	$strncasecmp
 (const char *
s1
, const char *
s2
, 
size_t
 
n
)

38 register const unsigned char *
p1
 = (const unsigned char *) 
s1
;

39 register const unsigned char *
p2
 = (const unsigned char *) 
s2
;

40 unsigned char 
c1
, 
c2
;

42 if (
p1
 == 
p2
 || 
n
 == 0)

47 
c1
 = 
	`TOLOWER
 (*
p1
);

48 
c2
 = 
	`TOLOWER
 (*
p2
);

50 if (--
n
 == 0 || 
c1
 == '\0')

53 ++
p1
;

54 ++
p2
;

56 while (
c1
 == 
c2
);

58 if (
UCHAR_MAX
 <= 
INT_MAX
)

59 return 
c1
 - 
c2
;

64 return (
c1
 > 
c2
 ? 1 : c1 < c2 ? -1 : 0);

65 
	}
}

	@lib/strndup.c

22 #include 
	~<config.h
>

24 #include 
	~<string.h
>

26 #include 
	~<stdlib.h
>

29 
	$strndup
 (char const *
s
, 
size_t
 
n
)

31 
size_t
 
len
 = 
	`strnlen
 (
s
, 
n
);

32 char *
new
 = 
	`malloc
 (
len
 + 1);

34 if (
new
 == 
NULL
)

35 return 
NULL
;

37 
new
[
len
] = '\0';

38 return 
	`memcpy
 (
new
, 
s
, 
len
);

39 
	}
}

	@lib/strnlen.c

21 #include 
	~<config.h
>

23 #include 
	~<string.h
>

28 
size_t


29 
	$strnlen
 (const char *
string
, 
size_t
 
maxlen
)

31 const char *
end
 = 
	`memchr
 (
string
, '\0', 
maxlen
);

32 return 
end
 ? (
size_t
) (end - 
string
) : 
maxlen
;

33 
	}
}

	@lib/strnlen1.c

17 #include 
	~<config.h
>

20 #include 
	~"strnlen1.h
"

22 #include 
	~<string.h
>

27 
size_t


28 
	$strnlen1
 (const char *
string
, 
size_t
 
maxlen
)

30 const char *
end
 = (const char *) 
	`memchr
 (
string
, '\0', 
maxlen
);

31 if (
end
 != 
NULL
)

32 return 
end
 - 
string
 + 1;

34 return 
maxlen
;

35 
	}
}

	@lib/strnlen1.h

17 #ifndef 
_STRNLEN1_H


18 #define 
	#_STRNLEN1_H


	)

20 #include 
	~<stddef.h
>

23 #ifdef 
__cplusplus


31 extern 
size_t
 
strnlen1
 (const char *
string
, size_t 
maxlen
);

34 #ifdef 
__cplusplus


	@lib/strtoimax.c

21 #include 
	~<config.h
>

24 #include 
	~<inttypes.h
>

26 #include 
	~<stdlib.h
>

28 #include 
	~"verify.h
"

30 #ifdef 
UNSIGNED


31 #ifndef 
HAVE_DECL_STRTOULL


34 #if !
HAVE_DECL_STRTOULL
 && 
HAVE_UNSIGNED_LONG_LONG_INT


35 unsigned long long int 
strtoull
 (char const *, char **, int);

40 #ifndef 
HAVE_DECL_STRTOLL


43 #if !
HAVE_DECL_STRTOLL
 && 
HAVE_LONG_LONG_INT


44 long long int 
strtoll
 (char const *, char **, int);

48 #ifdef 
UNSIGNED


49 #define 
	#Have_long_long
 
HAVE_UNSIGNED_LONG_LONG_INT


	)

50 #define 
	#Int
 
uintmax_t


	)

51 #define 
	#Unsigned
 unsigned

	)

52 #define 
	#strtoimax
 
strtoumax


	)

53 #define 
	#strtol
 
strtoul


	)

54 #define 
	#strtoll
 
strtoull


	)

56 #define 
	#Have_long_long
 
HAVE_LONG_LONG_INT


	)

57 #define 
	#Int
 
intmax_t


	)

58 #define 
	#Unsigned


	)

61 
Int


62 
	$strtoimax
 (char const *
ptr
, char **
endptr
, int 
base
)

64 #if 
Have_long_long


65 
	`verify
 (sizeof (
Int
) == sizeof (
Unsigned
 long int)

66 || sizeof (
Int
) == sizeof (
Unsigned
 long long int));

68 if (sizeof (
Int
) != sizeof (
Unsigned
 long int))

69 return 
	`strtoll
 (
ptr
, 
endptr
, 
base
);

71 
	`verify
 (sizeof (
Int
) == sizeof (
Unsigned
 long int));

74 return 
	`strtol
 (
ptr
, 
endptr
, 
base
);

75 
	}
}

	@lib/strtol.c

22 #ifdef 
_LIBC


23 #define 
	#USE_NUMBER_GROUPING


	)

25 #include 
	~<config.h
>

28 #include 
	~<ctype.h
>

29 #include 
	~<errno.h
>

30 #ifndef 
__set_errno


31 #define 
	#__set_errno
(
Val
) 
errno
 = (Val)

	)

34 #include 
	~<limits.h
>

35 #include 
	~<stddef.h
>

36 #include 
	~<stdlib.h
>

37 #include 
	~<string.h
>

39 #ifdef 
USE_NUMBER_GROUPING


40 #include 
	~"../locale/localeinfo.h
"

45 #ifndef 
UNSIGNED


46 #define 
	#UNSIGNED
 0

	)

47 #define 
	#INT
 
LONG
 int

	)

49 #define 
	#INT
 unsigned 
LONG
 int

	)

53 #ifdef 
USE_IN_EXTENDED_LOCALE_MODEL


54 #if 
UNSIGNED


55 #ifdef 
USE_WIDE_CHAR


56 #ifdef 
QUAD


57 #define 
	#strtol
 
__wcstoull_l


	)

59 #define 
	#strtol
 
__wcstoul_l


	)

62 #ifdef 
QUAD


63 #define 
	#strtol
 
__strtoull_l


	)

65 #define 
	#strtol
 
__strtoul_l


	)

69 #ifdef 
USE_WIDE_CHAR


70 #ifdef 
QUAD


71 #define 
	#strtol
 
__wcstoll_l


	)

73 #define 
	#strtol
 
__wcstol_l


	)

76 #ifdef 
QUAD


77 #define 
	#strtol
 
__strtoll_l


	)

79 #define 
	#strtol
 
__strtol_l


	)

84 #if 
UNSIGNED


85 #ifdef 
USE_WIDE_CHAR


86 #ifdef 
QUAD


87 #define 
	#strtol
 
wcstoull


	)

89 #define 
	#strtol
 
wcstoul


	)

92 #ifdef 
QUAD


93 #define 
	#strtol
 
strtoull


	)

95 #define 
	#strtol
 
strtoul


	)

99 #ifdef 
USE_WIDE_CHAR


100 #ifdef 
QUAD


101 #define 
	#strtol
 
wcstoll


	)

103 #define 
	#strtol
 
wcstol


	)

106 #ifdef 
QUAD


107 #define 
	#strtol
 
strtoll


	)

115 #ifdef 
QUAD


116 #define 
	#LONG
 long long

	)

117 #define 
	#STRTOL_LONG_MIN
 
LLONG_MIN


	)

118 #define 
	#STRTOL_LONG_MAX
 
LLONG_MAX


	)

119 #define 
	#STRTOL_ULONG_MAX
 
ULLONG_MAX


	)

128 #define 
	#TYPE_TWOS_COMPLEMENT
(
t
) ((t) ~ (t) 0 == (t) -1)

	)

129 #define 
	#TYPE_ONES_COMPLEMENT
(
t
) ((t) ~ (t) 0 == 0)

	)

130 #define 
	#TYPE_SIGNED_MAGNITUDE
(
t
) ((t) ~ (t) 0 < (t) -1)

	)

133 #define 
	#TYPE_SIGNED
(
t
) (! ((t) 0 < (t) -1))

	)

139 #define 
	#TYPE_MINIMUM
(
t
) \

140 ((
t
) (! 
	`TYPE_SIGNED
 (t) \

141 ? (
t
) 0 \

142 : 
	`TYPE_SIGNED_MAGNITUDE
 (
t
) \

143 ? ~ (
t
) 0 \

144 : ~ 
	`TYPE_MAXIMUM
 (
t
)))

	)

145 #define 
	#TYPE_MAXIMUM
(
t
) \

146 ((
t
) (! 
	`TYPE_SIGNED
 (t) \

147 ? (
t
) -1 \

148 : ((((
t
) 1 << (sizeof (t) * 
CHAR_BIT
 - 2)) - 1) * 2 + 1)))

	)

150 #ifndef 
ULLONG_MAX


151 #define 
	#ULLONG_MAX
 
	`TYPE_MAXIMUM
 (unsigned long long)

	)

153 #ifndef 
LLONG_MAX


154 #define 
	#LLONG_MAX
 
	`TYPE_MAXIMUM
 (long long int)

	)

156 #ifndef 
LLONG_MIN


157 #define 
	#LLONG_MIN
 
	`TYPE_MINIMUM
 (long long int)

	)

160 #if 
__GNUC__
 == 2 && 
__GNUC_MINOR__
 < 7

162 static const unsigned long long int 
	gmaxquad
 = 
ULLONG_MAX
;

163 #undef 
STRTOL_ULONG_MAX


164 #define 
	#STRTOL_ULONG_MAX
 
maxquad


	)

167 #define 
	#LONG
 long

	)

168 #define 
	#STRTOL_LONG_MIN
 
LONG_MIN


	)

169 #define 
	#STRTOL_LONG_MAX
 
LONG_MAX


	)

170 #define 
	#STRTOL_ULONG_MAX
 
ULONG_MAX


	)

178 #ifdef 
USE_IN_EXTENDED_LOCALE_MODEL


179 #undef 
_NL_CURRENT


180 #define 
	#_NL_CURRENT
(
category
, 
item
) \

181 (
current
->
values
[
	`_NL_ITEM_INDEX
 (
item
)].
string
)

	)

182 #define 
	#LOCALE_PARAM
 , 
loc


	)

183 #define 
	#LOCALE_PARAM_PROTO
 , 
__locale_t
 
loc


	)

185 #define 
	#LOCALE_PARAM


	)

186 #define 
	#LOCALE_PARAM_PROTO


	)

189 #ifdef 
USE_WIDE_CHAR


190 #include 
	~<wchar.h
>

191 #include 
	~<wctype.h
>

192 #define 
	#L_
(
Ch
) 
L
##
	)
Ch

193 #define 
	#UCHAR_TYPE
 
wint_t


	)

194 #define 
	#STRING_TYPE
 
wchar_t


	)

195 #ifdef 
USE_IN_EXTENDED_LOCALE_MODEL


196 #define 
	#ISSPACE
(
Ch
) 
	`__iswspace_l
 ((Ch), 
loc
)

	)

197 #define 
	#ISALPHA
(
Ch
) 
	`__iswalpha_l
 ((Ch), 
loc
)

	)

198 #define 
	#TOUPPER
(
Ch
) 
	`__towupper_l
 ((Ch), 
loc
)

	)

200 #define 
	#ISSPACE
(
Ch
) 
	`iswspace
 (Ch)

	)

201 #define 
	#ISALPHA
(
Ch
) 
	`iswalpha
 (Ch)

	)

202 #define 
	#TOUPPER
(
Ch
) 
	`towupper
 (Ch)

	)

205 #define 
	#L_
(
Ch
) 
	)
Ch

206 #define 
	#UCHAR_TYPE
 unsigned char

	)

207 #define 
	#STRING_TYPE
 char

	)

208 #ifdef 
USE_IN_EXTENDED_LOCALE_MODEL


209 #define 
	#ISSPACE
(
Ch
) 
	`__isspace_l
 ((Ch), 
loc
)

	)

210 #define 
	#ISALPHA
(
Ch
) 
	`__isalpha_l
 ((Ch), 
loc
)

	)

211 #define 
	#TOUPPER
(
Ch
) 
	`__toupper_l
 ((Ch), 
loc
)

	)

213 #define 
	#ISSPACE
(
Ch
) 
	`isspace
 (Ch)

	)

214 #define 
	#ISALPHA
(
Ch
) 
	`isalpha
 (Ch)

	)

215 #define 
	#TOUPPER
(
Ch
) 
	`toupper
 (Ch)

	)

219 #define 
	#INTERNAL
(
X
) 
	`INTERNAL1
(X)

	)

220 #define 
	#INTERNAL1
(
X
) 
__
##X##
_internal


	)

221 #define 
	#WEAKNAME
(
X
) 
	`WEAKNAME1
(X)

	)

223 #ifdef 
USE_NUMBER_GROUPING


225 #include 
	~"grouping.h
"

237 
INT


238 
	$INTERNAL
 (
strtol
) (const 
STRING_TYPE
 *
nptr
, STRING_TYPE **
endptr
,

239 int 
base
, int 
group
 
LOCALE_PARAM_PROTO
)

241 int 
negative
;

242 register unsigned 
LONG
 int 
cutoff
;

243 register unsigned int 
cutlim
;

244 register unsigned 
LONG
 int 
i
;

245 register const 
STRING_TYPE
 *
s
;

246 register 
UCHAR_TYPE
 
c
;

247 const 
STRING_TYPE
 *
save
, *
end
;

248 int 
overflow
;

250 #ifdef 
USE_NUMBER_GROUPING


251 #ifdef 
USE_IN_EXTENDED_LOCALE_MODEL


252 struct 
locale_data
 *
current
 = 
loc
->
__locales
[
LC_NUMERIC
];

255 
wchar_t
 
thousands
 = 
L
'\0';

258 const char *
grouping
;

260 if (
group
)

262 
grouping
 = 
	`_NL_CURRENT
 (
LC_NUMERIC
, 
GROUPING
);

263 if (*
grouping
 <= 0 || *grouping == 
CHAR_MAX
)

264 
grouping
 = 
NULL
;

268 #if 
defined
 
_LIBC
 || defined 
_HAVE_BTOWC


269 
thousands
 = 
	`__btowc
 (*
	`_NL_CURRENT
 (
LC_NUMERIC
, 
THOUSANDS_SEP
));

270 if (
thousands
 == 
WEOF
)

271 
thousands
 = 
L
'\0';

273 if (
thousands
 == 
L
'\0')

274 
grouping
 = 
NULL
;

278 
grouping
 = 
NULL
;

281 if (
base
 < 0 || base == 1 || base > 36)

283 
	`__set_errno
 (
EINVAL
);

287 
save
 = 
s
 = 
nptr
;

290 while (
	`ISSPACE
 (*
s
))

291 ++
s
;

292 if (*
s
 == 
	`L_
('\0'))

293 goto 
noconv
;

296 if (*
s
 == 
	`L_
('-'))

298 
negative
 = 1;

299 ++
s
;

301 else if (*
s
 == 
	`L_
('+'))

303 
negative
 = 0;

304 ++
s
;

307 
negative
 = 0;

310 if (*
s
 == 
	`L_
('0'))

312 if ((
base
 == 0 || base == 16) && 
	`TOUPPER
 (
s
[1]) == 
	`L_
('X'))

314 
s
 += 2;

315 
base
 = 16;

317 else if (
base
 == 0)

318 
base
 = 8;

320 else if (
base
 == 0)

321 
base
 = 10;

324 
save
 = 
s
;

326 #ifdef 
USE_NUMBER_GROUPING


327 if (
group
)

330 
end
 = 
s
;

331 for (
c
 = *
end
; c != 
	`L_
('\0'); c = *++end)

332 if ((
wchar_t
) 
c
 != 
thousands


333 && ((
wchar_t
) 
c
 < 
	`L_
('0') || (wchar_t) c > L_('9'))

334 && (!
	`ISALPHA
 (
c
) || (int) (
	`TOUPPER
 (c) - 
	`L_
('A') + 10) >= 
base
))

336 if (*
s
 == 
thousands
)

337 
end
 = 
s
;

339 
end
 = 
	`correctly_grouped_prefix
 (
s
, end, 
thousands
, 
grouping
);

343 
end
 = 
NULL
;

345 
cutoff
 = 
STRTOL_ULONG_MAX
 / (unsigned 
LONG
 int) 
base
;

346 
cutlim
 = 
STRTOL_ULONG_MAX
 % (unsigned 
LONG
 int) 
base
;

348 
overflow
 = 0;

349 
i
 = 0;

350 for (
c
 = *
s
; c != 
	`L_
('\0'); c = *++s)

352 if (
s
 == 
end
)

354 if (
c
 >= 
	`L_
('0') && c <= L_('9'))

355 
c
 -= 
	`L_
('0');

356 else if (
	`ISALPHA
 (
c
))

357 
c
 = 
	`TOUPPER
 (c) - 
	`L_
('A') + 10;

360 if ((int) 
c
 >= 
base
)

363 if (
i
 > 
cutoff
 || (i == cutoff && 
c
 > 
cutlim
))

364 
overflow
 = 1;

367 
i
 *= (unsigned 
LONG
 int) 
base
;

368 
i
 += 
c
;

373 if (
s
 == 
save
)

374 goto 
noconv
;

378 if (
endptr
 != 
NULL
)

379 *
endptr
 = (
STRING_TYPE
 *) 
s
;

381 #if !
UNSIGNED


384 if (
overflow
 == 0

385 && 
i
 > (
negative


386 ? -((unsigned 
LONG
 int) (
STRTOL_LONG_MIN
 + 1)) + 1

387 : (unsigned 
LONG
 int) 
STRTOL_LONG_MAX
))

388 
overflow
 = 1;

391 if (
overflow
)

393 
	`__set_errno
 (
ERANGE
);

394 #if 
UNSIGNED


395 return 
STRTOL_ULONG_MAX
;

397 return 
negative
 ? 
STRTOL_LONG_MIN
 : 
STRTOL_LONG_MAX
;

402 return 
negative
 ? -
i
 : i;

404 
noconv
:

409 if (
endptr
 != 
NULL
)

411 if (
save
 - 
nptr
 >= 2 && 
	`TOUPPER
 (save[-1]) == 
	`L_
('X')

412 && 
save
[-2] == 
	`L_
('0'))

413 *
endptr
 = (
STRING_TYPE
 *) &
save
[-1];

416 *
endptr
 = (
STRING_TYPE
 *) 
nptr
;

420 
	}
}

425 
	gINT


426 #ifdef 
weak_function


427 
	gweak_function


429 
	$strtol
 (const 
STRING_TYPE
 *
nptr
, STRING_TYPE **
endptr
,

430 int 
base
 
LOCALE_PARAM_PROTO
)

432 return 
	`INTERNAL
 (
strtol
) (
nptr
, 
endptr
, 
base
, 0 
LOCALE_PARAM
);

433 
	}
}

	@lib/strtoul.c

17 #define 
	#UNSIGNED
 1

	)

19 #include 
	~"strtol.c
"

	@lib/strtoull.c

19 #define 
	#QUAD
 1

	)

21 #include 
	~"strtoul.c
"

23 #ifdef 
_LIBC


24 
	$strong_alias
 (
__strtoull_internal
, 
__strtouq_internal
)

25 
	$weak_alias
 (
strtoull
, 
strtouq
)

	@lib/strtoumax.c

1 #define 
	#UNSIGNED
 1

	)

2 #include 
	~"strtoimax.c
"

	@lib/sys_stat.in.h

26 #if 
__GNUC__
 >= 3

27 @
	gPRAGMA_SYSTEM_HEADER
@

29 @
	gPRAGMA_COLUMNS
@

31 #if 
defined
 
__need_system_sys_stat_h


34 #@
INCLUDE_NEXT
@ @
NEXT_SYS_STAT_H
@

39 #ifndef 
_
@
GUARD_PREFIX
@
_SYS_STAT_H


42 #include 
	~<sys/types.h
>

45 #include 
	~<time.h
>

48 #@
INCLUDE_NEXT
@ @
NEXT_SYS_STAT_H
@

50 #ifndef 
_
@
GUARD_PREFIX
@
_SYS_STAT_H


51 #define 
	#_
@
GUARD_PREFIX
@
_SYS_STAT_H


	)

62 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


63 #include 
	~<io.h
>

64 #include 
	~<direct.h
>

67 #ifndef 
S_IFIFO


68 #ifdef 
_S_IFIFO


69 #define 
	#S_IFIFO
 
_S_IFIFO


	)

73 #ifndef 
S_IFMT


74 #define 
	#S_IFMT
 0170000

	)

77 #if 
STAT_MACROS_BROKEN


78 #undef 
S_ISBLK


79 #undef 
S_ISCHR


80 #undef 
S_ISDIR


81 #undef 
S_ISFIFO


82 #undef 
S_ISLNK


83 #undef 
S_ISNAM


84 #undef 
S_ISMPB


85 #undef 
S_ISMPC


86 #undef 
S_ISNWK


87 #undef 
S_ISREG


88 #undef 
S_ISSOCK


91 #ifndef 
S_ISBLK


92 #ifdef 
S_IFBLK


93 #define 
	#S_ISBLK
(
m
) (((m) & 
S_IFMT
) == 
S_IFBLK
)

	)

95 #define 
	#S_ISBLK
(
m
) 0

	)

99 #ifndef 
S_ISCHR


100 #ifdef 
S_IFCHR


101 #define 
	#S_ISCHR
(
m
) (((m) & 
S_IFMT
) == 
S_IFCHR
)

	)

103 #define 
	#S_ISCHR
(
m
) 0

	)

107 #ifndef 
S_ISDIR


108 #ifdef 
S_IFDIR


109 #define 
	#S_ISDIR
(
m
) (((m) & 
S_IFMT
) == 
S_IFDIR
)

	)

111 #define 
	#S_ISDIR
(
m
) 0

	)

115 #ifndef 
S_ISDOOR


116 #define 
	#S_ISDOOR
(
m
) 0

	)

119 #ifndef 
S_ISFIFO


120 #ifdef 
S_IFIFO


121 #define 
	#S_ISFIFO
(
m
) (((m) & 
S_IFMT
) == 
S_IFIFO
)

	)

123 #define 
	#S_ISFIFO
(
m
) 0

	)

127 #ifndef 
S_ISLNK


128 #ifdef 
S_IFLNK


129 #define 
	#S_ISLNK
(
m
) (((m) & 
S_IFMT
) == 
S_IFLNK
)

	)

131 #define 
	#S_ISLNK
(
m
) 0

	)

135 #ifndef 
S_ISMPB


136 #ifdef 
S_IFMPB


137 #define 
	#S_ISMPB
(
m
) (((m) & 
S_IFMT
) == 
S_IFMPB
)

	)

138 #define 
	#S_ISMPC
(
m
) (((m) & 
S_IFMT
) == 
S_IFMPC
)

	)

140 #define 
	#S_ISMPB
(
m
) 0

	)

141 #define 
	#S_ISMPC
(
m
) 0

	)

145 #ifndef 
S_ISNAM


146 #ifdef 
S_IFNAM


147 #define 
	#S_ISNAM
(
m
) (((m) & 
S_IFMT
) == 
S_IFNAM
)

	)

149 #define 
	#S_ISNAM
(
m
) 0

	)

153 #ifndef 
S_ISNWK


154 #ifdef 
S_IFNWK


155 #define 
	#S_ISNWK
(
m
) (((m) & 
S_IFMT
) == 
S_IFNWK
)

	)

157 #define 
	#S_ISNWK
(
m
) 0

	)

161 #ifndef 
S_ISPORT


162 #define 
	#S_ISPORT
(
m
) 0

	)

165 #ifndef 
S_ISREG


166 #ifdef 
S_IFREG


167 #define 
	#S_ISREG
(
m
) (((m) & 
S_IFMT
) == 
S_IFREG
)

	)

169 #define 
	#S_ISREG
(
m
) 0

	)

173 #ifndef 
S_ISSOCK


174 #ifdef 
S_IFSOCK


175 #define 
	#S_ISSOCK
(
m
) (((m) & 
S_IFMT
) == 
S_IFSOCK
)

	)

177 #define 
	#S_ISSOCK
(
m
) 0

	)

182 #ifndef 
S_TYPEISMQ


183 #define 
	#S_TYPEISMQ
(
p
) 0

	)

186 #ifndef 
S_TYPEISTMO


187 #define 
	#S_TYPEISTMO
(
p
) 0

	)

191 #ifndef 
S_TYPEISSEM


192 #ifdef 
S_INSEM


193 #define 
	#S_TYPEISSEM
(
p
) (
	`S_ISNAM
 ((p)->
st_mode
) && (p)->
st_rdev
 == 
S_INSEM
)

	)

195 #define 
	#S_TYPEISSEM
(
p
) 0

	)

199 #ifndef 
S_TYPEISSHM


200 #ifdef 
S_INSHD


201 #define 
	#S_TYPEISSHM
(
p
) (
	`S_ISNAM
 ((p)->
st_mode
) && (p)->
st_rdev
 == 
S_INSHD
)

	)

203 #define 
	#S_TYPEISSHM
(
p
) 0

	)

208 #ifndef 
S_ISCTG


209 #define 
	#S_ISCTG
(
p
) 0

	)

213 #ifndef 
S_ISOFD


214 #define 
	#S_ISOFD
(
p
) 0

	)

218 #ifndef 
S_ISOFL


219 #define 
	#S_ISOFL
(
p
) 0

	)

223 #ifndef 
S_ISWHT


224 #define 
	#S_ISWHT
(
m
) 0

	)

229 #if !
S_ISUID


230 #define 
	#S_ISUID
 04000

	)

232 #if !
S_ISGID


233 #define 
	#S_ISGID
 02000

	)

237 #ifndef 
S_ISVTX


238 #define 
	#S_ISVTX
 01000

	)

241 #if !
S_IRUSR
 && 
S_IREAD


242 #define 
	#S_IRUSR
 
S_IREAD


	)

244 #if !
S_IRUSR


245 #define 
	#S_IRUSR
 00400

	)

247 #if !
S_IRGRP


248 #define 
	#S_IRGRP
 (
S_IRUSR
 >> 3)

	)

250 #if !
S_IROTH


251 #define 
	#S_IROTH
 (
S_IRUSR
 >> 6)

	)

254 #if !
S_IWUSR
 && 
S_IWRITE


255 #define 
	#S_IWUSR
 
S_IWRITE


	)

257 #if !
S_IWUSR


258 #define 
	#S_IWUSR
 00200

	)

260 #if !
S_IWGRP


261 #define 
	#S_IWGRP
 (
S_IWUSR
 >> 3)

	)

263 #if !
S_IWOTH


264 #define 
	#S_IWOTH
 (
S_IWUSR
 >> 6)

	)

267 #if !
S_IXUSR
 && 
S_IEXEC


268 #define 
	#S_IXUSR
 
S_IEXEC


	)

270 #if !
S_IXUSR


271 #define 
	#S_IXUSR
 00100

	)

273 #if !
S_IXGRP


274 #define 
	#S_IXGRP
 (
S_IXUSR
 >> 3)

	)

276 #if !
S_IXOTH


277 #define 
	#S_IXOTH
 (
S_IXUSR
 >> 6)

	)

280 #if !
S_IRWXU


281 #define 
	#S_IRWXU
 (
S_IRUSR
 | 
S_IWUSR
 | 
S_IXUSR
)

	)

283 #if !
S_IRWXG


284 #define 
	#S_IRWXG
 (
S_IRGRP
 | 
S_IWGRP
 | 
S_IXGRP
)

	)

286 #if !
S_IRWXO


287 #define 
	#S_IRWXO
 (
S_IROTH
 | 
S_IWOTH
 | 
S_IXOTH
)

	)

291 #if !
S_IXUGO


292 #define 
	#S_IXUGO
 (
S_IXUSR
 | 
S_IXGRP
 | 
S_IXOTH
)

	)

295 #ifndef 
S_IRWXUGO


296 #define 
	#S_IRWXUGO
 (
S_IRWXU
 | 
S_IRWXG
 | 
S_IRWXO
)

	)

300 #ifndef 
UTIME_NOW


301 #define 
	#UTIME_NOW
 (-1)

	)

302 #define 
	#UTIME_OMIT
 (-2)

	)

306 #if @
GNULIB_FCHMODAT
@

307 #if !@
HAVE_FCHMODAT
@

308 
_GL_FUNCDECL_SYS
 (
fchmodat
, int,

309 (int 
fd
, char const *
file
, 
mode_t
 
mode
, int 
flag
)

310 
_GL_ARG_NONNULL
 ((2)));

312 
_GL_CXXALIAS_SYS
 (
fchmodat
, int,

313 (int 
fd
, char const *
file
, 
mode_t
 
mode
, int 
flag
));

314 
_GL_CXXALIASWARN
 (
fchmodat
);

315 #elif 
defined
 
GNULIB_POSIXCHECK


316 #undef 
fchmodat


317 #if 
HAVE_RAW_DECL_FCHMODAT


318 
_GL_WARN_ON_USE
 (
fchmodat
, "fchmodat is not portable - "

324 #if @
GNULIB_FSTAT
@

325 #if @
REPLACE_FSTAT
@

326 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

327 #undef 
fstat


328 #define 
	#fstat
 
rpl_fstat


	)

330 
_GL_FUNCDECL_RPL
 (
fstat
, int, (int 
fd
, struct 
stat
 *
buf
) 
_GL_ARG_NONNULL
 ((2)));

331 
_GL_CXXALIAS_RPL
 (
fstat
, int, (int 
fd
, struct 
stat
 *
buf
));

333 
_GL_CXXALIAS_SYS
 (
fstat
, int, (int 
fd
, struct 
stat
 *
buf
));

335 
_GL_CXXALIASWARN
 (
fstat
);

336 #elif 
defined
 
GNULIB_POSIXCHECK


337 #undef 
fstat


338 #if 
HAVE_RAW_DECL_FSTAT


339 
_GL_WARN_ON_USE
 (
fstat
, "fstat has portability problems - "

345 #if @
GNULIB_FSTATAT
@

346 #if @
REPLACE_FSTATAT
@

347 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

348 #undef 
fstatat


349 #define 
	#fstatat
 
rpl_fstatat


	)

351 
_GL_FUNCDECL_RPL
 (
fstatat
, int,

352 (int 
fd
, char const *
name
, struct 
stat
 *
st
, int 
flags
)

353 
_GL_ARG_NONNULL
 ((2, 3)));

354 
_GL_CXXALIAS_RPL
 (
fstatat
, int,

355 (int 
fd
, char const *
name
, struct 
stat
 *
st
, int 
flags
));

357 #if !@
HAVE_FSTATAT
@

358 
_GL_FUNCDECL_SYS
 (
fstatat
, int,

359 (int 
fd
, char const *
name
, struct 
stat
 *
st
, int 
flags
)

360 
_GL_ARG_NONNULL
 ((2, 3)));

362 
_GL_CXXALIAS_SYS
 (
fstatat
, int,

363 (int 
fd
, char const *
name
, struct 
stat
 *
st
, int 
flags
));

365 
_GL_CXXALIASWARN
 (
fstatat
);

366 #elif 
defined
 
GNULIB_POSIXCHECK


367 #undef 
fstatat


368 #if 
HAVE_RAW_DECL_FSTATAT


369 
_GL_WARN_ON_USE
 (
fstatat
, "fstatat is not portable - "

375 #if @
GNULIB_FUTIMENS
@

380 #if @
REPLACE_FUTIMENS
@ || (!@
HAVE_FUTIMENS
@ && 
defined
 
__sun
)

381 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

382 #undef 
futimens


383 #define 
	#futimens
 
rpl_futimens


	)

385 
_GL_FUNCDECL_RPL
 (
futimens
, int, (int 
fd
, struct 
timespec
 const 
times
[2]));

386 
_GL_CXXALIAS_RPL
 (
futimens
, int, (int 
fd
, struct 
timespec
 const 
times
[2]));

388 #if !@
HAVE_FUTIMENS
@

389 
_GL_FUNCDECL_SYS
 (
futimens
, int, (int 
fd
, struct 
timespec
 const 
times
[2]));

391 
_GL_CXXALIAS_SYS
 (
futimens
, int, (int 
fd
, struct 
timespec
 const 
times
[2]));

393 #if @
HAVE_FUTIMENS
@

394 
_GL_CXXALIASWARN
 (
futimens
);

396 #elif 
defined
 
GNULIB_POSIXCHECK


397 #undef 
futimens


398 #if 
HAVE_RAW_DECL_FUTIMENS


399 
_GL_WARN_ON_USE
 (
futimens
, "futimens is not portable - "

405 #if @
GNULIB_LCHMOD
@

408 #if !@
HAVE_LCHMOD
@

416 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

417 #define 
	#lchmod
 
chmod


	)

421 
_GL_CXXALIAS_RPL_CAST_1
 (
lchmod
, 
chmod
, int,

422 (const char *
filename
, 
mode_t
 
mode
));

425 
_GL_FUNCDECL_SYS
 (
lchmod
, int, (const char *
filename
, 
mode_t
 
mode
)

426 
_GL_ARG_NONNULL
 ((1)));

428 
_GL_CXXALIAS_SYS
 (
lchmod
, int, (const char *
filename
, 
mode_t
 
mode
));

430 #if @
HAVE_LCHMOD
@

431 
_GL_CXXALIASWARN
 (
lchmod
);

433 #elif 
defined
 
GNULIB_POSIXCHECK


434 #undef 
lchmod


435 #if 
HAVE_RAW_DECL_LCHMOD


436 
_GL_WARN_ON_USE
 (
lchmod
, "lchmod is unportable - "

442 #if @
GNULIB_LSTAT
@

443 #if ! @
HAVE_LSTAT
@

446 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

447 #define 
	#lstat
 
stat


	)

449 
_GL_CXXALIAS_RPL_1
 (
lstat
, 
stat
, int, (const char *
name
, struct stat *
buf
));

450 #elif @
REPLACE_LSTAT
@

451 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

452 #undef 
lstat


453 #define 
	#lstat
 
rpl_lstat


	)

455 
_GL_FUNCDECL_RPL
 (
lstat
, int, (const char *
name
, struct 
stat
 *
buf
)

456 
_GL_ARG_NONNULL
 ((1, 2)));

457 
_GL_CXXALIAS_RPL
 (
lstat
, int, (const char *
name
, struct 
stat
 *
buf
));

459 
_GL_CXXALIAS_SYS
 (
lstat
, int, (const char *
name
, struct 
stat
 *
buf
));

461 #if @
HAVE_LSTAT
@

462 
_GL_CXXALIASWARN
 (
lstat
);

464 #elif 
defined
 
GNULIB_POSIXCHECK


465 #undef 
lstat


466 #if 
HAVE_RAW_DECL_LSTAT


467 
_GL_WARN_ON_USE
 (
lstat
, "lstat is unportable - "

473 #if @
REPLACE_MKDIR
@

474 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

475 #undef 
mkdir


476 #define 
	#mkdir
 
rpl_mkdir


	)

478 
_GL_FUNCDECL_RPL
 (
mkdir
, int, (char const *
name
, 
mode_t
 
mode
)

479 
_GL_ARG_NONNULL
 ((1)));

480 
_GL_CXXALIAS_RPL
 (
mkdir
, int, (char const *
name
, 
mode_t
 
mode
));

486 #if (
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__


488 #if !
GNULIB_defined_rpl_mkdir


489 static 
inline
 int

490 
	$rpl_mkdir
 (char const *
name
, 
mode_t
 
mode
)

492 return 
	`_mkdir
 (
name
);

493 
	}
}

494 #define 
	#GNULIB_defined_rpl_mkdir
 1

	)

497 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

498 #define 
	#mkdir
 
rpl_mkdir


	)

500 
_GL_CXXALIAS_RPL
 (
mkdir
, int, (char const *
name
, 
mode_t
 
mode
));

502 
_GL_CXXALIAS_SYS
 (
mkdir
, int, (char const *
name
, 
mode_t
 
mode
));

505 
_GL_CXXALIASWARN
 (
mkdir
);

508 #if @
GNULIB_MKDIRAT
@

509 #if !@
HAVE_MKDIRAT
@

510 
_GL_FUNCDECL_SYS
 (
mkdirat
, int, (int 
fd
, char const *
file
, 
mode_t
 
mode
)

511 
_GL_ARG_NONNULL
 ((2)));

513 
_GL_CXXALIAS_SYS
 (
mkdirat
, int, (int 
fd
, char const *
file
, 
mode_t
 
mode
));

514 
_GL_CXXALIASWARN
 (
mkdirat
);

515 #elif 
defined
 
GNULIB_POSIXCHECK


516 #undef 
mkdirat


517 #if 
HAVE_RAW_DECL_MKDIRAT


518 
_GL_WARN_ON_USE
 (
mkdirat
, "mkdirat is not portable - "

524 #if @
GNULIB_MKFIFO
@

525 #if @
REPLACE_MKFIFO
@

526 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

527 #undef 
mkfifo


528 #define 
	#mkfifo
 
rpl_mkfifo


	)

530 
_GL_FUNCDECL_RPL
 (
mkfifo
, int, (char const *
file
, 
mode_t
 
mode
)

531 
_GL_ARG_NONNULL
 ((1)));

532 
_GL_CXXALIAS_RPL
 (
mkfifo
, int, (char const *
file
, 
mode_t
 
mode
));

534 #if !@
HAVE_MKFIFO
@

535 
_GL_FUNCDECL_SYS
 (
mkfifo
, int, (char const *
file
, 
mode_t
 
mode
)

536 
_GL_ARG_NONNULL
 ((1)));

538 
_GL_CXXALIAS_SYS
 (
mkfifo
, int, (char const *
file
, 
mode_t
 
mode
));

540 
_GL_CXXALIASWARN
 (
mkfifo
);

541 #elif 
defined
 
GNULIB_POSIXCHECK


542 #undef 
mkfifo


543 #if 
HAVE_RAW_DECL_MKFIFO


544 
_GL_WARN_ON_USE
 (
mkfifo
, "mkfifo is not portable - "

550 #if @
GNULIB_MKFIFOAT
@

551 #if !@
HAVE_MKFIFOAT
@

552 
_GL_FUNCDECL_SYS
 (
mkfifoat
, int, (int 
fd
, char const *
file
, 
mode_t
 
mode
)

553 
_GL_ARG_NONNULL
 ((2)));

555 
_GL_CXXALIAS_SYS
 (
mkfifoat
, int, (int 
fd
, char const *
file
, 
mode_t
 
mode
));

556 
_GL_CXXALIASWARN
 (
mkfifoat
);

557 #elif 
defined
 
GNULIB_POSIXCHECK


558 #undef 
mkfifoat


559 #if 
HAVE_RAW_DECL_MKFIFOAT


560 
_GL_WARN_ON_USE
 (
mkfifoat
, "mkfifoat is not portable - "

566 #if @
GNULIB_MKNOD
@

567 #if @
REPLACE_MKNOD
@

568 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

569 #undef 
mknod


570 #define 
	#mknod
 
rpl_mknod


	)

572 
_GL_FUNCDECL_RPL
 (
mknod
, int, (char const *
file
, 
mode_t
 
mode
, 
dev_t
 
dev
)

573 
_GL_ARG_NONNULL
 ((1)));

574 
_GL_CXXALIAS_RPL
 (
mknod
, int, (char const *
file
, 
mode_t
 
mode
, 
dev_t
 
dev
));

576 #if !@
HAVE_MKNOD
@

577 
_GL_FUNCDECL_SYS
 (
mknod
, int, (char const *
file
, 
mode_t
 
mode
, 
dev_t
 
dev
)

578 
_GL_ARG_NONNULL
 ((1)));

581 
_GL_CXXALIAS_SYS_CAST
 (
mknod
, int, (char const *
file
, 
mode_t
 
mode
, 
dev_t
 
dev
));

583 
_GL_CXXALIASWARN
 (
mknod
);

584 #elif 
defined
 
GNULIB_POSIXCHECK


585 #undef 
mknod


586 #if 
HAVE_RAW_DECL_MKNOD


587 
_GL_WARN_ON_USE
 (
mknod
, "mknod is not portable - "

593 #if @
GNULIB_MKNODAT
@

594 #if !@
HAVE_MKNODAT
@

595 
_GL_FUNCDECL_SYS
 (
mknodat
, int,

596 (int 
fd
, char const *
file
, 
mode_t
 
mode
, 
dev_t
 
dev
)

597 
_GL_ARG_NONNULL
 ((2)));

599 
_GL_CXXALIAS_SYS
 (
mknodat
, int,

600 (int 
fd
, char const *
file
, 
mode_t
 
mode
, 
dev_t
 
dev
));

601 
_GL_CXXALIASWARN
 (
mknodat
);

602 #elif 
defined
 
GNULIB_POSIXCHECK


603 #undef 
mknodat


604 #if 
HAVE_RAW_DECL_MKNODAT


605 
_GL_WARN_ON_USE
 (
mknodat
, "mknodat is not portable - "

611 #if @
GNULIB_STAT
@

612 #if @
REPLACE_STAT
@

616 #undef 
stat


617 #ifdef 
_LARGE_FILES


620 #define 
	#stat
 
stat64


	)

621 #undef 
stat64


622 #define 
	#stat64
(
name
, 
st
) 
	`rpl_stat
 (name, st)

	)

624 #define 
	#stat
(
name
, 
st
) 
	`rpl_stat
 (name, st)

	)

626 
_GL_EXTERN_C
 int 
	$stat
 (const char *
name
, struct 
stat
 *
buf
)

627 
	`_GL_ARG_NONNULL
 ((1, 2));

629 #elif 
defined
 
GNULIB_POSIXCHECK


630 #undef 
stat


631 #if 
HAVE_RAW_DECL_STAT


632 
	`_GL_WARN_ON_USE
 (
stat
, "stat is unportable - "

638 #if @
GNULIB_UTIMENSAT
@

643 #if @
REPLACE_UTIMENSAT
@ || (!@
HAVE_UTIMENSAT
@ && 
defined
 
__sun
)

644 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

645 #undef 
utimensat


646 #define 
	#utimensat
 
rpl_utimensat


	)

648 
	`_GL_FUNCDECL_RPL
 (
utimensat
, int, (int 
fd
, char const *
name
,

649 struct 
timespec
 const 
times
[2], int 
flag
)

650 
	`_GL_ARG_NONNULL
 ((2)));

651 
	`_GL_CXXALIAS_RPL
 (
utimensat
, int, (int 
fd
, char const *
name
,

652 struct 
timespec
 const 
times
[2], int 
flag
));

654 #if !@
HAVE_UTIMENSAT
@

655 
	`_GL_FUNCDECL_SYS
 (
utimensat
, int, (int 
fd
, char const *
name
,

656 struct 
timespec
 const 
times
[2], int 
flag
)

657 
	`_GL_ARG_NONNULL
 ((2)));

659 
	`_GL_CXXALIAS_SYS
 (
utimensat
, int, (int 
fd
, char const *
name
,

660 struct 
timespec
 const 
times
[2], int 
flag
));

662 #if @
HAVE_UTIMENSAT
@

663 
	`_GL_CXXALIASWARN
 (
utimensat
);

665 #elif 
defined
 
GNULIB_POSIXCHECK


666 #undef 
utimensat


667 #if 
HAVE_RAW_DECL_UTIMENSAT


668 
	`_GL_WARN_ON_USE
 (
utimensat
, "utimensat is not portable - "

	@lib/sys_types.in.h

21 #if 
__GNUC__
 >= 3

22 @
	gPRAGMA_SYSTEM_HEADER
@

24 @
	gPRAGMA_COLUMNS
@

26 #ifndef 
_
@
GUARD_PREFIX
@
_SYS_TYPES_H


29 #@
INCLUDE_NEXT
@ @
NEXT_SYS_TYPES_H
@

31 #ifndef 
_
@
GUARD_PREFIX
@
_SYS_TYPES_H


32 #define 
	#_
@
GUARD_PREFIX
@
_SYS_TYPES_H


	)

36 #if ((
defined
 
_WIN32
 || defined 
__WIN32__
) && ! defined 
__CYGWIN__
) \

37 && ! 
defined
 
	g__GLIBC__


38 #include 
	~<stddef.h
>

	@lib/time.in.h

21 #if 
__GNUC__
 >= 3

22 @
	gPRAGMA_SYSTEM_HEADER
@

24 @
	gPRAGMA_COLUMNS
@

31 #if (
defined
 
__need_time_t
 || defined 
__need_clock_t
 \

32 || 
defined
 
	g__need_timespec
 \

33 || 
defined
 
	g_
@
	gGUARD_PREFIX
@
	g_TIME_H
)

35 #@
INCLUDE_NEXT
@ @
NEXT_TIME_H
@

39 #define 
	#_
@
GUARD_PREFIX
@
_TIME_H


	)

41 #@
INCLUDE_NEXT
@ @
NEXT_TIME_H
@

44 #include 
	~<stddef.h
>

56 #if ! @
TIME_H_DEFINES_STRUCT_TIMESPEC
@

57 #if @
SYS_TIME_H_DEFINES_STRUCT_TIMESPEC
@

58 #include 
	~<sys/time.h
>

59 #elif @
PTHREAD_H_DEFINES_STRUCT_TIMESPEC
@

60 #include 
	~<pthread.h
>

62 #undef 
asctime_r


63 #undef 
ctime_r


64 #undef 
gmtime_r


65 #undef 
localtime_r


66 #undef 
rand_r


67 #undef 
strtok_r


70 #ifdef 
__cplusplus


74 #if !
GNULIB_defined_struct_timespec


75 #undef 
timespec


76 #define 
	#timespec
 
rpl_timespec


	)

77 struct 
	stimespec


79 
time_t
 
tv_sec
;

80 long int 
tv_nsec
;

82 #define 
	#GNULIB_defined_struct_timespec
 1

	)

85 #ifdef 
__cplusplus


92 #if !
GNULIB_defined_struct_time_t_must_be_integral


98 struct 
	s__time_t_must_be_integral
 {

99 unsigned int 
	m__floating_time_t_unsupported
 : (
time_t
) 1;

101 #define 
	#GNULIB_defined_struct_time_t_must_be_integral
 1

	)

107 #if @
GNULIB_NANOSLEEP
@

108 #if @
REPLACE_NANOSLEEP
@

109 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

110 #define 
	#nanosleep
 
rpl_nanosleep


	)

112 
_GL_FUNCDECL_RPL
 (
nanosleep
, int,

113 (struct 
timespec
 const *
__rqtp
, struct timespec *
__rmtp
)

114 
_GL_ARG_NONNULL
 ((1)));

115 
_GL_CXXALIAS_RPL
 (
nanosleep
, int,

116 (struct 
timespec
 const *
__rqtp
, struct timespec *
__rmtp
));

118 #if ! @
HAVE_NANOSLEEP
@

119 
_GL_FUNCDECL_SYS
 (
nanosleep
, int,

120 (struct 
timespec
 const *
__rqtp
, struct timespec *
__rmtp
)

121 
_GL_ARG_NONNULL
 ((1)));

123 
_GL_CXXALIAS_SYS
 (
nanosleep
, int,

124 (struct 
timespec
 const *
__rqtp
, struct timespec *
__rmtp
));

126 
_GL_CXXALIASWARN
 (
nanosleep
);

130 #if @
GNULIB_MKTIME
@

131 #if @
REPLACE_MKTIME
@

132 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

133 #define 
	#mktime
 
rpl_mktime


	)

135 
_GL_FUNCDECL_RPL
 (
mktime
, 
time_t
, (struct 
tm
 *
__tp
) 
_GL_ARG_NONNULL
 ((1)));

136 
_GL_CXXALIAS_RPL
 (
mktime
, 
time_t
, (struct 
tm
 *
__tp
));

138 
_GL_CXXALIAS_SYS
 (
mktime
, 
time_t
, (struct 
tm
 *
__tp
));

140 
_GL_CXXALIASWARN
 (
mktime
);

146 #if @
GNULIB_TIME_R
@

147 #if @
REPLACE_LOCALTIME_R
@

148 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

149 #undef 
localtime_r


150 #define 
	#localtime_r
 
rpl_localtime_r


	)

152 
_GL_FUNCDECL_RPL
 (
localtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

153 struct 
tm
 *
restrict
 
__result
)

154 
_GL_ARG_NONNULL
 ((1, 2)));

155 
_GL_CXXALIAS_RPL
 (
localtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

156 struct 
tm
 *
restrict
 
__result
));

158 #if ! @
HAVE_DECL_LOCALTIME_R
@

159 
_GL_FUNCDECL_SYS
 (
localtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

160 struct 
tm
 *
restrict
 
__result
)

161 
_GL_ARG_NONNULL
 ((1, 2)));

163 
_GL_CXXALIAS_SYS
 (
localtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

164 struct 
tm
 *
restrict
 
__result
));

166 #if @
HAVE_DECL_LOCALTIME_R
@

167 
_GL_CXXALIASWARN
 (
localtime_r
);

169 #if @
REPLACE_LOCALTIME_R
@

170 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

171 #undef 
gmtime_r


172 #define 
	#gmtime_r
 
rpl_gmtime_r


	)

174 
_GL_FUNCDECL_RPL
 (
gmtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

175 struct 
tm
 *
restrict
 
__result
)

176 
_GL_ARG_NONNULL
 ((1, 2)));

177 
_GL_CXXALIAS_RPL
 (
gmtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

178 struct 
tm
 *
restrict
 
__result
));

180 #if ! @
HAVE_DECL_LOCALTIME_R
@

181 
_GL_FUNCDECL_SYS
 (
gmtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

182 struct 
tm
 *
restrict
 
__result
)

183 
_GL_ARG_NONNULL
 ((1, 2)));

185 
_GL_CXXALIAS_SYS
 (
gmtime_r
, struct 
tm
 *, (
time_t
 const *
restrict
 
__timer
,

186 struct 
tm
 *
restrict
 
__result
));

188 #if @
HAVE_DECL_LOCALTIME_R
@

189 
_GL_CXXALIASWARN
 (
gmtime_r
);

196 #if @
GNULIB_STRPTIME
@

197 #if ! @
HAVE_STRPTIME
@

198 
_GL_FUNCDECL_SYS
 (
strptime
, char *, (char const *
restrict
 
__buf
,

199 char const *
restrict
 
__format
,

200 struct 
tm
 *
restrict
 
__tm
)

201 
_GL_ARG_NONNULL
 ((1, 2, 3)));

203 
_GL_CXXALIAS_SYS
 (
strptime
, char *, (char const *
restrict
 
__buf
,

204 char const *
restrict
 
__format
,

205 struct 
tm
 *
restrict
 
__tm
));

206 
_GL_CXXALIASWARN
 (
strptime
);

210 #if @
GNULIB_TIMEGM
@

211 #if @
REPLACE_TIMEGM
@

212 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

213 #undef 
timegm


214 #define 
	#timegm
 
rpl_timegm


	)

216 
_GL_FUNCDECL_RPL
 (
timegm
, 
time_t
, (struct 
tm
 *
__tm
) 
_GL_ARG_NONNULL
 ((1)));

217 
_GL_CXXALIAS_RPL
 (
timegm
, 
time_t
, (struct 
tm
 *
__tm
));

219 #if ! @
HAVE_TIMEGM
@

220 
_GL_FUNCDECL_SYS
 (
timegm
, 
time_t
, (struct 
tm
 *
__tm
) 
_GL_ARG_NONNULL
 ((1)));

222 
_GL_CXXALIAS_SYS
 (
timegm
, 
time_t
, (struct 
tm
 *
__tm
));

224 
_GL_CXXALIASWARN
 (
timegm
);

230 #if 
defined
 
GNULIB_POSIXCHECK


231 #undef 
asctime


232 
_GL_WARN_ON_USE
 (
asctime
, "asctime can overrun buffers in some cases - "

235 #if 
defined
 
GNULIB_POSIXCHECK


236 #undef 
asctime_r


237 
_GL_WARN_ON_USE
 (
asctime
, "asctime_r can overrun buffers in some cases - "

240 #if 
defined
 
GNULIB_POSIXCHECK


241 #undef 
ctime


242 
_GL_WARN_ON_USE
 (
asctime
, "ctime can overrun buffers in some cases - "

245 #if 
defined
 
GNULIB_POSIXCHECK


246 #undef 
ctime_r


247 
_GL_WARN_ON_USE
 (
asctime
, "ctime_r can overrun buffers in some cases - "

	@lib/trim.c

19 #include 
	~<config.h
>

22 #include 
	~"trim.h
"

24 #include 
	~<ctype.h
>

25 #include 
	~<string.h
>

26 #include 
	~<stddef.h
>

27 #include 
	~<stdlib.h
>

29 #include 
	~"mbchar.h
"

30 #include 
	~"mbiter.h
"

31 #include 
	~"xalloc.h
"

34 #ifdef 
lint


35 #define 
	#IF_LINT
(
Code
) 
	)
Code

37 #define 
	#IF_LINT
(
Code
)

	)

41 
	$trim2
 (const char *
s
, int 
how
)

43 char *
d
;

45 
d
 = 
	`strdup
 (
s
);

47 if (!
d
)

48 
	`xalloc_die
 ();

50 if (
MB_CUR_MAX
 > 1)

52 
mbi_iterator_t
 
i
;

55 if (
how
 != 
TRIM_TRAILING
)

57 
	`mbi_init
 (
i
, 
d
, 
	`strlen
 (d));

59 for (; 
	`mbi_avail
 (
i
) && 
	`mb_isspace
 (
	`mbi_cur
 (i)); 
	`mbi_advance
 (i))

62 
	`memmove
 (
d
, 
	`mbi_cur_ptr
 (
i
), 
	`strlen
 (mbi_cur_ptr (i)) + 1);

66 if (
how
 != 
TRIM_LEADING
)

68 unsigned int 
state
 = 0;

69 char *
r
 
	`IF_LINT
 (= 
NULL
);

71 
	`mbi_init
 (
i
, 
d
, 
	`strlen
 (d));

73 for (; 
	`mbi_avail
 (
i
); 
	`mbi_advance
 (i))

75 if (
state
 == 0 && 
	`mb_isspace
 (
	`mbi_cur
 (
i
)))

78 if (
state
 == 0 && !
	`mb_isspace
 (
	`mbi_cur
 (
i
)))

80 
state
 = 1;

84 if (
state
 == 1 && !
	`mb_isspace
 (
	`mbi_cur
 (
i
)))

87 if (
state
 == 1 && 
	`mb_isspace
 (
	`mbi_cur
 (
i
)))

89 
state
 = 2;

90 
r
 = (char *) 
	`mbi_cur_ptr
 (
i
);

92 else if (
state
 == 2 && 
	`mb_isspace
 (
	`mbi_cur
 (
i
)))

98 
state
 = 1;

102 if (
state
 == 2)

103 *
r
 = '\0';

108 char *
p
;

111 if (
how
 != 
TRIM_TRAILING
)

113 for (
p
 = 
d
; *p && 
	`isspace
 ((unsigned char) *p); p++)

116 
	`memmove
 (
d
, 
p
, 
	`strlen
 (p) + 1);

120 if (
how
 != 
TRIM_LEADING
)

122 for (
p
 = 
d
 + 
	`strlen
 (d) - 1;

123 
p
 >= 
d
 && 
	`isspace
 ((unsigned char) *p); p--)

124 *
p
 = '\0';

128 return 
d
;

129 
	}
}

	@lib/trim.h

20 #define 
	#TRIM_TRAILING
 0

	)

21 #define 
	#TRIM_LEADING
 1

	)

22 #define 
	#TRIM_BOTH
 2

	)

25 #define 
	#trim
(
s
) 
	`trim2
(s, 
TRIM_BOTH
)

	)

28 #define 
	#trim_trailing
(
s
) 
	`trim2
(s, 
TRIM_TRAILING
)

	)

31 #define 
	#trim_leading
(
s
) 
	`trim2
(s, 
TRIM_LEADING
)

	)

33 char *
trim2
 (const char *, int);

	@lib/unistd.in.h

20 #if 
__GNUC__
 >= 3

21 @
	gPRAGMA_SYSTEM_HEADER
@

23 @
	gPRAGMA_COLUMNS
@

29 #if @
GNULIB_GETHOSTNAME
@ && @
UNISTD_H_HAVE_WINSOCK2_H
@ \

30 && !
defined
 
	g_GL_WINSOCK2_H_WITNESS
 && defined 
	g_WINSOCK2_H


33 #if @
HAVE_UNISTD_H
@

34 #@
INCLUDE_NEXT
@ @
NEXT_UNISTD_H
@

36 #error 
unexpected
; 
report
 
this
 
to
 
bug
-
gnulib
@
gnu
.
org


38 #define 
	#_GL_WINSOCK2_H_WITNESS


	)

41 #elif !
defined
 
_
@
GUARD_PREFIX
@
_UNISTD_H


44 #if @
HAVE_UNISTD_H
@

45 #@
INCLUDE_NEXT
@ @
NEXT_UNISTD_H
@

49 #if @
GNULIB_GETHOSTNAME
@ && @
UNISTD_H_HAVE_WINSOCK2_H
@ \

50 && !
defined
 
	g_GL_INCLUDING_WINSOCK2_H


51 #define 
	#_GL_INCLUDING_WINSOCK2_H


	)

52 #include 
	~<winsock2.h
>

53 #undef 
_GL_INCLUDING_WINSOCK2_H


56 #if !
defined
 
_
@
GUARD_PREFIX
@
_UNISTD_H
 && !defined 
_GL_INCLUDING_WINSOCK2_H


57 #define 
	#_
@
GUARD_PREFIX
@
_UNISTD_H


	)

60 #include 
	~<stddef.h
>

65 #if (!(
defined
 
SEEK_CUR
 && defined 
SEEK_END
 && defined 
SEEK_SET
) \

66 || ((@
	gGNULIB_SYMLINKAT
@ || 
defined
 
	gGNULIB_POSIXCHECK
) \

67 && 
defined
 
	g__CYGWIN__
)) \

68 && ! 
defined
 
	g__GLIBC__


69 #include 
	~<stdio.h
>

74 #if (@
GNULIB_UNLINKAT
@ || 
defined
 
GNULIB_POSIXCHECK
) && defined 
__CYGWIN__
 \

75 && ! 
defined
 
	g__GLIBC__


76 #include 
	~<fcntl.h
>

84 #ifndef 
__GLIBC__


85 #include 
	~<stdlib.h
>

90 #if ((@
GNULIB_CHDIR
@ || @
GNULIB_GETCWD
@ || @
GNULIB_RMDIR
@ \

91 || 
defined
 
	gGNULIB_POSIXCHECK
) \

92 && ((
defined
 
	g_WIN32
 || defined 
	g__WIN32__
) && ! defined 
	g__CYGWIN__
))

93 #include 
	~<io.h
>

94 #include 
	~<direct.h
>

100 #if ((@
GNULIB_GETDOMAINNAME
@ && (
defined
 
_AIX
 || defined 
__osf__
)) \

101 || (@
	gGNULIB_GETHOSTNAME
@ && 
defined
 
	g__TANDEM
)) \

102 && !
defined
 
	g__GLIBC__


103 #include 
	~<netdb.h
>

107 #if !@
HAVE_UNISTD_H
@

109 #include 
	~<sys/types.h
>

112 #if (@
GNULIB_READ
@ || @
GNULIB_WRITE
@ \

113 || @
	gGNULIB_READLINK
@ || @
	gGNULIB_READLINKAT
@ \

114 || @
	gGNULIB_PREAD
@ || @
	gGNULIB_PWRITE
@ || 
defined
 
	gGNULIB_POSIXCHECK
)

116 #include 
	~<sys/types.h
>

121 #if @
GNULIB_UNISTD_H_GETOPT
@ && !
defined
 
__GLIBC__
 && !defined 
_GL_SYSTEM_GETOPT


122 #include 
	~<getopt.h
>

134 #if @
GNULIB_GETHOSTNAME
@ && @
UNISTD_H_HAVE_WINSOCK2_H
@

135 #if !
defined
 
_
@
GUARD_PREFIX
@
_SYS_SOCKET_H


136 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

137 #undef 
socket


138 #define 
	#socket
 
socket_used_without_including_sys_socket_h


	)

139 #undef 
connect


140 #define 
	#connect
 
connect_used_without_including_sys_socket_h


	)

141 #undef 
accept


142 #define 
	#accept
 
accept_used_without_including_sys_socket_h


	)

143 #undef 
bind


144 #define 
	#bind
 
bind_used_without_including_sys_socket_h


	)

145 #undef 
getpeername


146 #define 
	#getpeername
 
getpeername_used_without_including_sys_socket_h


	)

147 #undef 
getsockname


148 #define 
	#getsockname
 
getsockname_used_without_including_sys_socket_h


	)

149 #undef 
getsockopt


150 #define 
	#getsockopt
 
getsockopt_used_without_including_sys_socket_h


	)

151 #undef 
listen


152 #define 
	#listen
 
listen_used_without_including_sys_socket_h


	)

153 #undef 
recv


154 #define 
	#recv
 
recv_used_without_including_sys_socket_h


	)

155 #undef 
send


156 #define 
	#send
 
send_used_without_including_sys_socket_h


	)

157 #undef 
recvfrom


158 #define 
	#recvfrom
 
recvfrom_used_without_including_sys_socket_h


	)

159 #undef 
sendto


160 #define 
	#sendto
 
sendto_used_without_including_sys_socket_h


	)

161 #undef 
setsockopt


162 #define 
	#setsockopt
 
setsockopt_used_without_including_sys_socket_h


	)

163 #undef 
shutdown


164 #define 
	#shutdown
 
shutdown_used_without_including_sys_socket_h


	)

166 
_GL_WARN_ON_USE
 (
socket
,

168 
_GL_WARN_ON_USE
 (
connect
,

170 
_GL_WARN_ON_USE
 (
accept
,

172 
_GL_WARN_ON_USE
 (
bind
,

174 
_GL_WARN_ON_USE
 (
getpeername
,

176 
_GL_WARN_ON_USE
 (
getsockname
,

178 
_GL_WARN_ON_USE
 (
getsockopt
,

180 
_GL_WARN_ON_USE
 (
listen
,

182 
_GL_WARN_ON_USE
 (
recv
,

184 
_GL_WARN_ON_USE
 (
send
,

186 
_GL_WARN_ON_USE
 (
recvfrom
,

188 
_GL_WARN_ON_USE
 (
sendto
,

190 
_GL_WARN_ON_USE
 (
setsockopt
,

192 
_GL_WARN_ON_USE
 (
shutdown
,

196 #if !
defined
 
_
@
GUARD_PREFIX
@
_SYS_SELECT_H


197 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

198 #undef 
select


199 #define 
	#select
 
select_used_without_including_sys_select_h


	)

201 
_GL_WARN_ON_USE
 (
select
,

209 #ifndef 
STDIN_FILENO


210 #define 
	#STDIN_FILENO
 0

	)

212 #ifndef 
STDOUT_FILENO


213 #define 
	#STDOUT_FILENO
 1

	)

215 #ifndef 
STDERR_FILENO


216 #define 
	#STDERR_FILENO
 2

	)

220 #ifndef 
F_OK


221 #define 
	#F_OK
 0

	)

222 #define 
	#X_OK
 1

	)

223 #define 
	#W_OK
 2

	)

224 #define 
	#R_OK
 4

	)

231 #if 
defined
 
GNULIB_POSIXCHECK


233 
_GL_WARN_ON_USE
 (
access
, "the access function is a security risk - "

238 #if @
GNULIB_CHDIR
@

239 
_GL_CXXALIAS_SYS
 (
chdir
, int, (const char *
file
) 
_GL_ARG_NONNULL
 ((1)));

240 
_GL_CXXALIASWARN
 (
chdir
);

241 #elif 
defined
 
GNULIB_POSIXCHECK


242 #undef 
chdir


243 #if 
HAVE_RAW_DECL_CHDIR


244 
_GL_WARN_ON_USE
 (
chown
, "chdir is not always in <unistd.h> - "

250 #if @
GNULIB_CHOWN
@

256 #if @
REPLACE_CHOWN
@

257 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

258 #undef 
chown


259 #define 
	#chown
 
rpl_chown


	)

261 
_GL_FUNCDECL_RPL
 (
chown
, int, (const char *
file
, 
uid_t
 
uid
, 
gid_t
 
gid
)

262 
_GL_ARG_NONNULL
 ((1)));

263 
_GL_CXXALIAS_RPL
 (
chown
, int, (const char *
file
, 
uid_t
 
uid
, 
gid_t
 
gid
));

265 #if !@
HAVE_CHOWN
@

266 
_GL_FUNCDECL_SYS
 (
chown
, int, (const char *
file
, 
uid_t
 
uid
, 
gid_t
 
gid
)

267 
_GL_ARG_NONNULL
 ((1)));

269 
_GL_CXXALIAS_SYS
 (
chown
, int, (const char *
file
, 
uid_t
 
uid
, 
gid_t
 
gid
));

271 
_GL_CXXALIASWARN
 (
chown
);

272 #elif 
defined
 
GNULIB_POSIXCHECK


273 #undef 
chown


274 #if 
HAVE_RAW_DECL_CHOWN


275 
_GL_WARN_ON_USE
 (
chown
, "chown fails to follow symlinks on some systems and "

282 #if @
GNULIB_CLOSE
@

283 #if @
REPLACE_CLOSE
@

285 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

286 #undef 
close


287 #define 
	#close
 
rpl_close


	)

289 
_GL_FUNCDECL_RPL
 (
close
, int, (int 
fd
));

290 
_GL_CXXALIAS_RPL
 (
close
, int, (int 
fd
));

292 
_GL_CXXALIAS_SYS
 (
close
, int, (int 
fd
));

294 
_GL_CXXALIASWARN
 (
close
);

295 #elif @
UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS
@

296 #undef 
close


297 #define 
	#close
 
close_used_without_requesting_gnulib_module_close


	)

298 #elif 
defined
 
GNULIB_POSIXCHECK


299 #undef 
close


301 
_GL_WARN_ON_USE
 (
close
, "close does not portably work on sockets - "

306 #if @
GNULIB_DUP
@

307 #if @
REPLACE_DUP
@

308 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

309 #define 
	#dup
 
rpl_dup


	)

311 
_GL_FUNCDECL_RPL
 (
dup
, int, (int 
oldfd
));

312 
_GL_CXXALIAS_RPL
 (
dup
, int, (int 
oldfd
));

314 
_GL_CXXALIAS_SYS
 (
dup
, int, (int 
oldfd
));

316 
_GL_CXXALIASWARN
 (
dup
);

317 #elif 
defined
 
GNULIB_POSIXCHECK


318 #undef 
dup


319 #if 
HAVE_RAW_DECL_DUP


320 
_GL_WARN_ON_USE
 (
dup
, "dup is unportable - "

326 #if @
GNULIB_DUP2
@

332 #if @
REPLACE_DUP2
@

333 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

334 #define 
	#dup2
 
rpl_dup2


	)

336 
_GL_FUNCDECL_RPL
 (
dup2
, int, (int 
oldfd
, int 
newfd
));

337 
_GL_CXXALIAS_RPL
 (
dup2
, int, (int 
oldfd
, int 
newfd
));

339 #if !@
HAVE_DUP2
@

340 
_GL_FUNCDECL_SYS
 (
dup2
, int, (int 
oldfd
, int 
newfd
));

342 
_GL_CXXALIAS_SYS
 (
dup2
, int, (int 
oldfd
, int 
newfd
));

344 
_GL_CXXALIASWARN
 (
dup2
);

345 #elif 
defined
 
GNULIB_POSIXCHECK


346 #undef 
dup2


347 #if 
HAVE_RAW_DECL_DUP2


348 
_GL_WARN_ON_USE
 (
dup2
, "dup2 is unportable - "

354 #if @
GNULIB_DUP3
@

363 #if @
HAVE_DUP3
@

364 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

365 #define 
	#dup3
 
rpl_dup3


	)

367 
_GL_FUNCDECL_RPL
 (
dup3
, int, (int 
oldfd
, int 
newfd
, int 
flags
));

368 
_GL_CXXALIAS_RPL
 (
dup3
, int, (int 
oldfd
, int 
newfd
, int 
flags
));

370 
_GL_FUNCDECL_SYS
 (
dup3
, int, (int 
oldfd
, int 
newfd
, int 
flags
));

371 
_GL_CXXALIAS_SYS
 (
dup3
, int, (int 
oldfd
, int 
newfd
, int 
flags
));

373 
_GL_CXXALIASWARN
 (
dup3
);

374 #elif 
defined
 
GNULIB_POSIXCHECK


375 #undef 
dup3


376 #if 
HAVE_RAW_DECL_DUP3


377 
_GL_WARN_ON_USE
 (
dup3
, "dup3 is unportable - "

383 #if @
GNULIB_ENVIRON
@

384 #if !@
HAVE_DECL_ENVIRON
@

387 #if 
defined
 
__APPLE__
 && defined 
__MACH__


388 #include 
	~<crt_externs.h
>

389 #define 
	#environ
 (*
	`_NSGetEnviron
 ())

	)

391 #ifdef 
__cplusplus


394 extern char **
environ
;

395 #ifdef 
__cplusplus


400 #elif 
defined
 
GNULIB_POSIXCHECK


401 #if 
HAVE_RAW_DECL_ENVIRON


402 static 
inline
 char ***

403 
	$rpl_environ
 (void)

405 return &
environ
;

406 
	}
}

407 
_GL_WARN_ON_USE
 (
rpl_environ
, "environ is unportable - "

409 #undef 
environ


410 #define 
	#environ
 (*
	`rpl_environ
 ())

	)

415 #if @
GNULIB_EUIDACCESS
@

418 #if !@
HAVE_EUIDACCESS
@

419 
_GL_FUNCDECL_SYS
 (
euidaccess
, int, (const char *
filename
, int 
mode
)

420 
_GL_ARG_NONNULL
 ((1)));

422 
_GL_CXXALIAS_SYS
 (
euidaccess
, int, (const char *
filename
, int 
mode
));

423 
_GL_CXXALIASWARN
 (
euidaccess
);

424 #if 
defined
 
GNULIB_POSIXCHECK


426 
_GL_WARN_ON_USE
 (
euidaccess
, "the euidaccess function is a security risk - "

429 #elif 
defined
 
GNULIB_POSIXCHECK


430 #undef 
euidaccess


431 #if 
HAVE_RAW_DECL_EUIDACCESS


432 
_GL_WARN_ON_USE
 (
euidaccess
, "euidaccess is unportable - "

438 #if @
GNULIB_FACCESSAT
@

439 #if !@
HAVE_FACCESSAT
@

440 
_GL_FUNCDECL_SYS
 (
faccessat
, int,

441 (int 
fd
, char const *
file
, int 
mode
, int 
flag
)

442 
_GL_ARG_NONNULL
 ((2)));

444 
_GL_CXXALIAS_SYS
 (
faccessat
, int,

445 (int 
fd
, char const *
file
, int 
mode
, int 
flag
));

446 
_GL_CXXALIASWARN
 (
faccessat
);

447 #elif 
defined
 
GNULIB_POSIXCHECK


448 #undef 
faccessat


449 #if 
HAVE_RAW_DECL_FACCESSAT


450 
_GL_WARN_ON_USE
 (
faccessat
, "faccessat is not portable - "

456 #if @
GNULIB_FCHDIR
@

462 #if ! @
HAVE_FCHDIR
@

463 
_GL_FUNCDECL_SYS
 (
fchdir
, int, (int ));

466 
_GL_EXTERN_C
 int 
	$_gl_register_fd
 (int 
fd
, const char *
filename
)

467 
	`_GL_ARG_NONNULL
 ((2));

468 
_GL_EXTERN_C
 void 
	`_gl_unregister_fd
 (int 
fd
);

469 
_GL_EXTERN_C
 int 
	`_gl_register_dup
 (int 
oldfd
, int 
newfd
);

470 
_GL_EXTERN_C
 const char *
	`_gl_directory_name
 (int 
fd
);

473 #if !@
HAVE_DECL_FCHDIR
@

474 
	`_GL_FUNCDECL_SYS
 (
fchdir
, int, (int ));

477 
	`_GL_CXXALIAS_SYS
 (
fchdir
, int, (int ));

478 
	`_GL_CXXALIASWARN
 (
fchdir
);

479 #elif 
defined
 
GNULIB_POSIXCHECK


480 #undef 
fchdir


481 #if 
HAVE_RAW_DECL_FCHDIR


482 
	`_GL_WARN_ON_USE
 (
fchdir
, "fchdir is unportable - "

488 #if @
GNULIB_FCHOWNAT
@

489 #if @
REPLACE_FCHOWNAT
@

490 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

491 #undef 
fchownat


492 #define 
	#fchownat
 
rpl_fchownat


	)

494 
	`_GL_FUNCDECL_RPL
 (
fchownat
, int, (int 
fd
, char const *
file
,

495 
uid_t
 
owner
, 
gid_t
 
group
, int 
flag
)

496 
	`_GL_ARG_NONNULL
 ((2)));

497 
	`_GL_CXXALIAS_RPL
 (
fchownat
, int, (int 
fd
, char const *
file
,

498 
uid_t
 
owner
, 
gid_t
 
group
, int 
flag
));

500 #if !@
HAVE_FCHOWNAT
@

501 
	`_GL_FUNCDECL_SYS
 (
fchownat
, int, (int 
fd
, char const *
file
,

502 
uid_t
 
owner
, 
gid_t
 
group
, int 
flag
)

503 
	`_GL_ARG_NONNULL
 ((2)));

505 
	`_GL_CXXALIAS_SYS
 (
fchownat
, int, (int 
fd
, char const *
file
,

506 
uid_t
 
owner
, 
gid_t
 
group
, int 
flag
));

508 
	`_GL_CXXALIASWARN
 (
fchownat
);

509 #elif 
defined
 
GNULIB_POSIXCHECK


510 #undef 
fchownat


511 #if 
HAVE_RAW_DECL_FCHOWNAT


512 
	`_GL_WARN_ON_USE
 (
fchownat
, "fchownat is not portable - "

518 #if @
GNULIB_FDATASYNC
@

523 #if !@
HAVE_FDATASYNC
@ || !@
HAVE_DECL_FDATASYNC
@

524 
	`_GL_FUNCDECL_SYS
 (
fdatasync
, int, (int 
fd
));

526 
	`_GL_CXXALIAS_SYS
 (
fdatasync
, int, (int 
fd
));

527 
	`_GL_CXXALIASWARN
 (
fdatasync
);

528 #elif 
defined
 
GNULIB_POSIXCHECK


529 #undef 
fdatasync


530 #if 
HAVE_RAW_DECL_FDATASYNC


531 
	`_GL_WARN_ON_USE
 (
fdatasync
, "fdatasync is unportable - "

537 #if @
GNULIB_FSYNC
@

542 #if !@
HAVE_FSYNC
@

543 
	`_GL_FUNCDECL_SYS
 (
fsync
, int, (int 
fd
));

545 
	`_GL_CXXALIAS_SYS
 (
fsync
, int, (int 
fd
));

546 
	`_GL_CXXALIASWARN
 (
fsync
);

547 #elif 
defined
 
GNULIB_POSIXCHECK


548 #undef 
fsync


549 #if 
HAVE_RAW_DECL_FSYNC


550 
	`_GL_WARN_ON_USE
 (
fsync
, "fsync is unportable - "

556 #if @
GNULIB_FTRUNCATE
@

561 #if !@
HAVE_FTRUNCATE
@

562 
	`_GL_FUNCDECL_SYS
 (
ftruncate
, int, (int 
fd
, 
off_t
 
length
));

564 
	`_GL_CXXALIAS_SYS
 (
ftruncate
, int, (int 
fd
, 
off_t
 
length
));

565 
	`_GL_CXXALIASWARN
 (
ftruncate
);

566 #elif 
defined
 
GNULIB_POSIXCHECK


567 #undef 
ftruncate


568 #if 
HAVE_RAW_DECL_FTRUNCATE


569 
	`_GL_WARN_ON_USE
 (
ftruncate
, "ftruncate is unportable - "

575 #if @
GNULIB_GETCWD
@

586 #if @
REPLACE_GETCWD
@

587 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

588 #define 
	#getcwd
 
rpl_getcwd


	)

590 
	`_GL_FUNCDECL_RPL
 (
getcwd
, char *, (char *
buf
, 
size_t
 
size
));

591 
	`_GL_CXXALIAS_RPL
 (
getcwd
, char *, (char *
buf
, 
size_t
 
size
));

595 
	`_GL_CXXALIAS_SYS_CAST
 (
getcwd
, char *, (char *
buf
, 
size_t
 
size
));

597 
	`_GL_CXXALIASWARN
 (
getcwd
);

598 #elif 
defined
 
GNULIB_POSIXCHECK


599 #undef 
getcwd


600 #if 
HAVE_RAW_DECL_GETCWD


601 
	`_GL_WARN_ON_USE
 (
getcwd
, "getcwd is unportable - "

607 #if @
GNULIB_GETDOMAINNAME
@

618 #if @
REPLACE_GETDOMAINNAME
@

619 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

620 #undef 
getdomainname


621 #define 
	#getdomainname
 
rpl_getdomainname


	)

623 
	`_GL_FUNCDECL_RPL
 (
getdomainname
, int, (char *
name
, 
size_t
 
len
)

624 
	`_GL_ARG_NONNULL
 ((1)));

625 
	`_GL_CXXALIAS_RPL
 (
getdomainname
, int, (char *
name
, 
size_t
 
len
));

627 #if !@
HAVE_DECL_GETDOMAINNAME
@

628 
	`_GL_FUNCDECL_SYS
 (
getdomainname
, int, (char *
name
, 
size_t
 
len
)

629 
	`_GL_ARG_NONNULL
 ((1)));

631 
	`_GL_CXXALIAS_SYS
 (
getdomainname
, int, (char *
name
, 
size_t
 
len
));

633 
	`_GL_CXXALIASWARN
 (
getdomainname
);

634 #elif 
defined
 
GNULIB_POSIXCHECK


635 #undef 
getdomainname


636 #if 
HAVE_RAW_DECL_GETDOMAINNAME


637 
	`_GL_WARN_ON_USE
 (
getdomainname
, "getdomainname is unportable - "

643 #if @
GNULIB_GETDTABLESIZE
@

646 #if !@
HAVE_GETDTABLESIZE
@

647 
	`_GL_FUNCDECL_SYS
 (
getdtablesize
, int, (void));

649 
	`_GL_CXXALIAS_SYS
 (
getdtablesize
, int, (void));

650 
	`_GL_CXXALIASWARN
 (
getdtablesize
);

651 #elif 
defined
 
GNULIB_POSIXCHECK


652 #undef 
getdtablesize


653 #if 
HAVE_RAW_DECL_GETDTABLESIZE


654 
	`_GL_WARN_ON_USE
 (
getdtablesize
, "getdtablesize is unportable - "

660 #if @
GNULIB_GETGROUPS
@

666 #if @
REPLACE_GETGROUPS
@

667 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

668 #undef 
getgroups


669 #define 
	#getgroups
 
rpl_getgroups


	)

671 
	`_GL_FUNCDECL_RPL
 (
getgroups
, int, (int 
n
, 
gid_t
 *
groups
));

672 
	`_GL_CXXALIAS_RPL
 (
getgroups
, int, (int 
n
, 
gid_t
 *
groups
));

674 #if !@
HAVE_GETGROUPS
@

675 
	`_GL_FUNCDECL_SYS
 (
getgroups
, int, (int 
n
, 
gid_t
 *
groups
));

677 
	`_GL_CXXALIAS_SYS
 (
getgroups
, int, (int 
n
, 
gid_t
 *
groups
));

679 
	`_GL_CXXALIASWARN
 (
getgroups
);

680 #elif 
defined
 
GNULIB_POSIXCHECK


681 #undef 
getgroups


682 #if 
HAVE_RAW_DECL_GETGROUPS


683 
	`_GL_WARN_ON_USE
 (
getgroups
, "getgroups is unportable - "

689 #if @
GNULIB_GETHOSTNAME
@

697 #if @
UNISTD_H_HAVE_WINSOCK2_H
@

698 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

699 #undef 
gethostname


700 #define 
	#gethostname
 
rpl_gethostname


	)

702 
	`_GL_FUNCDECL_RPL
 (
gethostname
, int, (char *
name
, 
size_t
 
len
)

703 
	`_GL_ARG_NONNULL
 ((1)));

704 
	`_GL_CXXALIAS_RPL
 (
gethostname
, int, (char *
name
, 
size_t
 
len
));

706 #if !@
HAVE_GETHOSTNAME
@

707 
	`_GL_FUNCDECL_SYS
 (
gethostname
, int, (char *
name
, 
size_t
 
len
)

708 
	`_GL_ARG_NONNULL
 ((1)));

713 
	`_GL_CXXALIAS_SYS_CAST
 (
gethostname
, int, (char *
name
, 
size_t
 
len
));

715 
	`_GL_CXXALIASWARN
 (
gethostname
);

716 #elif @
UNISTD_H_HAVE_WINSOCK2_H
@

717 #undef 
gethostname


718 #define 
	#gethostname
 
gethostname_used_without_requesting_gnulib_module_gethostname


	)

719 #elif 
defined
 
GNULIB_POSIXCHECK


720 #undef 
gethostname


721 #if 
HAVE_RAW_DECL_GETHOSTNAME


722 
	`_GL_WARN_ON_USE
 (
gethostname
, "gethostname is unportable - "

728 #if @
GNULIB_GETLOGIN
@

739 #if !@
HAVE_GETLOGIN
@

740 
	`_GL_FUNCDECL_SYS
 (
getlogin
, char *, (void));

742 
	`_GL_CXXALIAS_SYS
 (
getlogin
, char *, (void));

743 
	`_GL_CXXALIASWARN
 (
getlogin
);

744 #elif 
defined
 
GNULIB_POSIXCHECK


745 #undef 
getlogin


746 #if 
HAVE_RAW_DECL_GETLOGIN


747 
	`_GL_WARN_ON_USE
 (
getlogin
, "getlogin is unportable - "

753 #if @
GNULIB_GETLOGIN_R
@

768 #if @
REPLACE_GETLOGIN_R
@

769 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

770 #define 
	#getlogin_r
 
rpl_getlogin_r


	)

772 
	`_GL_FUNCDECL_RPL
 (
getlogin_r
, int, (char *
name
, 
size_t
 
size
)

773 
	`_GL_ARG_NONNULL
 ((1)));

774 
	`_GL_CXXALIAS_RPL
 (
getlogin_r
, int, (char *
name
, 
size_t
 
size
));

776 #if !@
HAVE_DECL_GETLOGIN_R
@

777 
	`_GL_FUNCDECL_SYS
 (
getlogin_r
, int, (char *
name
, 
size_t
 
size
)

778 
	`_GL_ARG_NONNULL
 ((1)));

782 
	`_GL_CXXALIAS_SYS_CAST
 (
getlogin_r
, int, (char *
name
, 
size_t
 
size
));

784 
	`_GL_CXXALIASWARN
 (
getlogin_r
);

785 #elif 
defined
 
GNULIB_POSIXCHECK


786 #undef 
getlogin_r


787 #if 
HAVE_RAW_DECL_GETLOGIN_R


788 
	`_GL_WARN_ON_USE
 (
getlogin_r
, "getlogin_r is unportable - "

794 #if @
GNULIB_GETPAGESIZE
@

795 #if @
REPLACE_GETPAGESIZE
@

796 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

797 #define 
	#getpagesize
 
rpl_getpagesize


	)

799 
	`_GL_FUNCDECL_RPL
 (
getpagesize
, int, (void));

800 
	`_GL_CXXALIAS_RPL
 (
getpagesize
, int, (void));

802 #if !@
HAVE_GETPAGESIZE
@

803 #if !
defined
 
getpagesize


805 #if !
defined
 
_gl_getpagesize
 && defined 
_SC_PAGESIZE


806 #if ! (
defined
 
__VMS
 && 
__VMS_VER
 < 70000000)

807 #define 
	#_gl_getpagesize
() 
	`sysconf
 (
_SC_PAGESIZE
)

	)

811 #if !
defined
 
_gl_getpagesize
 && defined 
__VMS


812 #ifdef 
__ALPHA


813 #define 
	#_gl_getpagesize
() 8192

	)

815 #define 
	#_gl_getpagesize
() 512

	)

819 #if !
defined
 
_gl_getpagesize
 && @
HAVE_OS_H
@

820 #include 
	~<OS.h
>

821 #if 
defined
 
B_PAGE_SIZE


822 #define 
	#_gl_getpagesize
() 
B_PAGE_SIZE


	)

826 #if !
defined
 
_gl_getpagesize
 && defined 
__amigaos4__


827 #define 
	#_gl_getpagesize
() 2048

	)

830 #if !
defined
 
_gl_getpagesize
 && @
HAVE_SYS_PARAM_H
@

831 #include 
	~<sys/param.h
>

832 #ifdef 
EXEC_PAGESIZE


833 #define 
	#_gl_getpagesize
() 
EXEC_PAGESIZE


	)

835 #ifdef 
NBPG


836 #ifndef 
CLSIZE


837 #define 
	#CLSIZE
 1

	)

839 #define 
	#_gl_getpagesize
() (
NBPG
 * 
CLSIZE
)

	)

841 #ifdef 
NBPC


842 #define 
	#_gl_getpagesize
() 
NBPC


	)

847 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

848 #define 
	#getpagesize
() 
	`_gl_getpagesize
 ()

	)

850 #if !
GNULIB_defined_getpagesize_function


851 static 
inline
 int

852 
	$getpagesize
 ()

854 return 
	`_gl_getpagesize
 ();

855 
	}
}

856 #define 
	#GNULIB_defined_getpagesize_function
 1

	)

862 
_GL_CXXALIAS_SYS_CAST
 (
getpagesize
, int, (void));

864 #if @
HAVE_DECL_GETPAGESIZE
@

865 
_GL_CXXALIASWARN
 (
getpagesize
);

867 #elif 
defined
 
GNULIB_POSIXCHECK


868 #undef 
getpagesize


869 #if 
HAVE_RAW_DECL_GETPAGESIZE


870 
_GL_WARN_ON_USE
 (
getpagesize
, "getpagesize is unportable - "

876 #if @
GNULIB_GETUSERSHELL
@

879 #if !@
HAVE_DECL_GETUSERSHELL
@

880 
_GL_FUNCDECL_SYS
 (
getusershell
, char *, (void));

882 
_GL_CXXALIAS_SYS
 (
getusershell
, char *, (void));

883 
_GL_CXXALIASWARN
 (
getusershell
);

884 #elif 
defined
 
GNULIB_POSIXCHECK


885 #undef 
getusershell


886 #if 
HAVE_RAW_DECL_GETUSERSHELL


887 
_GL_WARN_ON_USE
 (
getusershell
, "getusershell is unportable - "

892 #if @
GNULIB_GETUSERSHELL
@

894 #if !@
HAVE_DECL_GETUSERSHELL
@

895 
_GL_FUNCDECL_SYS
 (
setusershell
, void, (void));

897 
_GL_CXXALIAS_SYS
 (
setusershell
, void, (void));

898 
_GL_CXXALIASWARN
 (
setusershell
);

899 #elif 
defined
 
GNULIB_POSIXCHECK


900 #undef 
setusershell


901 #if 
HAVE_RAW_DECL_SETUSERSHELL


902 
_GL_WARN_ON_USE
 (
setusershell
, "setusershell is unportable - "

907 #if @
GNULIB_GETUSERSHELL
@

910 #if !@
HAVE_DECL_GETUSERSHELL
@

911 
_GL_FUNCDECL_SYS
 (
endusershell
, void, (void));

913 
_GL_CXXALIAS_SYS
 (
endusershell
, void, (void));

914 
_GL_CXXALIASWARN
 (
endusershell
);

915 #elif 
defined
 
GNULIB_POSIXCHECK


916 #undef 
endusershell


917 #if 
HAVE_RAW_DECL_ENDUSERSHELL


918 
_GL_WARN_ON_USE
 (
endusershell
, "endusershell is unportable - "

924 #if @
GNULIB_GROUP_MEMBER
@

926 #if !@
HAVE_GROUP_MEMBER
@

927 
_GL_FUNCDECL_SYS
 (
group_member
, int, (
gid_t
 
gid
));

929 
_GL_CXXALIAS_SYS
 (
group_member
, int, (
gid_t
 
gid
));

930 
_GL_CXXALIASWARN
 (
group_member
);

931 #elif 
defined
 
GNULIB_POSIXCHECK


932 #undef 
group_member


933 #if 
HAVE_RAW_DECL_GROUP_MEMBER


934 
_GL_WARN_ON_USE
 (
group_member
, "group_member is unportable - "

940 #if @
GNULIB_LCHOWN
@

946 #if @
REPLACE_LCHOWN
@

947 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

948 #undef 
lchown


949 #define 
	#lchown
 
rpl_lchown


	)

951 
_GL_FUNCDECL_RPL
 (
lchown
, int, (char const *
file
, 
uid_t
 
owner
, 
gid_t
 
group
)

952 
_GL_ARG_NONNULL
 ((1)));

953 
_GL_CXXALIAS_RPL
 (
lchown
, int, (char const *
file
, 
uid_t
 
owner
, 
gid_t
 
group
));

955 #if !@
HAVE_LCHOWN
@

956 
_GL_FUNCDECL_SYS
 (
lchown
, int, (char const *
file
, 
uid_t
 
owner
, 
gid_t
 
group
)

957 
_GL_ARG_NONNULL
 ((1)));

959 
_GL_CXXALIAS_SYS
 (
lchown
, int, (char const *
file
, 
uid_t
 
owner
, 
gid_t
 
group
));

961 
_GL_CXXALIASWARN
 (
lchown
);

962 #elif 
defined
 
GNULIB_POSIXCHECK


963 #undef 
lchown


964 #if 
HAVE_RAW_DECL_LCHOWN


965 
_GL_WARN_ON_USE
 (
lchown
, "lchown is unportable to pre-POSIX.1-2001 systems - "

971 #if @
GNULIB_LINK
@

976 #if @
REPLACE_LINK
@

977 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

978 #define 
	#link
 
rpl_link


	)

980 
_GL_FUNCDECL_RPL
 (
link
, int, (const char *
path1
, const char *
path2
)

981 
_GL_ARG_NONNULL
 ((1, 2)));

982 
_GL_CXXALIAS_RPL
 (
link
, int, (const char *
path1
, const char *
path2
));

984 #if !@
HAVE_LINK
@

985 
_GL_FUNCDECL_SYS
 (
link
, int, (const char *
path1
, const char *
path2
)

986 
_GL_ARG_NONNULL
 ((1, 2)));

988 
_GL_CXXALIAS_SYS
 (
link
, int, (const char *
path1
, const char *
path2
));

990 
_GL_CXXALIASWARN
 (
link
);

991 #elif 
defined
 
GNULIB_POSIXCHECK


992 #undef 
link


993 #if 
HAVE_RAW_DECL_LINK


994 
_GL_WARN_ON_USE
 (
link
, "link is unportable - "

1000 #if @
GNULIB_LINKAT
@

1004 #if @
REPLACE_LINKAT
@

1005 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1006 #undef 
linkat


1007 #define 
	#linkat
 
rpl_linkat


	)

1009 
_GL_FUNCDECL_RPL
 (
linkat
, int,

1010 (int 
fd1
, const char *
path1
, int 
fd2
, const char *
path2
,

1011 int 
flag
)

1012 
_GL_ARG_NONNULL
 ((2, 4)));

1013 
_GL_CXXALIAS_RPL
 (
linkat
, int,

1014 (int 
fd1
, const char *
path1
, int 
fd2
, const char *
path2
,

1015 int 
flag
));

1017 #if !@
HAVE_LINKAT
@

1018 
_GL_FUNCDECL_SYS
 (
linkat
, int,

1019 (int 
fd1
, const char *
path1
, int 
fd2
, const char *
path2
,

1020 int 
flag
)

1021 
_GL_ARG_NONNULL
 ((2, 4)));

1023 
_GL_CXXALIAS_SYS
 (
linkat
, int,

1024 (int 
fd1
, const char *
path1
, int 
fd2
, const char *
path2
,

1025 int 
flag
));

1027 
_GL_CXXALIASWARN
 (
linkat
);

1028 #elif 
defined
 
GNULIB_POSIXCHECK


1029 #undef 
linkat


1030 #if 
HAVE_RAW_DECL_LINKAT


1031 
_GL_WARN_ON_USE
 (
linkat
, "linkat is unportable - "

1037 #if @
GNULIB_LSEEK
@

1042 #if @
REPLACE_LSEEK
@

1043 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1044 #define 
	#lseek
 
rpl_lseek


	)

1046 
_GL_FUNCDECL_RPL
 (
lseek
, 
off_t
, (int 
fd
, off_t 
offset
, int 
whence
));

1047 
_GL_CXXALIAS_RPL
 (
lseek
, 
off_t
, (int 
fd
, off_t 
offset
, int 
whence
));

1049 
_GL_CXXALIAS_SYS
 (
lseek
, 
off_t
, (int 
fd
, off_t 
offset
, int 
whence
));

1051 
_GL_CXXALIASWARN
 (
lseek
);

1052 #elif 
defined
 
GNULIB_POSIXCHECK


1053 #undef 
lseek


1054 #if 
HAVE_RAW_DECL_LSEEK


1055 
_GL_WARN_ON_USE
 (
lseek
, "lseek does not fail with ESPIPE on pipes on some "

1061 #if @
GNULIB_PIPE
@

1065 #if !@
HAVE_PIPE
@

1066 
_GL_FUNCDECL_SYS
 (
pipe
, int, (int 
fd
[2]) 
_GL_ARG_NONNULL
 ((1)));

1068 
_GL_CXXALIAS_SYS
 (
pipe
, int, (int 
fd
[2]));

1069 
_GL_CXXALIASWARN
 (
pipe
);

1070 #elif 
defined
 
GNULIB_POSIXCHECK


1071 #undef 
pipe


1072 #if 
HAVE_RAW_DECL_PIPE


1073 
_GL_WARN_ON_USE
 (
pipe
, "pipe is unportable - "

1079 #if @
GNULIB_PIPE2
@

1088 #if @
HAVE_PIPE2
@

1089 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1090 #define 
	#pipe2
 
rpl_pipe2


	)

1092 
_GL_FUNCDECL_RPL
 (
pipe2
, int, (int 
fd
[2], int 
flags
) 
_GL_ARG_NONNULL
 ((1)));

1093 
_GL_CXXALIAS_RPL
 (
pipe2
, int, (int 
fd
[2], int 
flags
));

1095 
_GL_FUNCDECL_SYS
 (
pipe2
, int, (int 
fd
[2], int 
flags
) 
_GL_ARG_NONNULL
 ((1)));

1096 
_GL_CXXALIAS_SYS
 (
pipe2
, int, (int 
fd
[2], int 
flags
));

1098 
_GL_CXXALIASWARN
 (
pipe2
);

1099 #elif 
defined
 
GNULIB_POSIXCHECK


1100 #undef 
pipe2


1101 #if 
HAVE_RAW_DECL_PIPE2


1102 
_GL_WARN_ON_USE
 (
pipe2
, "pipe2 is unportable - "

1108 #if @
GNULIB_PREAD
@

1114 #if @
REPLACE_PREAD
@

1115 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1116 #undef 
pread


1117 #define 
	#pread
 
rpl_pread


	)

1119 
_GL_FUNCDECL_RPL
 (
pread
, 
ssize_t
,

1120 (int 
fd
, void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
)

1121 
_GL_ARG_NONNULL
 ((2)));

1122 
_GL_CXXALIAS_RPL
 (
pread
, 
ssize_t
,

1123 (int 
fd
, void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
));

1125 #if !@
HAVE_PREAD
@

1126 
_GL_FUNCDECL_SYS
 (
pread
, 
ssize_t
,

1127 (int 
fd
, void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
)

1128 
_GL_ARG_NONNULL
 ((2)));

1130 
_GL_CXXALIAS_SYS
 (
pread
, 
ssize_t
,

1131 (int 
fd
, void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
));

1133 
_GL_CXXALIASWARN
 (
pread
);

1134 #elif 
defined
 
GNULIB_POSIXCHECK


1135 #undef 
pread


1136 #if 
HAVE_RAW_DECL_PREAD


1137 
_GL_WARN_ON_USE
 (
pread
, "pread is unportable - "

1143 #if @
GNULIB_PWRITE
@

1149 #if @
REPLACE_PWRITE
@

1150 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1151 #undef 
pwrite


1152 #define 
	#pwrite
 
rpl_pwrite


	)

1154 
_GL_FUNCDECL_RPL
 (
pwrite
, 
ssize_t
,

1155 (int 
fd
, const void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
)

1156 
_GL_ARG_NONNULL
 ((2)));

1157 
_GL_CXXALIAS_RPL
 (
pwrite
, 
ssize_t
,

1158 (int 
fd
, const void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
));

1160 #if !@
HAVE_PWRITE
@

1161 
_GL_FUNCDECL_SYS
 (
pwrite
, 
ssize_t
,

1162 (int 
fd
, const void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
)

1163 
_GL_ARG_NONNULL
 ((2)));

1165 
_GL_CXXALIAS_SYS
 (
pwrite
, 
ssize_t
,

1166 (int 
fd
, const void *
buf
, 
size_t
 
bufsize
, 
off_t
 
offset
));

1168 
_GL_CXXALIASWARN
 (
pwrite
);

1169 #elif 
defined
 
GNULIB_POSIXCHECK


1170 #undef 
pwrite


1171 #if 
HAVE_RAW_DECL_PWRITE


1172 
_GL_WARN_ON_USE
 (
pwrite
, "pwrite is unportable - "

1178 #if @
GNULIB_READ
@

1182 #if @
REPLACE_READ
@

1183 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1184 #undef 
read


1185 #define 
	#read
 
rpl_read


	)

1187 
_GL_FUNCDECL_RPL
 (
read
, 
ssize_t
, (int 
fd
, void *
buf
, 
size_t
 
count
)

1188 
_GL_ARG_NONNULL
 ((2)));

1189 
_GL_CXXALIAS_RPL
 (
read
, 
ssize_t
, (int 
fd
, void *
buf
, 
size_t
 
count
));

1194 
_GL_CXXALIAS_SYS_CAST
 (
read
, 
ssize_t
, (int 
fd
, void *
buf
, 
size_t
 
count
));

1196 
_GL_CXXALIASWARN
 (
read
);

1200 #if @
GNULIB_READLINK
@

1206 #if @
REPLACE_READLINK
@

1207 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1208 #define 
	#readlink
 
rpl_readlink


	)

1210 
_GL_FUNCDECL_RPL
 (
readlink
, 
ssize_t
,

1211 (const char *
file
, char *
buf
, 
size_t
 
bufsize
)

1212 
_GL_ARG_NONNULL
 ((1, 2)));

1213 
_GL_CXXALIAS_RPL
 (
readlink
, 
ssize_t
,

1214 (const char *
file
, char *
buf
, 
size_t
 
bufsize
));

1216 #if !@
HAVE_READLINK
@

1217 
_GL_FUNCDECL_SYS
 (
readlink
, 
ssize_t
,

1218 (const char *
file
, char *
buf
, 
size_t
 
bufsize
)

1219 
_GL_ARG_NONNULL
 ((1, 2)));

1221 
_GL_CXXALIAS_SYS
 (
readlink
, 
ssize_t
,

1222 (const char *
file
, char *
buf
, 
size_t
 
bufsize
));

1224 
_GL_CXXALIASWARN
 (
readlink
);

1225 #elif 
defined
 
GNULIB_POSIXCHECK


1226 #undef 
readlink


1227 #if 
HAVE_RAW_DECL_READLINK


1228 
_GL_WARN_ON_USE
 (
readlink
, "readlink is unportable - "

1234 #if @
GNULIB_READLINKAT
@

1235 #if !@
HAVE_READLINKAT
@

1236 
_GL_FUNCDECL_SYS
 (
readlinkat
, 
ssize_t
,

1237 (int 
fd
, char const *
file
, char *
buf
, 
size_t
 
len
)

1238 
_GL_ARG_NONNULL
 ((2, 3)));

1240 
_GL_CXXALIAS_SYS
 (
readlinkat
, 
ssize_t
,

1241 (int 
fd
, char const *
file
, char *
buf
, 
size_t
 
len
));

1242 
_GL_CXXALIASWARN
 (
readlinkat
);

1243 #elif 
defined
 
GNULIB_POSIXCHECK


1244 #undef 
readlinkat


1245 #if 
HAVE_RAW_DECL_READLINKAT


1246 
_GL_WARN_ON_USE
 (
readlinkat
, "readlinkat is not portable - "

1252 #if @
GNULIB_RMDIR
@

1254 #if @
REPLACE_RMDIR
@

1255 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1256 #define 
	#rmdir
 
rpl_rmdir


	)

1258 
_GL_FUNCDECL_RPL
 (
rmdir
, int, (char const *
name
) 
_GL_ARG_NONNULL
 ((1)));

1259 
_GL_CXXALIAS_RPL
 (
rmdir
, int, (char const *
name
));

1261 
_GL_CXXALIAS_SYS
 (
rmdir
, int, (char const *
name
));

1263 
_GL_CXXALIASWARN
 (
rmdir
);

1264 #elif 
defined
 
GNULIB_POSIXCHECK


1265 #undef 
rmdir


1266 #if 
HAVE_RAW_DECL_RMDIR


1267 
_GL_WARN_ON_USE
 (
rmdir
, "rmdir is unportable - "

1273 #if @
GNULIB_SLEEP
@

1278 #if @
REPLACE_SLEEP
@

1279 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1280 #undef 
sleep


1281 #define 
	#sleep
 
rpl_sleep


	)

1283 
_GL_FUNCDECL_RPL
 (
sleep
, unsigned int, (unsigned int 
n
));

1284 
_GL_CXXALIAS_RPL
 (
sleep
, unsigned int, (unsigned int 
n
));

1286 #if !@
HAVE_SLEEP
@

1287 
_GL_FUNCDECL_SYS
 (
sleep
, unsigned int, (unsigned int 
n
));

1289 
_GL_CXXALIAS_SYS
 (
sleep
, unsigned int, (unsigned int 
n
));

1291 
_GL_CXXALIASWARN
 (
sleep
);

1292 #elif 
defined
 
GNULIB_POSIXCHECK


1293 #undef 
sleep


1294 #if 
HAVE_RAW_DECL_SLEEP


1295 
_GL_WARN_ON_USE
 (
sleep
, "sleep is unportable - "

1301 #if @
GNULIB_SYMLINK
@

1302 #if @
REPLACE_SYMLINK
@

1303 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1304 #undef 
symlink


1305 #define 
	#symlink
 
rpl_symlink


	)

1307 
_GL_FUNCDECL_RPL
 (
symlink
, int, (char const *
contents
, char const *
file
)

1308 
_GL_ARG_NONNULL
 ((1, 2)));

1309 
_GL_CXXALIAS_RPL
 (
symlink
, int, (char const *
contents
, char const *
file
));

1311 #if !@
HAVE_SYMLINK
@

1312 
_GL_FUNCDECL_SYS
 (
symlink
, int, (char const *
contents
, char const *
file
)

1313 
_GL_ARG_NONNULL
 ((1, 2)));

1315 
_GL_CXXALIAS_SYS
 (
symlink
, int, (char const *
contents
, char const *
file
));

1317 
_GL_CXXALIASWARN
 (
symlink
);

1318 #elif 
defined
 
GNULIB_POSIXCHECK


1319 #undef 
symlink


1320 #if 
HAVE_RAW_DECL_SYMLINK


1321 
_GL_WARN_ON_USE
 (
symlink
, "symlink is not portable - "

1327 #if @
GNULIB_SYMLINKAT
@

1328 #if !@
HAVE_SYMLINKAT
@

1329 
_GL_FUNCDECL_SYS
 (
symlinkat
, int,

1330 (char const *
contents
, int 
fd
, char const *
file
)

1331 
_GL_ARG_NONNULL
 ((1, 3)));

1333 
_GL_CXXALIAS_SYS
 (
symlinkat
, int,

1334 (char const *
contents
, int 
fd
, char const *
file
));

1335 
_GL_CXXALIASWARN
 (
symlinkat
);

1336 #elif 
defined
 
GNULIB_POSIXCHECK


1337 #undef 
symlinkat


1338 #if 
HAVE_RAW_DECL_SYMLINKAT


1339 
_GL_WARN_ON_USE
 (
symlinkat
, "symlinkat is not portable - "

1345 #if @
GNULIB_TTYNAME_R
@

1348 #if @
REPLACE_TTYNAME_R
@

1349 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1350 #undef 
ttyname_r


1351 #define 
	#ttyname_r
 
rpl_ttyname_r


	)

1353 
_GL_FUNCDECL_RPL
 (
ttyname_r
, int,

1354 (int 
fd
, char *
buf
, 
size_t
 
buflen
) 
_GL_ARG_NONNULL
 ((2)));

1355 
_GL_CXXALIAS_RPL
 (
ttyname_r
, int,

1356 (int 
fd
, char *
buf
, 
size_t
 
buflen
));

1358 #if !@
HAVE_DECL_TTYNAME_R
@

1359 
_GL_FUNCDECL_SYS
 (
ttyname_r
, int,

1360 (int 
fd
, char *
buf
, 
size_t
 
buflen
) 
_GL_ARG_NONNULL
 ((2)));

1362 
_GL_CXXALIAS_SYS
 (
ttyname_r
, int,

1363 (int 
fd
, char *
buf
, 
size_t
 
buflen
));

1365 
_GL_CXXALIASWARN
 (
ttyname_r
);

1366 #elif 
defined
 
GNULIB_POSIXCHECK


1367 #undef 
ttyname_r


1368 #if 
HAVE_RAW_DECL_TTYNAME_R


1369 
_GL_WARN_ON_USE
 (
ttyname_r
, "ttyname_r is not portable - "

1375 #if @
GNULIB_UNLINK
@

1376 #if @
REPLACE_UNLINK
@

1377 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1378 #undef 
unlink


1379 #define 
	#unlink
 
rpl_unlink


	)

1381 
_GL_FUNCDECL_RPL
 (
unlink
, int, (char const *
file
) 
_GL_ARG_NONNULL
 ((1)));

1382 
_GL_CXXALIAS_RPL
 (
unlink
, int, (char const *
file
));

1384 
_GL_CXXALIAS_SYS
 (
unlink
, int, (char const *
file
));

1386 
_GL_CXXALIASWARN
 (
unlink
);

1387 #elif 
defined
 
GNULIB_POSIXCHECK


1388 #undef 
unlink


1389 #if 
HAVE_RAW_DECL_UNLINK


1390 
_GL_WARN_ON_USE
 (
unlink
, "unlink is not portable - "

1396 #if @
GNULIB_UNLINKAT
@

1397 #if @
REPLACE_UNLINKAT
@

1398 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1399 #undef 
unlinkat


1400 #define 
	#unlinkat
 
rpl_unlinkat


	)

1402 
_GL_FUNCDECL_RPL
 (
unlinkat
, int, (int 
fd
, char const *
file
, int 
flag
)

1403 
_GL_ARG_NONNULL
 ((2)));

1404 
_GL_CXXALIAS_RPL
 (
unlinkat
, int, (int 
fd
, char const *
file
, int 
flag
));

1406 #if !@
HAVE_UNLINKAT
@

1407 
_GL_FUNCDECL_SYS
 (
unlinkat
, int, (int 
fd
, char const *
file
, int 
flag
)

1408 
_GL_ARG_NONNULL
 ((2)));

1410 
_GL_CXXALIAS_SYS
 (
unlinkat
, int, (int 
fd
, char const *
file
, int 
flag
));

1412 
_GL_CXXALIASWARN
 (
unlinkat
);

1413 #elif 
defined
 
GNULIB_POSIXCHECK


1414 #undef 
unlinkat


1415 #if 
HAVE_RAW_DECL_UNLINKAT


1416 
_GL_WARN_ON_USE
 (
unlinkat
, "unlinkat is not portable - "

1422 #if @
GNULIB_USLEEP
@

1427 #if @
REPLACE_USLEEP
@

1428 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1429 #undef 
usleep


1430 #define 
	#usleep
 
rpl_usleep


	)

1432 
_GL_FUNCDECL_RPL
 (
usleep
, int, (
useconds_t
 
n
));

1433 
_GL_CXXALIAS_RPL
 (
usleep
, int, (
useconds_t
 
n
));

1435 #if !@
HAVE_USLEEP
@

1436 
_GL_FUNCDECL_SYS
 (
usleep
, int, (
useconds_t
 
n
));

1438 
_GL_CXXALIAS_SYS
 (
usleep
, int, (
useconds_t
 
n
));

1440 
_GL_CXXALIASWARN
 (
usleep
);

1441 #elif 
defined
 
GNULIB_POSIXCHECK


1442 #undef 
usleep


1443 #if 
HAVE_RAW_DECL_USLEEP


1444 
_GL_WARN_ON_USE
 (
usleep
, "usleep is unportable - "

1450 #if @
GNULIB_WRITE
@

1454 #if @
REPLACE_WRITE
@

1455 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

1456 #undef 
write


1457 #define 
	#write
 
rpl_write


	)

1459 
_GL_FUNCDECL_RPL
 (
write
, 
ssize_t
, (int 
fd
, const void *
buf
, 
size_t
 
count
)

1460 
_GL_ARG_NONNULL
 ((2)));

1461 
_GL_CXXALIAS_RPL
 (
write
, 
ssize_t
, (int 
fd
, const void *
buf
, 
size_t
 
count
));

1466 
_GL_CXXALIAS_SYS_CAST
 (
write
, 
ssize_t
, (int 
fd
, const void *
buf
, 
size_t
 
count
));

1468 
_GL_CXXALIASWARN
 (
write
);

	@lib/unistr.in.h

19 #ifndef 
_UNISTR_H


20 #define 
	#_UNISTR_H


	)

22 #include 
	~"unitypes.h
"

25 #include 
	~"unused-parameter.h
"

28 #include 
	~<stdbool.h
>

31 #include 
	~<stddef.h
>

33 #ifdef 
__cplusplus


70 extern const 
uint8_t
 *

71 
u8_check
 (const 
uint8_t
 *
s
, 
size_t
 
n
);

75 extern const 
uint16_t
 *

76 
u16_check
 (const 
uint16_t
 *
s
, 
size_t
 
n
);

80 extern const 
uint32_t
 *

81 
u32_check
 (const 
uint32_t
 *
s
, 
size_t
 
n
);

87 extern 
uint16_t
 *

88 
u8_to_u16
 (const 
uint8_t
 *
s
, 
size_t
 
n
, 
uint16_t
 *
resultbuf
,

89 
size_t
 *
lengthp
);

92 extern 
uint32_t
 *

93 
u8_to_u32
 (const 
uint8_t
 *
s
, 
size_t
 
n
, 
uint32_t
 *
resultbuf
,

94 
size_t
 *
lengthp
);

97 extern 
uint8_t
 *

98 
u16_to_u8
 (const 
uint16_t
 *
s
, 
size_t
 
n
, 
uint8_t
 *
resultbuf
,

99 
size_t
 *
lengthp
);

102 extern 
uint32_t
 *

103 
u16_to_u32
 (const 
uint16_t
 *
s
, 
size_t
 
n
, 
uint32_t
 *
resultbuf
,

104 
size_t
 *
lengthp
);

107 extern 
uint8_t
 *

108 
u32_to_u8
 (const 
uint32_t
 *
s
, 
size_t
 
n
, 
uint8_t
 *
resultbuf
,

109 
size_t
 *
lengthp
);

112 extern 
uint16_t
 *

113 
u32_to_u16
 (const 
uint32_t
 *
s
, 
size_t
 
n
, 
uint16_t
 *
resultbuf
,

114 
size_t
 *
lengthp
);

124 
u8_mblen
 (const 
uint8_t
 *
s
, 
size_t
 
n
);

126 
u16_mblen
 (const 
uint16_t
 *
s
, 
size_t
 
n
);

128 
u32_mblen
 (const 
uint32_t
 *
s
, 
size_t
 
n
);

139 #if 
GNULIB_UNISTR_U8_MBTOUC_UNSAFE
 || 
HAVE_LIBUNISTRING


140 #if !
HAVE_INLINE


142 
u8_mbtouc_unsafe
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
);

145 
u8_mbtouc_unsafe_aux
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
);

146 static 
inline
 int

147 
u8_mbtouc_unsafe
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
)

149 
uint8_t
 
	gc
 = *
s
;

151 if (
	gc
 < 0x80)

153 *
	gpuc
 = 
c
;

157 return 
u8_mbtouc_unsafe_aux
 (
puc
, 
s
, 
n
);

162 #if 
GNULIB_UNISTR_U16_MBTOUC_UNSAFE
 || 
HAVE_LIBUNISTRING


163 #if !
HAVE_INLINE


165 
u16_mbtouc_unsafe
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, 
size_t
 
n
);

168 
u16_mbtouc_unsafe_aux
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, 
size_t
 
n
);

169 static 
inline
 int

170 
u16_mbtouc_unsafe
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, 
size_t
 
n
)

172 
uint16_t
 
	gc
 = *
s
;

174 if (
	gc
 < 0xd800 || c >= 0xe000)

176 *
puc
 = 
c
;

180 return 
u16_mbtouc_unsafe_aux
 (
puc
, 
s
, 
n
);

185 #if 
GNULIB_UNISTR_U32_MBTOUC_UNSAFE
 || 
HAVE_LIBUNISTRING


186 #if !
HAVE_INLINE


188 
u32_mbtouc_unsafe
 (
ucs4_t
 *
puc
, const 
uint32_t
 *
s
, 
size_t
 
n
);

190 static 
inline
 int

191 
u32_mbtouc_unsafe
 (
ucs4_t
 *
puc
,

192 const 
uint32_t
 *
s
, 
size_t
 
n
 
_GL_UNUSED_PARAMETER
)

194 
uint32_t
 
	gc
 = *
s
;

196 #if 
CONFIG_UNICODE_SAFETY


197 if (
	gc
 < 0xd800 || (c >= 0xe000 && 
c
 < 0x110000))

199 *
puc
 = 
c
;

200 #if 
CONFIG_UNICODE_SAFETY


203 *
	gpuc
 = 0xfffd;

210 #if 
GNULIB_UNISTR_U8_MBTOUC
 || 
HAVE_LIBUNISTRING


211 #if !
HAVE_INLINE


213 
u8_mbtouc
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
);

216 
u8_mbtouc_aux
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
);

217 static 
inline
 int

218 
u8_mbtouc
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
)

220 
uint8_t
 
	gc
 = *
s
;

222 if (
	gc
 < 0x80)

224 *
	gpuc
 = 
c
;

228 return 
u8_mbtouc_aux
 (
puc
, 
s
, 
n
);

233 #if 
GNULIB_UNISTR_U16_MBTOUC
 || 
HAVE_LIBUNISTRING


234 #if !
HAVE_INLINE


236 
u16_mbtouc
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, 
size_t
 
n
);

239 
u16_mbtouc_aux
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, 
size_t
 
n
);

240 static 
inline
 int

241 
u16_mbtouc
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, 
size_t
 
n
)

243 
uint16_t
 
	gc
 = *
s
;

245 if (
	gc
 < 0xd800 || c >= 0xe000)

247 *
puc
 = 
c
;

251 return 
u16_mbtouc_aux
 (
puc
, 
s
, 
n
);

256 #if 
GNULIB_UNISTR_U32_MBTOUC
 || 
HAVE_LIBUNISTRING


257 #if !
HAVE_INLINE


259 
u32_mbtouc
 (
ucs4_t
 *
puc
, const 
uint32_t
 *
s
, 
size_t
 
n
);

261 static 
inline
 int

262 
u32_mbtouc
 (
ucs4_t
 *
puc
, const 
uint32_t
 *
s
, 
size_t
 
n
 
_GL_UNUSED_PARAMETER
)

264 
uint32_t
 
	gc
 = *
s
;

266 if (
	gc
 < 0xd800 || (c >= 0xe000 && 
c
 < 0x110000))

267 *
puc
 = 
c
;

270 *
	gpuc
 = 0xfffd;

284 #if 
GNULIB_UNISTR_U8_MBTOUCR
 || 
HAVE_LIBUNISTRING


286 
u8_mbtoucr
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
);

289 #if 
GNULIB_UNISTR_U16_MBTOUCR
 || 
HAVE_LIBUNISTRING


291 
u16_mbtoucr
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, 
size_t
 
n
);

294 #if 
GNULIB_UNISTR_U32_MBTOUCR
 || 
HAVE_LIBUNISTRING


296 
u32_mbtoucr
 (
ucs4_t
 *
puc
, const 
uint32_t
 *
s
, 
size_t
 
n
);

305 #if 
GNULIB_UNISTR_U8_UCTOMB
 || 
HAVE_LIBUNISTRING


308 
u8_uctomb_aux
 (
uint8_t
 *
s
, 
ucs4_t
 
uc
, int 
n
);

309 #if !
HAVE_INLINE


311 
u8_uctomb
 (
uint8_t
 *
s
, 
ucs4_t
 
uc
, int 
n
);

313 static 
inline
 int

314 
u8_uctomb
 (
uint8_t
 *
s
, 
ucs4_t
 
uc
, int 
n
)

316 if (
	guc
 < 0x80 && 
	gn
 > 0)

318 
	gs
[0] = 
uc
;

322 return 
u8_uctomb_aux
 (
s
, 
uc
, 
n
);

327 #if 
GNULIB_UNISTR_U16_UCTOMB
 || 
HAVE_LIBUNISTRING


330 
u16_uctomb_aux
 (
uint16_t
 *
s
, 
ucs4_t
 
uc
, int 
n
);

331 #if !
HAVE_INLINE


333 
u16_uctomb
 (
uint16_t
 *
s
, 
ucs4_t
 
uc
, int 
n
);

335 static 
inline
 int

336 
u16_uctomb
 (
uint16_t
 *
s
, 
ucs4_t
 
uc
, int 
n
)

338 if (
	guc
 < 0xd800 && 
	gn
 > 0)

340 
	gs
[0] = 
uc
;

344 return 
u16_uctomb_aux
 (
s
, 
uc
, 
n
);

349 #if 
GNULIB_UNISTR_U32_UCTOMB
 || 
HAVE_LIBUNISTRING


350 #if !
HAVE_INLINE


352 
u32_uctomb
 (
uint32_t
 *
s
, 
ucs4_t
 
uc
, int 
n
);

354 static 
inline
 int

355 
u32_uctomb
 (
uint32_t
 *
s
, 
ucs4_t
 
uc
, int 
n
)

357 if (
	guc
 < 0xd800 || (uc >= 0xe000 && 
uc
 < 0x110000))

359 if (
n
 > 0)

361 *
s
 = 
uc
;

375 extern 
uint8_t
 *

376 
u8_cpy
 (
uint8_t
 *
dest
, const uint8_t *
src
, 
size_t
 
n
);

377 extern 
uint16_t
 *

378 
u16_cpy
 (
uint16_t
 *
dest
, const uint16_t *
src
, 
size_t
 
n
);

379 extern 
uint32_t
 *

380 
u32_cpy
 (
uint32_t
 *
dest
, const uint32_t *
src
, 
size_t
 
n
);

385 extern 
uint8_t
 *

386 
u8_move
 (
uint8_t
 *
dest
, const uint8_t *
src
, 
size_t
 
n
);

387 extern 
uint16_t
 *

388 
u16_move
 (
uint16_t
 *
dest
, const uint16_t *
src
, 
size_t
 
n
);

389 extern 
uint32_t
 *

390 
u32_move
 (
uint32_t
 *
dest
, const uint32_t *
src
, 
size_t
 
n
);

395 extern 
uint8_t
 *

396 
u8_set
 (
uint8_t
 *
s
, 
ucs4_t
 
uc
, 
size_t
 
n
);

397 extern 
uint16_t
 *

398 
u16_set
 (
uint16_t
 *
s
, 
ucs4_t
 
uc
, 
size_t
 
n
);

399 extern 
uint32_t
 *

400 
u32_set
 (
uint32_t
 *
s
, 
ucs4_t
 
uc
, 
size_t
 
n
);

405 
u8_cmp
 (const 
uint8_t
 *
s1
, const uint8_t *
s2
, 
size_t
 
n
);

407 
u16_cmp
 (const 
uint16_t
 *
s1
, const uint16_t *
s2
, 
size_t
 
n
);

409 
u32_cmp
 (const 
uint32_t
 *
s1
, const uint32_t *
s2
, 
size_t
 
n
);

414 
u8_cmp2
 (const 
uint8_t
 *
s1
, 
size_t
 
n1
, const uint8_t *
s2
, size_t 
n2
);

416 
u16_cmp2
 (const 
uint16_t
 *
s1
, 
size_t
 
n1
, const uint16_t *
s2
, size_t 
n2
);

418 
u32_cmp2
 (const 
uint32_t
 *
s1
, 
size_t
 
n1
, const uint32_t *
s2
, size_t 
n2
);

422 extern 
uint8_t
 *

423 
u8_chr
 (const 
uint8_t
 *
s
, 
size_t
 
n
, 
ucs4_t
 
uc
);

424 extern 
uint16_t
 *

425 
u16_chr
 (const 
uint16_t
 *
s
, 
size_t
 
n
, 
ucs4_t
 
uc
);

426 extern 
uint32_t
 *

427 
u32_chr
 (const 
uint32_t
 *
s
, 
size_t
 
n
, 
ucs4_t
 
uc
);

431 extern 
size_t


432 
u8_mbsnlen
 (const 
uint8_t
 *
s
, 
size_t
 
n
);

433 extern 
size_t


434 
u16_mbsnlen
 (const 
uint16_t
 *
s
, 
size_t
 
n
);

435 extern 
size_t


436 
u32_mbsnlen
 (const 
uint32_t
 *
s
, 
size_t
 
n
);

441 extern 
uint8_t
 *

442 
u8_cpy_alloc
 (const 
uint8_t
 *
s
, 
size_t
 
n
);

443 extern 
uint16_t
 *

444 
u16_cpy_alloc
 (const 
uint16_t
 *
s
, 
size_t
 
n
);

445 extern 
uint32_t
 *

446 
u32_cpy_alloc
 (const 
uint32_t
 *
s
, 
size_t
 
n
);

453 
u8_strmblen
 (const 
uint8_t
 *
s
);

455 
u16_strmblen
 (const 
uint16_t
 *
s
);

457 
u32_strmblen
 (const 
uint32_t
 *
s
);

463 
u8_strmbtouc
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
);

465 
u16_strmbtouc
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
);

467 
u32_strmbtouc
 (
ucs4_t
 *
puc
, const 
uint32_t
 *
s
);

472 extern const 
uint8_t
 *

473 
u8_next
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
);

474 extern const 
uint16_t
 *

475 
u16_next
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
);

476 extern const 
uint32_t
 *

477 
u32_next
 (
ucs4_t
 *
puc
, const 
uint32_t
 *
s
);

482 extern const 
uint8_t
 *

483 
u8_prev
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, const uint8_t *
start
);

484 extern const 
uint16_t
 *

485 
u16_prev
 (
ucs4_t
 *
puc
, const 
uint16_t
 *
s
, const uint16_t *
start
);

486 extern const 
uint32_t
 *

487 
u32_prev
 (
ucs4_t
 *
puc
, const 
uint32_t
 *
s
, const uint32_t *
start
);

491 extern 
size_t


492 
u8_strlen
 (const 
uint8_t
 *
s
);

493 extern 
size_t


494 
u16_strlen
 (const 
uint16_t
 *
s
);

495 extern 
size_t


496 
u32_strlen
 (const 
uint32_t
 *
s
);

500 extern 
size_t


501 
u8_strnlen
 (const 
uint8_t
 *
s
, 
size_t
 
maxlen
);

502 extern 
size_t


503 
u16_strnlen
 (const 
uint16_t
 *
s
, 
size_t
 
maxlen
);

504 extern 
size_t


505 
u32_strnlen
 (const 
uint32_t
 *
s
, 
size_t
 
maxlen
);

509 extern 
uint8_t
 *

510 
u8_strcpy
 (
uint8_t
 *
dest
, const uint8_t *
src
);

511 extern 
uint16_t
 *

512 
u16_strcpy
 (
uint16_t
 *
dest
, const uint16_t *
src
);

513 extern 
uint32_t
 *

514 
u32_strcpy
 (
uint32_t
 *
dest
, const uint32_t *
src
);

518 extern 
uint8_t
 *

519 
u8_stpcpy
 (
uint8_t
 *
dest
, const uint8_t *
src
);

520 extern 
uint16_t
 *

521 
u16_stpcpy
 (
uint16_t
 *
dest
, const uint16_t *
src
);

522 extern 
uint32_t
 *

523 
u32_stpcpy
 (
uint32_t
 *
dest
, const uint32_t *
src
);

527 extern 
uint8_t
 *

528 
u8_strncpy
 (
uint8_t
 *
dest
, const uint8_t *
src
, 
size_t
 
n
);

529 extern 
uint16_t
 *

530 
u16_strncpy
 (
uint16_t
 *
dest
, const uint16_t *
src
, 
size_t
 
n
);

531 extern 
uint32_t
 *

532 
u32_strncpy
 (
uint32_t
 *
dest
, const uint32_t *
src
, 
size_t
 
n
);

537 extern 
uint8_t
 *

538 
u8_stpncpy
 (
uint8_t
 *
dest
, const uint8_t *
src
, 
size_t
 
n
);

539 extern 
uint16_t
 *

540 
u16_stpncpy
 (
uint16_t
 *
dest
, const uint16_t *
src
, 
size_t
 
n
);

541 extern 
uint32_t
 *

542 
u32_stpncpy
 (
uint32_t
 *
dest
, const uint32_t *
src
, 
size_t
 
n
);

546 extern 
uint8_t
 *

547 
u8_strcat
 (
uint8_t
 *
dest
, const uint8_t *
src
);

548 extern 
uint16_t
 *

549 
u16_strcat
 (
uint16_t
 *
dest
, const uint16_t *
src
);

550 extern 
uint32_t
 *

551 
u32_strcat
 (
uint32_t
 *
dest
, const uint32_t *
src
);

555 extern 
uint8_t
 *

556 
u8_strncat
 (
uint8_t
 *
dest
, const uint8_t *
src
, 
size_t
 
n
);

557 extern 
uint16_t
 *

558 
u16_strncat
 (
uint16_t
 *
dest
, const uint16_t *
src
, 
size_t
 
n
);

559 extern 
uint32_t
 *

560 
u32_strncat
 (
uint32_t
 *
dest
, const uint32_t *
src
, 
size_t
 
n
);

564 #ifdef 
__sun


567 
u8_strcmp_gnu
 (const 
uint8_t
 *
s1
, const uint8_t *
s2
);

568 #define 
	#u8_strcmp
 
u8_strcmp_gnu


	)

571 
u8_strcmp
 (const 
uint8_t
 *
s1
, const uint8_t *
s2
);

574 
u16_strcmp
 (const 
uint16_t
 *
s1
, const uint16_t *
s2
);

576 
u32_strcmp
 (const 
uint32_t
 *
s1
, const uint32_t *
s2
);

583 
u8_strcoll
 (const 
uint8_t
 *
s1
, const uint8_t *
s2
);

585 
u16_strcoll
 (const 
uint16_t
 *
s1
, const uint16_t *
s2
);

587 
u32_strcoll
 (const 
uint32_t
 *
s1
, const uint32_t *
s2
);

592 
u8_strncmp
 (const 
uint8_t
 *
s1
, const uint8_t *
s2
, 
size_t
 
n
);

594 
u16_strncmp
 (const 
uint16_t
 *
s1
, const uint16_t *
s2
, 
size_t
 
n
);

596 
u32_strncmp
 (const 
uint32_t
 *
s1
, const uint32_t *
s2
, 
size_t
 
n
);

600 extern 
uint8_t
 *

601 
u8_strdup
 (const 
uint8_t
 *
s
);

602 extern 
uint16_t
 *

603 
u16_strdup
 (const 
uint16_t
 *
s
);

604 extern 
uint32_t
 *

605 
u32_strdup
 (const 
uint32_t
 *
s
);

609 extern 
uint8_t
 *

610 
u8_strchr
 (const 
uint8_t
 *
str
, 
ucs4_t
 
uc
);

611 extern 
uint16_t
 *

612 
u16_strchr
 (const 
uint16_t
 *
str
, 
ucs4_t
 
uc
);

613 extern 
uint32_t
 *

614 
u32_strchr
 (const 
uint32_t
 *
str
, 
ucs4_t
 
uc
);

618 extern 
uint8_t
 *

619 
u8_strrchr
 (const 
uint8_t
 *
str
, 
ucs4_t
 
uc
);

620 extern 
uint16_t
 *

621 
u16_strrchr
 (const 
uint16_t
 *
str
, 
ucs4_t
 
uc
);

622 extern 
uint32_t
 *

623 
u32_strrchr
 (const 
uint32_t
 *
str
, 
ucs4_t
 
uc
);

628 extern 
size_t


629 
u8_strcspn
 (const 
uint8_t
 *
str
, const uint8_t *
reject
);

630 extern 
size_t


631 
u16_strcspn
 (const 
uint16_t
 *
str
, const uint16_t *
reject
);

632 extern 
size_t


633 
u32_strcspn
 (const 
uint32_t
 *
str
, const uint32_t *
reject
);

638 extern 
size_t


639 
u8_strspn
 (const 
uint8_t
 *
str
, const uint8_t *
accept
);

640 extern 
size_t


641 
u16_strspn
 (const 
uint16_t
 *
str
, const uint16_t *
accept
);

642 extern 
size_t


643 
u32_strspn
 (const 
uint32_t
 *
str
, const uint32_t *
accept
);

647 extern 
uint8_t
 *

648 
u8_strpbrk
 (const 
uint8_t
 *
str
, const uint8_t *
accept
);

649 extern 
uint16_t
 *

650 
u16_strpbrk
 (const 
uint16_t
 *
str
, const uint16_t *
accept
);

651 extern 
uint32_t
 *

652 
u32_strpbrk
 (const 
uint32_t
 *
str
, const uint32_t *
accept
);

656 extern 
uint8_t
 *

657 
u8_strstr
 (const 
uint8_t
 *
haystack
, const uint8_t *
needle
);

658 extern 
uint16_t
 *

659 
u16_strstr
 (const 
uint16_t
 *
haystack
, const uint16_t *
needle
);

660 extern 
uint32_t
 *

661 
u32_strstr
 (const 
uint32_t
 *
haystack
, const uint32_t *
needle
);

664 extern 
bool


665 
u8_startswith
 (const 
uint8_t
 *
str
, const uint8_t *
prefix
);

666 extern 
bool


667 
u16_startswith
 (const 
uint16_t
 *
str
, const uint16_t *
prefix
);

668 extern 
bool


669 
u32_startswith
 (const 
uint32_t
 *
str
, const uint32_t *
prefix
);

672 extern 
bool


673 
u8_endswith
 (const 
uint8_t
 *
str
, const uint8_t *
suffix
);

674 extern 
bool


675 
u16_endswith
 (const 
uint16_t
 *
str
, const uint16_t *
suffix
);

676 extern 
bool


677 
u32_endswith
 (const 
uint32_t
 *
str
, const uint32_t *
suffix
);

682 extern 
uint8_t
 *

683 
u8_strtok
 (
uint8_t
 *
str
, const uint8_t *
delim
, uint8_t **
ptr
);

684 extern 
uint16_t
 *

685 
u16_strtok
 (
uint16_t
 *
str
, const uint16_t *
delim
, uint16_t **
ptr
);

686 extern 
uint32_t
 *

687 
u32_strtok
 (
uint32_t
 *
str
, const uint32_t *
delim
, uint32_t **
ptr
);

690 #ifdef 
__cplusplus


	@lib/unistr/u8-mbtoucr.c

20 #include 
	~<config.h
>

23 #include 
	~"unistr.h
"

26 
	$u8_mbtoucr
 (
ucs4_t
 *
puc
, const 
uint8_t
 *
s
, 
size_t
 
n
)

28 
uint8_t
 
c
 = *
s
;

30 if (
c
 < 0x80)

32 *
puc
 = 
c
;

35 else if (
c
 >= 0xc2)

37 if (
c
 < 0xe0)

39 if (
n
 >= 2)

41 if ((
s
[1] ^ 0x80) < 0x40)

43 *
puc
 = ((unsigned int) (
c
 & 0x1f) << 6)

44 | (unsigned int) (
s
[1] ^ 0x80);

52 *
puc
 = 0xfffd;

56 else if (
c
 < 0xf0)

58 if (
n
 >= 2)

60 if ((
s
[1] ^ 0x80) < 0x40

61 && (
c
 >= 0xe1 || 
s
[1] >= 0xa0)

62 && (
c
 != 0xed || 
s
[1] < 0xa0))

64 if (
n
 >= 3)

66 if ((
s
[2] ^ 0x80) < 0x40)

68 *
puc
 = ((unsigned int) (
c
 & 0x0f) << 12)

69 | ((unsigned int) (
s
[1] ^ 0x80) << 6)

70 | (unsigned int) (
s
[2] ^ 0x80);

78 *
puc
 = 0xfffd;

87 *
puc
 = 0xfffd;

91 else if (
c
 < 0xf8)

93 if (
n
 >= 2)

95 if ((
s
[1] ^ 0x80) < 0x40

96 && (
c
 >= 0xf1 || 
s
[1] >= 0x90)

98 && (
c
 < 0xf4 || (c == 0xf4 && 
s
[1] < 0x90))

102 if (
n
 >= 3)

104 if ((
s
[2] ^ 0x80) < 0x40)

106 if (
n
 >= 4)

108 if ((
s
[3] ^ 0x80) < 0x40)

110 *
puc
 = ((unsigned int) (
c
 & 0x07) << 18)

111 | ((unsigned int) (
s
[1] ^ 0x80) << 12)

112 | ((unsigned int) (
s
[2] ^ 0x80) << 6)

113 | (unsigned int) (
s
[3] ^ 0x80);

121 *
puc
 = 0xfffd;

130 *
puc
 = 0xfffd;

139 *
puc
 = 0xfffd;

144 else if (
c
 < 0xfc)

146 if (
n
 >= 2)

148 if ((
s
[1] ^ 0x80) < 0x40

149 && (
c
 >= 0xf9 || 
s
[1] >= 0x88))

151 if (
n
 >= 3)

153 if ((
s
[2] ^ 0x80) < 0x40)

155 if (
n
 >= 4)

157 if ((
s
[3] ^ 0x80) < 0x40)

159 if (
n
 >= 5)

161 if ((
s
[4] ^ 0x80) < 0x40)

163 *
puc
 = ((unsigned int) (
c
 & 0x03) << 24)

164 | ((unsigned int) (
s
[1] ^ 0x80) << 18)

165 | ((unsigned int) (
s
[2] ^ 0x80) << 12)

166 | ((unsigned int) (
s
[3] ^ 0x80) << 6)

167 | (unsigned int) (
s
[4] ^ 0x80);

175 *
puc
 = 0xfffd;

184 *
puc
 = 0xfffd;

193 *
puc
 = 0xfffd;

202 *
puc
 = 0xfffd;

206 else if (
c
 < 0xfe)

208 if (
n
 >= 2)

210 if ((
s
[1] ^ 0x80) < 0x40

211 && (
c
 >= 0xfd || 
s
[1] >= 0x84))

213 if (
n
 >= 3)

215 if ((
s
[2] ^ 0x80) < 0x40)

217 if (
n
 >= 4)

219 if ((
s
[3] ^ 0x80) < 0x40)

221 if (
n
 >= 5)

223 if ((
s
[4] ^ 0x80) < 0x40)

225 if (
n
 >= 6)

227 if ((
s
[5] ^ 0x80) < 0x40)

229 *
puc
 = ((unsigned int) (
c
 & 0x01) << 30)

230 | ((unsigned int) (
s
[1] ^ 0x80) << 24)

231 | ((unsigned int) (
s
[2] ^ 0x80) << 18)

232 | ((unsigned int) (
s
[3] ^ 0x80) << 12)

233 | ((unsigned int) (
s
[4] ^ 0x80) << 6)

234 | (unsigned int) (
s
[5] ^ 0x80);

242 *
puc
 = 0xfffd;

251 *
puc
 = 0xfffd;

260 *
puc
 = 0xfffd;

269 *
puc
 = 0xfffd;

278 *
puc
 = 0xfffd;

285 *
puc
 = 0xfffd;

287 
	}
}

	@lib/unistr/u8-uctomb-aux.c

20 #include 
	~<config.h
>

23 #include 
	~"unistr.h
"

26 
	$u8_uctomb_aux
 (
uint8_t
 *
s
, 
ucs4_t
 
uc
, int 
n
)

28 int 
count
;

30 if (
uc
 < 0x80)

33 else if (
uc
 < 0x800)

34 
count
 = 2;

35 else if (
uc
 < 0x10000)

37 if (
uc
 < 0xd800 || uc >= 0xe000)

38 
count
 = 3;

43 else if (
uc
 < 0x200000)

44 
count
 = 4;

45 else if (
uc
 < 0x4000000)

46 
count
 = 5;

47 else if (
uc
 <= 0x7fffffff)

48 
count
 = 6;

50 else if (
uc
 < 0x110000)

51 
count
 = 4;

56 if (
n
 < 
count
)

59 switch (
count
)

62 case 6: 
s
[5] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x4000000;

63 case 5: 
s
[4] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x200000;

65 case 4: 
s
[3] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x10000;

66 case 3: 
s
[2] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x800;

67 case 2: 
s
[1] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0xc0;

68  
s
[0] = 
uc
;

70 return 
count
;

71 
	}
}

	@lib/unistr/u8-uctomb.c

20 #include 
	~<config.h
>

22 #if 
defined
 
IN_LIBUNISTRING


24 #include 
	~"unistring-notinline.h
"

28 #include 
	~"unistr.h
"

30 #if !
HAVE_INLINE


33 
	$u8_uctomb
 (
uint8_t
 *
s
, 
ucs4_t
 
uc
, int 
n
)

35 if (
uc
 < 0x80)

37 if (
n
 > 0)

39 
s
[0] = 
uc
;

46 int 
count
;

48 if (
uc
 < 0x800)

49 
count
 = 2;

50 else if (
uc
 < 0x10000)

52 if (
uc
 < 0xd800 || uc >= 0xe000)

53 
count
 = 3;

58 else if (
uc
 < 0x200000)

59 
count
 = 4;

60 else if (
uc
 < 0x4000000)

61 
count
 = 5;

62 else if (
uc
 <= 0x7fffffff)

63 
count
 = 6;

65 else if (
uc
 < 0x110000)

66 
count
 = 4;

71 if (
n
 >= 
count
)

73 switch (
count
)

76 case 6: 
s
[5] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x4000000;

77 case 5: 
s
[4] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x200000;

79 case 4: 
s
[3] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x10000;

80 case 3: 
s
[2] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0x800;

81 case 2: 
s
[1] = 0x80 | (
uc
 & 0x3f); uc = uc >> 6; uc |= 0xc0;

82  
s
[0] = 
uc
;

84 return 
count
;

88 
	}
}

	@lib/unitypes.in.h

19 #ifndef 
_UNITYPES_H


20 #define 
	#_UNITYPES_H


	)

23 #include 
	~<stdint.h
>

26 typedef 
uint32_t
 
	tucs4_t
;

	@lib/uniwidth.in.h

20 #ifndef 
_UNIWIDTH_H


21 #define 
	#_UNIWIDTH_H


	)

23 #include 
	~"unitypes.h
"

26 #include 
	~<stddef.h
>

29 #include 
	~"localcharset.h
"

31 #ifdef 
__cplusplus


43 
uc_width
 (
ucs4_t
 
uc
, const char *
encoding
);

48 
u8_width
 (const 
uint8_t
 *
s
, 
size_t
 
n
, const char *
encoding
);

50 
u16_width
 (const 
uint16_t
 *
s
, 
size_t
 
n
, const char *
encoding
);

52 
u32_width
 (const 
uint32_t
 *
s
, 
size_t
 
n
, const char *
encoding
);

56 
u8_strwidth
 (const 
uint8_t
 *
s
, const char *
encoding
);

58 
u16_strwidth
 (const 
uint16_t
 *
s
, const char *
encoding
);

60 
u32_strwidth
 (const 
uint32_t
 *
s
, const char *
encoding
);

63 #ifdef 
__cplusplus


	@lib/uniwidth/cjk.h

20 #include 
	~"streq.h
"

23 
	$is_cjk_encoding
 (const char *
encoding
)

27 || 
	`STREQ
 (
encoding
, "EUC-JP", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0)

29 || 
	`STREQ
 (
encoding
, "GB2312", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)

30 || 
	`STREQ
 (
encoding
, "GBK", 'G', 'B', 'K', 0, 0, 0, 0, 0, 0)

31 || 
	`STREQ
 (
encoding
, "EUC-TW", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0)

32 || 
	`STREQ
 (
encoding
, "BIG5", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0)

34 || 
	`STREQ
 (
encoding
, "EUC-KR", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)

35 || 
	`STREQ
 (
encoding
, "CP949", 'C', 'P', '9', '4', '9', 0, 0, 0, 0)

36 || 
	`STREQ
 (
encoding
, "JOHAB", 'J', 'O', 'H', 'A', 'B', 0, 0, 0, 0))

39 
	}
}

	@lib/uniwidth/width.c

20 #include 
	~<config.h
>

23 #include 
	~"uniwidth.h
"

25 #include 
	~"cjk.h
"

37 static const unsigned char 
	gnonspacing_table_data
[27*64] = {

282 static const signed char 
	gnonspacing_table_ind
[240] = {

317 
	$uc_width
 (
ucs4_t
 
uc
, const char *
encoding
)

320 if ((
uc
 >> 9) < 240)

322 int 
ind
 = 
nonspacing_table_ind
[
uc
 >> 9];

323 if (
ind
 >= 0)

324 if ((
nonspacing_table_data
[64*
ind
 + ((
uc
 >> 3) & 63)] >> (uc & 7)) & 1)

326 if (
uc
 > 0 && uc < 0xa0)

332 else if ((
uc
 >> 9) == (0xe0000 >> 9))

334 if (
uc
 >= 0xe0100)

336 if (
uc
 <= 0xe01ef)

341 if (
uc
 >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)

349 if (
uc
 >= 0x1100

350 && ((
uc
 < 0x1160)

351 || (
uc
 >= 0x2329 && uc < 0x232b)

352 || (
uc
 >= 0x2e80 && uc < 0xa4d0

353 && !(
uc
 == 0x303f) && !(uc >= 0x4dc0 && uc < 0x4e00))

354 || (
uc
 >= 0xac00 && uc < 0xd7a4)

355 || (
uc
 >= 0xf900 && uc < 0xfb00)

356 || (
uc
 >= 0xfe10 && uc < 0xfe20)

357 || (
uc
 >= 0xfe30 && uc < 0xfe70)

358 || (
uc
 >= 0xff00 && uc < 0xff61)

359 || (
uc
 >= 0xffe0 && uc < 0xffe7)

360 || (
uc
 >= 0x20000 && uc <= 0x2ffff)

361 || (
uc
 >= 0x30000 && uc <= 0x3ffff)

366 if (
uc
 >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9

367 && 
	`is_cjk_encoding
 (
encoding
))

370 
	}
}

	@lib/unlocked-io.h

20 #ifndef 
UNLOCKED_IO_H


21 #define 
	#UNLOCKED_IO_H
 1

	)

34 #include 
	~<stdio.h
>

36 #if 
HAVE_DECL_CLEARERR_UNLOCKED


37 #undef 
clearerr


38 #define 
	#clearerr
(
x
) 
	`clearerr_unlocked
 (x)

	)

40 #define 
	#clearerr_unlocked
(
x
) 
	`clearerr
 (x)

	)

43 #if 
HAVE_DECL_FEOF_UNLOCKED


44 #undef 
feof


45 #define 
	#feof
(
x
) 
	`feof_unlocked
 (x)

	)

47 #define 
	#feof_unlocked
(
x
) 
	`feof
 (x)

	)

50 #if 
HAVE_DECL_FERROR_UNLOCKED


51 #undef 
ferror


52 #define 
	#ferror
(
x
) 
	`ferror_unlocked
 (x)

	)

54 #define 
	#ferror_unlocked
(
x
) 
	`ferror
 (x)

	)

57 #if 
HAVE_DECL_FFLUSH_UNLOCKED


58 #undef 
fflush


59 #define 
	#fflush
(
x
) 
	`fflush_unlocked
 (x)

	)

61 #define 
	#fflush_unlocked
(
x
) 
	`fflush
 (x)

	)

64 #if 
HAVE_DECL_FGETS_UNLOCKED


65 #undef 
fgets


66 #define 
	#fgets
(
x
,
y
,
z
) 
	`fgets_unlocked
 (x,y,z)

	)

68 #define 
	#fgets_unlocked
(
x
,
y
,
z
) 
	`fgets
 (x,y,z)

	)

71 #if 
HAVE_DECL_FPUTC_UNLOCKED


72 #undef 
fputc


73 #define 
	#fputc
(
x
,
y
) 
	`fputc_unlocked
 (x,y)

	)

75 #define 
	#fputc_unlocked
(
x
,
y
) 
	`fputc
 (x,y)

	)

78 #if 
HAVE_DECL_FPUTS_UNLOCKED


79 #undef 
fputs


80 #define 
	#fputs
(
x
,
y
) 
	`fputs_unlocked
 (x,y)

	)

82 #define 
	#fputs_unlocked
(
x
,
y
) 
	`fputs
 (x,y)

	)

85 #if 
HAVE_DECL_FREAD_UNLOCKED


86 #undef 
fread


87 #define 
	#fread
(
w
,
x
,
y
,
z
) 
	`fread_unlocked
 (w,x,y,z)

	)

89 #define 
	#fread_unlocked
(
w
,
x
,
y
,
z
) 
	`fread
 (w,x,y,z)

	)

92 #if 
HAVE_DECL_FWRITE_UNLOCKED


93 #undef 
fwrite


94 #define 
	#fwrite
(
w
,
x
,
y
,
z
) 
	`fwrite_unlocked
 (w,x,y,z)

	)

96 #define 
	#fwrite_unlocked
(
w
,
x
,
y
,
z
) 
	`fwrite
 (w,x,y,z)

	)

99 #if 
HAVE_DECL_GETC_UNLOCKED


100 #undef 
getc


101 #define 
	#getc
(
x
) 
	`getc_unlocked
 (x)

	)

103 #define 
	#getc_unlocked
(
x
) 
	`getc
 (x)

	)

106 #if 
HAVE_DECL_GETCHAR_UNLOCKED


107 #undef 
getchar


108 #define 
	#getchar
() 
	`getchar_unlocked
 ()

	)

110 #define 
	#getchar_unlocked
() 
	`getchar
 ()

	)

113 #if 
HAVE_DECL_PUTC_UNLOCKED


114 #undef 
putc


115 #define 
	#putc
(
x
,
y
) 
	`putc_unlocked
 (x,y)

	)

117 #define 
	#putc_unlocked
(
x
,
y
) 
	`putc
 (x,y)

	)

120 #if 
HAVE_DECL_PUTCHAR_UNLOCKED


121 #undef 
putchar


122 #define 
	#putchar
(
x
) 
	`putchar_unlocked
 (x)

	)

124 #define 
	#putchar_unlocked
(
x
) 
	`putchar
 (x)

	)

127 #undef 
flockfile


128 #define 
	#flockfile
(
x
) ((void) 0)

	)

130 #undef 
ftrylockfile


131 #define 
	#ftrylockfile
(
x
) 0

	)

133 #undef 
funlockfile


134 #define 
	#funlockfile
(
x
) ((void) 0)

	)

	@lib/verify.h

20 #ifndef 
_GL_VERIFY_H


21 #define 
	#_GL_VERIFY_H


	)

36 #if (4 < 
__GNUC__
 || (__GNUC__ == 4 && 6 <= 
__GNUC_MINOR__
)) && !
defined
 
__cplusplus


37 #define 
	#_GL_HAVE__STATIC_ASSERT
 1

	)

41 #if (99 < 
__GNUC__
) && 
defined
 
__cplusplus


42 #define 
	#_GL_HAVE_STATIC_ASSERT
 1

	)

142 #define 
	#_GL_CONCAT
(
x
, 
y
) 
	`_GL_CONCAT0
 (x, y)

	)

143 #define 
	#_GL_CONCAT0
(
x
, 
y
) x##
	)
y

149 #if 
defined
 
__COUNTER__
 && __COUNTER__ != __COUNTER__

150 #define 
	#_GL_COUNTER
 
__COUNTER__


	)

152 #define 
	#_GL_COUNTER
 
__LINE__


	)

157 #define 
	#_GL_GENSYM
(
prefix
) 
	`_GL_CONCAT
 (prefix, 
_GL_COUNTER
)

	)

163 #define 
	#_GL_VERIFY_TRUE
(
R
, 
DIAGNOSTIC
) \

164 (!!sizeof (
	`_GL_VERIFY_TYPE
 (
R
, 
DIAGNOSTIC
)))

	)

166 #ifdef 
__cplusplus


167 #if !
GNULIB_defined_struct__gl_verify_type


168 
	gtemplate
 <int 
	gw
>

169 struct 
	s_gl_verify_type
 {

170 unsigned int 
	m_gl_verify_error_if_negative
: 
w
;

172 #define 
	#GNULIB_defined_struct__gl_verify_type
 1

	)

174 #define 
	#_GL_VERIFY_TYPE
(
R
, 
DIAGNOSTIC
) \

175 
_gl_verify_type
<(
R
) ? 1 : -1>

	)

176 #elif 
defined
 
_GL_HAVE__STATIC_ASSERT


177 #define 
	#_GL_VERIFY_TYPE
(
R
, 
DIAGNOSTIC
) \

179 
	`_Static_assert
 (
R
, 
DIAGNOSTIC
); \

180 int 
_gl_dummy
; \

181 }

	)

183 #define 
	#_GL_VERIFY_TYPE
(
R
, 
DIAGNOSTIC
) \

184 struct { unsigned int 
_gl_verify_error_if_negative
: (
R
) ? 1 : -1; }

	)

194 #ifdef 
_GL_HAVE__STATIC_ASSERT


195 #define 
	#_GL_VERIFY
 
_Static_assert


	)

197 #define 
	#_GL_VERIFY
(
R
, 
DIAGNOSTIC
) \

198 extern int (*
	`_GL_GENSYM
 (
_gl_verify_function
) (void)) \

199 [
	`_GL_VERIFY_TRUE
 (
R
, 
DIAGNOSTIC
)]

	)

203 #ifdef 
_GL_STATIC_ASSERT_H


204 #if !
defined
 
_GL_HAVE__STATIC_ASSERT
 && !defined 
_Static_assert


205 #define 
	#_Static_assert
(
R
, 
DIAGNOSTIC
) 
	`_GL_VERIFY
 (R, DIAGNOSTIC)

	)

207 #if !
defined
 
_GL_HAVE_STATIC_ASSERT
 && !defined 
static_assert


208 #define 
	#static_assert
 
_Static_assert


	)

228 #define 
	#verify_true
(
R
) 
	`_GL_VERIFY_TRUE
 (R, "verify_true (" #R ")")

	)

233 #define 
	#verify_expr
(
R
, 
E
) \

234 (
	`_GL_VERIFY_TRUE
 (
R
, "verify_expr (" #R ", " #E ")") ? (
E
) : (E))

	)

239 #define 
	#verify
(
R
) 
	`_GL_VERIFY
 (R, "verify (" #R ")")

	)

	@lib/version-etc-fsf.c

19 #include 
	~<config.h
>

22 #include 
	~"version-etc.h
"

26 const char 
	gversion_etc_copyright
[] =

	@lib/version-etc.c

19 #include 
	~<config.h
>

22 #include 
	~"version-etc.h
"

24 #include 
	~<stdarg.h
>

25 #include 
	~<stdio.h
>

26 #include 
	~<stdlib.h
>

28 #if 
USE_UNLOCKED_IO


29 #include 
	~"unlocked-io.h
"

32 #include 
	~"gettext.h
"

33 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

37 #if ! 
defined
 
PACKAGE
 && defined 
PACKAGE_TARNAME


38 #define 
	#PACKAGE
 
PACKAGE_TARNAME


	)

41 enum { 
	mCOPYRIGHT_YEAR
 = 2011 };

62 
	$version_etc_arn
 (
FILE
 *
stream
,

63 const char *
command_name
, const char *
package
,

64 const char *
version
,

65 const char * const * 
authors
, 
size_t
 
n_authors
)

67 if (
command_name
)

68 
	`fprintf
 (
stream
, "%s (%s) %s\n", 
command_name
, 
package
, 
version
);

70 
	`fprintf
 (
stream
, "%s %s\n", 
package
, 
version
);

72 #ifdef 
PACKAGE_PACKAGER


73 #ifdef 
PACKAGE_PACKAGER_VERSION


74 
	`fprintf
 (
stream
, 
	`_
("Packaged by %s (%s)\n"), 
PACKAGE_PACKAGER
,

75 
PACKAGE_PACKAGER_VERSION
);

77 
	`fprintf
 (
stream
, 
	`_
("Packaged by %s\n"), 
PACKAGE_PACKAGER
);

84 
	`fprintf
 (
stream
, 
version_etc_copyright
, 
	`_
("(C)"), 
COPYRIGHT_YEAR
);

86 
	`fputs
 (
	`_
("\
\n\
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n\
This is free software: you are free to change and redistribute it.\n\
There is NO WARRANTY, to the extent permitted by law.\n\
\n\
"),

93 
stream
);

95 switch (
n_authors
)

99 
	`abort
 ();

102 
	`fprintf
 (
stream
, 
	`_
("Written by %s.\n"), 
authors
[0]);

106 
	`fprintf
 (
stream
, 
	`_
("Written by %s and %s.\n"), 
authors
[0], authors[1]);

110 
	`fprintf
 (
stream
, 
	`_
("Written by %s, %s, and %s.\n"),

111 
authors
[0], authors[1], authors[2]);

117 
	`fprintf
 (
stream
, 
	`_
("Written by %s, %s, %s,\nand %s.\n"),

118 
authors
[0], authors[1], authors[2], authors[3]);

124 
	`fprintf
 (
stream
, 
	`_
("Written by %s, %s, %s,\n%s, and %s.\n"),

125 
authors
[0], authors[1], authors[2], authors[3], authors[4]);

131 
	`fprintf
 (
stream
, 
	`_
("Written by %s, %s, %s,\n%s, %s, and %s.\n"),

132 
authors
[0], authors[1], authors[2], authors[3], authors[4],

133 
authors
[5]);

139 
	`fprintf
 (
stream
, 
	`_
("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"),

140 
authors
[0], authors[1], authors[2], authors[3], authors[4],

141 
authors
[5], authors[6]);

147 
	`fprintf
 (
stream
, 
	`_
("\
Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"),

149 
authors
[0], authors[1], authors[2], authors[3], authors[4],

150 
authors
[5], authors[6], authors[7]);

156 
	`fprintf
 (
stream
, 
	`_
("\
Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"),

158 
authors
[0], authors[1], authors[2], authors[3], authors[4],

159 
authors
[5], authors[6], authors[7], authors[8]);

167 
	`fprintf
 (
stream
, 
	`_
("\
Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"),

169 
authors
[0], authors[1], authors[2], authors[3], authors[4],

170 
authors
[5], authors[6], authors[7], authors[8]);

173 
	}
}

180 
	$version_etc_ar
 (
FILE
 *
stream
,

181 const char *
command_name
, const char *
package
,

182 const char *
version
, const char * const * 
authors
)

184 
size_t
 
n_authors
;

186 for (
n_authors
 = 0; 
authors
[n_authors]; n_authors++)

188 
	`version_etc_arn
 (
stream
, 
command_name
, 
package
, 
version
, 
authors
, 
n_authors
);

189 
	}
}

196 
	$version_etc_va
 (
FILE
 *
stream
,

197 const char *
command_name
, const char *
package
,

198 const char *
version
, 
va_list
 
authors
)

200 
size_t
 
n_authors
;

201 const char *
authtab
[10];

203 for (
n_authors
 = 0;

204 
n_authors
 < 10

205 && (
authtab
[
n_authors
] = 
	`va_arg
 (
authors
, const char *)) != 
NULL
;

206 
n_authors
++)

208 
	`version_etc_arn
 (
stream
, 
command_name
, 
package
, 
version
,

209 
authtab
, 
n_authors
);

210 
	}
}

227 
	$version_etc
 (
FILE
 *
stream
,

228 const char *
command_name
, const char *
package
,

229 const char *
version
, ...)

231 
va_list
 
authors
;

233 
	`va_start
 (
authors
, 
version
);

234 
	`version_etc_va
 (
stream
, 
command_name
, 
package
, 
version
, 
authors
);

235 
	`va_end
 (
authors
);

236 
	}
}

239 
	$emit_bug_reporting_address
 (void)

245 
	`printf
 (
	`_
("\nReport bugs to: %s\n"), 
PACKAGE_BUGREPORT
);

246 #ifdef 
PACKAGE_PACKAGER_BUG_REPORTS


247 
	`printf
 (
	`_
("Report %s bugs to: %s\n"), 
PACKAGE_PACKAGER
,

248 
PACKAGE_PACKAGER_BUG_REPORTS
);

250 #ifdef 
PACKAGE_URL


251 
	`printf
 (
	`_
("%s home page: <%s>\n"), 
PACKAGE_NAME
, 
PACKAGE_URL
);

253 
	`printf
 (
	`_
("%s home page: <http://www.gnu.org/software/%s/>\n"),

254 
PACKAGE_NAME
, 
PACKAGE
);

256 
	`fputs
 (
	`_
("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),

257 
stdout
);

258 
	}
}

	@lib/version-etc.h

19 #ifndef 
VERSION_ETC_H


20 #define 
	#VERSION_ETC_H
 1

	)

22 #include 
	~<stdarg.h
>

23 #include 
	~<stdio.h
>

26 #ifndef 
_GL_ATTRIBUTE_SENTINEL


27 #if 4 <= 
__GNUC__


28 #define 
	#_GL_ATTRIBUTE_SENTINEL
 
	`__attribute__
 ((
__sentinel__
))

	)

30 #define 
	#_GL_ATTRIBUTE_SENTINEL


	)

34 extern const char 
version_etc_copyright
[];

52 extern void 
version_etc_arn
 (
FILE
 *
stream
,

53 const char *
command_name
, const char *
package
,

54 const char *
version
,

55 const char * const * 
authors
, 
size_t
 
n_authors
);

58 extern void 
version_etc_ar
 (
FILE
 *
stream
,

59 const char *
command_name
, const char *
package
,

60 const char *
version
, const char * const * 
authors
);

63 extern void 
version_etc_va
 (
FILE
 *
stream
,

64 const char *
command_name
, const char *
package
,

65 const char *
version
, 
va_list
 
authors
);

69 extern void 
	$version_etc
 (
FILE
 *
stream
,

70 const char *
command_name
, const char *
package
,

71 const char *
version
,

73 
_GL_ATTRIBUTE_SENTINEL
;

76 extern void 
	`emit_bug_reporting_address
 (void);

	@lib/wchar.in.h

31 #if 
__GNUC__
 >= 3

32 @
	gPRAGMA_SYSTEM_HEADER
@

34 @
	gPRAGMA_COLUMNS
@

36 #if 
defined
 
__need_mbstate_t
 || defined 
__need_wint_t
 || (defined 
__hpux
 && ((defined 
_INTTYPES_INCLUDED
 && !defined 
strtoimax
) || defined 
_GL_JUST_INCLUDE_SYSTEM_WCHAR_H
)) || defined 
_GL_ALREADY_INCLUDING_WCHAR_H


49 #@
INCLUDE_NEXT
@ @
NEXT_WCHAR_H
@

54 #ifndef 
_
@
GUARD_PREFIX
@
_WCHAR_H


56 #define 
	#_GL_ALREADY_INCLUDING_WCHAR_H


	)

58 #if @
HAVE_FEATURES_H
@

59 #include 
	~<features.h
>

69 #if !(
defined
 
__GLIBC__
 && !defined 
__UCLIBC__
)

70 #include 
	~<stddef.h
>

72 #ifndef 
__GLIBC__


73 #include 
	~<stdio.h
>

74 #include 
	~<time.h
>

80 #if @
HAVE_WCHAR_H
@

81 #@
INCLUDE_NEXT
@ @
NEXT_WCHAR_H
@

84 #undef 
_GL_ALREADY_INCLUDING_WCHAR_H


86 #ifndef 
_
@
GUARD_PREFIX
@
_WCHAR_H


87 #define 
	#_
@
GUARD_PREFIX
@
_WCHAR_H


	)

97 #if !@
HAVE_WINT_T
@ && !
defined
 
wint_t


98 #define 
	#wint_t
 int

	)

99 #ifndef 
WEOF


100 #define 
	#WEOF
 -1

	)

106 #if 
defined
 
_MSC_VER


107 #if !
GNULIB_defined_wint_t


108 #include 
	~<crtdefs.h
>

109 typedef unsigned int 
	trpl_wint_t
;

110 #undef 
wint_t


111 #define 
	#wint_t
 
rpl_wint_t


	)

112 #define 
	#GNULIB_defined_wint_t
 1

	)

115 #ifndef 
WEOF


116 #define 
	#WEOF
 ((
wint_t
) -1)

	)

124 #if !(@
HAVE_MBSINIT
@ && @
HAVE_MBRTOWC
@) || @
REPLACE_MBSTATE_T
@

125 #if !
GNULIB_defined_mbstate_t


126 typedef int 
	trpl_mbstate_t
;

127 #undef 
mbstate_t


128 #define 
	#mbstate_t
 
rpl_mbstate_t


	)

129 #define 
	#GNULIB_defined_mbstate_t
 1

	)

135 #if @
GNULIB_BTOWC
@

136 #if @
REPLACE_BTOWC
@

137 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

138 #undef 
btowc


139 #define 
	#btowc
 
rpl_btowc


	)

141 
_GL_FUNCDECL_RPL
 (
btowc
, 
wint_t
, (int 
c
));

142 
_GL_CXXALIAS_RPL
 (
btowc
, 
wint_t
, (int 
c
));

144 #if !@
HAVE_BTOWC
@

145 
_GL_FUNCDECL_SYS
 (
btowc
, 
wint_t
, (int 
c
));

147 
_GL_CXXALIAS_SYS
 (
btowc
, 
wint_t
, (int 
c
));

149 
_GL_CXXALIASWARN
 (
btowc
);

150 #elif 
defined
 
GNULIB_POSIXCHECK


151 #undef 
btowc


152 #if 
HAVE_RAW_DECL_BTOWC


153 
_GL_WARN_ON_USE
 (
btowc
, "btowc is unportable - "

160 #if @
GNULIB_WCTOB
@

161 #if @
REPLACE_WCTOB
@

162 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

163 #undef 
wctob


164 #define 
	#wctob
 
rpl_wctob


	)

166 
_GL_FUNCDECL_RPL
 (
wctob
, int, (
wint_t
 
wc
));

167 
_GL_CXXALIAS_RPL
 (
wctob
, int, (
wint_t
 
wc
));

169 #if !
defined
 
wctob
 && !@
HAVE_DECL_WCTOB
@

171 
_GL_FUNCDECL_SYS
 (
wctob
, int, (
wint_t
 
wc
));

173 
_GL_CXXALIAS_SYS
 (
wctob
, int, (
wint_t
 
wc
));

175 
_GL_CXXALIASWARN
 (
wctob
);

176 #elif 
defined
 
GNULIB_POSIXCHECK


177 #undef 
wctob


178 #if 
HAVE_RAW_DECL_WCTOB


179 
_GL_WARN_ON_USE
 (
wctob
, "wctob is unportable - "

186 #if @
GNULIB_MBSINIT
@

187 #if @
REPLACE_MBSINIT
@

188 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

189 #undef 
mbsinit


190 #define 
	#mbsinit
 
rpl_mbsinit


	)

192 
_GL_FUNCDECL_RPL
 (
mbsinit
, int, (const 
mbstate_t
 *
ps
));

193 
_GL_CXXALIAS_RPL
 (
mbsinit
, int, (const 
mbstate_t
 *
ps
));

195 #if !@
HAVE_MBSINIT
@

196 
_GL_FUNCDECL_SYS
 (
mbsinit
, int, (const 
mbstate_t
 *
ps
));

198 
_GL_CXXALIAS_SYS
 (
mbsinit
, int, (const 
mbstate_t
 *
ps
));

200 
_GL_CXXALIASWARN
 (
mbsinit
);

201 #elif 
defined
 
GNULIB_POSIXCHECK


202 #undef 
mbsinit


203 #if 
HAVE_RAW_DECL_MBSINIT


204 
_GL_WARN_ON_USE
 (
mbsinit
, "mbsinit is unportable - "

211 #if @
GNULIB_MBRTOWC
@

212 #if @
REPLACE_MBRTOWC
@

213 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

214 #undef 
mbrtowc


215 #define 
	#mbrtowc
 
rpl_mbrtowc


	)

217 
_GL_FUNCDECL_RPL
 (
mbrtowc
, 
size_t
,

218 (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
, 
mbstate_t
 *
ps
));

219 
_GL_CXXALIAS_RPL
 (
mbrtowc
, 
size_t
,

220 (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
, 
mbstate_t
 *
ps
));

222 #if !@
HAVE_MBRTOWC
@

223 
_GL_FUNCDECL_SYS
 (
mbrtowc
, 
size_t
,

224 (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
, 
mbstate_t
 *
ps
));

226 
_GL_CXXALIAS_SYS
 (
mbrtowc
, 
size_t
,

227 (
wchar_t
 *
pwc
, const char *
s
, 
size_t
 
n
, 
mbstate_t
 *
ps
));

229 
_GL_CXXALIASWARN
 (
mbrtowc
);

230 #elif 
defined
 
GNULIB_POSIXCHECK


231 #undef 
mbrtowc


232 #if 
HAVE_RAW_DECL_MBRTOWC


233 
_GL_WARN_ON_USE
 (
mbrtowc
, "mbrtowc is unportable - "

240 #if @
GNULIB_MBRLEN
@

241 #if @
REPLACE_MBRLEN
@

242 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

243 #undef 
mbrlen


244 #define 
	#mbrlen
 
rpl_mbrlen


	)

246 
_GL_FUNCDECL_RPL
 (
mbrlen
, 
size_t
, (const char *
s
, size_t 
n
, 
mbstate_t
 *
ps
));

247 
_GL_CXXALIAS_RPL
 (
mbrlen
, 
size_t
, (const char *
s
, size_t 
n
, 
mbstate_t
 *
ps
));

249 #if !@
HAVE_MBRLEN
@

250 
_GL_FUNCDECL_SYS
 (
mbrlen
, 
size_t
, (const char *
s
, size_t 
n
, 
mbstate_t
 *
ps
));

252 
_GL_CXXALIAS_SYS
 (
mbrlen
, 
size_t
, (const char *
s
, size_t 
n
, 
mbstate_t
 *
ps
));

254 
_GL_CXXALIASWARN
 (
mbrlen
);

255 #elif 
defined
 
GNULIB_POSIXCHECK


256 #undef 
mbrlen


257 #if 
HAVE_RAW_DECL_MBRLEN


258 
_GL_WARN_ON_USE
 (
mbrlen
, "mbrlen is unportable - "

265 #if @
GNULIB_MBSRTOWCS
@

266 #if @
REPLACE_MBSRTOWCS
@

267 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

268 #undef 
mbsrtowcs


269 #define 
	#mbsrtowcs
 
rpl_mbsrtowcs


	)

271 
_GL_FUNCDECL_RPL
 (
mbsrtowcs
, 
size_t
,

272 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
len
, 
mbstate_t
 *
ps
)

273 
_GL_ARG_NONNULL
 ((2)));

274 
_GL_CXXALIAS_RPL
 (
mbsrtowcs
, 
size_t
,

275 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
len
,

276 
mbstate_t
 *
ps
));

278 #if !@
HAVE_MBSRTOWCS
@

279 
_GL_FUNCDECL_SYS
 (
mbsrtowcs
, 
size_t
,

280 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
len
, 
mbstate_t
 *
ps
)

281 
_GL_ARG_NONNULL
 ((2)));

283 
_GL_CXXALIAS_SYS
 (
mbsrtowcs
, 
size_t
,

284 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
len
,

285 
mbstate_t
 *
ps
));

287 
_GL_CXXALIASWARN
 (
mbsrtowcs
);

288 #elif 
defined
 
GNULIB_POSIXCHECK


289 #undef 
mbsrtowcs


290 #if 
HAVE_RAW_DECL_MBSRTOWCS


291 
_GL_WARN_ON_USE
 (
mbsrtowcs
, "mbsrtowcs is unportable - "

298 #if @
GNULIB_MBSNRTOWCS
@

299 #if @
REPLACE_MBSNRTOWCS
@

300 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

301 #undef 
mbsnrtowcs


302 #define 
	#mbsnrtowcs
 
rpl_mbsnrtowcs


	)

304 
_GL_FUNCDECL_RPL
 (
mbsnrtowcs
, 
size_t
,

305 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
srclen
, size_t 
len
,

306 
mbstate_t
 *
ps
)

307 
_GL_ARG_NONNULL
 ((2)));

308 
_GL_CXXALIAS_RPL
 (
mbsnrtowcs
, 
size_t
,

309 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
srclen
, size_t 
len
,

310 
mbstate_t
 *
ps
));

312 #if !@
HAVE_MBSNRTOWCS
@

313 
_GL_FUNCDECL_SYS
 (
mbsnrtowcs
, 
size_t
,

314 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
srclen
, size_t 
len
,

315 
mbstate_t
 *
ps
)

316 
_GL_ARG_NONNULL
 ((2)));

318 
_GL_CXXALIAS_SYS
 (
mbsnrtowcs
, 
size_t
,

319 (
wchar_t
 *
dest
, const char **
srcp
, 
size_t
 
srclen
, size_t 
len
,

320 
mbstate_t
 *
ps
));

322 
_GL_CXXALIASWARN
 (
mbsnrtowcs
);

323 #elif 
defined
 
GNULIB_POSIXCHECK


324 #undef 
mbsnrtowcs


325 #if 
HAVE_RAW_DECL_MBSNRTOWCS


326 
_GL_WARN_ON_USE
 (
mbsnrtowcs
, "mbsnrtowcs is unportable - "

333 #if @
GNULIB_WCRTOMB
@

334 #if @
REPLACE_WCRTOMB
@

335 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

336 #undef 
wcrtomb


337 #define 
	#wcrtomb
 
rpl_wcrtomb


	)

339 
_GL_FUNCDECL_RPL
 (
wcrtomb
, 
size_t
, (char *
s
, 
wchar_t
 
wc
, 
mbstate_t
 *
ps
));

340 
_GL_CXXALIAS_RPL
 (
wcrtomb
, 
size_t
, (char *
s
, 
wchar_t
 
wc
, 
mbstate_t
 *
ps
));

342 #if !@
HAVE_WCRTOMB
@

343 
_GL_FUNCDECL_SYS
 (
wcrtomb
, 
size_t
, (char *
s
, 
wchar_t
 
wc
, 
mbstate_t
 *
ps
));

345 
_GL_CXXALIAS_SYS
 (
wcrtomb
, 
size_t
, (char *
s
, 
wchar_t
 
wc
, 
mbstate_t
 *
ps
));

347 
_GL_CXXALIASWARN
 (
wcrtomb
);

348 #elif 
defined
 
GNULIB_POSIXCHECK


349 #undef 
wcrtomb


350 #if 
HAVE_RAW_DECL_WCRTOMB


351 
_GL_WARN_ON_USE
 (
wcrtomb
, "wcrtomb is unportable - "

358 #if @
GNULIB_WCSRTOMBS
@

359 #if @
REPLACE_WCSRTOMBS
@

360 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

361 #undef 
wcsrtombs


362 #define 
	#wcsrtombs
 
rpl_wcsrtombs


	)

364 
_GL_FUNCDECL_RPL
 (
wcsrtombs
, 
size_t
,

365 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
len
, 
mbstate_t
 *
ps
)

366 
_GL_ARG_NONNULL
 ((2)));

367 
_GL_CXXALIAS_RPL
 (
wcsrtombs
, 
size_t
,

368 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
len
,

369 
mbstate_t
 *
ps
));

371 #if !@
HAVE_WCSRTOMBS
@

372 
_GL_FUNCDECL_SYS
 (
wcsrtombs
, 
size_t
,

373 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
len
, 
mbstate_t
 *
ps
)

374 
_GL_ARG_NONNULL
 ((2)));

376 
_GL_CXXALIAS_SYS
 (
wcsrtombs
, 
size_t
,

377 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
len
,

378 
mbstate_t
 *
ps
));

380 
_GL_CXXALIASWARN
 (
wcsrtombs
);

381 #elif 
defined
 
GNULIB_POSIXCHECK


382 #undef 
wcsrtombs


383 #if 
HAVE_RAW_DECL_WCSRTOMBS


384 
_GL_WARN_ON_USE
 (
wcsrtombs
, "wcsrtombs is unportable - "

391 #if @
GNULIB_WCSNRTOMBS
@

392 #if @
REPLACE_WCSNRTOMBS
@

393 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

394 #undef 
wcsnrtombs


395 #define 
	#wcsnrtombs
 
rpl_wcsnrtombs


	)

397 
_GL_FUNCDECL_RPL
 (
wcsnrtombs
, 
size_t
,

398 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
srclen
, size_t 
len
,

399 
mbstate_t
 *
ps
)

400 
_GL_ARG_NONNULL
 ((2)));

401 
_GL_CXXALIAS_RPL
 (
wcsnrtombs
, 
size_t
,

402 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
srclen
, size_t 
len
,

403 
mbstate_t
 *
ps
));

405 #if !@
HAVE_WCSNRTOMBS
@

406 
_GL_FUNCDECL_SYS
 (
wcsnrtombs
, 
size_t
,

407 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
srclen
, size_t 
len
,

408 
mbstate_t
 *
ps
)

409 
_GL_ARG_NONNULL
 ((2)));

411 
_GL_CXXALIAS_SYS
 (
wcsnrtombs
, 
size_t
,

412 (char *
dest
, const 
wchar_t
 **
srcp
, 
size_t
 
srclen
, size_t 
len
,

413 
mbstate_t
 *
ps
));

415 
_GL_CXXALIASWARN
 (
wcsnrtombs
);

416 #elif 
defined
 
GNULIB_POSIXCHECK


417 #undef 
wcsnrtombs


418 #if 
HAVE_RAW_DECL_WCSNRTOMBS


419 
_GL_WARN_ON_USE
 (
wcsnrtombs
, "wcsnrtombs is unportable - "

426 #if @
GNULIB_WCWIDTH
@

427 #if @
REPLACE_WCWIDTH
@

428 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

429 #undef 
wcwidth


430 #define 
	#wcwidth
 
rpl_wcwidth


	)

432 
_GL_FUNCDECL_RPL
 (
wcwidth
, int, (
wchar_t
));

433 
_GL_CXXALIAS_RPL
 (
wcwidth
, int, (
wchar_t
));

435 #if !@
HAVE_DECL_WCWIDTH
@

437 
_GL_FUNCDECL_SYS
 (
wcwidth
, int, (
wchar_t
));

439 
_GL_CXXALIAS_SYS
 (
wcwidth
, int, (
wchar_t
));

441 
_GL_CXXALIASWARN
 (
wcwidth
);

442 #elif 
defined
 
GNULIB_POSIXCHECK


443 #undef 
wcwidth


444 #if 
HAVE_RAW_DECL_WCWIDTH


445 
_GL_WARN_ON_USE
 (
wcwidth
, "wcwidth is unportable - "

452 #if @
GNULIB_WMEMCHR
@

453 #if !@
HAVE_WMEMCHR
@

454 
_GL_FUNCDECL_SYS
 (
wmemchr
, 
wchar_t
 *, (const wchar_t *
s
, wchar_t 
c
, 
size_t
 
n
));

461 
_GL_CXXALIAS_SYS_CAST2
 (
wmemchr
,

462 
wchar_t
 *, (const wchar_t *, wchar_t, 
size_t
),

463 const 
wchar_t
 *, (const wchar_t *, wchar_t, 
size_t
));

464 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

465 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

466 
_GL_CXXALIASWARN1
 (
wmemchr
, 
wchar_t
 *, (wchar_t *
s
, wchar_t 
c
, 
size_t
 
n
));

467 
_GL_CXXALIASWARN1
 (
wmemchr
, const 
wchar_t
 *,

468 (const 
wchar_t
 *
s
, wchar_t 
c
, 
size_t
 
n
));

470 
_GL_CXXALIASWARN
 (
wmemchr
);

472 #elif 
defined
 
GNULIB_POSIXCHECK


473 #undef 
wmemchr


474 #if 
HAVE_RAW_DECL_WMEMCHR


475 
_GL_WARN_ON_USE
 (
wmemchr
, "wmemchr is unportable - "

482 #if @
GNULIB_WMEMCMP
@

483 #if !@
HAVE_WMEMCMP
@

484 
_GL_FUNCDECL_SYS
 (
wmemcmp
, int,

485 (const 
wchar_t
 *
s1
, const wchar_t *
s2
, 
size_t
 
n
));

487 
_GL_CXXALIAS_SYS
 (
wmemcmp
, int,

488 (const 
wchar_t
 *
s1
, const wchar_t *
s2
, 
size_t
 
n
));

489 
_GL_CXXALIASWARN
 (
wmemcmp
);

490 #elif 
defined
 
GNULIB_POSIXCHECK


491 #undef 
wmemcmp


492 #if 
HAVE_RAW_DECL_WMEMCMP


493 
_GL_WARN_ON_USE
 (
wmemcmp
, "wmemcmp is unportable - "

500 #if @
GNULIB_WMEMCPY
@

501 #if !@
HAVE_WMEMCPY
@

502 
_GL_FUNCDECL_SYS
 (
wmemcpy
, 
wchar_t
 *,

503 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

505 
_GL_CXXALIAS_SYS
 (
wmemcpy
, 
wchar_t
 *,

506 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

507 
_GL_CXXALIASWARN
 (
wmemcpy
);

508 #elif 
defined
 
GNULIB_POSIXCHECK


509 #undef 
wmemcpy


510 #if 
HAVE_RAW_DECL_WMEMCPY


511 
_GL_WARN_ON_USE
 (
wmemcpy
, "wmemcpy is unportable - "

519 #if @
GNULIB_WMEMMOVE
@

520 #if !@
HAVE_WMEMMOVE
@

521 
_GL_FUNCDECL_SYS
 (
wmemmove
, 
wchar_t
 *,

522 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

524 
_GL_CXXALIAS_SYS
 (
wmemmove
, 
wchar_t
 *,

525 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

526 
_GL_CXXALIASWARN
 (
wmemmove
);

527 #elif 
defined
 
GNULIB_POSIXCHECK


528 #undef 
wmemmove


529 #if 
HAVE_RAW_DECL_WMEMMOVE


530 
_GL_WARN_ON_USE
 (
wmemmove
, "wmemmove is unportable - "

537 #if @
GNULIB_WMEMSET
@

538 #if !@
HAVE_WMEMSET
@

539 
_GL_FUNCDECL_SYS
 (
wmemset
, 
wchar_t
 *, (wchar_t *
s
, wchar_t 
c
, 
size_t
 
n
));

541 
_GL_CXXALIAS_SYS
 (
wmemset
, 
wchar_t
 *, (wchar_t *
s
, wchar_t 
c
, 
size_t
 
n
));

542 
_GL_CXXALIASWARN
 (
wmemset
);

543 #elif 
defined
 
GNULIB_POSIXCHECK


544 #undef 
wmemset


545 #if 
HAVE_RAW_DECL_WMEMSET


546 
_GL_WARN_ON_USE
 (
wmemset
, "wmemset is unportable - "

553 #if @
GNULIB_WCSLEN
@

554 #if !@
HAVE_WCSLEN
@

555 
_GL_FUNCDECL_SYS
 (
wcslen
, 
size_t
, (const 
wchar_t
 *
s
));

557 
_GL_CXXALIAS_SYS
 (
wcslen
, 
size_t
, (const 
wchar_t
 *
s
));

558 
_GL_CXXALIASWARN
 (
wcslen
);

559 #elif 
defined
 
GNULIB_POSIXCHECK


560 #undef 
wcslen


561 #if 
HAVE_RAW_DECL_WCSLEN


562 
_GL_WARN_ON_USE
 (
wcslen
, "wcslen is unportable - "

569 #if @
GNULIB_WCSNLEN
@

570 #if !@
HAVE_WCSNLEN
@

571 
_GL_FUNCDECL_SYS
 (
wcsnlen
, 
size_t
, (const 
wchar_t
 *
s
, size_t 
maxlen
));

573 
_GL_CXXALIAS_SYS
 (
wcsnlen
, 
size_t
, (const 
wchar_t
 *
s
, size_t 
maxlen
));

574 
_GL_CXXALIASWARN
 (
wcsnlen
);

575 #elif 
defined
 
GNULIB_POSIXCHECK


576 #undef 
wcsnlen


577 #if 
HAVE_RAW_DECL_WCSNLEN


578 
_GL_WARN_ON_USE
 (
wcsnlen
, "wcsnlen is unportable - "

585 #if @
GNULIB_WCSCPY
@

586 #if !@
HAVE_WCSCPY
@

587 
_GL_FUNCDECL_SYS
 (
wcscpy
, 
wchar_t
 *, (wchar_t *
dest
, const wchar_t *
src
));

589 
_GL_CXXALIAS_SYS
 (
wcscpy
, 
wchar_t
 *, (wchar_t *
dest
, const wchar_t *
src
));

590 
_GL_CXXALIASWARN
 (
wcscpy
);

591 #elif 
defined
 
GNULIB_POSIXCHECK


592 #undef 
wcscpy


593 #if 
HAVE_RAW_DECL_WCSCPY


594 
_GL_WARN_ON_USE
 (
wcscpy
, "wcscpy is unportable - "

601 #if @
GNULIB_WCPCPY
@

602 #if !@
HAVE_WCPCPY
@

603 
_GL_FUNCDECL_SYS
 (
wcpcpy
, 
wchar_t
 *, (wchar_t *
dest
, const wchar_t *
src
));

605 
_GL_CXXALIAS_SYS
 (
wcpcpy
, 
wchar_t
 *, (wchar_t *
dest
, const wchar_t *
src
));

606 
_GL_CXXALIASWARN
 (
wcpcpy
);

607 #elif 
defined
 
GNULIB_POSIXCHECK


608 #undef 
wcpcpy


609 #if 
HAVE_RAW_DECL_WCPCPY


610 
_GL_WARN_ON_USE
 (
wcpcpy
, "wcpcpy is unportable - "

617 #if @
GNULIB_WCSNCPY
@

618 #if !@
HAVE_WCSNCPY
@

619 
_GL_FUNCDECL_SYS
 (
wcsncpy
, 
wchar_t
 *,

620 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

622 
_GL_CXXALIAS_SYS
 (
wcsncpy
, 
wchar_t
 *,

623 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

624 
_GL_CXXALIASWARN
 (
wcsncpy
);

625 #elif 
defined
 
GNULIB_POSIXCHECK


626 #undef 
wcsncpy


627 #if 
HAVE_RAW_DECL_WCSNCPY


628 
_GL_WARN_ON_USE
 (
wcsncpy
, "wcsncpy is unportable - "

636 #if @
GNULIB_WCPNCPY
@

637 #if !@
HAVE_WCPNCPY
@

638 
_GL_FUNCDECL_SYS
 (
wcpncpy
, 
wchar_t
 *,

639 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

641 
_GL_CXXALIAS_SYS
 (
wcpncpy
, 
wchar_t
 *,

642 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

643 
_GL_CXXALIASWARN
 (
wcpncpy
);

644 #elif 
defined
 
GNULIB_POSIXCHECK


645 #undef 
wcpncpy


646 #if 
HAVE_RAW_DECL_WCPNCPY


647 
_GL_WARN_ON_USE
 (
wcpncpy
, "wcpncpy is unportable - "

654 #if @
GNULIB_WCSCAT
@

655 #if !@
HAVE_WCSCAT
@

656 
_GL_FUNCDECL_SYS
 (
wcscat
, 
wchar_t
 *, (wchar_t *
dest
, const wchar_t *
src
));

658 
_GL_CXXALIAS_SYS
 (
wcscat
, 
wchar_t
 *, (wchar_t *
dest
, const wchar_t *
src
));

659 
_GL_CXXALIASWARN
 (
wcscat
);

660 #elif 
defined
 
GNULIB_POSIXCHECK


661 #undef 
wcscat


662 #if 
HAVE_RAW_DECL_WCSCAT


663 
_GL_WARN_ON_USE
 (
wcscat
, "wcscat is unportable - "

670 #if @
GNULIB_WCSNCAT
@

671 #if !@
HAVE_WCSNCAT
@

672 
_GL_FUNCDECL_SYS
 (
wcsncat
, 
wchar_t
 *,

673 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

675 
_GL_CXXALIAS_SYS
 (
wcsncat
, 
wchar_t
 *,

676 (
wchar_t
 *
dest
, const wchar_t *
src
, 
size_t
 
n
));

677 
_GL_CXXALIASWARN
 (
wcsncat
);

678 #elif 
defined
 
GNULIB_POSIXCHECK


679 #undef 
wcsncat


680 #if 
HAVE_RAW_DECL_WCSNCAT


681 
_GL_WARN_ON_USE
 (
wcsncat
, "wcsncat is unportable - "

688 #if @
GNULIB_WCSCMP
@

689 #if !@
HAVE_WCSCMP
@

690 
_GL_FUNCDECL_SYS
 (
wcscmp
, int, (const 
wchar_t
 *
s1
, const wchar_t *
s2
));

692 
_GL_CXXALIAS_SYS
 (
wcscmp
, int, (const 
wchar_t
 *
s1
, const wchar_t *
s2
));

693 
_GL_CXXALIASWARN
 (
wcscmp
);

694 #elif 
defined
 
GNULIB_POSIXCHECK


695 #undef 
wcscmp


696 #if 
HAVE_RAW_DECL_WCSCMP


697 
_GL_WARN_ON_USE
 (
wcscmp
, "wcscmp is unportable - "

704 #if @
GNULIB_WCSNCMP
@

705 #if !@
HAVE_WCSNCMP
@

706 
_GL_FUNCDECL_SYS
 (
wcsncmp
, int,

707 (const 
wchar_t
 *
s1
, const wchar_t *
s2
, 
size_t
 
n
));

709 
_GL_CXXALIAS_SYS
 (
wcsncmp
, int,

710 (const 
wchar_t
 *
s1
, const wchar_t *
s2
, 
size_t
 
n
));

711 
_GL_CXXALIASWARN
 (
wcsncmp
);

712 #elif 
defined
 
GNULIB_POSIXCHECK


713 #undef 
wcsncmp


714 #if 
HAVE_RAW_DECL_WCSNCMP


715 
_GL_WARN_ON_USE
 (
wcsncmp
, "wcsncmp is unportable - "

722 #if @
GNULIB_WCSCASECMP
@

723 #if !@
HAVE_WCSCASECMP
@

724 
_GL_FUNCDECL_SYS
 (
wcscasecmp
, int, (const 
wchar_t
 *
s1
, const wchar_t *
s2
));

726 
_GL_CXXALIAS_SYS
 (
wcscasecmp
, int, (const 
wchar_t
 *
s1
, const wchar_t *
s2
));

727 
_GL_CXXALIASWARN
 (
wcscasecmp
);

728 #elif 
defined
 
GNULIB_POSIXCHECK


729 #undef 
wcscasecmp


730 #if 
HAVE_RAW_DECL_WCSCASECMP


731 
_GL_WARN_ON_USE
 (
wcscasecmp
, "wcscasecmp is unportable - "

738 #if @
GNULIB_WCSNCASECMP
@

739 #if !@
HAVE_WCSNCASECMP
@

740 
_GL_FUNCDECL_SYS
 (
wcsncasecmp
, int,

741 (const 
wchar_t
 *
s1
, const wchar_t *
s2
, 
size_t
 
n
));

743 
_GL_CXXALIAS_SYS
 (
wcsncasecmp
, int,

744 (const 
wchar_t
 *
s1
, const wchar_t *
s2
, 
size_t
 
n
));

745 
_GL_CXXALIASWARN
 (
wcsncasecmp
);

746 #elif 
defined
 
GNULIB_POSIXCHECK


747 #undef 
wcsncasecmp


748 #if 
HAVE_RAW_DECL_WCSNCASECMP


749 
_GL_WARN_ON_USE
 (
wcsncasecmp
, "wcsncasecmp is unportable - "

757 #if @
GNULIB_WCSCOLL
@

758 #if !@
HAVE_WCSCOLL
@

759 
_GL_FUNCDECL_SYS
 (
wcscoll
, int, (const 
wchar_t
 *
s1
, const wchar_t *
s2
));

761 
_GL_CXXALIAS_SYS
 (
wcscoll
, int, (const 
wchar_t
 *
s1
, const wchar_t *
s2
));

762 
_GL_CXXALIASWARN
 (
wcscoll
);

763 #elif 
defined
 
GNULIB_POSIXCHECK


764 #undef 
wcscoll


765 #if 
HAVE_RAW_DECL_WCSCOLL


766 
_GL_WARN_ON_USE
 (
wcscoll
, "wcscoll is unportable - "

775 #if @
GNULIB_WCSXFRM
@

776 #if !@
HAVE_WCSXFRM
@

777 
_GL_FUNCDECL_SYS
 (
wcsxfrm
, 
size_t
, (
wchar_t
 *
s1
, const wchar_t *
s2
, size_t 
n
));

779 
_GL_CXXALIAS_SYS
 (
wcsxfrm
, 
size_t
, (
wchar_t
 *
s1
, const wchar_t *
s2
, size_t 
n
));

780 
_GL_CXXALIASWARN
 (
wcsxfrm
);

781 #elif 
defined
 
GNULIB_POSIXCHECK


782 #undef 
wcsxfrm


783 #if 
HAVE_RAW_DECL_WCSXFRM


784 
_GL_WARN_ON_USE
 (
wcsxfrm
, "wcsxfrm is unportable - "

791 #if @
GNULIB_WCSDUP
@

792 #if !@
HAVE_WCSDUP
@

793 
_GL_FUNCDECL_SYS
 (
wcsdup
, 
wchar_t
 *, (const wchar_t *
s
));

795 
_GL_CXXALIAS_SYS
 (
wcsdup
, 
wchar_t
 *, (const wchar_t *
s
));

796 
_GL_CXXALIASWARN
 (
wcsdup
);

797 #elif 
defined
 
GNULIB_POSIXCHECK


798 #undef 
wcsdup


799 #if 
HAVE_RAW_DECL_WCSDUP


800 
_GL_WARN_ON_USE
 (
wcsdup
, "wcsdup is unportable - "

807 #if @
GNULIB_WCSCHR
@

808 #if !@
HAVE_WCSCHR
@

809 
_GL_FUNCDECL_SYS
 (
wcschr
, 
wchar_t
 *, (const wchar_t *
wcs
, wchar_t 
wc
));

816 
_GL_CXXALIAS_SYS_CAST2
 (
wcschr
,

817 
wchar_t
 *, (const wchar_t *, wchar_t),

818 const 
wchar_t
 *, (const wchar_t *, wchar_t));

819 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

820 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

821 
_GL_CXXALIASWARN1
 (
wcschr
, 
wchar_t
 *, (wchar_t *
wcs
, wchar_t 
wc
));

822 
_GL_CXXALIASWARN1
 (
wcschr
, const 
wchar_t
 *, (const wchar_t *
wcs
, wchar_t 
wc
));

824 
_GL_CXXALIASWARN
 (
wcschr
);

826 #elif 
defined
 
GNULIB_POSIXCHECK


827 #undef 
wcschr


828 #if 
HAVE_RAW_DECL_WCSCHR


829 
_GL_WARN_ON_USE
 (
wcschr
, "wcschr is unportable - "

836 #if @
GNULIB_WCSRCHR
@

837 #if !@
HAVE_WCSRCHR
@

838 
_GL_FUNCDECL_SYS
 (
wcsrchr
, 
wchar_t
 *, (const wchar_t *
wcs
, wchar_t 
wc
));

845 
_GL_CXXALIAS_SYS_CAST2
 (
wcsrchr
,

846 
wchar_t
 *, (const wchar_t *, wchar_t),

847 const 
wchar_t
 *, (const wchar_t *, wchar_t));

848 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

849 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

850 
_GL_CXXALIASWARN1
 (
wcsrchr
, 
wchar_t
 *, (wchar_t *
wcs
, wchar_t 
wc
));

851 
_GL_CXXALIASWARN1
 (
wcsrchr
, const 
wchar_t
 *, (const wchar_t *
wcs
, wchar_t 
wc
));

853 
_GL_CXXALIASWARN
 (
wcsrchr
);

855 #elif 
defined
 
GNULIB_POSIXCHECK


856 #undef 
wcsrchr


857 #if 
HAVE_RAW_DECL_WCSRCHR


858 
_GL_WARN_ON_USE
 (
wcsrchr
, "wcsrchr is unportable - "

866 #if @
GNULIB_WCSCSPN
@

867 #if !@
HAVE_WCSCSPN
@

868 
_GL_FUNCDECL_SYS
 (
wcscspn
, 
size_t
, (const 
wchar_t
 *
wcs
, const wchar_t *
reject
));

870 
_GL_CXXALIAS_SYS
 (
wcscspn
, 
size_t
, (const 
wchar_t
 *
wcs
, const wchar_t *
reject
));

871 
_GL_CXXALIASWARN
 (
wcscspn
);

872 #elif 
defined
 
GNULIB_POSIXCHECK


873 #undef 
wcscspn


874 #if 
HAVE_RAW_DECL_WCSCSPN


875 
_GL_WARN_ON_USE
 (
wcscspn
, "wcscspn is unportable - "

883 #if @
GNULIB_WCSSPN
@

884 #if !@
HAVE_WCSSPN
@

885 
_GL_FUNCDECL_SYS
 (
wcsspn
, 
size_t
, (const 
wchar_t
 *
wcs
, const wchar_t *
accept
));

887 
_GL_CXXALIAS_SYS
 (
wcsspn
, 
size_t
, (const 
wchar_t
 *
wcs
, const wchar_t *
accept
));

888 
_GL_CXXALIASWARN
 (
wcsspn
);

889 #elif 
defined
 
GNULIB_POSIXCHECK


890 #undef 
wcsspn


891 #if 
HAVE_RAW_DECL_WCSSPN


892 
_GL_WARN_ON_USE
 (
wcsspn
, "wcsspn is unportable - "

899 #if @
GNULIB_WCSPBRK
@

900 #if !@
HAVE_WCSPBRK
@

901 
_GL_FUNCDECL_SYS
 (
wcspbrk
, 
wchar_t
 *,

902 (const 
wchar_t
 *
wcs
, const wchar_t *
accept
));

909 
_GL_CXXALIAS_SYS_CAST2
 (
wcspbrk
,

910 
wchar_t
 *, (const wchar_t *, const wchar_t *),

911 const 
wchar_t
 *, (const wchar_t *, const wchar_t *));

912 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

913 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

914 
_GL_CXXALIASWARN1
 (
wcspbrk
, 
wchar_t
 *,

915 (
wchar_t
 *
wcs
, const wchar_t *
accept
));

916 
_GL_CXXALIASWARN1
 (
wcspbrk
, const 
wchar_t
 *,

917 (const 
wchar_t
 *
wcs
, const wchar_t *
accept
));

919 
_GL_CXXALIASWARN
 (
wcspbrk
);

921 #elif 
defined
 
GNULIB_POSIXCHECK


922 #undef 
wcspbrk


923 #if 
HAVE_RAW_DECL_WCSPBRK


924 
_GL_WARN_ON_USE
 (
wcspbrk
, "wcspbrk is unportable - "

931 #if @
GNULIB_WCSSTR
@

932 #if !@
HAVE_WCSSTR
@

933 
_GL_FUNCDECL_SYS
 (
wcsstr
, 
wchar_t
 *,

934 (const 
wchar_t
 *
haystack
, const wchar_t *
needle
));

941 
_GL_CXXALIAS_SYS_CAST2
 (
wcsstr
,

942 
wchar_t
 *, (const wchar_t *, const wchar_t *),

943 const 
wchar_t
 *, (const wchar_t *, const wchar_t *));

944 #if ((
__GLIBC__
 == 2 && 
__GLIBC_MINOR__
 >= 10) && !
defined
 
__UCLIBC__
) \

945 && (
	g__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 4))

946 
_GL_CXXALIASWARN1
 (
wcsstr
, 
wchar_t
 *,

947 (
wchar_t
 *
haystack
, const wchar_t *
needle
));

948 
_GL_CXXALIASWARN1
 (
wcsstr
, const 
wchar_t
 *,

949 (const 
wchar_t
 *
haystack
, const wchar_t *
needle
));

951 
_GL_CXXALIASWARN
 (
wcsstr
);

953 #elif 
defined
 
GNULIB_POSIXCHECK


954 #undef 
wcsstr


955 #if 
HAVE_RAW_DECL_WCSSTR


956 
_GL_WARN_ON_USE
 (
wcsstr
, "wcsstr is unportable - "

963 #if @
GNULIB_WCSTOK
@

964 #if !@
HAVE_WCSTOK
@

965 
_GL_FUNCDECL_SYS
 (
wcstok
, 
wchar_t
 *,

966 (
wchar_t
 *
wcs
, const wchar_t *
delim
, wchar_t **
ptr
));

968 
_GL_CXXALIAS_SYS
 (
wcstok
, 
wchar_t
 *,

969 (
wchar_t
 *
wcs
, const wchar_t *
delim
, wchar_t **
ptr
));

970 
_GL_CXXALIASWARN
 (
wcstok
);

971 #elif 
defined
 
GNULIB_POSIXCHECK


972 #undef 
wcstok


973 #if 
HAVE_RAW_DECL_WCSTOK


974 
_GL_WARN_ON_USE
 (
wcstok
, "wcstok is unportable - "

982 #if @
GNULIB_WCSWIDTH
@

983 #if @
REPLACE_WCSWIDTH
@

984 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

985 #undef 
wcswidth


986 #define 
	#wcswidth
 
rpl_wcswidth


	)

988 
_GL_FUNCDECL_RPL
 (
wcswidth
, int, (const 
wchar_t
 *
s
, 
size_t
 
n
));

989 
_GL_CXXALIAS_RPL
 (
wcswidth
, int, (const 
wchar_t
 *
s
, 
size_t
 
n
));

991 #if !@
HAVE_WCSWIDTH
@

992 
_GL_FUNCDECL_SYS
 (
wcswidth
, int, (const 
wchar_t
 *
s
, 
size_t
 
n
));

994 
_GL_CXXALIAS_SYS
 (
wcswidth
, int, (const 
wchar_t
 *
s
, 
size_t
 
n
));

996 
_GL_CXXALIASWARN
 (
wcswidth
);

997 #elif 
defined
 
GNULIB_POSIXCHECK


998 #undef 
wcswidth


999 #if 
HAVE_RAW_DECL_WCSWIDTH


1000 
_GL_WARN_ON_USE
 (
wcswidth
, "wcswidth is unportable - "

	@lib/wcrtomb.c

18 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #include 
	~<errno.h
>

24 #include 
	~<stdlib.h
>

27 
size_t


28 
	$wcrtomb
 (char *
s
, 
wchar_t
 
wc
, 
mbstate_t
 *
ps
)

32 if (
ps
 != 
NULL
 && !
	`mbsinit
 (ps))

34 
errno
 = 
EINVAL
;

35 return (
size_t
)(-1);

38 if (
s
 == 
NULL
)

43 int 
ret
 = 
	`wctomb
 (
s
, 
wc
);

45 if (
ret
 >= 0)

46 return 
ret
;

49 
errno
 = 
EILSEQ
;

50 return (
size_t
)(-1);

53 
	}
}

	@lib/wctob.c

18 #include 
	~<config.h
>

21 #include 
	~<wchar.h
>

23 #include 
	~<stdio.h
>

24 #include 
	~<stdlib.h
>

27 
	$wctob
 (
wint_t
 
wc
)

29 char 
buf
[64];

31 if (!(
MB_CUR_MAX
 <= sizeof (
buf
)))

32 
	`abort
 ();

34 if (
wc
 == (
wchar_t
)wc)

35 if (
	`wctomb
 (
buf
, (
wchar_t
)
wc
) == 1)

36 return (unsigned char) 
buf
[0];

37 return 
EOF
;

38 
	}
}

	@lib/wctomb-impl.h

19 
	$wctomb
 (char *
s
, 
wchar_t
 
wc
)

21 if (
s
 == 
NULL
)

25 
mbstate_t
 
state
;

26 
size_t
 
result
;

28 
	`memset
 (&
state
, 0, sizeof (
mbstate_t
));

29 
result
 = 
	`wcrtomb
 (
s
, 
wc
, &
state
);

30 if (
result
 == (
size_t
)-1)

32 return 
result
;

34 
	}
}

	@lib/wctomb.c

18 #include 
	~<config.h
>

20 #include 
	~<stdlib.h
>

22 #include 
	~<string.h
>

23 #include 
	~<wchar.h
>

25 #include 
	~"wctomb-impl.h
"

	@lib/wctype.in.h

31 #ifndef 
_
@
GUARD_PREFIX
@
_WCTYPE_H


33 #if 
__GNUC__
 >= 3

34 @
	gPRAGMA_SYSTEM_HEADER
@

36 @
	gPRAGMA_COLUMNS
@

38 #if @
HAVE_WINT_T
@

44 #include 
	~<stddef.h
>

45 #include 
	~<stdio.h
>

46 #include 
	~<time.h
>

47 #include 
	~<wchar.h
>

53 #if @
HAVE_WCTYPE_H
@

54 #@
INCLUDE_NEXT
@ @
NEXT_WCTYPE_H
@

57 #ifndef 
_
@
GUARD_PREFIX
@
_WCTYPE_H


58 #define 
	#_
@
GUARD_PREFIX
@
_WCTYPE_H


	)

67 #ifdef 
__sun


68 #undef 
multibyte


69 #undef 
eucw1


70 #undef 
eucw2


71 #undef 
eucw3


72 #undef 
scrw1


73 #undef 
scrw2


74 #undef 
scrw3


78 #if !@
HAVE_WINT_T
@ && !
defined
 
wint_t


79 #define 
	#wint_t
 int

	)

80 #ifndef 
WEOF


81 #define 
	#WEOF
 -1

	)

87 #if 
defined
 
_MSC_VER


88 #if !
GNULIB_defined_wint_t


89 #include 
	~<crtdefs.h
>

90 typedef unsigned int 
	trpl_wint_t
;

91 #undef 
wint_t


92 #define 
	#wint_t
 
rpl_wint_t


	)

93 #define 
	#GNULIB_defined_wint_t
 1

	)

96 #ifndef 
WEOF


97 #define 
	#WEOF
 ((
wint_t
) -1)

	)

102 #if !
GNULIB_defined_wctype_functions


108 #if ! @
HAVE_ISWCNTRL
@ || @
REPLACE_ISWCNTRL
@

115 #undef 
iswalnum


116 #undef 
iswalpha


117 #undef 
iswblank


118 #undef 
iswcntrl


119 #undef 
iswdigit


120 #undef 
iswgraph


121 #undef 
iswlower


122 #undef 
iswprint


123 #undef 
iswpunct


124 #undef 
iswspace


125 #undef 
iswupper


126 #undef 
iswxdigit


127 #undef 
towlower


128 #undef 
towupper


131 #if @
REPLACE_ISWCNTRL
@

132 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

133 #define 
	#iswalnum
 
rpl_iswalnum


	)

134 #define 
	#iswalpha
 
rpl_iswalpha


	)

135 #define 
	#iswblank
 
rpl_iswblank


	)

136 #define 
	#iswcntrl
 
rpl_iswcntrl


	)

137 #define 
	#iswdigit
 
rpl_iswdigit


	)

138 #define 
	#iswgraph
 
rpl_iswgraph


	)

139 #define 
	#iswlower
 
rpl_iswlower


	)

140 #define 
	#iswprint
 
rpl_iswprint


	)

141 #define 
	#iswpunct
 
rpl_iswpunct


	)

142 #define 
	#iswspace
 
rpl_iswspace


	)

143 #define 
	#iswupper
 
rpl_iswupper


	)

144 #define 
	#iswxdigit
 
rpl_iswxdigit


	)

147 #if @
REPLACE_TOWLOWER
@

148 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

149 #define 
	#towlower
 
rpl_towlower


	)

150 #define 
	#towupper
 
rpl_towupper


	)

154 static 
inline
 int

155 #if @
REPLACE_ISWCNTRL
@

156 
	grpl_iswalnum


158 
	giswalnum


160 (
wint_t
 
	gwc
)

162 return ((
	gwc
 >= '0' && 
wc
 <= '9')

163 || ((
wc
 & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z'));

166 static 
inline
 int

167 #if @
REPLACE_ISWCNTRL
@

168 
	grpl_iswalpha


170 
	giswalpha


172 (
wint_t
 
	gwc
)

174 return (
	gwc
 & ~0x20) >= 'A' && (
wc
 & ~0x20) <= 'Z';

177 static 
inline
 int

178 #if @
REPLACE_ISWCNTRL
@

179 
	grpl_iswblank


181 
	giswblank


183 (
wint_t
 
	gwc
)

185 return 
	gwc
 == ' ' || 
wc
 == '\t';

188 static 
inline
 int

189 #if @
REPLACE_ISWCNTRL
@

190 
	grpl_iswcntrl


192 
	giswcntrl


194 (
wint_t
 
	gwc
)

196 return (
	gwc
 & ~0x1f) == 0 || 
wc
 == 0x7f;

199 static 
inline
 int

200 #if @
REPLACE_ISWCNTRL
@

201 
	grpl_iswdigit


203 
	giswdigit


205 (
wint_t
 
	gwc
)

207 return 
	gwc
 >= '0' && 
wc
 <= '9';

210 static 
inline
 int

211 #if @
REPLACE_ISWCNTRL
@

212 
	grpl_iswgraph


214 
	giswgraph


216 (
wint_t
 
	gwc
)

218 return 
	gwc
 >= '!' && 
wc
 <= '~';

221 static 
inline
 int

222 #if @
REPLACE_ISWCNTRL
@

223 
	grpl_iswlower


225 
	giswlower


227 (
wint_t
 
	gwc
)

229 return 
	gwc
 >= 'a' && 
wc
 <= 'z';

232 static 
inline
 int

233 #if @
REPLACE_ISWCNTRL
@

234 
	grpl_iswprint


236 
	giswprint


238 (
wint_t
 
	gwc
)

240 return 
	gwc
 >= ' ' && 
wc
 <= '~';

243 static 
inline
 int

244 #if @
REPLACE_ISWCNTRL
@

245 
	grpl_iswpunct


247 
	giswpunct


249 (
wint_t
 
	gwc
)

251 return (
	gwc
 >= '!' && 
wc
 <= '~'

252 && !((
wc
 >= '0' && wc <= '9')

253 || ((
wc
 & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z')));

256 static 
inline
 int

257 #if @
REPLACE_ISWCNTRL
@

258 
	grpl_iswspace


260 
	giswspace


262 (
wint_t
 
	gwc
)

264 return (
	gwc
 == ' ' || 
wc
 == '\t'

265 || 
wc
 == '\n' || wc == '\v' || wc == '\f' || wc == '\r');

268 static 
inline
 int

269 #if @
REPLACE_ISWCNTRL
@

270 
	grpl_iswupper


272 
	giswupper


274 (
wint_t
 
	gwc
)

276 return 
	gwc
 >= 'A' && 
wc
 <= 'Z';

279 static 
inline
 int

280 #if @
REPLACE_ISWCNTRL
@

281 
	grpl_iswxdigit


283 
	giswxdigit


285 (
wint_t
 
	gwc
)

287 return ((
	gwc
 >= '0' && 
wc
 <= '9')

288 || ((
wc
 & ~0x20) >= 'A' && (wc & ~0x20) <= 'F'));

291 static 
inline
 
	gwint_t


292 #if @
REPLACE_TOWLOWER
@

293 
	grpl_towlower


295 
	gtowlower


297 (
wint_t
 
	gwc
)

299 return (
	gwc
 >= 'A' && 
wc
 <= 'Z' ? wc - 'A' + 'a' : wc);

302 static 
inline
 
	gwint_t


303 #if @
REPLACE_TOWLOWER
@

304 
	grpl_towupper


306 
	gtowupper


308 (
wint_t
 
	gwc
)

310 return (
	gwc
 >= 'a' && 
wc
 <= 'z' ? wc - 'a' + 'A' : wc);

313 #elif @
GNULIB_ISWBLANK
@ && (! @
HAVE_ISWBLANK
@ || @
REPLACE_ISWBLANK
@)

316 #if @
REPLACE_ISWBLANK
@

317 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

318 #define 
	#iswblank
 
rpl_iswblank


	)

320 
_GL_FUNCDECL_RPL
 (
iswblank
, int, (
wint_t
 
wc
));

322 
_GL_FUNCDECL_SYS
 (
iswblank
, int, (
wint_t
 
wc
));

327 #if 
defined
 
__MINGW32__


342 static 
inline
 
wint_t


343 
	$rpl_towlower
 (
wint_t
 
wc
)

345 return (
wint_t
) (
wchar_t
) 
	`towlower
 (
wc
);

346 
	}
}

347 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

348 #define 
	#towlower
 
rpl_towlower


	)

351 static 
inline
 
wint_t


352 
	$rpl_towupper
 (
wint_t
 
wc
)

354 return (
wint_t
) (
wchar_t
) 
	`towupper
 (
wc
);

355 
	}
}

356 #if !(
defined
 
__cplusplus
 && defined 
GNULIB_NAMESPACE
)

357 #define 
	#towupper
 
rpl_towupper


	)

362 #define 
	#GNULIB_defined_wctype_functions
 1

	)

365 #if @
REPLACE_ISWCNTRL
@

366 
_GL_CXXALIAS_RPL
 (
iswalnum
, int, (
wint_t
 
wc
));

367 
_GL_CXXALIAS_RPL
 (
iswalpha
, int, (
wint_t
 
wc
));

368 
_GL_CXXALIAS_RPL
 (
iswcntrl
, int, (
wint_t
 
wc
));

369 
_GL_CXXALIAS_RPL
 (
iswdigit
, int, (
wint_t
 
wc
));

370 
_GL_CXXALIAS_RPL
 (
iswgraph
, int, (
wint_t
 
wc
));

371 
_GL_CXXALIAS_RPL
 (
iswlower
, int, (
wint_t
 
wc
));

372 
_GL_CXXALIAS_RPL
 (
iswprint
, int, (
wint_t
 
wc
));

373 
_GL_CXXALIAS_RPL
 (
iswpunct
, int, (
wint_t
 
wc
));

374 
_GL_CXXALIAS_RPL
 (
iswspace
, int, (
wint_t
 
wc
));

375 
_GL_CXXALIAS_RPL
 (
iswupper
, int, (
wint_t
 
wc
));

376 
_GL_CXXALIAS_RPL
 (
iswxdigit
, int, (
wint_t
 
wc
));

378 
_GL_CXXALIAS_SYS
 (
iswalnum
, int, (
wint_t
 
wc
));

379 
_GL_CXXALIAS_SYS
 (
iswalpha
, int, (
wint_t
 
wc
));

380 
_GL_CXXALIAS_SYS
 (
iswcntrl
, int, (
wint_t
 
wc
));

381 
_GL_CXXALIAS_SYS
 (
iswdigit
, int, (
wint_t
 
wc
));

382 
_GL_CXXALIAS_SYS
 (
iswgraph
, int, (
wint_t
 
wc
));

383 
_GL_CXXALIAS_SYS
 (
iswlower
, int, (
wint_t
 
wc
));

384 
_GL_CXXALIAS_SYS
 (
iswprint
, int, (
wint_t
 
wc
));

385 
_GL_CXXALIAS_SYS
 (
iswpunct
, int, (
wint_t
 
wc
));

386 
_GL_CXXALIAS_SYS
 (
iswspace
, int, (
wint_t
 
wc
));

387 
_GL_CXXALIAS_SYS
 (
iswupper
, int, (
wint_t
 
wc
));

388 
_GL_CXXALIAS_SYS
 (
iswxdigit
, int, (
wint_t
 
wc
));

390 
_GL_CXXALIASWARN
 (
iswalnum
);

391 
_GL_CXXALIASWARN
 (
iswalpha
);

392 
_GL_CXXALIASWARN
 (
iswcntrl
);

393 
_GL_CXXALIASWARN
 (
iswdigit
);

394 
_GL_CXXALIASWARN
 (
iswgraph
);

395 
_GL_CXXALIASWARN
 (
iswlower
);

396 
_GL_CXXALIASWARN
 (
iswprint
);

397 
_GL_CXXALIASWARN
 (
iswpunct
);

398 
_GL_CXXALIASWARN
 (
iswspace
);

399 
_GL_CXXALIASWARN
 (
iswupper
);

400 
_GL_CXXALIASWARN
 (
iswxdigit
);

402 #if @
GNULIB_ISWBLANK
@

403 #if @
REPLACE_ISWCNTRL
@ || @
REPLACE_ISWBLANK
@

404 
_GL_CXXALIAS_RPL
 (
iswblank
, int, (
wint_t
 
wc
));

406 
_GL_CXXALIAS_SYS
 (
iswblank
, int, (
wint_t
 
wc
));

408 
_GL_CXXALIASWARN
 (
iswblank
);

411 #if !@
HAVE_WCTYPE_T
@

412 #if !
GNULIB_defined_wctype_t


413 typedef void * 
	twctype_t
;

414 #define 
	#GNULIB_defined_wctype_t
 1

	)

419 #if @
GNULIB_WCTYPE
@

420 #if !@
HAVE_WCTYPE_T
@

421 
_GL_FUNCDECL_SYS
 (
wctype
, 
wctype_t
, (const char *
name
));

423 
_GL_CXXALIAS_SYS
 (
wctype
, 
wctype_t
, (const char *
name
));

424 
_GL_CXXALIASWARN
 (
wctype
);

425 #elif 
defined
 
GNULIB_POSIXCHECK


426 #undef 
wctype


427 #if 
HAVE_RAW_DECL_WCTYPE


428 
_GL_WARN_ON_USE
 (
wctype
, "wctype is unportable - "

436 #if @
GNULIB_ISWCTYPE
@

437 #if !@
HAVE_WCTYPE_T
@

438 
_GL_FUNCDECL_SYS
 (
iswctype
, int, (
wint_t
 
wc
, 
wctype_t
 
desc
));

440 
_GL_CXXALIAS_SYS
 (
iswctype
, int, (
wint_t
 
wc
, 
wctype_t
 
desc
));

441 
_GL_CXXALIASWARN
 (
iswctype
);

442 #elif 
defined
 
GNULIB_POSIXCHECK


443 #undef 
iswctype


444 #if 
HAVE_RAW_DECL_ISWCTYPE


445 
_GL_WARN_ON_USE
 (
iswctype
, "iswctype is unportable - "

450 #if @
REPLACE_TOWLOWER
@ || 
defined
 
__MINGW32__


451 
_GL_CXXALIAS_RPL
 (
towlower
, 
wint_t
, (wint_t 
wc
));

452 
_GL_CXXALIAS_RPL
 (
towupper
, 
wint_t
, (wint_t 
wc
));

454 
_GL_CXXALIAS_SYS
 (
towlower
, 
wint_t
, (wint_t 
wc
));

455 
_GL_CXXALIAS_SYS
 (
towupper
, 
wint_t
, (wint_t 
wc
));

457 
_GL_CXXALIASWARN
 (
towlower
);

458 
_GL_CXXALIASWARN
 (
towupper
);

460 #if !@
HAVE_WCTRANS_T
@

461 #if !
GNULIB_defined_wctrans_t


462 typedef void * 
	twctrans_t
;

463 #define 
	#GNULIB_defined_wctrans_t
 1

	)

468 #if @
GNULIB_WCTRANS
@

469 #if !@
HAVE_WCTRANS_T
@

470 
_GL_FUNCDECL_SYS
 (
wctrans
, 
wctrans_t
, (const char *
name
));

472 
_GL_CXXALIAS_SYS
 (
wctrans
, 
wctrans_t
, (const char *
name
));

473 
_GL_CXXALIASWARN
 (
wctrans
);

474 #elif 
defined
 
GNULIB_POSIXCHECK


475 #undef 
wctrans


476 #if 
HAVE_RAW_DECL_WCTRANS


477 
_GL_WARN_ON_USE
 (
wctrans
, "wctrans is unportable - "

485 #if @
GNULIB_TOWCTRANS
@

486 #if !@
HAVE_WCTRANS_T
@

487 
_GL_FUNCDECL_SYS
 (
towctrans
, 
wint_t
, (wint_t 
wc
, 
wctrans_t
 
desc
));

489 
_GL_CXXALIAS_SYS
 (
towctrans
, 
wint_t
, (wint_t 
wc
, 
wctrans_t
 
desc
));

490 
_GL_CXXALIASWARN
 (
towctrans
);

491 #elif 
defined
 
GNULIB_POSIXCHECK


492 #undef 
towctrans


493 #if 
HAVE_RAW_DECL_TOWCTRANS


494 
_GL_WARN_ON_USE
 (
towctrans
, "towctrans is unportable - "

	@lib/wcwidth.c

17 #include 
	~<config.h
>

20 #include 
	~<wchar.h
>

23 #include 
	~<wctype.h
>

25 #include 
	~"localcharset.h
"

26 #include 
	~"streq.h
"

27 #include 
	~"uniwidth.h
"

30 
	$wcwidth
 (
wchar_t
 
wc
)

31 #undef 
wcwidth


34 const char *
encoding
 = 
	`locale_charset
 ();

35 if (
	`STREQ
 (
encoding
, "UTF-8", 'U', 'T', 'F', '-', '8', 0, 0, 0 ,0))

39 return 
	`uc_width
 (
wc
, 
encoding
);

44 #if 
HAVE_WCWIDTH


45 return 
	`wcwidth
 (
wc
);

47 return 
wc
 == 0 ? 0 : 
	`iswprint
 (wc) ? 1 : -1;

50 
	}
}

	@lib/xalloc-die.c

19 #include 
	~<config.h
>

21 #include 
	~"xalloc.h
"

23 #include 
	~<stdlib.h
>

25 #include 
	~"error.h
"

26 #include 
	~"exitfail.h
"

28 #include 
	~"gettext.h
"

29 #define 
	#_
(
msgid
) 
	`gettext
 (msgid)

	)

32 
	$xalloc_die
 (void)

34 
	`error
 (
exit_failure
, 0, "%s", 
	`_
("memory exhausted"));

40 
	`abort
 ();

41 
	}
}

	@lib/xalloc-oversized.h

18 #ifndef 
XALLOC_OVERSIZED_H_


19 #define 
	#XALLOC_OVERSIZED_H_


	)

21 #include 
	~<stddef.h
>

35 #define 
	#xalloc_oversized
(
n
, 
s
) \

36 ((
size_t
) (sizeof (
ptrdiff_t
) <= sizeof (size_t) ? -1 : -2) / (
s
) < (
n
))

	)

	@lib/xalloc.h

18 #ifndef 
XALLOC_H_


19 #define 
	#XALLOC_H_


	)

21 #include 
	~<stddef.h
>

23 #include 
	~"xalloc-oversized.h
"

25 #ifdef 
__cplusplus


30 #if 
__GNUC__
 >= 3

31 #define 
	#_GL_ATTRIBUTE_MALLOC
 
	`__attribute__
 ((
__malloc__
))

	)

33 #define 
	#_GL_ATTRIBUTE_MALLOC


	)

36 #if 
__GNUC__
 > 4 || (__GNUC__ == 4 && 
__GNUC_MINOR__
 >= 3)

37 #define 
	#_GL_ATTRIBUTE_ALLOC_SIZE
(
args
) 
	`__attribute__
 ((
__alloc_size__
 args))

	)

39 #define 
	#_GL_ATTRIBUTE_ALLOC_SIZE
(
args
)

	)

47 extern 
_Noreturn
 void 
xalloc_die
 (void);

49 void *
xmalloc
 (
size_t
 
s
)

50 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((1));

51 void *
xzalloc
 (
size_t
 
s
)

52 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((1));

53 void *
xcalloc
 (
size_t
 
n
, size_t 
s
)

54 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((1, 2));

55 void *
xrealloc
 (void *
p
, 
size_t
 
s
)

56 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((2));

57 void *
x2realloc
 (void *
p
, 
size_t
 *
pn
);

58 void *
xmemdup
 (void const *
p
, 
size_t
 
s
)

59 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((2));

60 char *
xstrdup
 (char const *
str
)

61 
	g_GL_ATTRIBUTE_MALLOC
;

70 #define 
	#XMALLOC
(
t
) ((t *) 
	`xmalloc
 (sizeof (t)))

	)

74 #define 
	#XNMALLOC
(
n
, 
t
) \

75 ((
t
 *) (sizeof (t) == 1 ? 
	`xmalloc
 (
n
) : 
	`xnmalloc
 (n, sizeof (t))))

	)

80 #define 
	#XZALLOC
(
t
) ((t *) 
	`xzalloc
 (sizeof (t)))

	)

85 #define 
	#XCALLOC
(
n
, 
t
) \

86 ((
t
 *) (sizeof (t) == 1 ? 
	`xzalloc
 (
n
) : 
	`xcalloc
 (n, sizeof (t))))

	)

89 #if 
HAVE_INLINE


90 #define 
	#static_inline
 static 
inline


	)

92 void *
xnmalloc
 (
size_t
 
n
, size_t 
s
)

93 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((1, 2));

94 void *
xnrealloc
 (void *
p
, 
size_t
 
n
, size_t 
s
)

95 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((2, 3));

96 void *
x2nrealloc
 (void *
p
, 
size_t
 *
pn
, size_t 
s
);

97 char *
xcharalloc
 (
size_t
 
n
)

98 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((1));

101 #ifdef 
static_inline


106 
static_inline
 void *
xnmalloc
 (
size_t
 
n
, size_t 
s
)

107 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((1, 2));

108 
static_inline
 void *

109 
xnmalloc
 (
size_t
 
n
, size_t 
s
)

111 if (
xalloc_oversized
 (
n
, 
s
))

112 
xalloc_die
 ();

113 return 
xmalloc
 (
n
 * 
s
);

119 
static_inline
 void *
xnrealloc
 (void *
p
, 
size_t
 
n
, size_t 
s
)

120 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((2, 3));

121 
static_inline
 void *

122 
xnrealloc
 (void *
p
, 
size_t
 
n
, size_t 
s
)

124 if (
xalloc_oversized
 (
n
, 
s
))

125 
xalloc_die
 ();

126 return 
xrealloc
 (
p
, 
n
 * 
s
);

184 
static_inline
 void *

185 
x2nrealloc
 (void *
p
, 
size_t
 *
pn
, size_t 
s
)

187 
size_t
 
	gn
 = *
pn
;

189 if (! 
	gp
)

191 if (! 
	gn
)

197 enum { 
	gDEFAULT_MXFAST
 = 64 * sizeof (
size_t
) / 4 };

199 
	gn
 = 
DEFAULT_MXFAST
 / 
s
;

200 
	gn
 += !
n
;

209 if ((
	gsize_t
) -1 / 3 * 2 / 
	gs
 <= 
n
)

210 
xalloc_die
 ();

211 
	gn
 += (
n
 + 1) / 2;

214 *
	gpn
 = 
n
;

215 return 
xrealloc
 (
p
, 
n
 * 
s
);

221 
static_inline
 char *
xcharalloc
 (
size_t
 
n
)

222 
_GL_ATTRIBUTE_MALLOC
 
_GL_ATTRIBUTE_ALLOC_SIZE
 ((1));

223 
static_inline
 char *

224 
xcharalloc
 (
size_t
 
n
)

226 return 
XNMALLOC
 (
n
, char);

231 #ifdef 
__cplusplus


238 
	gtemplate
 <
typename
 
	gT
> 
inline
 
T
 *

239 
	$xrealloc
 (
T
 *
p
, 
size_t
 
s
)

241 return (
T
 *) 
	`xrealloc
 ((void *) 
p
, 
s
);

242 
	}
}

244 
	gtemplate
 <
typename
 
	gT
> 
inline
 
T
 *

245 
	$xnrealloc
 (
T
 *
p
, 
size_t
 
n
, size_t 
s
)

247 return (
T
 *) 
	`xnrealloc
 ((void *) 
p
, 
n
, 
s
);

248 
	}
}

250 
	gtemplate
 <
typename
 
	gT
> 
inline
 
T
 *

251 
	$x2realloc
 (
T
 *
p
, 
size_t
 *
pn
)

253 return (
T
 *) 
	`x2realloc
 ((void *) 
p
, 
pn
);

254 
	}
}

256 
	gtemplate
 <
typename
 
	gT
> 
inline
 
T
 *

257 
	$x2nrealloc
 (
T
 *
p
, 
size_t
 *
pn
, size_t 
s
)

259 return (
T
 *) 
	`x2nrealloc
 ((void *) 
p
, 
pn
, 
s
);

260 
	}
}

262 
	gtemplate
 <
typename
 
	gT
> 
inline
 
T
 *

263 
	$xmemdup
 (
T
 const *
p
, 
size_t
 
s
)

265 return (
T
 *) 
	`xmemdup
 ((void const *) 
p
, 
s
);

266 
	}
}

	@lib/xmalloc.c

18 #include 
	~<config.h
>

20 #if ! 
HAVE_INLINE


21 #define 
	#static_inline


	)

23 #include 
	~"xalloc.h
"

24 #undef 
static_inline


26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

32 #if 
defined
 
HAVE_CALLOC_GNU
 || (defined 
__GLIBC__
 && !defined 
__UCLIBC__
)

33 enum { 
	mHAVE_GNU_CALLOC
 = 1 };

35 enum { 
	mHAVE_GNU_CALLOC
 = 0 };

41 
	$xmalloc
 (
size_t
 
n
)

43 void *
p
 = 
	`malloc
 (
n
);

44 if (!
p
 && 
n
 != 0)

45 
	`xalloc_die
 ();

46 return 
p
;

47 
	}
}

53 
	$xrealloc
 (void *
p
, 
size_t
 
n
)

55 if (!
n
 && 
p
)

59 
	`free
 (
p
);

60 return 
NULL
;

63 
p
 = 
	`realloc
 (p, 
n
);

64 if (!
p
 && 
n
)

65 
	`xalloc_die
 ();

66 return 
p
;

67 
	}
}

76 
	$x2realloc
 (void *
p
, 
size_t
 *
pn
)

78 return 
	`x2nrealloc
 (
p
, 
pn
, 1);

79 
	}
}

86 
	$xzalloc
 (
size_t
 
s
)

88 return 
	`memset
 (
	`xmalloc
 (
s
), 0, s);

89 
	}
}

95 
	$xcalloc
 (
size_t
 
n
, size_t 
s
)

97 void *
p
;

102 if ((! 
HAVE_GNU_CALLOC
 && 
	`xalloc_oversized
 (
n
, 
s
))

103 || (! (
p
 = 
	`calloc
 (
n
, 
s
)) && (
HAVE_GNU_CALLOC
 || n != 0)))

104 
	`xalloc_die
 ();

105 return 
p
;

106 
	}
}

113 
	$xmemdup
 (void const *
p
, 
size_t
 
s
)

115 return 
	`memcpy
 (
	`xmalloc
 (
s
), 
p
, s);

116 
	}
}

121 
	$xstrdup
 (char const *
string
)

123 return 
	`xmemdup
 (
string
, 
	`strlen
 (string) + 1);

124 
	}
}

	@lib/xstriconv.c

18 #include 
	~<config.h
>

21 #include 
	~"xstriconv.h
"

23 #include 
	~<errno.h
>

25 #include 
	~"striconv.h
"

26 #include 
	~"xalloc.h
"

29 #if 
HAVE_ICONV


32 
	$xmem_cd_iconv
 (const char *
src
, 
size_t
 
srclen
, 
iconv_t
 
cd
,

33 char **
resultp
, 
size_t
 *
lengthp
)

35 int 
retval
 = 
	`mem_cd_iconv
 (
src
, 
srclen
, 
cd
, 
resultp
, 
lengthp
);

37 if (
retval
 < 0 && 
errno
 == 
ENOMEM
)

38 
	`xalloc_die
 ();

39 return 
retval
;

40 
	}
}

43 
	$xstr_cd_iconv
 (const char *
src
, 
iconv_t
 
cd
)

45 char *
result
 = 
	`str_cd_iconv
 (
src
, 
cd
);

47 if (
result
 == 
NULL
 && 
errno
 == 
ENOMEM
)

48 
	`xalloc_die
 ();

49 return 
result
;

50 
	}
}

55 
	$xstr_iconv
 (const char *
src
, const char *
from_codeset
, const char *
to_codeset
)

57 char *
result
 = 
	`str_iconv
 (
src
, 
from_codeset
, 
to_codeset
);

59 if (
result
 == 
NULL
 && 
errno
 == 
ENOMEM
)

60 
	`xalloc_die
 ();

61 return 
result
;

62 
	}
}

	@lib/xstriconv.h

18 #ifndef 
_XSTRICONV_H


19 #define 
	#_XSTRICONV_H


	)

21 #include 
	~<stddef.h
>

22 #if 
HAVE_ICONV


23 #include 
	~<iconv.h
>

27 #ifdef 
__cplusplus


32 #if 
HAVE_ICONV


45 extern int 
xmem_cd_iconv
 (const char *
src
, 
size_t
 
srclen
, 
iconv_t
 
cd
,

46 char **
resultp
, 
size_t
 *
lengthp
);

57 extern char * 
xstr_cd_iconv
 (const char *
src
, 
iconv_t
 
cd
);

69 extern char * 
xstr_iconv
 (const char *
src
,

70 const char *
from_codeset
, const char *
to_codeset
);

73 #ifdef 
__cplusplus


	@lib/xstrndup.c

18 #include 
	~<config.h
>

21 #include 
	~"xstrndup.h
"

23 #include 
	~<string.h
>

24 #include 
	~"xalloc.h
"

30 
	$xstrndup
 (const char *
string
, 
size_t
 
n
)

32 char *
s
 = 
	`strndup
 (
string
, 
n
);

33 if (! 
s
)

34 
	`xalloc_die
 ();

35 return 
s
;

36 
	}
}

	@lib/xstrndup.h

18 #include 
	~<stddef.h
>

23 extern char *
xstrndup
 (const char *
string
, 
size_t
 
n
);

	@lib/xstrtol-error.c

19 #include 
	~<config.h
>

20 #include 
	~"xstrtol.h
"

22 #include 
	~<stdlib.h
>

24 #include 
	~"error.h
"

25 #include 
	~"exitfail.h
"

26 #include 
	~"gettext.h
"

28 #define 
	#N_
(
msgid
) 
	)
msgid

47 
	$xstrtol_error
 (enum 
strtol_error
 
err
,

48 int 
opt_idx
, char 
c
, struct 
option
 const *
long_options
,

49 char const *
arg
,

50 int 
exit_status
)

52 char const *
hyphens
 = "--";

53 char const *
msgid
;

54 char const *
option
;

55 char 
option_buffer
[2];

57 switch (
err
)

60 
	`abort
 ();

62 case 
LONGINT_INVALID
:

63 
msgid
 = 
	`N_
("invalid %s%s argument `%s'");

66 case 
LONGINT_INVALID_SUFFIX_CHAR
:

67 case 
LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW
:

68 
msgid
 = 
	`N_
("invalid suffix in %s%s argument `%s'");

71 case 
LONGINT_OVERFLOW
:

72 
msgid
 = 
	`N_
("%s%s argument `%s' too large");

76 if (
opt_idx
 < 0)

78 
hyphens
 -= 
opt_idx
;

79 
option_buffer
[0] = 
c
;

80 
option_buffer
[1] = '\0';

81 
option
 = 
option_buffer
;

84 
option
 = 
long_options
[
opt_idx
].
name
;

86 
	`error
 (
exit_status
, 0, 
	`gettext
 (
msgid
), 
hyphens
, 
option
, 
arg
);

87 
	}
}

92 
	$xstrtol_fatal
 (enum 
strtol_error
 
err
,

93 int 
opt_idx
, char 
c
, struct 
option
 const *
long_options
,

94 char const *
arg
)

96 
	`xstrtol_error
 (
err
, 
opt_idx
, 
c
, 
long_options
, 
arg
, 
exit_failure
);

97 
	`abort
 ();

98 
	}
}

	@lib/xstrtol.c

21 #ifndef 
__strtol


22 #define 
	#__strtol
 
strtol


	)

23 #define 
	#__strtol_t
 long int

	)

24 #define 
	#__xstrtol
 
xstrtol


	)

25 #define 
	#STRTOL_T_MINIMUM
 
LONG_MIN


	)

26 #define 
	#STRTOL_T_MAXIMUM
 
LONG_MAX


	)

29 #include 
	~<config.h
>

31 #include 
	~"xstrtol.h
"

35 #include 
	~<stdio.h
>

37 #include 
	~<assert.h
>

38 #include 
	~<ctype.h
>

39 #include 
	~<errno.h
>

40 #include 
	~<limits.h
>

41 #include 
	~<stdlib.h
>

42 #include 
	~<string.h
>

44 #include 
	~"intprops.h
"

49 #ifndef 
ULLONG_MAX


50 #define 
	#ULLONG_MAX
 
	`TYPE_MAXIMUM
 (unsigned long long)

	)

52 #ifndef 
LLONG_MAX


53 #define 
	#LLONG_MAX
 
	`TYPE_MAXIMUM
 (long long int)

	)

55 #ifndef 
LLONG_MIN


56 #define 
	#LLONG_MIN
 
	`TYPE_MINIMUM
 (long long int)

	)

59 static 
strtol_error


60 
	$bkm_scale
 (
__strtol_t
 *
x
, int 
scale_factor
)

62 if (
	`TYPE_SIGNED
 (
__strtol_t
) && *
x
 < 
STRTOL_T_MINIMUM
 / 
scale_factor
)

64 *
x
 = 
STRTOL_T_MINIMUM
;

65 return 
LONGINT_OVERFLOW
;

67 if (
STRTOL_T_MAXIMUM
 / 
scale_factor
 < *
x
)

69 *
x
 = 
STRTOL_T_MAXIMUM
;

70 return 
LONGINT_OVERFLOW
;

72 *
x
 *= 
scale_factor
;

73 return 
LONGINT_OK
;

74 
	}
}

76 static 
strtol_error


77 
	$bkm_scale_by_power
 (
__strtol_t
 *
x
, int 
base
, int 
power
)

79 
strtol_error
 
err
 = 
LONGINT_OK
;

80 while (
power
--)

81 
err
 |= 
	`bkm_scale
 (
x
, 
base
);

82 return 
err
;

83 
	}
}

87 
strtol_error


88 
	$__xstrtol
 (const char *
s
, char **
ptr
, int 
strtol_base
,

89 
__strtol_t
 *
val
, const char *
valid_suffixes
)

91 char *
t_ptr
;

92 char **
p
;

93 
__strtol_t
 
tmp
;

94 
strtol_error
 
err
 = 
LONGINT_OK
;

96 
	`assert
 (0 <= 
strtol_base
 && strtol_base <= 36);

98 
p
 = (
ptr
 ? ptr : &
t_ptr
);

100 if (! 
	`TYPE_SIGNED
 (
__strtol_t
))

102 const char *
q
 = 
s
;

103 unsigned char 
ch
 = *
q
;

104 while (
	`isspace
 (
ch
))

105 
ch
 = *++
q
;

106 if (
ch
 == '-')

107 return 
LONGINT_INVALID
;

110 
errno
 = 0;

111 
tmp
 = 
	`__strtol
 (
s
, 
p
, 
strtol_base
);

113 if (*
p
 == 
s
)

117 if (
valid_suffixes
 && **
p
 && 
	`strchr
 (valid_suffixes, **p))

118 
tmp
 = 1;

120 return 
LONGINT_INVALID
;

122 else if (
errno
 != 0)

124 if (
errno
 != 
ERANGE
)

125 return 
LONGINT_INVALID
;

126 
err
 = 
LONGINT_OVERFLOW
;

132 if (!
valid_suffixes
)

134 *
val
 = 
tmp
;

135 return 
err
;

138 if (**
p
 != '\0')

140 int 
base
 = 1024;

141 int 
suffixes
 = 1;

142 
strtol_error
 
overflow
;

144 if (!
	`strchr
 (
valid_suffixes
, **
p
))

146 *
val
 = 
tmp
;

147 return 
err
 | 
LONGINT_INVALID_SUFFIX_CHAR
;

150 if (
	`strchr
 (
valid_suffixes
, '0'))

159 switch (
p
[0][1])

162 if (
p
[0][2] == 'B')

163 
suffixes
 += 2;

168 
base
 = 1000;

169 
suffixes
++;

174 switch (**
p
)

177 
overflow
 = 
	`bkm_scale
 (&
tmp
, 512);

181 
overflow
 = 
	`bkm_scale
 (&
tmp
, 1024);

185 
overflow
 = 0;

189 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 6);

194 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 3);

199 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 1);

204 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 2);

208 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 5);

213 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 4);

217 
overflow
 = 
	`bkm_scale
 (&
tmp
, 2);

221 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 8);

225 
overflow
 = 
	`bkm_scale_by_power
 (&
tmp
, 
base
, 7);

229 *
val
 = 
tmp
;

230 return 
err
 | 
LONGINT_INVALID_SUFFIX_CHAR
;

233 
err
 |= 
overflow
;

234 *
p
 += 
suffixes
;

235 if (**
p
)

236 
err
 |= 
LONGINT_INVALID_SUFFIX_CHAR
;

239 *
val
 = 
tmp
;

240 return 
err
;

241 
	}
}

	@lib/xstrtol.h

19 #ifndef 
XSTRTOL_H_


20 #define 
	#XSTRTOL_H_
 1

	)

22 #include 
	~<getopt.h
>

23 #include 
	~<inttypes.h
>

25 #ifndef 
_STRTOL_ERROR


26 enum 
	estrtol_error


28 
	mLONGINT_OK
 = 0,

32 
	mLONGINT_OVERFLOW
 = 1,

33 
	mLONGINT_INVALID_SUFFIX_CHAR
 = 2,

35 
	mLONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW
 = (
LONGINT_INVALID_SUFFIX_CHAR


36 | 
LONGINT_OVERFLOW
),

37 
	mLONGINT_INVALID
 = 4

39 typedef enum 
strtol_error
 
	tstrtol_error
;

42 #define 
	#_DECLARE_XSTRTOL
(
name
, 
type
) \

43 
strtol_error
 
	`name
 (const char *, char **, int, 
type
 *, const char *);

	)

44 
	$_DECLARE_XSTRTOL
 (
xstrtol
, long int)

45 
	$_DECLARE_XSTRTOL
 (
xstrtoul
, unsigned long int)

46 
	$_DECLARE_XSTRTOL
 (
xstrtoimax
, 
intmax_t
)

47 
	$_DECLARE_XSTRTOL
 (
xstrtoumax
, 
uintmax_t
)

49 #if 
HAVE_LONG_LONG_INT


50 
	$_DECLARE_XSTRTOL
 (
xstrtoll
, long long int)

51 
	$_DECLARE_XSTRTOL
 (
xstrtoull
, unsigned long long int)

69 void 
_Noreturn
 
	`xstrtol_fatal
 (enum 
strtol_error
,

70 int, char, struct 
option
 const *,

	@lib/xstrtoul.c

1 #define 
	#__strtol
 
strtoul


	)

2 #define 
	#__strtol_t
 unsigned long int

	)

3 #define 
	#__xstrtol
 
xstrtoul


	)

4 #define 
	#STRTOL_T_MINIMUM
 0

	)

5 #define 
	#STRTOL_T_MAXIMUM
 
ULONG_MAX


	)

6 #include 
	~"xstrtol.c
"

	@lib/xstrtoumax.c

1 #define 
	#__strtol
 
strtoumax


	)

2 #define 
	#__strtol_t
 
uintmax_t


	)

3 #define 
	#__xstrtol
 
xstrtoumax


	)

4 #define 
	#STRTOL_T_MINIMUM
 0

	)

5 #define 
	#STRTOL_T_MAXIMUM
 
UINTMAX_MAX


	)

6 #include 
	~"xstrtol.c
"

	@src/dfa.c

23 #include 
	~<config.h
>

24 #include 
	~<assert.h
>

25 #include 
	~<ctype.h
>

26 #include 
	~<stdio.h
>

27 #include 
	~<sys/types.h
>

28 #include 
	~<stdlib.h
>

29 #include 
	~<limits.h
>

30 #include 
	~<string.h
>

31 #include 
	~<locale.h
>

33 #define 
	#STREQ
(
a
, 
b
) (
	`strcmp
 (a, b) == 0)

	)

43 #define 
	#ISASCIIDIGIT
(
c
) ((unsigned) (c) - '0' <= 9)

	)

46 #include 
	~"gettext.h
"

47 #define 
	#_
(
str
) 
	`gettext
 (str)

	)

49 #include 
	~"mbsupport.h
"

50 #include 
	~<wchar.h
>

51 #include 
	~<wctype.h
>

53 #if 
HAVE_LANGINFO_CODESET


54 #include 
	~<langinfo.h
>

57 #include 
	~"regex.h
"

58 #include 
	~"dfa.h
"

59 #include 
	~"hard-locale.h
"

60 #include 
	~"xalloc.h
"

63 #ifdef 
setbit


64 #undef 
setbit


66 #ifdef 
clrbit


67 #undef 
clrbit


71 #ifndef 
CHARBITS


72 #define 
	#CHARBITS
 8

	)

76 #define 
	#NOTCHAR
 (1 << 
CHARBITS
)

	)

79 #ifndef 
INTBITS


80 #define 
	#INTBITS
 (
CHARBITS
 * sizeof (int))

	)

84 #define 
	#CHARCLASS_INTS
 ((
NOTCHAR
 + 
INTBITS
 - 1) / INTBITS)

	)

87 typedef int 
	tcharclass
[
CHARCLASS_INTS
];

92 static 
inline
 unsigned char 
	$to_uchar
 (char 
ch
) { return ch; 
	}
}

117 #define 
	#MATCHES_NEWLINE_CONTEXT
(
constraint
, 
prevn
, 
currn
) \

118 ((
constraint
) & 1 << (((
prevn
) ? 2 : 0) + ((
currn
) ? 1 : 0) + 4))

	)

119 #define 
	#MATCHES_LETTER_CONTEXT
(
constraint
, 
prevl
, 
currl
) \

120 ((
constraint
) & 1 << (((
prevl
) ? 2 : 0) + ((
currl
) ? 1 : 0)))

	)

121 #define 
	#SUCCEEDS_IN_CONTEXT
(
constraint
, 
prevn
, 
currn
, 
prevl
, 
currl
) \

122 (
	`MATCHES_NEWLINE_CONTEXT
(
constraint
, 
prevn
, 
currn
) \

123 && 
	`MATCHES_LETTER_CONTEXT
(
constraint
, 
prevl
, 
currl
))

	)

126 #define 
	#PREV_NEWLINE_DEPENDENT
(
constraint
) \

127 (((
constraint
) & 0xc0) >> 2 != ((constraint) & 0x30))

	)

128 #define 
	#PREV_LETTER_DEPENDENT
(
constraint
) \

129 (((
constraint
) & 0x0c) >> 2 != ((constraint) & 0x03))

	)

135 #define 
	#NO_CONSTRAINT
 0xff

	)

136 #define 
	#BEGLINE_CONSTRAINT
 0xcf

	)

137 #define 
	#ENDLINE_CONSTRAINT
 0xaf

	)

138 #define 
	#BEGWORD_CONSTRAINT
 0xf2

	)

139 #define 
	#ENDWORD_CONSTRAINT
 0xf4

	)

140 #define 
	#LIMWORD_CONSTRAINT
 0xf6

	)

141 #define 
	#NOTLIMWORD_CONSTRAINT
 0xf9

	)

148 
	mEND
 = -1,

156 
	mEMPTY
 = 
NOTCHAR
,

159 
	mBACKREF
,

166 
	mBEGLINE
,

170 
	mENDLINE
,

174 
	mBEGWORD
,

178 
	mENDWORD
,

182 
	mLIMWORD
,

186 
	mNOTLIMWORD
,

190 
	mQMARK
,

194 
	mSTAR
,

198 
	mPLUS
,

202 
	mREPMN
,

206 
	mCAT
,

211 
	mOR
,

214 
	mLPAREN
,

217 
	mRPAREN
,

219 
	mANYCHAR
,

223 
	mMBCSET
,

226 
	mWCHAR
,

229 
	mCSET


232 } 
	ttoken
;

241 unsigned int 
	mindex
;

242 unsigned int 
	mconstraint
;

243 } 
	tposition
;

248 
position
 *
	melems
;

249 int 
	mnelem
;

250 } 
	tposition_set
;

257 int 
	mhash
;

258 
position_set
 
	melems
;

259 char 
	mnewline
;

260 char 
	mletter
;

261 char 
	mbackref
;

262 unsigned char 
	mconstraint
;

263 int 
	mfirst_end
;

264 
position_set
 
	mmbps
;

268 } 
	tdfa_state
;

272 struct 
	smb_char_classes


274 int 
	mcset
;

275 int 
	minvert
;

276 
wchar_t
 *
	mchars
;

277 int 
	mnchars
;

278 
wctype_t
 *
	mch_classes
;

279 int 
	mnch_classes
;

280 
wchar_t
 *
	mrange_sts
;

281 
wchar_t
 *
	mrange_ends
;

282 int 
	mnranges
;

283 char **
	mequivs
;

284 int 
	mnequivs
;

285 char **
	mcoll_elems
;

286 int 
	mncoll_elems
;

290 struct 
	sdfa


293 
charclass
 *
	mcharclasses
;

294 int 
	mcindex
;

295 int 
	mcalloc
;

298 
token
 *
	mtokens
;

299 int 
	mtindex
;

300 int 
	mtalloc
;

301 int 
	mdepth
;

304 int 
	mnleaves
;

305 int 
	mnregexps
;

307 unsigned int 
	mmb_cur_max
;

308 int 
	mutf8_anychar_classes
[5];

329 int 
	mnmultibyte_prop
;

330 int *
	mmultibyte_prop
;

333 struct 
mb_char_classes
 *
	mmbcsets
;

334 int 
	mnmbcsets
;

335 int 
	mmbcsets_alloc
;

338 
dfa_state
 *
	mstates
;

339 int 
	msindex
;

340 int 
	msalloc
;

343 
position_set
 *
	mfollows
;

350 int 
	msearchflag
;

359 int 
	mtralloc
;

361 int 
	mtrcount
;

363 int **
	mtrans
;

368 int **
	mrealtrans
;

370 int **
	mfails
;

372 int *
	msuccess
;

374 int *
	mnewlines
;

381 struct 
dfamust
 *
	mmusts
;

389 #define 
	#ACCEPTING
(
s
, 
r
) ((r).
states
[s].
constraint
)

	)

393 #define 
	#ACCEPTS_IN_CONTEXT
(
prevn
, 
currn
, 
prevl
, 
currl
, 
state
, 
dfa
) \

394 
	`SUCCEEDS_IN_CONTEXT
((
dfa
).
states
[
state
].
constraint
, \

395 
prevn
, 
currn
, 
prevl
, 
currl
)

	)

397 static void 
dfamust
 (struct 
dfa
 *dfa);

398 static void 
regexp
 (void);

403 #undef 
XNMALLOC


404 #undef 
XCALLOC


408 #define 
	#XNMALLOC
(
n
, 
t
) \

409 (sizeof (
t
) == 1 ? 
	`xmalloc
 (
n
) : 
	`xnmalloc
 (n, sizeof (t)))

	)

414 #define 
	#XCALLOC
(
n
, 
t
) \

415 (sizeof (
t
) == 1 ? 
	`xzalloc
 (
n
) : 
	`xcalloc
 (n, sizeof (t)))

	)

417 #define 
	#CALLOC
(
p
, 
n
) do { (p) = 
	`XCALLOC
 (n, *(p)); } while (0)

	)

418 #define 
	#MALLOC
(
p
, 
n
) do { (p) = 
	`XNMALLOC
 (n, *(p)); } while (0)

	)

419 #define 
	#REALLOC
(
p
, 
n
) do {(p) = 
	`xnrealloc
 (p, n, sizeof (*(p))); } while (0)

	)

422 #define 
	#REALLOC_IF_NECESSARY
(
p
, 
n_alloc
, 
n_required
) \

425 
	`assert
 (0 <= (
n_required
)); \

426 if ((
n_alloc
) <= (
n_required
)) \

428 
size_t
 
new_n_alloc
 = (
n_required
) + !(
p
); \

429 (
p
) = 
	`x2nrealloc
 (p, &
new_n_alloc
, sizeof (*(p))); \

430 (
n_alloc
) = 
new_n_alloc
; \

433 while (
false
)

	)

436 #ifdef 
DEBUG


439 
	$prtok
 (
token
 
t
)

441 char const *
s
;

443 if (
t
 < 0)

444 
	`fprintf
(
stderr
, "END");

445 else if (
t
 < 
NOTCHAR
)

446 
	`fprintf
(
stderr
, "%c", 
t
);

449 switch (
t
)

451 case 
EMPTY
: 
s
 = "EMPTY"; break;

452 case 
BACKREF
: 
s
 = "BACKREF"; break;

453 case 
BEGLINE
: 
s
 = "BEGLINE"; break;

454 case 
ENDLINE
: 
s
 = "ENDLINE"; break;

455 case 
BEGWORD
: 
s
 = "BEGWORD"; break;

456 case 
ENDWORD
: 
s
 = "ENDWORD"; break;

457 case 
LIMWORD
: 
s
 = "LIMWORD"; break;

458 case 
NOTLIMWORD
: 
s
 = "NOTLIMWORD"; break;

459 case 
QMARK
: 
s
 = "QMARK"; break;

460 case 
STAR
: 
s
 = "STAR"; break;

461 case 
PLUS
: 
s
 = "PLUS"; break;

462 case 
CAT
: 
s
 = "CAT"; break;

463 case 
OR
: 
s
 = "OR"; break;

464 case 
LPAREN
: 
s
 = "LPAREN"; break;

465 case 
RPAREN
: 
s
 = "RPAREN"; break;

466 case 
ANYCHAR
: 
s
 = "ANYCHAR"; break;

467 case 
MBCSET
: 
s
 = "MBCSET"; break;

468 default: 
s
 = "CSET"; break;

470 
	`fprintf
(
stderr
, "%s", 
s
);

472 
	}
}

478 
	$tstbit
 (unsigned int 
b
, 
charclass
 const 
c
)

480 return 
c
[
b
 / 
INTBITS
] & 1 << b % INTBITS;

481 
	}
}

484 
	$setbit
 (unsigned int 
b
, 
charclass
 
c
)

486 
c
[
b
 / 
INTBITS
] |= 1 << b % INTBITS;

487 
	}
}

490 
	$clrbit
 (unsigned int 
b
, 
charclass
 
c
)

492 
c
[
b
 / 
INTBITS
] &= ~(1 << b % INTBITS);

493 
	}
}

496 
	$copyset
 (
charclass
 const 
src
, charclass 
dst
)

498 
	`memcpy
 (
dst
, 
src
, sizeof (
charclass
));

499 
	}
}

502 
	$zeroset
 (
charclass
 
s
)

504 
	`memset
 (
s
, 0, sizeof (
charclass
));

505 
	}
}

508 
	$notset
 (
charclass
 
s
)

510 int 
i
;

512 for (
i
 = 0; i < 
CHARCLASS_INTS
; ++i)

513 
s
[
i
] = ~s[i];

514 
	}
}

517 
	$equal
 (
charclass
 const 
s1
, charclass const 
s2
)

519 return 
	`memcmp
 (
s1
, 
s2
, sizeof (
charclass
)) == 0;

520 
	}
}

523 static struct 
dfa
 *
	gdfa
;

527 
	$charclass_index
 (
charclass
 const 
s
)

529 int 
i
;

531 for (
i
 = 0; i < 
dfa
->
cindex
; ++i)

532 if (
	`equal
(
s
, 
dfa
->
charclasses
[
i
]))

533 return 
i
;

534 
	`REALLOC_IF_NECESSARY
(
dfa
->
charclasses
, dfa->
calloc
, dfa->
cindex
 + 1);

535 ++
dfa
->
cindex
;

536 
	`copyset
(
s
, 
dfa
->
charclasses
[
i
]);

537 return 
i
;

538 
	}
}

541 static 
reg_syntax_t
 
	gsyntax_bits
, 
	gsyntax_bits_set
;

544 static int 
	gcase_fold
;

547 static unsigned char 
	geolbyte
;

551 
	$dfasyntax
 (
reg_syntax_t
 
bits
, int 
fold
, unsigned char 
eol
)

553 
syntax_bits_set
 = 1;

554 
syntax_bits
 = 
bits
;

555 
case_fold
 = 
fold
;

556 
eolbyte
 = 
eol
;

557 
	}
}

564 #if 
MBS_SUPPORT


565 static 
bool


566 
	$setbit_wc
 (
wint_t
 
wc
, 
charclass
 
c
)

568 int 
b
 = 
	`wctob
 (
wc
);

569 if (
b
 == 
EOF
)

570 return 
false
;

572 
	`setbit
 (
b
, 
c
);

573 return 
true
;

574 
	}
}

579 
	$setbit_c
 (int 
b
, 
charclass
 
c
)

582 if (
MB_CUR_MAX
 > 1 && 
	`btowc
 (
b
) == 
WEOF
)

584 
	`setbit
 (
b
, 
c
);

585 
	}
}

587 #define 
	#setbit_c
 
setbit


	)

588 static 
inline
 
bool
 
	$setbit_wc
 (
wint_t
 
wc
, 
charclass
 
c
) { 
	`abort
 (); 
	}
}

596 
	$setbit_case_fold_c
 (int 
b
, 
charclass
 
c
)

598 if (
MB_CUR_MAX
 > 1)

600 
wint_t
 
wc
 = 
	`btowc
 (
b
);

601 if (
wc
 == 
WEOF
)

603 
	`setbit
 (
b
, 
c
);

604 if (
case_fold
 && 
	`iswalpha
 (
wc
))

605 
	`setbit_wc
 (
	`iswupper
 (
wc
) ? 
	`towlower
 (wc) : 
	`towupper
 (wc), 
c
);

609 
	`setbit
 (
b
, 
c
);

610 if (
case_fold
 && 
	`isalpha
 (
b
))

611 
	`setbit_c
 (
	`isupper
 (
b
) ? 
	`tolower
 (b) : 
	`toupper
 (b), 
c
);

613 
	}
}

619 static 
inline
 int

620 
	$using_utf8
 (void)

622 static int 
utf8
 = -1;

623 if (
utf8
 == -1)

625 #if 
defined
 
HAVE_LANGINFO_CODESET
 && defined 
MBS_SUPPORT


626 
utf8
 = (
	`STREQ
 (
	`nl_langinfo
 (
CODESET
), "UTF-8"));

628 
utf8
 = 0;

632 return 
utf8
;

633 
	}
}

640 static char const *
	glexptr
;

641 static int 
	glexleft
;

642 static 
token
 
	glasttok
;

643 static int 
	glaststart
;

645 static int 
	gparens
;

646 static int 
	gminrep
, 
	gmaxrep
;

647 static int 
	ghard_LC_COLLATE
;

649 static int 
	gcur_mb_len
 = 1;

652 static 
mbstate_t
 
	gmbs
;

653 static 
wchar_t
 
	gwctok
;

655 static unsigned char *
	gmblen_buf
;

664 static 
wchar_t
 *
	ginputwcs
;

671 static unsigned char const *
	gbuf_begin
;

672 static unsigned char const *
	gbuf_end
;

675 #if 
MBS_SUPPORT


677 #define 
	#FETCH_WC
(
c
, 
wc
, 
eoferr
) \

679 if (! 
lexleft
) \

681 if ((
eoferr
) != 0) \

682 
	`dfaerror
 (
eoferr
); \

684 return 
lasttok
 = 
END
; \

688 
wchar_t
 
_wc
; \

689 
cur_mb_len
 = 
	`mbrtowc
(&
_wc
, 
lexptr
, 
lexleft
, &
mbs
); \

690 if (
cur_mb_len
 <= 0) \

692 
cur_mb_len
 = 1; \

693 --
lexleft
; \

694 (
wc
) = (
c
) = 
	`to_uchar
 (*
lexptr
++); \

698 
lexptr
 += 
cur_mb_len
; \

699 
lexleft
 -= 
cur_mb_len
; \

700 (
wc
) = 
_wc
; \

701 (
c
) = 
	`wctob
(
wc
); \

704 } while(0)

	)

706 #define 
	#FETCH
(
c
, 
eoferr
) \

708 
wint_t
 
wc
; \

709 
	`FETCH_WC
(
c
, 
wc
, 
eoferr
); \

710 } while(0)

	)

714 #define 
	#FETCH
(
c
, 
eoferr
) \

716 if (! 
lexleft
) \

718 if ((
eoferr
) != 0) \

719 
	`dfaerror
 (
eoferr
); \

721 return 
lasttok
 = 
END
; \

723 (
c
) = 
	`to_uchar
 (*
lexptr
++); \

724 --
lexleft
; \

725 } while(0)

	)

727 #define 
	#FETCH_WC
(
c
, 
unused
, 
eoferr
) 
	`FETCH
 (c, eoferr)

	)

731 typedef int 
	tpredicate
 (int);

736 struct 
	sdfa_ctype
 {

737 const char *
	mname
;

738 
predicate
 *
	mfunc
;

739 
bool
 
	msingle_byte_only
;

742 static const struct 
dfa_ctype
 
	gprednames
[] = {

743 { "alpha", 
isalpha
, 
false
 },

744 { "upper", 
isupper
, 
false
 },

745 { "lower", 
islower
, 
false
 },

746 { "digit", 
isdigit
, 
true
 },

747 { "xdigit", 
isxdigit
, 
true
 },

748 { "space", 
isspace
, 
false
 },

749 { "punct", 
ispunct
, 
false
 },

750 { "alnum", 
isalnum
, 
false
 },

751 { "print", 
isprint
, 
false
 },

752 { "graph", 
isgraph
, 
false
 },

753 { "cntrl", 
iscntrl
, 
false
 },

754 { "blank", 
isblank
, 
false
 },

755 { 
NULL
, NULL, 
false
 }

758 static const struct 
dfa_ctype
 *

759 
	$find_pred
 (const char *
str
)

761 unsigned int 
i
;

762 for (
i
 = 0; 
prednames
[i].
name
; ++i)

763 if (
	`STREQ
 (
str
, 
prednames
[
i
].
name
))

766 return &
prednames
[
i
];

767 
	}
}

772 static 
token


773 
	$parse_bracket_exp
 (void)

775 int 
invert
;

776 int 
c
, 
c1
, 
c2
;

777 
charclass
 
ccl
;

784 int 
colon_warning_state
;

786 
wint_t
 
wc
;

787 
wint_t
 
wc2
;

790 struct 
mb_char_classes
 *
work_mbc
;

791 int 
chars_al
, 
range_sts_al
, 
range_ends_al
, 
ch_classes_al
,

792 
equivs_al
, 
coll_elems_al
;

794 
chars_al
 = 1;

795 
range_sts_al
 = 
range_ends_al
 = 0;

796 
ch_classes_al
 = 
equivs_al
 = 
coll_elems_al
 = 0;

797 if (
MB_CUR_MAX
 > 1)

799 
	`REALLOC_IF_NECESSARY
(
dfa
->
mbcsets
, dfa->
mbcsets_alloc
, dfa->
nmbcsets
 + 1);

806 
work_mbc
 = &(
dfa
->
mbcsets
[dfa->
nmbcsets
++]);

807 
	`memset
 (
work_mbc
, 0, sizeof *work_mbc);

810 
work_mbc
 = 
NULL
;

812 
	`memset
 (
ccl
, 0, sizeof ccl);

813 
	`FETCH_WC
 (
c
, 
wc
, 
	`_
("unbalanced ["));

814 if (
c
 == '^')

816 
	`FETCH_WC
 (
c
, 
wc
, 
	`_
("unbalanced ["));

817 
invert
 = 1;

820 
invert
 = 0;

822 
wint_t
 
wc1
 = 0;

823 
colon_warning_state
 = (
c
 == ':');

826 
c1
 = 
EOF
;

827 
colon_warning_state
 &= ~2;

833 if (
c
 == '[' && (
syntax_bits
 & 
RE_CHAR_CLASSES
))

835 #define 
	#BRACKET_BUFFER_SIZE
 128

	)

836 char 
str
[
BRACKET_BUFFER_SIZE
];

837 
	`FETCH_WC
 (
c1
, 
wc1
, 
	`_
("unbalanced ["));

840 if (
c1
 == ':'

842 || (
MB_CUR_MAX
 > 1 && (
c1
 == '.' || c1 == '='))

845 
size_t
 
len
 = 0;

848 
	`FETCH_WC
 (
c
, 
wc
, 
	`_
("unbalanced ["));

849 if ((
c
 == 
c1
 && *
lexptr
 == ']') || 
lexleft
 == 0)

851 if (
len
 < 
BRACKET_BUFFER_SIZE
)

852 
str
[
len
++] = 
c
;

855 
str
[0] = '\0';

857 
str
[
len
] = '\0';

860 
	`FETCH_WC
 (
c
, 
wc
, 
	`_
("unbalanced ["));

861 if (
c1
 == ':')

864 char const *
class


865 = (
case_fold
 && (
	`STREQ
 (
str
, "upper")

866 || 
	`STREQ
 (
str
, "lower"))

868 : 
str
);

869 const struct 
dfa_ctype
 *
pred
 = 
	`find_pred
 (
class
);

870 if (!
pred
)

871 
	`dfaerror
(
	`_
("invalid character class"));

873 if (
MB_CUR_MAX
 > 1 && !
pred
->
single_byte_only
)

876 
wctype_t
 
wt
 = 
	`wctype
 (
class
);

878 if (
ch_classes_al
 == 0)

879 
	`MALLOC
(
work_mbc
->
ch_classes
, ++
ch_classes_al
);

880 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
ch_classes
,

881 
ch_classes_al
,

882 
work_mbc
->
nch_classes
 + 1);

883 
work_mbc
->
ch_classes
[work_mbc->
nch_classes
++] = 
wt
;

886 for (
c2
 = 0; c2 < 
NOTCHAR
; ++c2)

887 if (
pred
->
	`func
(
c2
))

888 
	`setbit_case_fold_c
 (
c2
, 
ccl
);

891 else if (
MBS_SUPPORT
 && (
c1
 == '=' || c1 == '.'))

893 char *
elem
;

894 
	`MALLOC
(
elem
, 
len
 + 1);

895 
	`strncpy
(
elem
, 
str
, 
len
 + 1);

897 if (
c1
 == '=')

900 if (
equivs_al
 == 0)

901 
	`MALLOC
(
work_mbc
->
equivs
, ++
equivs_al
);

902 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
equivs
,

903 
equivs_al
,

904 
work_mbc
->
nequivs
 + 1);

905 
work_mbc
->
equivs
[work_mbc->
nequivs
++] = 
elem
;

908 if (
c1
 == '.')

911 if (
coll_elems_al
 == 0)

912 
	`MALLOC
(
work_mbc
->
coll_elems
, ++
coll_elems_al
);

913 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
coll_elems
,

914 
coll_elems_al
,

915 
work_mbc
->
ncoll_elems
 + 1);

916 
work_mbc
->
coll_elems
[work_mbc->
ncoll_elems
++] = 
elem
;

919 
colon_warning_state
 |= 8;

922 
	`FETCH_WC
 (
c1
, 
wc1
, 
	`_
("unbalanced ["));

930 if (
c
 == '\\' && (
syntax_bits
 & 
RE_BACKSLASH_ESCAPE_IN_LISTS
))

931 
	`FETCH_WC
(
c
, 
wc
, 
	`_
("unbalanced ["));

933 if (
c1
 == 
EOF
)

934 
	`FETCH_WC
(
c1
, 
wc1
, 
	`_
("unbalanced ["));

936 if (
c1
 == '-')

939 
	`FETCH_WC
(
c2
, 
wc2
, 
	`_
("unbalanced ["));

940 if (
c2
 == ']')

944 
lexptr
 -= 
cur_mb_len
;

945 
lexleft
 += 
cur_mb_len
;

949 if (
c1
 == '-' && 
c2
 != ']')

951 if (
c2
 == '\\'

952 && (
syntax_bits
 & 
RE_BACKSLASH_ESCAPE_IN_LISTS
))

953 
	`FETCH_WC
(
c2
, 
wc2
, 
	`_
("unbalanced ["));

955 if (
MB_CUR_MAX
 > 1)

959 if (
range_sts_al
 == 0)

961 
	`MALLOC
(
work_mbc
->
range_sts
, ++
range_sts_al
);

962 
	`MALLOC
(
work_mbc
->
range_ends
, ++
range_ends_al
);

964 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
range_sts
,

965 
range_sts_al
, 
work_mbc
->
nranges
 + 1);

966 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
range_ends
,

967 
range_ends_al
, 
work_mbc
->
nranges
 + 1);

968 
work_mbc
->
range_sts
[work_mbc->
nranges
] =

969 
case_fold
 ? 
	`towlower
(
wc
) : (
wchar_t
)wc;

970 
work_mbc
->
range_ends
[work_mbc->
nranges
++] =

971 
case_fold
 ? 
	`towlower
(
wc2
) : (
wchar_t
)wc2;

973 #ifndef 
GREP


974 if (
case_fold
 && (
	`iswalpha
(
wc
) || iswalpha(
wc2
)))

976 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
range_sts
,

977 
range_sts_al
, 
work_mbc
->
nranges
 + 1);

978 
work_mbc
->
range_sts
[work_mbc->
nranges
] = 
	`towupper
(
wc
);

979 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
range_ends
,

980 
range_ends_al
, 
work_mbc
->
nranges
 + 1);

981 
work_mbc
->
range_ends
[work_mbc->
nranges
++] = 
	`towupper
(
wc2
);

987 
c1
 = 
c
;

988 if (
case_fold
)

990 
c1
 = 
	`tolower
 (c1);

991 
c2
 = 
	`tolower
 (c2);

993 if (!
hard_LC_COLLATE
)

994 for (
c
 = 
c1
; c <= 
c2
; c++)

995 
	`setbit_case_fold_c
 (
c
, 
ccl
);

1000 
regex_t
 
re
;

1001 char 
pattern
[6] = { '[', 
c1
, '-', 
c2
, ']', 0 };

1002 char 
subject
[2] = { 0, 0 };

1003 
	`regcomp
 (&
re
, 
pattern
, 
REG_NOSUB
);

1004 for (
c
 = 0; c < 
NOTCHAR
; ++c)

1006 
subject
[0] = 
c
;

1007 if (!(
case_fold
 && 
	`isupper
 (
c
))

1008 && 
	`regexec
 (&
re
, 
subject
, 0, 
NULL
, 0) != 
REG_NOMATCH
)

1009 
	`setbit_case_fold_c
 (
c
, 
ccl
);

1011 
	`regfree
 (&
re
);

1015 
colon_warning_state
 |= 8;

1016 
	`FETCH_WC
(
c1
, 
wc1
, 
	`_
("unbalanced ["));

1020 
colon_warning_state
 |= (
c
 == ':') ? 2 : 4;

1022 if (
MB_CUR_MAX
 == 1)

1024 
	`setbit_case_fold_c
 (
c
, 
ccl
);

1028 if (
case_fold
 && 
	`iswalpha
(
wc
))

1030 
wc
 = 
	`towlower
(wc);

1031 if (!
	`setbit_wc
 (
wc
, 
ccl
))

1033 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
chars
, 
chars_al
,

1034 
work_mbc
->
nchars
 + 1);

1035 
work_mbc
->
chars
[work_mbc->
nchars
++] = 
wc
;

1037 #ifdef 
GREP


1040 
wc
 = 
	`towupper
(wc);

1043 if (!
	`setbit_wc
 (
wc
, 
ccl
))

1045 
	`REALLOC_IF_NECESSARY
(
work_mbc
->
chars
, 
chars_al
,

1046 
work_mbc
->
nchars
 + 1);

1047 
work_mbc
->
chars
[work_mbc->
nchars
++] = 
wc
;

1050 while ((
wc
 = 
wc1
, (
c
 = 
c1
) != ']'));

1052 if (
colon_warning_state
 == 7)

1053 
	`dfawarn
 (
	`_
("character class syntax is [[:space:]], not [:space:]"));

1055 if (
MB_CUR_MAX
 > 1)

1057 static 
charclass
 
zeroclass
;

1058 
work_mbc
->
invert
 = invert;

1059 
work_mbc
->
cset
 = 
	`equal
(
ccl
, 
zeroclass
) ? -1 : 
	`charclass_index
(ccl);

1060 return 
MBCSET
;

1063 if (
invert
)

1065 
	`assert
(
MB_CUR_MAX
 == 1);

1066 
	`notset
(
ccl
);

1067 if (
syntax_bits
 & 
RE_HAT_LISTS_NOT_NEWLINE
)

1068 
	`clrbit
(
eolbyte
, 
ccl
);

1071 return 
CSET
 + 
	`charclass_index
(
ccl
);

1072 
	}
}

1075 #define 
	#IS_WORD_CONSTITUENT
(
C
) (
	`isalnum
(C) || (C) == '_')

	)

1077 static 
token


1078 
	$lex
 (void)

1080 unsigned int 
c
, 
c2
;

1081 int 
backslash
 = 0;

1082 
charclass
 
ccl
;

1083 int 
i
;

1091 for (
i
 = 0; i < 2; ++i)

1093 if (
MB_CUR_MAX
 > 1)

1095 
	`FETCH_WC
 (
c
, 
wctok
, 
NULL
);

1096 if ((int)
c
 == 
EOF
)

1097 goto 
normal_char
;

1100 
	`FETCH
(
c
, 
NULL
);

1102 switch (
c
)

1105 if (
backslash
)

1106 goto 
normal_char
;

1107 if (
lexleft
 == 0)

1108 
	`dfaerror
(
	`_
("unfinished \\ escape"));

1109 
backslash
 = 1;

1113 if (
backslash
)

1114 goto 
normal_char
;

1115 if (
syntax_bits
 & 
RE_CONTEXT_INDEP_ANCHORS


1116 || 
lasttok
 == 
END


1117 || 
lasttok
 == 
LPAREN


1118 || 
lasttok
 == 
OR
)

1119 return 
lasttok
 = 
BEGLINE
;

1120 goto 
normal_char
;

1123 if (
backslash
)

1124 goto 
normal_char
;

1125 if (
syntax_bits
 & 
RE_CONTEXT_INDEP_ANCHORS


1126 || 
lexleft
 == 0

1127 || (
syntax_bits
 & 
RE_NO_BK_PARENS


1128 ? 
lexleft
 > 0 && *
lexptr
 == ')'

1129 : 
lexleft
 > 1 && 
lexptr
[0] == '\\' && lexptr[1] == ')')

1130 || (
syntax_bits
 & 
RE_NO_BK_VBAR


1131 ? 
lexleft
 > 0 && *
lexptr
 == '|'

1132 : 
lexleft
 > 1 && 
lexptr
[0] == '\\' && lexptr[1] == '|')

1133 || ((
syntax_bits
 & 
RE_NEWLINE_ALT
)

1134 && 
lexleft
 > 0 && *
lexptr
 == '\n'))

1135 return 
lasttok
 = 
ENDLINE
;

1136 goto 
normal_char
;

1147 if (
backslash
 && !(
syntax_bits
 & 
RE_NO_BK_REFS
))

1149 
laststart
 = 0;

1150 return 
lasttok
 = 
BACKREF
;

1152 goto 
normal_char
;

1155 if (
backslash
 && !(
syntax_bits
 & 
RE_NO_GNU_OPS
))

1156 return 
lasttok
 = 
BEGLINE
;

1157 goto 
normal_char
;

1160 if (
backslash
 && !(
syntax_bits
 & 
RE_NO_GNU_OPS
))

1161 return 
lasttok
 = 
ENDLINE
;

1162 goto 
normal_char
;

1165 if (
backslash
 && !(
syntax_bits
 & 
RE_NO_GNU_OPS
))

1166 return 
lasttok
 = 
BEGWORD
;

1167 goto 
normal_char
;

1170 if (
backslash
 && !(
syntax_bits
 & 
RE_NO_GNU_OPS
))

1171 return 
lasttok
 = 
ENDWORD
;

1172 goto 
normal_char
;

1175 if (
backslash
 && !(
syntax_bits
 & 
RE_NO_GNU_OPS
))

1176 return 
lasttok
 = 
LIMWORD
;

1177 goto 
normal_char
;

1180 if (
backslash
 && !(
syntax_bits
 & 
RE_NO_GNU_OPS
))

1181 return 
lasttok
 = 
NOTLIMWORD
;

1182 goto 
normal_char
;

1185 if (
syntax_bits
 & 
RE_LIMITED_OPS
)

1186 goto 
normal_char
;

1187 if (
backslash
 != ((
syntax_bits
 & 
RE_BK_PLUS_QM
) != 0))

1188 goto 
normal_char
;

1189 if (!(
syntax_bits
 & 
RE_CONTEXT_INDEP_OPS
) && 
laststart
)

1190 goto 
normal_char
;

1191 return 
lasttok
 = 
QMARK
;

1194 if (
backslash
)

1195 goto 
normal_char
;

1196 if (!(
syntax_bits
 & 
RE_CONTEXT_INDEP_OPS
) && 
laststart
)

1197 goto 
normal_char
;

1198 return 
lasttok
 = 
STAR
;

1201 if (
syntax_bits
 & 
RE_LIMITED_OPS
)

1202 goto 
normal_char
;

1203 if (
backslash
 != ((
syntax_bits
 & 
RE_BK_PLUS_QM
) != 0))

1204 goto 
normal_char
;

1205 if (!(
syntax_bits
 & 
RE_CONTEXT_INDEP_OPS
) && 
laststart
)

1206 goto 
normal_char
;

1207 return 
lasttok
 = 
PLUS
;

1210 if (!(
syntax_bits
 & 
RE_INTERVALS
))

1211 goto 
normal_char
;

1212 if (
backslash
 != ((
syntax_bits
 & 
RE_NO_BK_BRACES
) == 0))

1213 goto 
normal_char
;

1214 if (!(
syntax_bits
 & 
RE_CONTEXT_INDEP_OPS
) && 
laststart
)

1215 goto 
normal_char
;

1217 if (
syntax_bits
 & 
RE_NO_BK_BRACES
)

1221 int 
lo
 = -1, 
hi
 = -1;

1222 char const *
p
 = 
lexptr
;

1223 char const *
lim
 = 
p
 + 
lexleft
;

1224 for (; 
p
 != 
lim
 && 
	`ISASCIIDIGIT
 (*p); p++)

1225 
lo
 = (lo < 0 ? 0 : lo * 10) + *
p
 - '0';

1226 if (
p
 != 
lim
 && *p == ',')

1227 while (++
p
 != 
lim
 && 
	`ISASCIIDIGIT
 (*p))

1228 
hi
 = (hi < 0 ? 0 : hi * 10) + *
p
 - '0';

1230 
hi
 = 
lo
;

1231 if (
p
 == 
lim
 || *p != '}'

1232 || 
lo
 < 0 || 
RE_DUP_MAX
 < 
hi
 || (0 <= hi && hi < lo))

1233 goto 
normal_char
;

1236 
minrep
 = 0;

1241 
	`FETCH
(
c
, 
	`_
("unfinished repeat count"));

1242 if (
	`ISASCIIDIGIT
 (
c
))

1244 
minrep
 = 
c
 - '0';

1247 
	`FETCH
(
c
, 
	`_
("unfinished repeat count"));

1248 if (! 
	`ISASCIIDIGIT
 (
c
))

1250 
minrep
 = 10 * minrep + 
c
 - '0';

1254 
	`dfaerror
(
	`_
("malformed repeat count"));

1255 if (
c
 == ',')

1257 
	`FETCH
 (
c
, 
	`_
("unfinished repeat count"));

1258 if (! 
	`ISASCIIDIGIT
 (
c
))

1259 
maxrep
 = -1;

1262 
maxrep
 = 
c
 - '0';

1265 
	`FETCH
 (
c
, 
	`_
("unfinished repeat count"));

1266 if (! 
	`ISASCIIDIGIT
 (
c
))

1268 
maxrep
 = 10 * maxrep + 
c
 - '0';

1270 if (0 <= 
maxrep
 && maxrep < 
minrep
)

1271 
	`dfaerror
 (
	`_
("malformed repeat count"));

1275 
maxrep
 = 
minrep
;

1276 if (!(
syntax_bits
 & 
RE_NO_BK_BRACES
))

1278 if (
c
 != '\\')

1279 
	`dfaerror
(
	`_
("malformed repeat count"));

1280 
	`FETCH
(
c
, 
	`_
("unfinished repeat count"));

1282 if (
c
 != '}')

1283 
	`dfaerror
(
	`_
("malformed repeat count"));

1284 
laststart
 = 0;

1285 return 
lasttok
 = 
REPMN
;

1288 if (
syntax_bits
 & 
RE_LIMITED_OPS
)

1289 goto 
normal_char
;

1290 if (
backslash
 != ((
syntax_bits
 & 
RE_NO_BK_VBAR
) == 0))

1291 goto 
normal_char
;

1292 
laststart
 = 1;

1293 return 
lasttok
 = 
OR
;

1296 if (
syntax_bits
 & 
RE_LIMITED_OPS


1297 || 
backslash


1298 || !(
syntax_bits
 & 
RE_NEWLINE_ALT
))

1299 goto 
normal_char
;

1300 
laststart
 = 1;

1301 return 
lasttok
 = 
OR
;

1304 if (
backslash
 != ((
syntax_bits
 & 
RE_NO_BK_PARENS
) == 0))

1305 goto 
normal_char
;

1306 ++
parens
;

1307 
laststart
 = 1;

1308 return 
lasttok
 = 
LPAREN
;

1311 if (
backslash
 != ((
syntax_bits
 & 
RE_NO_BK_PARENS
) == 0))

1312 goto 
normal_char
;

1313 if (
parens
 == 0 && 
syntax_bits
 & 
RE_UNMATCHED_RIGHT_PAREN_ORD
)

1314 goto 
normal_char
;

1315 --
parens
;

1316 
laststart
 = 0;

1317 return 
lasttok
 = 
RPAREN
;

1320 if (
backslash
)

1321 goto 
normal_char
;

1322 if (
MB_CUR_MAX
 > 1)

1326 
laststart
 = 0;

1327 return 
lasttok
 = 
ANYCHAR
;

1329 
	`zeroset
(
ccl
);

1330 
	`notset
(
ccl
);

1331 if (!(
syntax_bits
 & 
RE_DOT_NEWLINE
))

1332 
	`clrbit
(
eolbyte
, 
ccl
);

1333 if (
syntax_bits
 & 
RE_DOT_NOT_NULL
)

1334 
	`clrbit
('\0', 
ccl
);

1335 
laststart
 = 0;

1336 return 
lasttok
 = 
CSET
 + 
	`charclass_index
(
ccl
);

1340 if (!
backslash
 || (
syntax_bits
 & 
RE_NO_GNU_OPS
))

1341 goto 
normal_char
;

1342 
	`zeroset
(
ccl
);

1343 for (
c2
 = 0; c2 < 
NOTCHAR
; ++c2)

1344 if (
	`isspace
(
c2
))

1345 
	`setbit
(
c2
, 
ccl
);

1346 if (
c
 == 'S')

1347 
	`notset
(
ccl
);

1348 
laststart
 = 0;

1349 return 
lasttok
 = 
CSET
 + 
	`charclass_index
(
ccl
);

1353 if (!
backslash
 || (
syntax_bits
 & 
RE_NO_GNU_OPS
))

1354 goto 
normal_char
;

1355 
	`zeroset
(
ccl
);

1356 for (
c2
 = 0; c2 < 
NOTCHAR
; ++c2)

1357 if (
	`IS_WORD_CONSTITUENT
(
c2
))

1358 
	`setbit
(
c2
, 
ccl
);

1359 if (
c
 == 'W')

1360 
	`notset
(
ccl
);

1361 
laststart
 = 0;

1362 return 
lasttok
 = 
CSET
 + 
	`charclass_index
(
ccl
);

1365 if (
backslash
)

1366 goto 
normal_char
;

1367 
laststart
 = 0;

1368 return 
lasttok
 = 
	`parse_bracket_exp
();

1371 
normal_char
:

1372 
laststart
 = 0;

1375 if (
MB_CUR_MAX
 > 1)

1376 return 
lasttok
 = 
WCHAR
;

1378 if (
case_fold
 && 
	`isalpha
(
c
))

1380 
	`zeroset
(
ccl
);

1381 
	`setbit_case_fold_c
 (
c
, 
ccl
);

1382 return 
lasttok
 = 
CSET
 + 
	`charclass_index
(
ccl
);

1385 return 
lasttok
 = 
c
;

1391 
	`abort
();

1392 return 
END
;

1393 
	}
}

1397 static 
token
 
	gtok
;

1398 static int 
	gdepth
;

1405 
	$addtok_mb
 (
token
 
t
, int 
mbprop
)

1407 if (
MB_CUR_MAX
 > 1)

1409 
	`REALLOC_IF_NECESSARY
(
dfa
->
multibyte_prop
, dfa->
nmultibyte_prop
,

1410 
dfa
->
tindex
 + 1);

1411 
dfa
->
multibyte_prop
[dfa->
tindex
] = 
mbprop
;

1414 
	`REALLOC_IF_NECESSARY
(
dfa
->
tokens
, dfa->
talloc
, dfa->
tindex
 + 1);

1415 
dfa
->
tokens
[dfa->
tindex
++] = 
t
;

1417 switch (
t
)

1419 case 
QMARK
:

1420 case 
STAR
:

1421 case 
PLUS
:

1424 case 
CAT
:

1425 case 
OR
:

1426 --
depth
;

1430 ++
dfa
->
nleaves
;

1431 case 
EMPTY
:

1432 ++
depth
;

1435 if (
depth
 > 
dfa
->depth)

1436 
dfa
->
depth
 = depth;

1437 
	}
}

1439 static void 
addtok_wc
 (
wint_t
 
wc
);

1444 
	$addtok
 (
token
 
t
)

1446 if (
MB_CUR_MAX
 > 1 && 
t
 == 
MBCSET
)

1448 
bool
 
need_or
 = 
false
;

1449 struct 
mb_char_classes
 *
work_mbc
 = &
dfa
->
mbcsets
[dfa->
nmbcsets
 - 1];

1453 if (!
work_mbc
->
invert
)

1455 int 
i
;

1456 for (
i
 = 0; i < 
work_mbc
->
nchars
; i++)

1458 
	`addtok_wc
 (
work_mbc
->
chars
[
i
]);

1459 if (
need_or
)

1460 
	`addtok
 (
OR
);

1461 
need_or
 = 
true
;

1463 
work_mbc
->
nchars
 = 0;

1467 if (
work_mbc
->
invert


1468 || (!
	`using_utf8
() && 
work_mbc
->
cset
 != -1)

1469 || 
work_mbc
->
nchars
 != 0

1470 || 
work_mbc
->
nch_classes
 != 0

1471 || 
work_mbc
->
nranges
 != 0

1472 || 
work_mbc
->
nequivs
 != 0

1473 || 
work_mbc
->
ncoll_elems
 != 0)

1475 
	`addtok_mb
 (
MBCSET
, ((
dfa
->
nmbcsets
 - 1) << 2) + 3);

1476 if (
need_or
)

1477 
	`addtok
 (
OR
);

1483 if (
work_mbc
->
cset
 != -1)

1485 
	`assert
 (
	`using_utf8
 ());

1486 
	`addtok
 (
CSET
 + 
work_mbc
->
cset
);

1487 if (
need_or
)

1488 
	`addtok
 (
OR
);

1494 
	`addtok_mb
 (
t
, 3);

1496 
	}
}

1498 #if 
MBS_SUPPORT


1506 
	$addtok_wc
 (
wint_t
 
wc
)

1508 unsigned char 
buf
[
MB_LEN_MAX
];

1509 
mbstate_t
 
s
;

1510 int 
i
;

1511 
	`memset
 (&
s
, 0, sizeof s);

1512 
cur_mb_len
 = 
	`wcrtomb
 ((char *) 
buf
, 
wc
, &
s
);

1517 if (
cur_mb_len
 <= 0)

1518 
buf
[0] = 0;

1520 
	`addtok_mb
(
buf
[0], 
cur_mb_len
 == 1 ? 3 : 1);

1521 for (
i
 = 1; i < 
cur_mb_len
; i++)

1523 
	`addtok_mb
(
buf
[
i
], i == 
cur_mb_len
 - 1 ? 2 : 0);

1524 
	`addtok
(
CAT
);

1526 
	}
}

1528 static void 
	$addtok_wc
 (
wint_t
 
wc
) {
	}
}

1532 
	$add_utf8_anychar
 (void)

1534 #if 
MBS_SUPPORT


1535 static const 
charclass
 
utf8_classes
[5] = {

1542 const unsigned int 
n
 = sizeof (
utf8_classes
) / sizeof (utf8_classes[0]);

1543 unsigned int 
i
;

1546 if (
dfa
->
utf8_anychar_classes
[0] == 0)

1547 for (
i
 = 0; i < 
n
; i++)

1549 
charclass
 
c
;

1550 
	`copyset
 (
utf8_classes
[
i
], 
c
);

1551 if (
i
 == 1)

1553 if (!(
syntax_bits
 & 
RE_DOT_NEWLINE
))

1554 
	`clrbit
 (
eolbyte
, 
c
);

1555 if (
syntax_bits
 & 
RE_DOT_NOT_NULL
)

1556 
	`clrbit
 ('\0', 
c
);

1558 
dfa
->
utf8_anychar_classes
[
i
] = 
CSET
 + 
	`charclass_index
(
c
);

1571 for (
i
 = 1; i < 
n
; i++)

1572 
	`addtok
 (
dfa
->
utf8_anychar_classes
[
i
]);

1573 while (--
i
 > 1)

1575 
	`addtok
 (
dfa
->
utf8_anychar_classes
[0]);

1576 
	`addtok
 (
CAT
);

1577 
	`addtok
 (
OR
);

1580 
	}
}

1618 
	$atom
 (void)

1624 else if (
MBS_SUPPORT
 && 
tok
 == 
WCHAR
)

1626 
	`addtok_wc
 (
case_fold
 ? 
	`towlower
(
wctok
) : wctok);

1627 #ifndef 
GREP


1628 if (
case_fold
 && 
	`iswalpha
(
wctok
))

1630 
	`addtok_wc
 (
	`towupper
(
wctok
));

1631 
	`addtok
 (
OR
);

1635 
tok
 = 
	`lex
();

1637 else if (
MBS_SUPPORT
 && 
tok
 == 
ANYCHAR
 && 
	`using_utf8
())

1646 
	`add_utf8_anychar
();

1647 
tok
 = 
	`lex
();

1649 else if ((
tok
 >= 0 && tok < 
NOTCHAR
) || tok >= 
CSET
 || tok == 
BACKREF


1650 || 
tok
 == 
BEGLINE
 || tok == 
ENDLINE
 || tok == 
BEGWORD


1651 #if 
MBS_SUPPORT


1652 || 
tok
 == 
ANYCHAR
 || tok == 
MBCSET


1654 || 
tok
 == 
ENDWORD
 || tok == 
LIMWORD
 || tok == 
NOTLIMWORD
)

1656 
	`addtok
(
tok
);

1657 
tok
 = 
	`lex
();

1659 else if (
tok
 == 
LPAREN
)

1661 
tok
 = 
	`lex
();

1662 
	`regexp
();

1663 if (
tok
 != 
RPAREN
)

1664 
	`dfaerror
(
	`_
("unbalanced ("));

1665 
tok
 = 
	`lex
();

1668 
	`addtok
(
EMPTY
);

1669 
	}
}

1673 
	$nsubtoks
 (int 
tindex
)

1675 int 
ntoks1
;

1677 switch (
dfa
->
tokens
[
tindex
 - 1])

1681 case 
QMARK
:

1682 case 
STAR
:

1683 case 
PLUS
:

1684 return 1 + 
	`nsubtoks
(
tindex
 - 1);

1685 case 
CAT
:

1686 case 
OR
:

1687 
ntoks1
 = 
	`nsubtoks
(
tindex
 - 1);

1688 return 1 + 
ntoks1
 + 
	`nsubtoks
(
tindex
 - 1 - ntoks1);

1690 
	}
}

1694 
	$copytoks
 (int 
tindex
, int 
ntokens
)

1696 int 
i
;

1698 for (
i
 = 0; i < 
ntokens
; ++i)

1700 
	`addtok
(
dfa
->
tokens
[
tindex
 + 
i
]);

1702 if (
MB_CUR_MAX
 > 1 && 
dfa
->
tokens
[
tindex
 + 
i
] == 
MBCSET
)

1703 
dfa
->
multibyte_prop
[dfa->
tindex
 - 1] = dfa->multibyte_prop[tindex + 
i
];

1705 
	}
}

1708 
	$closure
 (void)

1710 int 
tindex
, 
ntokens
, 
i
;

1712 
	`atom
();

1713 while (
tok
 == 
QMARK
 || tok == 
STAR
 || tok == 
PLUS
 || tok == 
REPMN
)

1714 if (
tok
 == 
REPMN
 && (
minrep
 || 
maxrep
))

1716 
ntokens
 = 
	`nsubtoks
(
dfa
->
tindex
);

1717 
tindex
 = 
dfa
->tindex - 
ntokens
;

1718 if (
maxrep
 < 0)

1719 
	`addtok
(
PLUS
);

1720 if (
minrep
 == 0)

1721 
	`addtok
(
QMARK
);

1722 for (
i
 = 1; i < 
minrep
; ++i)

1724 
	`copytoks
(
tindex
, 
ntokens
);

1725 
	`addtok
(
CAT
);

1727 for (; 
i
 < 
maxrep
; ++i)

1729 
	`copytoks
(
tindex
, 
ntokens
);

1730 
	`addtok
(
QMARK
);

1731 
	`addtok
(
CAT
);

1733 
tok
 = 
	`lex
();

1735 else if (
tok
 == 
REPMN
)

1737 
dfa
->
tindex
 -= 
	`nsubtoks
(dfa->tindex);

1738 
tok
 = 
	`lex
();

1739 
	`closure
();

1743 
	`addtok
(
tok
);

1744 
tok
 = 
	`lex
();

1746 
	}
}

1749 
	$branch
 (void)

1751 
	`closure
();

1752 while (
tok
 != 
RPAREN
 && tok != 
OR
 && tok >= 0)

1754 
	`closure
();

1755 
	`addtok
(
CAT
);

1757 
	}
}

1760 
	$regexp
 (void)

1762 
	`branch
();

1763 while (
tok
 == 
OR
)

1765 
tok
 = 
	`lex
();

1766 
	`branch
();

1767 
	`addtok
(
OR
);

1769 
	}
}

1775 
	$dfaparse
 (char const *
s
, 
size_t
 
len
, struct 
dfa
 *
d
)

1777 
dfa
 = 
d
;

1778 
lexptr
 = 
s
;

1779 
lexleft
 = 
len
;

1780 
lasttok
 = 
END
;

1781 
laststart
 = 1;

1782 
parens
 = 0;

1783 #ifdef 
LC_COLLATE


1784 
hard_LC_COLLATE
 = 
	`hard_locale
 (
LC_COLLATE
);

1786 if (
MB_CUR_MAX
 > 1)

1788 
cur_mb_len
 = 0;

1789 
	`memset
(&
mbs
, 0, sizeof mbs);

1792 if (! 
syntax_bits_set
)

1793 
	`dfaerror
(
	`_
("no syntax specified"));

1795 
tok
 = 
	`lex
();

1796 
depth
 = 
d
->depth;

1798 
	`regexp
();

1800 if (
tok
 != 
END
)

1801 
	`dfaerror
(
	`_
("unbalanced )"));

1803 
	`addtok
(
END
 - 
d
->
nregexps
);

1804 
	`addtok
(
CAT
);

1806 if (
d
->
nregexps
)

1807 
	`addtok
(
OR
);

1809 ++
d
->
nregexps
;

1810 
	}
}

1816 
	$copy
 (
position_set
 const *
src
, position_set *
dst
)

1818 
	`memcpy
(
dst
->
elems
, 
src
->elems, sizeof(dst->elems[0]) * src->
nelem
);

1819 
dst
->
nelem
 = 
src
->nelem;

1820 
	}
}

1827 
	$insert
 (
position
 
p
, 
position_set
 *
s
)

1829 int 
count
 = 
s
->
nelem
;

1830 int 
lo
 = 0, 
hi
 = 
count
;

1831 while (
lo
 < 
hi
)

1833 int 
mid
 = ((unsigned) 
lo
 + (unsigned) 
hi
) >> 1;

1834 if (
s
->
elems
[
mid
].
index
 > 
p
.index)

1835 
lo
 = 
mid
 + 1;

1837 
hi
 = 
mid
;

1840 if (
lo
 < 
count
 && 
p
.
index
 == 
s
->
elems
[lo].index)

1841 
s
->
elems
[
lo
].
constraint
 |= 
p
.constraint;

1844 int 
i
;

1845 for (
i
 = 
count
; i > 
lo
; i--)

1846 
s
->
elems
[
i
] = s->elems[i - 1];

1847 
s
->
elems
[
lo
] = 
p
;

1848 ++
s
->
nelem
;

1850 
	}
}

1855 
	$merge
 (
position_set
 const *
s1
, position_set const *
s2
, position_set *
m
)

1857 int 
i
 = 0, 
j
 = 0;

1859 
m
->
nelem
 = 0;

1860 while (
i
 < 
s1
->
nelem
 && 
j
 < 
s2
->nelem)

1861 if (
s1
->
elems
[
i
].
index
 > 
s2
->elems[
j
].index)

1862 
m
->
elems
[m->
nelem
++] = 
s1
->elems[
i
++];

1863 else if (
s1
->
elems
[
i
].
index
 < 
s2
->elems[
j
].index)

1864 
m
->
elems
[m->
nelem
++] = 
s2
->elems[
j
++];

1867 
m
->
elems
[m->
nelem
] = 
s1
->elems[
i
++];

1868 
m
->
elems
[m->
nelem
++].
constraint
 |= 
s2
->elems[
j
++].constraint;

1870 while (
i
 < 
s1
->
nelem
)

1871 
m
->
elems
[m->
nelem
++] = 
s1
->elems[
i
++];

1872 while (
j
 < 
s2
->
nelem
)

1873 
m
->
elems
[m->
nelem
++] = 
s2
->elems[
j
++];

1874 
	}
}

1878 
	$delete
 (
position
 
p
, 
position_set
 *
s
)

1880 int 
i
;

1882 for (
i
 = 0; i < 
s
->
nelem
; ++i)

1883 if (
p
.
index
 == 
s
->
elems
[
i
].index)

1885 if (
i
 < 
s
->
nelem
)

1886 for (--
s
->
nelem
; 
i
 < s->nelem; ++i)

1887 
s
->
elems
[
i
] = s->elems[i + 1];

1888 
	}
}

1895 
	$state_index
 (struct 
dfa
 *
d
, 
position_set
 const *
s
, int 
newline
, int 
letter
)

1897 int 
hash
 = 0;

1898 int 
constraint
;

1899 int 
i
, 
j
;

1901 
newline
 = newline ? 1 : 0;

1902 
letter
 = letter ? 1 : 0;

1904 for (
i
 = 0; i < 
s
->
nelem
; ++i)

1905 
hash
 ^= 
s
->
elems
[
i
].
index
 + s->elems[i].
constraint
;

1908 for (
i
 = 0; i < 
d
->
sindex
; ++i)

1910 if (
hash
 != 
d
->
states
[
i
].hash || 
s
->
nelem
 != d->states[i].
elems
.nelem

1911 || 
newline
 != 
d
->
states
[
i
].newline || 
letter
 != d->states[i].letter)

1913 for (
j
 = 0; j < 
s
->
nelem
; ++j)

1914 if (
s
->
elems
[
j
].
constraint


1915 != 
d
->
states
[
i
].
elems
.elems[
j
].
constraint


1916 || 
s
->
elems
[
j
].
index
 != 
d
->
states
[
i
].elems.elems[j].index)

1918 if (
j
 == 
s
->
nelem
)

1919 return 
i
;

1923 
	`REALLOC_IF_NECESSARY
(
d
->
states
, d->
salloc
, d->
sindex
 + 1);

1924 
d
->
states
[
i
].
hash
 = hash;

1925 
	`MALLOC
(
d
->
states
[
i
].
elems
.elems, 
s
->
nelem
);

1926 
	`copy
(
s
, &
d
->
states
[
i
].
elems
);

1927 
d
->
states
[
i
].
newline
 = newline;

1928 
d
->
states
[
i
].
letter
 = letter;

1929 
d
->
states
[
i
].
backref
 = 0;

1930 
d
->
states
[
i
].
constraint
 = 0;

1931 
d
->
states
[
i
].
first_end
 = 0;

1932 if (
MBS_SUPPORT
)

1934 
d
->
states
[
i
].
mbps
.
nelem
 = 0;

1935 
d
->
states
[
i
].
mbps
.
elems
 = 
NULL
;

1937 for (
j
 = 0; j < 
s
->
nelem
; ++j)

1938 if (
d
->
tokens
[
s
->
elems
[
j
].
index
] < 0)

1940 
constraint
 = 
s
->
elems
[
j
].constraint;

1941 if (
	`SUCCEEDS_IN_CONTEXT
(
constraint
, 
newline
, 0, 
letter
, 0)

1942 || 
	`SUCCEEDS_IN_CONTEXT
(
constraint
, 
newline
, 0, 
letter
, 1)

1943 || 
	`SUCCEEDS_IN_CONTEXT
(
constraint
, 
newline
, 1, 
letter
, 0)

1944 || 
	`SUCCEEDS_IN_CONTEXT
(
constraint
, 
newline
, 1, 
letter
, 1))

1945 
d
->
states
[
i
].
constraint
 |= constraint;

1946 if (! 
d
->
states
[
i
].
first_end
)

1947 
d
->
states
[
i
].
first_end
 = d->
tokens
[
s
->
elems
[
j
].
index
];

1949 else if (
d
->
tokens
[
s
->
elems
[
j
].
index
] == 
BACKREF
)

1951 
d
->
states
[
i
].
constraint
 = 
NO_CONSTRAINT
;

1952 
d
->
states
[
i
].
backref
 = 1;

1955 ++
d
->
sindex
;

1957 return 
i
;

1958 
	}
}

1966 
	$epsclosure
 (
position_set
 *
s
, struct 
dfa
 const *
d
)

1968 int 
i
, 
j
;

1969 char *
visited
;

1970 
position
 
p
, 
old
;

1972 
	`CALLOC
(
visited
, 
d
->
tindex
);

1974 for (
i
 = 0; i < 
s
->
nelem
; ++i)

1975 if (
d
->
tokens
[
s
->
elems
[
i
].
index
] >= 
NOTCHAR


1976 && 
d
->
tokens
[
s
->
elems
[
i
].
index
] != 
BACKREF


1977 #if 
MBS_SUPPORT


1978 && 
d
->
tokens
[
s
->
elems
[
i
].
index
] != 
ANYCHAR


1979 && 
d
->
tokens
[
s
->
elems
[
i
].
index
] != 
MBCSET


1981 && 
d
->
tokens
[
s
->
elems
[
i
].
index
] < 
CSET
)

1983 
old
 = 
s
->
elems
[
i
];

1984 
p
.
constraint
 = 
old
.constraint;

1985 
	`delete
(
s
->
elems
[
i
], s);

1986 if (
visited
[
old
.
index
])

1988 --
i
;

1991 
visited
[
old
.
index
] = 1;

1992 switch (
d
->
tokens
[
old
.
index
])

1994 case 
BEGLINE
:

1995 
p
.
constraint
 &= 
BEGLINE_CONSTRAINT
;

1997 case 
ENDLINE
:

1998 
p
.
constraint
 &= 
ENDLINE_CONSTRAINT
;

2000 case 
BEGWORD
:

2001 
p
.
constraint
 &= 
BEGWORD_CONSTRAINT
;

2003 case 
ENDWORD
:

2004 
p
.
constraint
 &= 
ENDWORD_CONSTRAINT
;

2006 case 
LIMWORD
:

2007 
p
.
constraint
 &= 
LIMWORD_CONSTRAINT
;

2009 case 
NOTLIMWORD
:

2010 
p
.
constraint
 &= 
NOTLIMWORD_CONSTRAINT
;

2015 for (
j
 = 0; j < 
d
->
follows
[
old
.
index
].
nelem
; ++j)

2017 
p
.
index
 = 
d
->
follows
[
old
.index].
elems
[
j
].index;

2018 
	`insert
(
p
, 
s
);

2021 
i
 = -1;

2024 
	`free
(
visited
);

2025 
	}
}

2080 
	$dfaanalyze
 (struct 
dfa
 *
d
, int 
searchflag
)

2082 int *
nullable
;

2083 int *
nfirstpos
;

2084 
position
 *
firstpos
;

2085 int *
nlastpos
;

2086 
position
 *
lastpos
;

2087 int *
nalloc
;

2088 
position_set
 
tmp
;

2089 
position_set
 
merged
;

2090 int 
wants_newline
;

2091 int *
o_nullable
;

2092 int *
o_nfirst
, *
o_nlast
;

2093 
position
 *
o_firstpos
, *
o_lastpos
;

2094 int 
i
, 
j
;

2095 
position
 *
pos
;

2097 #ifdef 
DEBUG


2098 
	`fprintf
(
stderr
, "dfaanalyze:\n");

2099 for (
i
 = 0; i < 
d
->
tindex
; ++i)

2101 
	`fprintf
(
stderr
, " %d:", 
i
);

2102 
	`prtok
(
d
->
tokens
[
i
]);

2104 
	`putc
('\n', 
stderr
);

2107 
d
->
searchflag
 = searchflag;

2109 
	`MALLOC
(
nullable
, 
d
->
depth
);

2110 
o_nullable
 = 
nullable
;

2111 
	`MALLOC
(
nfirstpos
, 
d
->
depth
);

2112 
o_nfirst
 = 
nfirstpos
;

2113 
	`MALLOC
(
firstpos
, 
d
->
nleaves
);

2114 
o_firstpos
 = 
firstpos
, firstpos += 
d
->
nleaves
;

2115 
	`MALLOC
(
nlastpos
, 
d
->
depth
);

2116 
o_nlast
 = 
nlastpos
;

2117 
	`MALLOC
(
lastpos
, 
d
->
nleaves
);

2118 
o_lastpos
 = 
lastpos
, lastpos += 
d
->
nleaves
;

2119 
	`CALLOC
(
nalloc
, 
d
->
tindex
);

2120 
	`MALLOC
(
merged
.
elems
, 
d
->
nleaves
);

2122 
	`CALLOC
(
d
->
follows
, d->
tindex
);

2124 for (
i
 = 0; i < 
d
->
tindex
; ++i)

2125 #ifdef 
DEBUG


2128 switch (
d
->
tokens
[
i
])

2130 case 
EMPTY
:

2132 *
nullable
++ = 1;

2135 *
nfirstpos
++ = *
nlastpos
++ = 0;

2138 case 
STAR
:

2139 case 
PLUS
:

2142 
tmp
.
nelem
 = 
nfirstpos
[-1];

2143 
tmp
.
elems
 = 
firstpos
;

2144 
pos
 = 
lastpos
;

2145 for (
j
 = 0; j < 
nlastpos
[-1]; ++j)

2147 
	`merge
(&
tmp
, &
d
->
follows
[
pos
[
j
].
index
], &
merged
);

2148 
	`REALLOC_IF_NECESSARY
(
d
->
follows
[
pos
[
j
].
index
].
elems
,

2149 
nalloc
[
pos
[
j
].
index
], 
merged
.
nelem
);

2150 
	`copy
(&
merged
, &
d
->
follows
[
pos
[
j
].
index
]);

2153 case 
QMARK
:

2155 if (
d
->
tokens
[
i
] != 
PLUS
)

2156 
nullable
[-1] = 1;

2159 case 
CAT
:

2162 
tmp
.
nelem
 = 
nfirstpos
[-1];

2163 
tmp
.
elems
 = 
firstpos
;

2164 
pos
 = 
lastpos
 + 
nlastpos
[-1];

2165 for (
j
 = 0; j < 
nlastpos
[-2]; ++j)

2167 
	`merge
(&
tmp
, &
d
->
follows
[
pos
[
j
].
index
], &
merged
);

2168 
	`REALLOC_IF_NECESSARY
(
d
->
follows
[
pos
[
j
].
index
].
elems
,

2169 
nalloc
[
pos
[
j
].
index
], 
merged
.
nelem
);

2170 
	`copy
(&
merged
, &
d
->
follows
[
pos
[
j
].
index
]);

2175 if (
nullable
[-2])

2176 
nfirstpos
[-2] += nfirstpos[-1];

2178 
firstpos
 += 
nfirstpos
[-1];

2179 --
nfirstpos
;

2183 if (
nullable
[-1])

2184 
nlastpos
[-2] += nlastpos[-1];

2187 
pos
 = 
lastpos
 + 
nlastpos
[-2];

2188 for (
j
 = 
nlastpos
[-1] - 1; j >= 0; --j)

2189 
pos
[
j
] = 
lastpos
[j];

2190 
lastpos
 += 
nlastpos
[-2];

2191 
nlastpos
[-2] = nlastpos[-1];

2193 --
nlastpos
;

2196 
nullable
[-2] = nullable[-1] && nullable[-2];

2197 --
nullable
;

2200 case 
OR
:

2202 
nfirstpos
[-2] += nfirstpos[-1];

2203 --
nfirstpos
;

2206 
nlastpos
[-2] += nlastpos[-1];

2207 --
nlastpos
;

2210 
nullable
[-2] = nullable[-1] || nullable[-2];

2211 --
nullable
;

2220 *
nullable
++ = 
d
->
tokens
[
i
] == 
BACKREF
;

2223 *
nfirstpos
++ = *
nlastpos
++ = 1;

2224 --
firstpos
, --
lastpos
;

2225 
firstpos
->
index
 = 
lastpos
->index = 
i
;

2226 
firstpos
->
constraint
 = 
lastpos
->constraint = 
NO_CONSTRAINT
;

2229 
nalloc
[
i
] = 1;

2230 
	`MALLOC
(
d
->
follows
[
i
].
elems
, 
nalloc
[i]);

2233 #ifdef 
DEBUG


2235 
	`fprintf
(
stderr
, "node %d:", 
i
);

2236 
	`prtok
(
d
->
tokens
[
i
]);

2237 
	`putc
('\n', 
stderr
);

2238 
	`fprintf
(
stderr
, 
nullable
[-1] ? " nullable: yes\n" : " nullable: no\n");

2239 
	`fprintf
(
stderr
, " firstpos:");

2240 for (
j
 = 
nfirstpos
[-1] - 1; j >= 0; --j)

2242 
	`fprintf
(
stderr
, " %d:", 
firstpos
[
j
].
index
);

2243 
	`prtok
(
d
->
tokens
[
firstpos
[
j
].
index
]);

2245 
	`fprintf
(
stderr
, "\n lastpos:");

2246 for (
j
 = 
nlastpos
[-1] - 1; j >= 0; --j)

2248 
	`fprintf
(
stderr
, " %d:", 
lastpos
[
j
].
index
);

2249 
	`prtok
(
d
->
tokens
[
lastpos
[
j
].
index
]);

2251 
	`putc
('\n', 
stderr
);

2257 for (
i
 = 0; i < 
d
->
tindex
; ++i)

2258 if (
d
->
tokens
[
i
] < 
NOTCHAR
 || d->tokens[i] == 
BACKREF


2259 #if 
MBS_SUPPORT


2260 || 
d
->
tokens
[
i
] == 
ANYCHAR


2261 || 
d
->
tokens
[
i
] == 
MBCSET


2263 || 
d
->
tokens
[
i
] >= 
CSET
)

2265 #ifdef 
DEBUG


2266 
	`fprintf
(
stderr
, "follows(%d:", 
i
);

2267 
	`prtok
(
d
->
tokens
[
i
]);

2268 
	`fprintf
(
stderr
, "):");

2269 for (
j
 = 
d
->
follows
[
i
].
nelem
 - 1; j >= 0; --j)

2271 
	`fprintf
(
stderr
, " %d:", 
d
->
follows
[
i
].
elems
[
j
].
index
);

2272 
	`prtok
(
d
->
tokens
[d->
follows
[
i
].
elems
[
j
].
index
]);

2274 
	`putc
('\n', 
stderr
);

2276 
	`copy
(&
d
->
follows
[
i
], &
merged
);

2277 
	`epsclosure
(&
merged
, 
d
);

2278 if (
d
->
follows
[
i
].
nelem
 < 
merged
.nelem)

2279 
	`REALLOC
(
d
->
follows
[
i
].
elems
, 
merged
.
nelem
);

2280 
	`copy
(&
merged
, &
d
->
follows
[
i
]);

2285 
merged
.
nelem
 = 0;

2286 for (
i
 = 0; i < 
nfirstpos
[-1]; ++i)

2287 
	`insert
(
firstpos
[
i
], &
merged
);

2288 
	`epsclosure
(&
merged
, 
d
);

2291 
wants_newline
 = 0;

2292 for (
i
 = 0; i < 
merged
.
nelem
; ++i)

2293 if (
	`PREV_NEWLINE_DEPENDENT
(
merged
.
elems
[
i
].
constraint
))

2294 
wants_newline
 = 1;

2297 
d
->
salloc
 = 1;

2298 
d
->
sindex
 = 0;

2299 
	`MALLOC
(
d
->
states
, d->
salloc
);

2300 
	`state_index
(
d
, &
merged
, 
wants_newline
, 0);

2302 
	`free
(
o_nullable
);

2303 
	`free
(
o_nfirst
);

2304 
	`free
(
o_firstpos
);

2305 
	`free
(
o_nlast
);

2306 
	`free
(
o_lastpos
);

2307 
	`free
(
nalloc
);

2308 
	`free
(
merged
.
elems
);

2309 
	}
}

2342 
	$dfastate
 (int 
s
, struct 
dfa
 *
d
, int 
trans
[])

2344 
position_set
 *
grps
;

2345 
charclass
 *
labels
;

2346 int 
ngrps
 = 0;

2347 
position
 
pos
;

2348 
charclass
 
matches
;

2349 int 
matchesf
;

2350 
charclass
 
intersect
;

2351 int 
intersectf
;

2352 
charclass
 
leftovers
;

2353 int 
leftoversf
;

2354 static 
charclass
 
letters
;

2355 static 
charclass
 
newline
;

2356 
position_set
 
follows
;

2357 
position_set
 
tmp
;

2358 int 
state
;

2359 int 
wants_newline
;

2360 int 
state_newline
;

2361 int 
wants_letter
;

2362 int 
state_letter
;

2363 static int 
initialized
;

2364 int 
next_isnt_1st_byte
 = 0;

2365 int 
i
, 
j
, 
k
;

2367 
grps
 = 
	`xnmalloc
 (
NOTCHAR
, sizeof *grps);

2368 
labels
 = 
	`xnmalloc
 (
NOTCHAR
, sizeof *labels);

2371 if (! 
initialized
)

2373 
initialized
 = 1;

2374 for (
i
 = 0; i < 
NOTCHAR
; ++i)

2375 if (
	`IS_WORD_CONSTITUENT
(
i
))

2376 
	`setbit
(
i
, 
letters
);

2377 
	`setbit
(
eolbyte
, 
newline
);

2380 
	`zeroset
(
matches
);

2382 for (
i
 = 0; i < 
d
->
states
[
s
].
elems
.
nelem
; ++i)

2384 
pos
 = 
d
->
states
[
s
].
elems
.elems[
i
];

2385 if (
d
->
tokens
[
pos
.
index
] >= 0 && d->tokens[pos.index] < 
NOTCHAR
)

2386 
	`setbit
(
d
->
tokens
[
pos
.
index
], 
matches
);

2387 else if (
d
->
tokens
[
pos
.
index
] >= 
CSET
)

2388 
	`copyset
(
d
->
charclasses
[d->
tokens
[
pos
.
index
] - 
CSET
], 
matches
);

2389 else if (
MBS_SUPPORT


2390 && (
d
->
tokens
[
pos
.
index
] == 
ANYCHAR


2391 || 
d
->
tokens
[
pos
.
index
] == 
MBCSET
))

2397 if (
d
->
states
[
s
].
mbps
.
nelem
 == 0)

2399 
	`MALLOC
(
d
->
states
[
s
].
mbps
.
elems
, d->states[s].elems.
nelem
);

2401 
	`insert
(
pos
, &(
d
->
states
[
s
].
mbps
));

2409 if (
pos
.
constraint
 != 0xFF)

2411 if (! 
	`MATCHES_NEWLINE_CONTEXT
(
pos
.
constraint
,

2412 
d
->
states
[
s
].
newline
, 1))

2413 
	`clrbit
(
eolbyte
, 
matches
);

2414 if (! 
	`MATCHES_NEWLINE_CONTEXT
(
pos
.
constraint
,

2415 
d
->
states
[
s
].
newline
, 0))

2416 for (
j
 = 0; j < 
CHARCLASS_INTS
; ++j)

2417 
matches
[
j
] &= 
newline
[j];

2418 if (! 
	`MATCHES_LETTER_CONTEXT
(
pos
.
constraint
,

2419 
d
->
states
[
s
].
letter
, 1))

2420 for (
j
 = 0; j < 
CHARCLASS_INTS
; ++j)

2421 
matches
[
j
] &= ~
letters
[j];

2422 if (! 
	`MATCHES_LETTER_CONTEXT
(
pos
.
constraint
,

2423 
d
->
states
[
s
].
letter
, 0))

2424 for (
j
 = 0; j < 
CHARCLASS_INTS
; ++j)

2425 
matches
[
j
] &= 
letters
[j];

2428 for (
j
 = 0; j < 
CHARCLASS_INTS
 && !
matches
[j]; ++j)

2430 if (
j
 == 
CHARCLASS_INTS
)

2434 for (
j
 = 0; j < 
ngrps
; ++j)

2439 if (
d
->
tokens
[
pos
.
index
] >= 0 && d->tokens[pos.index] < 
NOTCHAR


2440 && !
	`tstbit
(
d
->
tokens
[
pos
.
index
], 
labels
[
j
]))

2445 
intersectf
 = 0;

2446 for (
k
 = 0; k < 
CHARCLASS_INTS
; ++k)

2447 (
intersect
[
k
] = 
matches
[k] & 
labels
[
j
][k]) ? (
intersectf
 = 1) : 0;

2448 if (! 
intersectf
)

2452 
leftoversf
 = 
matchesf
 = 0;

2453 for (
k
 = 0; k < 
CHARCLASS_INTS
; ++k)

2456 int 
match
 = 
matches
[
k
], 
label
 = 
labels
[
j
][k];

2458 (
leftovers
[
k
] = ~
match
 & 
label
) ? (
leftoversf
 = 1) : 0;

2459 (
matches
[
k
] = 
match
 & ~
label
) ? (
matchesf
 = 1) : 0;

2463 if (
leftoversf
)

2465 
	`copyset
(
leftovers
, 
labels
[
ngrps
]);

2466 
	`copyset
(
intersect
, 
labels
[
j
]);

2467 
	`MALLOC
(
grps
[
ngrps
].
elems
, 
d
->
nleaves
);

2468 
	`copy
(&
grps
[
j
], &grps[
ngrps
]);

2469 ++
ngrps
;

2474 
grps
[
j
].
elems
[grps[j].
nelem
++] = 
pos
;

2478 if (! 
matchesf
)

2484 if (
j
 == 
ngrps
)

2486 
	`copyset
(
matches
, 
labels
[
ngrps
]);

2487 
	`zeroset
(
matches
);

2488 
	`MALLOC
(
grps
[
ngrps
].
elems
, 
d
->
nleaves
);

2489 
grps
[
ngrps
].
nelem
 = 1;

2490 
grps
[
ngrps
].
elems
[0] = 
pos
;

2491 ++
ngrps
;

2495 
	`MALLOC
(
follows
.
elems
, 
d
->
nleaves
);

2496 
	`MALLOC
(
tmp
.
elems
, 
d
->
nleaves
);

2501 if (
d
->
searchflag
)

2503 
wants_newline
 = 0;

2504 
wants_letter
 = 0;

2505 for (
i
 = 0; i < 
d
->
states
[0].
elems
.
nelem
; ++i)

2507 if (
	`PREV_NEWLINE_DEPENDENT
(
d
->
states
[0].
elems
.elems[
i
].
constraint
))

2508 
wants_newline
 = 1;

2509 if (
	`PREV_LETTER_DEPENDENT
(
d
->
states
[0].
elems
.elems[
i
].
constraint
))

2510 
wants_letter
 = 1;

2512 
	`copy
(&
d
->
states
[0].
elems
, &
follows
);

2513 
state
 = 
	`state_index
(
d
, &
follows
, 0, 0);

2514 if (
wants_newline
)

2515 
state_newline
 = 
	`state_index
(
d
, &
follows
, 1, 0);

2517 
state_newline
 = 
state
;

2518 if (
wants_letter
)

2519 
state_letter
 = 
	`state_index
(
d
, &
follows
, 0, 1);

2521 
state_letter
 = 
state
;

2522 for (
i
 = 0; i < 
NOTCHAR
; ++i)

2523 
trans
[
i
] = (
	`IS_WORD_CONSTITUENT
(i)) ? 
state_letter
 : 
state
;

2524 
trans
[
eolbyte
] = 
state_newline
;

2527 for (
i
 = 0; i < 
NOTCHAR
; ++i)

2528 
trans
[
i
] = -1;

2530 for (
i
 = 0; i < 
ngrps
; ++i)

2532 
follows
.
nelem
 = 0;

2536 for (
j
 = 0; j < 
grps
[
i
].
nelem
; ++j)

2537 for (
k
 = 0; k < 
d
->
follows
[
grps
[
i
].
elems
[
j
].
index
].
nelem
; ++k)

2538 
	`insert
(
d
->
follows
[
grps
[
i
].
elems
[
j
].
index
].elems[
k
], &follows);

2540 if (
d
->
mb_cur_max
 > 1)

2560 
next_isnt_1st_byte
 = 0;

2561 for (
j
 = 0; j < 
follows
.
nelem
; ++j)

2563 if (!(
d
->
multibyte_prop
[
follows
.
elems
[
j
].
index
] & 1))

2565 
next_isnt_1st_byte
 = 1;

2573 if (
d
->
searchflag


2574 && (! 
MBS_SUPPORT


2575 || (
d
->
mb_cur_max
 == 1 || !
next_isnt_1st_byte
)))

2576 for (
j
 = 0; j < 
d
->
states
[0].
elems
.
nelem
; ++j)

2577 
	`insert
(
d
->
states
[0].
elems
.elems[
j
], &
follows
);

2580 
wants_newline
 = 0;

2581 if (
	`tstbit
(
eolbyte
, 
labels
[
i
]))

2582 for (
j
 = 0; j < 
follows
.
nelem
; ++j)

2583 if (
	`PREV_NEWLINE_DEPENDENT
(
follows
.
elems
[
j
].
constraint
))

2584 
wants_newline
 = 1;

2586 
wants_letter
 = 0;

2587 for (
j
 = 0; j < 
CHARCLASS_INTS
; ++j)

2588 if (
labels
[
i
][
j
] & 
letters
[j])

2590 if (
j
 < 
CHARCLASS_INTS
)

2591 for (
j
 = 0; j < 
follows
.
nelem
; ++j)

2592 if (
	`PREV_LETTER_DEPENDENT
(
follows
.
elems
[
j
].
constraint
))

2593 
wants_letter
 = 1;

2596 
state
 = 
	`state_index
(
d
, &
follows
, 0, 0);

2597 if (
wants_newline
)

2598 
state_newline
 = 
	`state_index
(
d
, &
follows
, 1, 0);

2600 
state_newline
 = 
state
;

2601 if (
wants_letter
)

2602 
state_letter
 = 
	`state_index
(
d
, &
follows
, 0, 1);

2604 
state_letter
 = 
state
;

2607 for (
j
 = 0; j < 
CHARCLASS_INTS
; ++j)

2608 for (
k
 = 0; k < 
INTBITS
; ++k)

2609 if (
labels
[
i
][
j
] & 1 << 
k
)

2611 int 
c
 = 
j
 * 
INTBITS
 + 
k
;

2613 if (
c
 == 
eolbyte
)

2614 
trans
[
c
] = 
state_newline
;

2615 else if (
	`IS_WORD_CONSTITUENT
(
c
))

2616 
trans
[
c
] = 
state_letter
;

2617 else if (
c
 < 
NOTCHAR
)

2618 
trans
[
c
] = 
state
;

2622 for (
i
 = 0; i < 
ngrps
; ++i)

2623 
	`free
(
grps
[
i
].
elems
);

2624 
	`free
(
follows
.
elems
);

2625 
	`free
(
tmp
.
elems
);

2626 
	`free
(
grps
);

2627 
	`free
(
labels
);

2628 
	}
}

2638 
	$build_state
 (int 
s
, struct 
dfa
 *
d
)

2640 int *
trans
;

2641 int 
i
;

2647 if (
d
->
trcount
 >= 1024)

2649 for (
i
 = 0; i < 
d
->
tralloc
; ++i)

2651 
	`free
(
d
->
trans
[
i
]);

2652 
	`free
(
d
->
fails
[
i
]);

2653 
d
->
trans
[
i
] = d->
fails
[i] = 
NULL
;

2655 
d
->
trcount
 = 0;

2658 ++
d
->
trcount
;

2661 
d
->
success
[
s
] = 0;

2662 if (
	`ACCEPTS_IN_CONTEXT
(
d
->
states
[
s
].
newline
, 1, d->states[s].
letter
, 0,

2663 
s
, *
d
))

2664 
d
->
success
[
s
] |= 4;

2665 if (
	`ACCEPTS_IN_CONTEXT
(
d
->
states
[
s
].
newline
, 0, d->states[s].
letter
, 1,

2666 
s
, *
d
))

2667 
d
->
success
[
s
] |= 2;

2668 if (
	`ACCEPTS_IN_CONTEXT
(
d
->
states
[
s
].
newline
, 0, d->states[s].
letter
, 0,

2669 
s
, *
d
))

2670 
d
->
success
[
s
] |= 1;

2672 
	`MALLOC
(
trans
, 
NOTCHAR
);

2673 
	`dfastate
(
s
, 
d
, 
trans
);

2678 for (
i
 = 0; i < 
NOTCHAR
; ++i)

2679 if (
trans
[
i
] >= 
d
->
tralloc
)

2681 int 
oldalloc
 = 
d
->
tralloc
;

2683 while (
trans
[
i
] >= 
d
->
tralloc
)

2684 
d
->
tralloc
 *= 2;

2685 
	`REALLOC
(
d
->
realtrans
, d->
tralloc
 + 1);

2686 
d
->
trans
 = d->
realtrans
 + 1;

2687 
	`REALLOC
(
d
->
fails
, d->
tralloc
);

2688 
	`REALLOC
(
d
->
success
, d->
tralloc
);

2689 
	`REALLOC
(
d
->
newlines
, d->
tralloc
);

2690 while (
oldalloc
 < 
d
->
tralloc
)

2692 
d
->
trans
[
oldalloc
] = 
NULL
;

2693 
d
->
fails
[
oldalloc
++] = 
NULL
;

2699 
d
->
newlines
[
s
] = 
trans
[
eolbyte
];

2700 
trans
[
eolbyte
] = -1;

2702 if (
	`ACCEPTING
(
s
, *
d
))

2703 
d
->
fails
[
s
] = 
trans
;

2705 
d
->
trans
[
s
] = trans;

2706 
	}
}

2709 
	$build_state_zero
 (struct 
dfa
 *
d
)

2711 
d
->
tralloc
 = 1;

2712 
d
->
trcount
 = 0;

2713 
	`CALLOC
(
d
->
realtrans
, d->
tralloc
 + 1);

2714 
d
->
trans
 = d->
realtrans
 + 1;

2715 
	`CALLOC
(
d
->
fails
, d->
tralloc
);

2716 
	`MALLOC
(
d
->
success
, d->
tralloc
);

2717 
	`MALLOC
(
d
->
newlines
, d->
tralloc
);

2718 
	`build_state
(0, 
d
);

2719 
	}
}

2730 #define 
	#SKIP_REMAINS_MB_IF_INITIAL_STATE
(
s
, 
p
) \

2731 if (
s
 == 0) \

2733 while (
inputwcs
[
p
 - 
buf_begin
] == 0 \

2734 && 
mblen_buf
[
p
 - 
buf_begin
] > 0 \

2735 && (unsigned char const *) 
p
 < 
buf_end
) \

2736 ++
p
; \

2737 if ((char *) 
p
 >= 
end
) \

2739 
	`free
(
mblen_buf
); \

2740 
	`free
(
inputwcs
); \

2741 *
end
 = 
saved_end
; \

2742 return 
NULL
; \

2744 }

	)

2747 
	$realloc_trans_if_necessary
(struct 
dfa
 *
d
, int 
new_state
)

2751 if (
new_state
 >= 
d
->
tralloc
)

2753 int 
oldalloc
 = 
d
->
tralloc
;

2755 while (
new_state
 >= 
d
->
tralloc
)

2756 
d
->
tralloc
 *= 2;

2757 
	`REALLOC
(
d
->
realtrans
, d->
tralloc
 + 1);

2758 
d
->
trans
 = d->
realtrans
 + 1;

2759 
	`REALLOC
(
d
->
fails
, d->
tralloc
);

2760 
	`REALLOC
(
d
->
success
, d->
tralloc
);

2761 
	`REALLOC
(
d
->
newlines
, d->
tralloc
);

2762 while (
oldalloc
 < 
d
->
tralloc
)

2764 
d
->
trans
[
oldalloc
] = 
NULL
;

2765 
d
->
fails
[
oldalloc
++] = 
NULL
;

2768 
	}
}

2774 
	mTRANSIT_STATE_IN_PROGRESS
,

2775 
	mTRANSIT_STATE_DONE
,

2776 
	mTRANSIT_STATE_END_BUFFER


2777 } 
	tstatus_transit_state
;

2783 static 
status_transit_state


2784 
	$transit_state_singlebyte
 (struct 
dfa
 *
d
, int 
s
, unsigned char const *
p
,

2785 int *
next_state
)

2787 int *
t
;

2788 int 
works
 = 
s
;

2790 
status_transit_state
 
rval
 = 
TRANSIT_STATE_IN_PROGRESS
;

2792 while (
rval
 == 
TRANSIT_STATE_IN_PROGRESS
)

2794 if ((
t
 = 
d
->
trans
[
works
]) != 
NULL
)

2796 
works
 = 
t
[*
p
];

2797 
rval
 = 
TRANSIT_STATE_DONE
;

2798 if (
works
 < 0)

2799 
works
 = 0;

2801 else if (
works
 < 0)

2803 if (
p
 == 
buf_end
)

2806 
	`abort
 ();

2808 
works
 = 0;

2810 else if (
d
->
fails
[
works
])

2812 
works
 = 
d
->
fails
[works][*
p
];

2813 
rval
 = 
TRANSIT_STATE_DONE
;

2817 
	`build_state
(
works
, 
d
);

2820 *
next_state
 = 
works
;

2821 return 
rval
;

2822 
	}
}

2828 
	$match_anychar
 (struct 
dfa
 *
d
, int 
s
, 
position
 
pos
, int 
idx
)

2830 int 
newline
 = 0;

2831 int 
letter
 = 0;

2832 
wchar_t
 
wc
;

2833 int 
mbclen
;

2835 
wc
 = 
inputwcs
[
idx
];

2836 
mbclen
 = (
mblen_buf
[
idx
] == 0)? 1 : mblen_buf[idx];

2839 if (
wc
 == (
wchar_t
)
eolbyte
)

2841 if (!(
syntax_bits
 & 
RE_DOT_NEWLINE
))

2843 
newline
 = 1;

2845 else if (
wc
 == (
wchar_t
)'\0')

2847 if (
syntax_bits
 & 
RE_DOT_NOT_NULL
)

2849 
newline
 = 1;

2852 if (
	`iswalnum
(
wc
) || wc == 
L
'_')

2853 
letter
 = 1;

2855 if (!
	`SUCCEEDS_IN_CONTEXT
(
pos
.
constraint
, 
d
->
states
[
s
].
newline
,

2856 
newline
, 
d
->
states
[
s
].
letter
, letter))

2859 return 
mbclen
;

2860 
	}
}

2867 
	$match_mb_charset
 (struct 
dfa
 *
d
, int 
s
, 
position
 
pos
, int 
idx
)

2869 int 
i
;

2870 int 
match
;

2871 int 
match_len
;

2873 int 
op_len
;

2874 char 
buffer
[128];

2875 
wchar_t
 
wcbuf
[6];

2878 struct 
mb_char_classes
 *
work_mbc
;

2880 int 
newline
 = 0;

2881 int 
letter
 = 0;

2882 
wchar_t
 
wc
;

2884 
wc
 = 
inputwcs
[
idx
];

2887 if (
wc
 == (
wchar_t
)
eolbyte
)

2889 if (!(
syntax_bits
 & 
RE_DOT_NEWLINE
))

2891 
newline
 = 1;

2893 else if (
wc
 == (
wchar_t
)'\0')

2895 if (
syntax_bits
 & 
RE_DOT_NOT_NULL
)

2897 
newline
 = 1;

2899 if (
	`iswalnum
(
wc
) || wc == 
L
'_')

2900 
letter
 = 1;

2901 if (!
	`SUCCEEDS_IN_CONTEXT
(
pos
.
constraint
, 
d
->
states
[
s
].
newline
,

2902 
newline
, 
d
->
states
[
s
].
letter
, letter))

2906 
work_mbc
 = &(
d
->
mbcsets
[(d->
multibyte_prop
[
pos
.
index
]) >> 2]);

2907 
match
 = !
work_mbc
->
invert
;

2908 
match_len
 = (
mblen_buf
[
idx
] == 0)? 1 : mblen_buf[idx];

2911 if (
wc
 < 
NOTCHAR
 && 
work_mbc
->
cset
 != -1

2912 && 
	`tstbit
((unsigned char)
wc
, 
d
->
charclasses
[
work_mbc
->
cset
]))

2913 goto 
charset_matched
;

2916 for (
i
 = 0; i<
work_mbc
->
nch_classes
; i++)

2918 if (
	`iswctype
((
wint_t
)
wc
, 
work_mbc
->
ch_classes
[
i
]))

2919 goto 
charset_matched
;

2922 
	`strncpy
(
buffer
, (char const *) 
buf_begin
 + 
idx
, 
match_len
);

2923 
buffer
[
match_len
] = '\0';

2926 for (
i
 = 0; i<
work_mbc
->
nequivs
; i++)

2928 
op_len
 = 
	`strlen
(
work_mbc
->
equivs
[
i
]);

2929 
	`strncpy
(
buffer
, (char const *) 
buf_begin
 + 
idx
, 
op_len
);

2930 
buffer
[
op_len
] = '\0';

2931 if (
	`strcoll
(
work_mbc
->
equivs
[
i
], 
buffer
) == 0)

2933 
match_len
 = 
op_len
;

2934 goto 
charset_matched
;

2939 for (
i
 = 0; i<
work_mbc
->
ncoll_elems
; i++)

2941 
op_len
 = 
	`strlen
(
work_mbc
->
coll_elems
[
i
]);

2942 
	`strncpy
(
buffer
, (char const *) 
buf_begin
 + 
idx
, 
op_len
);

2943 
buffer
[
op_len
] = '\0';

2945 if (
	`strcoll
(
work_mbc
->
coll_elems
[
i
], 
buffer
) == 0)

2947 
match_len
 = 
op_len
;

2948 goto 
charset_matched
;

2952 
wcbuf
[0] = 
wc
;

2953 
wcbuf
[1] = wcbuf[3] = wcbuf[5] = '\0';

2956 for (
i
 = 0; i<
work_mbc
->
nranges
; i++)

2958 
wcbuf
[2] = 
work_mbc
->
range_sts
[
i
];

2959 
wcbuf
[4] = 
work_mbc
->
range_ends
[
i
];

2961 if (
	`wcscoll
(
wcbuf
, wcbuf+2) >= 0 &&

2962 
	`wcscoll
(
wcbuf
+4, wcbuf) >= 0)

2963 goto 
charset_matched
;

2967 for (
i
 = 0; i<
work_mbc
->
nchars
; i++)

2969 if (
wc
 == 
work_mbc
->
chars
[
i
])

2970 goto 
charset_matched
;

2973 
match
 = !match;

2975 
charset_matched
:

2976 return 
match
 ? 
match_len
 : 0;

2977 
	}
}

2987 
	$check_matching_with_multibyte_ops
 (struct 
dfa
 *
d
, int 
s
, int 
idx
)

2989 int 
i
;

2990 int* 
rarray
;

2992 
	`MALLOC
(
rarray
, 
d
->
states
[
s
].
mbps
.
nelem
);

2993 for (
i
 = 0; i < 
d
->
states
[
s
].
mbps
.
nelem
; ++i)

2995 
position
 
pos
 = 
d
->
states
[
s
].
mbps
.
elems
[
i
];

2996 switch(
d
->
tokens
[
pos
.
index
])

2998 case 
ANYCHAR
:

2999 
rarray
[
i
] = 
	`match_anychar
(
d
, 
s
, 
pos
, 
idx
);

3001 case 
MBCSET
:

3002 
rarray
[
i
] = 
	`match_mb_charset
(
d
, 
s
, 
pos
, 
idx
);

3008 return 
rarray
;

3009 
	}
}

3017 static 
status_transit_state


3018 
	$transit_state_consume_1char
 (struct 
dfa
 *
d
, int 
s
, unsigned char const **
pp
,

3019 int *
match_lens
, int *
mbclen
, 
position_set
 *
pps
)

3021 int 
i
, 
j
;

3022 int 
s1
, 
s2
;

3023 int* 
work_mbls
;

3024 
status_transit_state
 
rs
 = 
TRANSIT_STATE_DONE
;

3028 *
mbclen
 = (
mblen_buf
[*
pp
 - 
buf_begin
] == 0)? 1

3029 : 
mblen_buf
[*
pp
 - 
buf_begin
];

3033 
s1
 = 
s
;

3034 for (
i
 = 0; i < *
mbclen
; i++)

3036 
s2
 = 
s1
;

3037 
rs
 = 
	`transit_state_singlebyte
(
d
, 
s2
, (*
pp
)++, &
s1
);

3040 
	`copy
(&(
d
->
states
[
s1
].
elems
), 
pps
);

3043 if (
match_lens
 == 
NULL
 && 
d
->
states
[
s
].
mbps
.
nelem
 != 0)

3044 
work_mbls
 = 
	`check_matching_with_multibyte_ops
(
d
, 
s
, *
pp
 - 
buf_begin
);

3046 
work_mbls
 = 
match_lens
;

3050 for (
i
 = 0; i < 
d
->
states
[
s
].
mbps
.
nelem
 ; i++)

3052 if (
work_mbls
[
i
] == *
mbclen
)

3053 for (
j
 = 0; j < 
d
->
follows
[d->
states
[
s
].
mbps
.
elems
[
i
].
index
].
nelem
;

3054 
j
++)

3055 
	`insert
(
d
->
follows
[d->
states
[
s
].
mbps
.
elems
[
i
].
index
].elems[
j
],

3056 
pps
);

3059 if (
match_lens
 == 
NULL
 && 
work_mbls
 != NULL)

3060 
	`free
(
work_mbls
);

3061 return 
rs
;

3062 
	}
}

3068 
	$transit_state
 (struct 
dfa
 *
d
, int 
s
, unsigned char const **
pp
)

3070 int 
s1
;

3071 int 
mbclen
;

3072 int 
maxlen
 = 0;

3073 int 
i
, 
j
;

3074 int *
match_lens
 = 
NULL
;

3075 int 
nelem
 = 
d
->
states
[
s
].
mbps
.nelem;

3076 
position_set
 
follows
;

3077 unsigned char const *
p1
 = *
pp
;

3078 
wchar_t
 
wc
;

3080 if (
nelem
 > 0)

3085 
match_lens
 = 
	`check_matching_with_multibyte_ops
(
d
, 
s
, *
pp
 - 
buf_begin
);

3087 for (
i
 = 0; i < 
nelem
; i++)

3091 if (
match_lens
[
i
] > 
maxlen
)

3092 
maxlen
 = 
match_lens
[
i
];

3096 if (
nelem
 == 0 || 
maxlen
 == 0)

3100 
status_transit_state
 
rs
;

3101 
rs
 = 
	`transit_state_singlebyte
(
d
, 
s
, *
pp
, &
s1
);

3104 if (
rs
 == 
TRANSIT_STATE_DONE
)

3105 ++*
pp
;

3107 
	`free
(
match_lens
);

3108 return 
s1
;

3112 
follows
.
nelem
 = 0;

3113 
	`MALLOC
(
follows
.
elems
, 
d
->
nleaves
);

3119 
	`transit_state_consume_1char
(
d
, 
s
, 
pp
, 
match_lens
, &
mbclen
, &
follows
);

3121 
wc
 = 
inputwcs
[*
pp
 - 
mbclen
 - 
buf_begin
];

3122 
s1
 = 
	`state_index
(
d
, &
follows
, 
wc
 == 
L
'\n', 
	`iswalnum
(wc));

3123 
	`realloc_trans_if_necessary
(
d
, 
s1
);

3125 while (*
pp
 - 
p1
 < 
maxlen
)

3127 
follows
.
nelem
 = 0;

3128 
	`transit_state_consume_1char
(
d
, 
s1
, 
pp
, 
NULL
, &
mbclen
, &
follows
);

3130 for (
i
 = 0; i < 
nelem
 ; i++)

3132 if (
match_lens
[
i
] == *
pp
 - 
p1
)

3133 for (
j
 = 0;

3134 
j
 < 
d
->
follows
[d->
states
[
s1
].
mbps
.
elems
[
i
].
index
].
nelem
; j++)

3135 
	`insert
(
d
->
follows
[d->
states
[
s1
].
mbps
.
elems
[
i
].
index
].elems[
j
],

3136 &
follows
);

3139 
wc
 = 
inputwcs
[*
pp
 - 
mbclen
 - 
buf_begin
];

3140 
s1
 = 
	`state_index
(
d
, &
follows
, 
wc
 == 
L
'\n', 
	`iswalnum
(wc));

3141 
	`realloc_trans_if_necessary
(
d
, 
s1
);

3143 
	`free
(
match_lens
);

3144 
	`free
(
follows
.
elems
);

3145 return 
s1
;

3146 
	}
}

3152 
	$prepare_wc_buf
 (const char *
begin
, const char *
end
)

3154 #if 
MBS_SUPPORT


3155 unsigned char 
eol
 = 
eolbyte
;

3156 
size_t
 
remain_bytes
, 
i
;

3158 
buf_begin
 = (unsigned char *) 
begin
;

3160 
remain_bytes
 = 0;

3161 for (
i
 = 0; i < 
end
 - 
begin
 + 1; i++)

3163 if (
remain_bytes
 == 0)

3165 
remain_bytes


3166 = 
	`mbrtowc
(
inputwcs
 + 
i
, 
begin
 + i, 
end
 - begin - i + 1, &
mbs
);

3167 if (
remain_bytes
 < 1

3168 || 
remain_bytes
 == (
size_t
) -1

3169 || 
remain_bytes
 == (
size_t
) -2

3170 || (
remain_bytes
 == 1 && 
inputwcs
[
i
] == (
wchar_t
)
begin
[i]))

3172 
remain_bytes
 = 0;

3173 
inputwcs
[
i
] = (
wchar_t
)
begin
[i];

3174 
mblen_buf
[
i
] = 0;

3175 if (
begin
[
i
] == 
eol
)

3180 
mblen_buf
[
i
] = 
remain_bytes
;

3181 
remain_bytes
--;

3186 
mblen_buf
[
i
] = 
remain_bytes
;

3187 
inputwcs
[
i
] = 0;

3188 
remain_bytes
--;

3192 
buf_end
 = (unsigned char *) (
begin
 + 
i
);

3193 
mblen_buf
[
i
] = 0;

3194 
inputwcs
[
i
] = 0;

3196 
	}
}

3211 
	$dfaexec
 (struct 
dfa
 *
d
, char const *
begin
, char *
end
,

3212 int 
newline
, int *
count
, int *
backref
)

3214 int 
s
, 
s1
;

3215 unsigned char const *
p
;

3216 int **
trans
, *
t
;

3218 unsigned char 
eol
 = 
eolbyte
;

3219 unsigned char 
saved_end
;

3220 static int 
sbit
[
NOTCHAR
];

3221 static int 
sbit_init
;

3223 if (! 
sbit_init
)

3225 unsigned int 
i
;

3227 
sbit_init
 = 1;

3228 for (
i
 = 0; i < 
NOTCHAR
; ++i)

3229 
sbit
[
i
] = (
	`IS_WORD_CONSTITUENT
(i)) ? 2 : 1;

3230 
sbit
[
eol
] = 4;

3233 if (! 
d
->
tralloc
)

3234 
	`build_state_zero
(
d
);

3236 
s
 = 
s1
 = 0;

3237 
p
 = (unsigned char const *) 
begin
;

3238 
trans
 = 
d
->trans;

3239 
saved_end
 = *(unsigned char *) 
end
;

3240 *
end
 = 
eol
;

3242 if (
d
->
mb_cur_max
 > 1)

3244 
	`MALLOC
(
mblen_buf
, 
end
 - 
begin
 + 2);

3245 
	`MALLOC
(
inputwcs
, 
end
 - 
begin
 + 2);

3246 
	`memset
(&
mbs
, 0, sizeof(
mbstate_t
));

3247 
	`prepare_wc_buf
 ((const char *) 
p
, 
end
);

3252 if (
d
->
mb_cur_max
 > 1)

3253 while ((
t
 = 
trans
[
s
]))

3255 if (
p
 > 
buf_end
)

3257 
s1
 = 
s
;

3258 
	`SKIP_REMAINS_MB_IF_INITIAL_STATE
(
s
, 
p
);

3260 if (
d
->
states
[
s
].
mbps
.
nelem
 == 0)

3262 
s
 = 
t
[*
p
++];

3270 if (
backref
)

3272 *
backref
 = 1;

3273 
	`free
(
mblen_buf
);

3274 
	`free
(
inputwcs
);

3275 *
end
 = 
saved_end
;

3276 return (char *) 
p
;

3281 
s
 = 
	`transit_state
(
d
, s, &
p
);

3282 
trans
 = 
d
->trans;

3286 while ((
t
 = 
trans
[
s
]) != 0)

3288 
s1
 = 
t
[*
p
++];

3289 if ((
t
 = 
trans
[
s1
]) == 0)

3291 int 
tmp
 = 
s
; s = 
s1
; s1 = tmp;

3294 
s
 = 
t
[*
p
++];

3298 if (
s
 >= 0 && (char *) 
p
 <= 
end
 && 
d
->
fails
[s])

3300 if (
d
->
success
[
s
] & 
sbit
[*
p
])

3302 if (
backref
)

3303 *
backref
 = (
d
->
states
[
s
].backref != 0);

3304 if (
d
->
mb_cur_max
 > 1)

3306 
	`free
(
mblen_buf
);

3307 
	`free
(
inputwcs
);

3309 *
end
 = 
saved_end
;

3310 return (char *) 
p
;

3313 
s1
 = 
s
;

3314 if (
d
->
mb_cur_max
 > 1)

3318 
s
 = 
	`transit_state
(
d
, s, &
p
);

3319 
trans
 = 
d
->trans;

3322 
s
 = 
d
->
fails
[s][*
p
++];

3327 if ((char *) 
p
 <= 
end
 && p[-1] == 
eol
)

3329 if (
count
)

3330 ++*
count
;

3332 if (
d
->
mb_cur_max
 > 1)

3333 
	`prepare_wc_buf
 ((const char *) 
p
, 
end
);

3337 if ((char *) 
p
 > 
end
)

3339 if (
d
->
mb_cur_max
 > 1)

3341 
	`free
(
mblen_buf
);

3342 
	`free
(
inputwcs
);

3344 *
end
 = 
saved_end
;

3345 return 
NULL
;

3348 if (
s
 >= 0)

3350 
	`build_state
(
s
, 
d
);

3351 
trans
 = 
d
->trans;

3355 if (
p
[-1] == 
eol
 && 
newline
)

3357 
s
 = 
d
->
newlines
[
s1
];

3361 
s
 = 0;

3363 
	}
}

3366 
	$free_mbdata
 (struct 
dfa
 *
d
)

3368 unsigned int 
i
;

3370 
	`free
(
d
->
multibyte_prop
);

3371 
d
->
multibyte_prop
 = 
NULL
;

3373 for (
i
 = 0; i < 
d
->
nmbcsets
; ++i)

3375 unsigned int 
j
;

3376 struct 
mb_char_classes
 *
p
 = &(
d
->
mbcsets
[
i
]);

3377 
	`free
(
p
->
chars
);

3378 
	`free
(
p
->
ch_classes
);

3379 
	`free
(
p
->
range_sts
);

3380 
	`free
(
p
->
range_ends
);

3382 for (
j
 = 0; j < 
p
->
nequivs
; ++j)

3383 
	`free
(
p
->
equivs
[
j
]);

3384 
	`free
(
p
->
equivs
);

3386 for (
j
 = 0; j < 
p
->
ncoll_elems
; ++j)

3387 
	`free
(
p
->
coll_elems
[
j
]);

3388 
	`free
(
p
->
coll_elems
);

3391 
	`free
(
d
->
mbcsets
);

3392 
d
->
mbcsets
 = 
NULL
;

3393 
d
->
nmbcsets
 = 0;

3394 
	}
}

3399 
	$dfainit
 (struct 
dfa
 *
d
)

3401 
	`memset
 (
d
, 0, sizeof *d);

3403 
d
->
calloc
 = 1;

3404 
	`MALLOC
(
d
->
charclasses
, d->
calloc
);

3406 
d
->
talloc
 = 1;

3407 
	`MALLOC
(
d
->
tokens
, d->
talloc
);

3409 
d
->
mb_cur_max
 = 
MB_CUR_MAX
;

3411 if (
d
->
mb_cur_max
 > 1)

3413 
d
->
nmultibyte_prop
 = 1;

3414 
	`MALLOC
(
d
->
multibyte_prop
, d->
nmultibyte_prop
);

3415 
d
->
mbcsets_alloc
 = 1;

3416 
	`MALLOC
(
d
->
mbcsets
, d->
mbcsets_alloc
);

3418 
	}
}

3421 
	$dfaoptimize
 (struct 
dfa
 *
d
)

3423 if (!
MBS_SUPPORT
 || !
	`using_utf8
())

3426 unsigned int 
i
;

3427 for (
i
 = 0; i < 
d
->
tindex
; ++i)

3429 switch(
d
->
tokens
[
i
])

3431 case 
ANYCHAR
:

3433 
	`abort
 ();

3434 case 
MBCSET
:

3442 
	`free_mbdata
 (
d
);

3443 
d
->
mb_cur_max
 = 1;

3444 
	}
}

3448 
	$dfacomp
 (char const *
s
, 
size_t
 
len
, struct 
dfa
 *
d
, int 
searchflag
)

3450 
	`dfainit
(
d
);

3451 
	`dfaparse
(
s
, 
len
, 
d
);

3452 
	`dfamust
(
d
);

3453 
	`dfaoptimize
(
d
);

3454 
	`dfaanalyze
(
d
, 
searchflag
);

3455 
	}
}

3459 
	$dfafree
 (struct 
dfa
 *
d
)

3461 int 
i
;

3462 struct 
dfamust
 *
dm
, *
ndm
;

3464 
	`free
(
d
->
charclasses
);

3465 
	`free
(
d
->
tokens
);

3467 if (
d
->
mb_cur_max
 > 1)

3468 
	`free_mbdata
(
d
);

3470 for (
i
 = 0; i < 
d
->
sindex
; ++i) {

3471 
	`free
(
d
->
states
[
i
].
elems
.elems);

3472 if (
MBS_SUPPORT
)

3473 
	`free
(
d
->
states
[
i
].
mbps
.
elems
);

3475 
	`free
(
d
->
states
);

3476 for (
i
 = 0; i < 
d
->
tindex
; ++i)

3477 
	`free
(
d
->
follows
[
i
].
elems
);

3478 
	`free
(
d
->
follows
);

3479 for (
i
 = 0; i < 
d
->
tralloc
; ++i)

3481 
	`free
(
d
->
trans
[
i
]);

3482 
	`free
(
d
->
fails
[
i
]);

3484 
	`free
(
d
->
realtrans
);

3485 
	`free
(
d
->
fails
);

3486 
	`free
(
d
->
newlines
);

3487 
	`free
(
d
->
success
);

3488 for (
dm
 = 
d
->
musts
; dm; dm = 
ndm
)

3490 
ndm
 = 
dm
->
next
;

3491 
	`free
(
dm
->
must
);

3492 
	`free
(
dm
);

3494 
	}
}

3581 
	$icatalloc
 (char *
old
, char const *
new
)

3583 char *
result
;

3584 
size_t
 
oldsize
 = 
old
 == 
NULL
 ? 0 : 
	`strlen
 (old);

3585 
size_t
 
newsize
 = 
new
 == 
NULL
 ? 0 : 
	`strlen
 (new);

3586 if (
newsize
 == 0)

3587 return 
old
;

3588 
result
 = 
	`xrealloc
 (
old
, 
oldsize
 + 
newsize
 + 1);

3589 
	`strcpy
 (
result
 + 
oldsize
, 
new
);

3590 return 
result
;

3591 
	}
}

3594 
	$icpyalloc
 (char const *
string
)

3596 return 
	`icatalloc
 (
NULL
, 
string
);

3597 
	}
}

3600 
	$istrstr
 (char const *
lookin
, char const *
lookfor
)

3602 char const *
cp
;

3603 
size_t
 
len
;

3605 
len
 = 
	`strlen
(
lookfor
);

3606 for (
cp
 = 
lookin
; *cp != '\0'; ++cp)

3607 if (
	`strncmp
(
cp
, 
lookfor
, 
len
) == 0)

3608 return (char *) 
cp
;

3609 return 
NULL
;

3610 
	}
}

3613 
	$freelist
 (char **
cpp
)

3615 int 
i
;

3617 if (
cpp
 == 
NULL
)

3619 for (
i
 = 0; 
cpp
[i] != 
NULL
; ++i)

3621 
	`free
(
cpp
[
i
]);

3622 
cpp
[
i
] = 
NULL
;

3624 
	}
}

3627 
	$enlist
 (char **
cpp
, char *
new
, 
size_t
 
len
)

3629 int 
i
, 
j
;

3631 if (
cpp
 == 
NULL
)

3632 return 
NULL
;

3633 if ((
new
 = 
	`icpyalloc
(new)) == 
NULL
)

3635 
	`freelist
(
cpp
);

3636 return 
NULL
;

3638 
new
[
len
] = '\0';

3640 for (
i
 = 0; 
cpp
[i] != 
NULL
; ++i)

3641 if (
	`istrstr
(
cpp
[
i
], 
new
) != 
NULL
)

3643 
	`free
(
new
);

3644 return 
cpp
;

3647 
j
 = 0;

3648 while (
cpp
[
j
] != 
NULL
)

3649 if (
	`istrstr
(
new
, 
cpp
[
j
]) == 
NULL
)

3650 ++
j
;

3653 
	`free
(
cpp
[
j
]);

3654 if (--
i
 == 
j
)

3656 
cpp
[
j
] = cpp[
i
];

3657 
cpp
[
i
] = 
NULL
;

3660 
cpp
 = 
	`xnrealloc
(cpp, 
i
 + 2, sizeof *cpp);

3661 
cpp
[
i
] = 
new
;

3662 
cpp
[
i
 + 1] = 
NULL
;

3663 return 
cpp
;

3664 
	}
}

3670 
	$comsubs
 (char *
left
, char const *
right
)

3672 char **
cpp
;

3673 char *
lcp
;

3674 char *
rcp
;

3675 
size_t
 
i
, 
len
;

3677 if (
left
 == 
NULL
 || 
right
 == NULL)

3678 return 
NULL
;

3679 
cpp
 = 
	`malloc
(sizeof *cpp);

3680 if (
cpp
 == 
NULL
)

3681 return 
NULL
;

3682 
cpp
[0] = 
NULL
;

3683 for (
lcp
 = 
left
; *lcp != '\0'; ++lcp)

3685 
len
 = 0;

3686 
rcp
 = 
	`strchr
 (
right
, *
lcp
);

3687 while (
rcp
 != 
NULL
)

3689 for (
i
 = 1; 
lcp
[i] != '\0' && lcp[i] == 
rcp
[i]; ++i)

3691 if (
i
 > 
len
)

3692 
len
 = 
i
;

3693 
rcp
 = 
	`strchr
 (rcp + 1, *
lcp
);

3695 if (
len
 == 0)

3698 char **
p
 = 
	`enlist
 (
cpp
, 
lcp
, 
len
);

3699 if (
p
 == 
NULL
)

3701 
	`freelist
 (
cpp
);

3702 
cpp
 = 
NULL
;

3705 
cpp
 = 
p
;

3708 return 
cpp
;

3709 
	}
}

3712 
	$addlists
 (char **
old
, char **
new
)

3714 int 
i
;

3716 if (
old
 == 
NULL
 || 
new
 == NULL)

3717 return 
NULL
;

3718 for (
i
 = 0; 
new
[i] != 
NULL
; ++i)

3720 
old
 = 
	`enlist
(old, 
new
[
i
], 
	`strlen
(new[i]));

3721 if (
old
 == 
NULL
)

3724 return 
old
;

3725 
	}
}

3730 
	$inboth
 (char **
left
, char **
right
)

3732 char **
both
;

3733 char **
temp
;

3734 int 
lnum
, 
rnum
;

3736 if (
left
 == 
NULL
 || 
right
 == NULL)

3737 return 
NULL
;

3738 
both
 = 
	`malloc
(sizeof *both);

3739 if (
both
 == 
NULL
)

3740 return 
NULL
;

3741 
both
[0] = 
NULL
;

3742 for (
lnum
 = 0; 
left
[lnum] != 
NULL
; ++lnum)

3744 for (
rnum
 = 0; 
right
[rnum] != 
NULL
; ++rnum)

3746 
temp
 = 
	`comsubs
(
left
[
lnum
], 
right
[
rnum
]);

3747 if (
temp
 == 
NULL
)

3749 
	`freelist
(
both
);

3750 return 
NULL
;

3752 
both
 = 
	`addlists
(both, 
temp
);

3753 
	`freelist
(
temp
);

3754 
	`free
(
temp
);

3755 if (
both
 == 
NULL
)

3756 return 
NULL
;

3759 return 
both
;

3760 
	}
}

3764 char **
	min
;

3765 char *
	mleft
;

3766 char *
	mright
;

3767 char *
	mis
;

3768 } 
	tmust
;

3771 
	$resetmust
 (
must
 *
mp
)

3773 
mp
->
left
[0] = mp->
right
[0] = mp->
is
[0] = '\0';

3774 
	`freelist
(
mp
->
in
);

3775 
	}
}

3778 
	$dfamust
 (struct 
dfa
 *
d
)

3780 
must
 *
musts
;

3781 
must
 *
mp
;

3782 char *
result
;

3783 int 
ri
;

3784 int 
i
;

3785 int 
exact
;

3786 
token
 
t
;

3787 static 
must
 
must0
;

3788 struct 
dfamust
 *
dm
;

3789 static char 
empty_string
[] = "";

3791 
result
 = 
empty_string
;

3792 
exact
 = 0;

3793 
musts
 = 
	`xnmalloc
(
d
->
tindex
 + 1, sizeof *musts);

3794 
mp
 = 
musts
;

3795 for (
i
 = 0; i <= 
d
->
tindex
; ++i)

3796 
mp
[
i
] = 
must0
;

3797 for (
i
 = 0; i <= 
d
->
tindex
; ++i)

3799 
mp
[
i
].
in
 = 
	`xmalloc
(sizeof *mp[i].in);

3800 
mp
[
i
].
left
 = 
	`xmalloc
(2);

3801 
mp
[
i
].
right
 = 
	`xmalloc
(2);

3802 
mp
[
i
].
is
 = 
	`xmalloc
(2);

3803 
mp
[
i
].
left
[0] = mp[i].
right
[0] = mp[i].
is
[0] = '\0';

3804 
mp
[
i
].
in
[0] = 
NULL
;

3806 #ifdef 
DEBUG


3807 
	`fprintf
(
stderr
, "dfamust:\n");

3808 for (
i
 = 0; i < 
d
->
tindex
; ++i)

3810 
	`fprintf
(
stderr
, " %d:", 
i
);

3811 
	`prtok
(
d
->
tokens
[
i
]);

3813 
	`putc
('\n', 
stderr
);

3815 for (
ri
 = 0; ri < 
d
->
tindex
; ++ri)

3817 switch (
t
 = 
d
->
tokens
[
ri
])

3819 case 
LPAREN
:

3820 case 
RPAREN
:

3821 
	`assert
 (!"neither LPAREN nor RPAREN may appear here");

3822 case 
EMPTY
:

3823 case 
BEGLINE
:

3824 case 
ENDLINE
:

3825 case 
BEGWORD
:

3826 case 
ENDWORD
:

3827 case 
LIMWORD
:

3828 case 
NOTLIMWORD
:

3829 case 
BACKREF
:

3830 
	`resetmust
(
mp
);

3832 case 
STAR
:

3833 case 
QMARK
:

3834 
	`assert
 (
musts
 < 
mp
);

3835 --
mp
;

3836 
	`resetmust
(
mp
);

3838 case 
OR
:

3839 
	`assert
 (&
musts
[2] <= 
mp
);

3841 char **
new
;

3842 
must
 *
lmp
;

3843 
must
 *
rmp
;

3844 int 
j
, 
ln
, 
rn
, 
n
;

3846 
rmp
 = --
mp
;

3847 
lmp
 = --
mp
;

3849 if (!
	`STREQ
 (
lmp
->
is
, 
rmp
->is))

3850 
lmp
->
is
[0] = '\0';

3852 
i
 = 0;

3853 while (
lmp
->
left
[
i
] != '\0' && lmp->left[i] == 
rmp
->left[i])

3854 ++
i
;

3855 
lmp
->
left
[
i
] = '\0';

3857 
ln
 = 
	`strlen
(
lmp
->
right
);

3858 
rn
 = 
	`strlen
(
rmp
->
right
);

3859 
n
 = 
ln
;

3860 if (
n
 > 
rn
)

3861 
n
 = 
rn
;

3862 for (
i
 = 0; i < 
n
; ++i)

3863 if (
lmp
->
right
[
ln
 - 
i
 - 1] != 
rmp
->right[
rn
 - i - 1])

3865 for (
j
 = 0; j < 
i
; ++j)

3866 
lmp
->
right
[
j
] = lmp->right[(
ln
 - 
i
) + j];

3867 
lmp
->
right
[
j
] = '\0';

3868 
new
 = 
	`inboth
(
lmp
->
in
, 
rmp
->in);

3869 if (
new
 == 
NULL
)

3870 goto 
done
;

3871 
	`freelist
(
lmp
->
in
);

3872 
	`free
(
lmp
->
in
);

3873 
lmp
->
in
 = 
new
;

3876 case 
PLUS
:

3877 
	`assert
 (
musts
 < 
mp
);

3878 --
mp
;

3879 
mp
->
is
[0] = '\0';

3881 case 
END
:

3882 
	`assert
 (
mp
 == &
musts
[1]);

3883 for (
i
 = 0; 
musts
[0].
in
[i] != 
NULL
; ++i)

3884 if (
	`strlen
(
musts
[0].
in
[
i
]) > strlen(
result
))

3885 
result
 = 
musts
[0].
in
[
i
];

3886 if (
	`STREQ
 (
result
, 
musts
[0].
is
))

3887 
exact
 = 1;

3888 goto 
done
;

3889 case 
CAT
:

3890 
	`assert
 (&
musts
[2] <= 
mp
);

3892 
must
 *
lmp
;

3893 
must
 *
rmp
;

3895 
rmp
 = --
mp
;

3896 
lmp
 = --
mp
;

3900 
lmp
->
in
 = 
	`addlists
(lmp->in, 
rmp
->in);

3901 if (
lmp
->
in
 == 
NULL
)

3902 goto 
done
;

3903 if (
lmp
->
right
[0] != '\0' &&

3904 
rmp
->
left
[0] != '\0')

3906 char *
tp
;

3908 
tp
 = 
	`icpyalloc
(
lmp
->
right
);

3909 
tp
 = 
	`icatalloc
(tp, 
rmp
->
left
);

3910 
lmp
->
in
 = 
	`enlist
(lmp->in, 
tp
, 
	`strlen
(tp));

3911 
	`free
(
tp
);

3912 if (
lmp
->
in
 == 
NULL
)

3913 goto 
done
;

3916 if (
lmp
->
is
[0] != '\0')

3918 
lmp
->
left
 = 
	`icatalloc
(lmp->left,

3919 
rmp
->
left
);

3920 if (
lmp
->
left
 == 
NULL
)

3921 goto 
done
;

3924 if (
rmp
->
is
[0] == '\0')

3925 
lmp
->
right
[0] = '\0';

3926 
lmp
->
right
 = 
	`icatalloc
(lmp->right, 
rmp
->right);

3927 if (
lmp
->
right
 == 
NULL
)

3928 goto 
done
;

3930 if (
lmp
->
is
[0] != '\0' && 
rmp
->is[0] != '\0')

3932 
lmp
->
is
 = 
	`icatalloc
(lmp->is, 
rmp
->is);

3933 if (
lmp
->
is
 == 
NULL
)

3934 goto 
done
;

3937 
lmp
->
is
[0] = '\0';

3941 if (
t
 < 
END
)

3943 
	`assert
 (!"oops! t >= END");

3945 else if (
t
 == '\0')

3948 goto 
done
;

3950 else if (
t
 >= 
CSET


3951 || !
MBS_SUPPORT


3952 || 
t
 == 
ANYCHAR


3953 || 
t
 == 
MBCSET


3957 
	`resetmust
(
mp
);

3962 
	`resetmust
(
mp
);

3963 
mp
->
is
[0] = mp->
left
[0] = mp->
right
[0] = 
t
;

3964 
mp
->
is
[1] = mp->
left
[1] = mp->
right
[1] = '\0';

3965 
mp
->
in
 = 
	`enlist
(mp->in, mp->
is
, (
size_t
)1);

3966 if (
mp
->
in
 == 
NULL
)

3967 goto 
done
;

3971 #ifdef 
DEBUG


3972 
	`fprintf
(
stderr
, " node: %d:", 
ri
);

3973 
	`prtok
(
d
->
tokens
[
ri
]);

3974 
	`fprintf
(
stderr
, "\n in:");

3975 for (
i
 = 0; 
mp
->
in
[i]; ++i)

3976 
	`fprintf
(
stderr
, " \"%s\"", 
mp
->
in
[
i
]);

3977 
	`fprintf
(
stderr
, "\n is: \"%s\"\n", 
mp
->
is
);

3978 
	`fprintf
(
stderr
, " left: \"%s\"\n", 
mp
->
left
);

3979 
	`fprintf
(
stderr
, " right: \"%s\"\n", 
mp
->
right
);

3981 ++
mp
;

3983 
done
:

3984 if (
	`strlen
(
result
))

3986 
	`MALLOC
(
dm
, 1);

3987 
dm
->
exact
 = exact;

3988 
	`MALLOC
(
dm
->
must
, 
	`strlen
(
result
) + 1);

3989 
	`strcpy
(
dm
->
must
, 
result
);

3990 
dm
->
next
 = 
d
->
musts
;

3991 
d
->
musts
 = 
dm
;

3993 
mp
 = 
musts
;

3994 for (
i
 = 0; i <= 
d
->
tindex
; ++i)

3996 
	`freelist
(
mp
[
i
].
in
);

3997 
	`free
(
mp
[
i
].
in
);

3998 
	`free
(
mp
[
i
].
left
);

3999 
	`free
(
mp
[
i
].
right
);

4000 
	`free
(
mp
[
i
].
is
);

4002 
	`free
(
mp
);

4003 
	}
}

4005 struct 
dfa
 *

4006 
	$dfaalloc
 (void)

4008 return 
	`xmalloc
 (sizeof (struct 
dfa
));

4009 
	}
}

4011 struct 
dfamust
 *

4012 
	$dfamusts
 (struct 
dfa
 const *
d
)

4014 return 
d
->
musts
;

4015 
	}
}

	@src/dfa.h

21 #if 
__GNUC__
 < 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 < 6) || 
__STRICT_ANSI__


22 #define 
	#__attribute__
(
x
)

	)

27 struct 
	sdfamust


29 int 
	mexact
;

30 char *
	mmust
;

31 struct 
dfamust
 *
	mnext
;

35 struct 
	gdfa
;

42 extern struct 
dfa
 *
dfaalloc
 (void);

45 extern struct 
dfamust
 *
dfamusts
 (struct 
dfa
 const *);

50 extern void 
dfasyntax
 (
reg_syntax_t
, int, unsigned char);

55 extern void 
dfacomp
 (char const *, 
size_t
, struct 
dfa
 *, int);

69 extern char *
dfaexec
 (struct 
dfa
 *
d
, char const *
begin
, char *
end
,

70 int 
newline
, int *
count
, int *
backref
);

73 extern void 
dfafree
 (struct 
dfa
 *);

78 extern void 
dfainit
 (struct 
dfa
 *);

81 extern void 
dfaparse
 (char const *, 
size_t
, struct 
dfa
 *);

85 extern void 
dfaanalyze
 (struct 
dfa
 *, int);

89 extern void 
dfastate
 (int, struct 
dfa
 *, int []);

97 extern void 
dfawarn
 (const char *);

102 extern void 
	$dfaerror
 (const char *) 
	`__attribute__
 ((
noreturn
));

	@src/dfasearch.c

21 #include 
	~<config.h
>

22 #include 
	~"search.h
"

23 #include 
	~"dfa.h
"

26 #define 
	#WCHAR
(
C
) (
	`isalnum
 (C) || (C) == '_')

	)

31 static 
kwset_t
 
	gkwset
;

34 static struct 
dfa
 *
	gdfa
;

37 static struct 
	spatterns


40 struct 
re_pattern_buffer
 
	mregexbuf
;

41 struct 
re_registers
 
	mregs
;

43 } 
	gpatterns0
;

45 static struct 
patterns
 *
	gpatterns
;

46 static 
size_t
 
	gpcount
;

49 
	$dfaerror
 (char const *
mesg
)

51 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
mesg
);

55 
	`abort
 ();

56 
	}
}

62 
	$dfawarn
 (char const *
mesg
)

64 static enum { 
DW_NONE
 = 0, 
DW_POSIX
, 
DW_GNU
 } 
mode
;

65 if (
mode
 == 
DW_NONE
)

66 
mode
 = (
	`getenv
 ("POSIXLY_CORRECT") ? 
DW_POSIX
 : 
DW_GNU
);

67 if (
mode
 == 
DW_GNU
)

68 
	`dfaerror
 (
mesg
);

69 
	}
}

74 static int 
	gkwset_exact_matches
;

77 
	$kwsincr_case
 (const char *
must
)

79 
size_t
 
n
 = 
	`strlen
 (
must
);

80 const char *
buf
 = (
match_icase
 && 
MB_CUR_MAX
 > 1

81 ? 
	`mbtolower
 (
must
, &
n
)

82 : 
must
);

83 return 
	`kwsincr
 (
kwset
, 
buf
, 
n
);

84 
	}
}

91 
	$kwsmusts
 (void)

93 struct 
dfamust
 const *
dm
;

94 char const *
err
;

96 
dm
 = 
	`dfamusts
 (
dfa
);

97 if (
dm
)

99 
	`kwsinit
 (&
kwset
);

103 for (; 
dm
; dm = dm->
next
)

105 if (!
dm
->
exact
)

107 ++
kwset_exact_matches
;

108 if ((
err
 = 
	`kwsincr_case
 (
dm
->
must
)) != 
NULL
)

109 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
err
);

113 for (
dm
 = 
	`dfamusts
 (
dfa
); dm; dm = dm->
next
)

115 if (
dm
->
exact
)

117 if ((
err
 = 
	`kwsincr_case
 (
dm
->
must
)) != 
NULL
)

118 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
err
);

120 if ((
err
 = 
	`kwsprep
 (
kwset
)) != 
NULL
)

121 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
err
);

123 
	}
}

126 
	$GEAcompile
 (char const *
pattern
, 
size_t
 
size
, 
reg_syntax_t
 
syntax_bits
)

128 const char *
err
;

129 const char *
p
, *
sep
;

130 
size_t
 
total
 = 
size
;

131 char *
motif
;

133 if (
match_icase
)

134 
syntax_bits
 |= 
RE_ICASE
;

135 
	`re_set_syntax
 (
syntax_bits
);

136 
	`dfasyntax
 (
syntax_bits
, 
match_icase
, 
eolbyte
);

142 
p
 = 
pattern
;

145 
size_t
 
len
;

146 
sep
 = 
	`memchr
 (
p
, '\n', 
total
);

147 if (
sep
)

149 
len
 = 
sep
 - 
p
;

150 
sep
++;

151 
total
 -= (
len
 + 1);

155 
len
 = 
total
;

156 
total
 = 0;

159 
patterns
 = 
	`xnrealloc
 (patterns, 
pcount
 + 1, sizeof *patterns);

160 
patterns
[
pcount
] = 
patterns0
;

162 if ((
err
 = 
	`re_compile_pattern
 (
p
, 
len
,

163 &(
patterns
[
pcount
].
regexbuf
))) != 
NULL
)

164 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
err
);

165 
pcount
++;

167 
p
 = 
sep
;

168 } while (
sep
 && 
total
 != 0);

174 if (
match_words
 || 
match_lines
)

176 static char const 
line_beg_no_bk
[] = "^(";

177 static char const 
line_end_no_bk
[] = ")$";

178 static char const 
word_beg_no_bk
[] = "(^|[^[:alnum:]_])(";

179 static char const 
word_end_no_bk
[] = ")([^[:alnum:]_]|$)";

180 static char const 
line_beg_bk
[] = "^\\(";

181 static char const 
line_end_bk
[] = "\\)$";

182 static char const 
word_beg_bk
[] = "\\(^\\|[^[:alnum:]_]\\)\\(";

183 static char const 
word_end_bk
[] = "\\)\\([^[:alnum:]_]\\|$\\)";

184 int 
bk
 = !(
syntax_bits
 & 
RE_NO_BK_PARENS
);

185 char *
n
 = 
	`xmalloc
 (sizeof 
word_beg_bk
 - 1 + 
size
 + sizeof 
word_end_bk
);

187 
	`strcpy
 (
n
, 
match_lines
 ? (
bk
 ? 
line_beg_bk
 : 
line_beg_no_bk
)

188 : (
bk
 ? 
word_beg_bk
 : 
word_beg_no_bk
));

189 
total
 = 
	`strlen
(
n
);

190 
	`memcpy
 (
n
 + 
total
, 
pattern
, 
size
);

191 
total
 += 
size
;

192 
	`strcpy
 (
n
 + 
total
, 
match_lines
 ? (
bk
 ? 
line_end_bk
 : 
line_end_no_bk
)

193 : (
bk
 ? 
word_end_bk
 : 
word_end_no_bk
));

194 
total
 += 
	`strlen
 (
n
 + total);

195 
pattern
 = 
motif
 = 
n
;

196 
size
 = 
total
;

199 
motif
 = 
NULL
;

201 
dfa
 = 
	`dfaalloc
 ();

202 
	`dfacomp
 (
pattern
, 
size
, 
dfa
, 1);

203 
	`kwsmusts
 ();

205 
	`free
(
motif
);

206 
	}
}

208 
size_t


209 
	$EGexecute
 (char const *
buf
, 
size_t
 
size
, size_t *
match_size
,

210 char const *
start_ptr
)

212 char const *
buflim
, *
beg
, *
end
, *
match
, *
best_match
, *
mb_start
;

213 char 
eol
 = 
eolbyte
;

214 int 
backref
, 
start
, 
len
, 
best_len
;

215 struct 
kwsmatch
 
kwsm
;

216 
size_t
 
i
, 
ret_val
;

217 if (
MB_CUR_MAX
 > 1)

219 if (
match_icase
)

223 char *
case_buf
 = 
	`mbtolower
 (
buf
, &
size
);

224 if (
start_ptr
)

225 
start_ptr
 = 
case_buf
 + (start_ptr - 
buf
);

226 
buf
 = 
case_buf
;

230 
mb_start
 = 
buf
;

231 
buflim
 = 
buf
 + 
size
;

233 for (
beg
 = 
end
 = 
buf
; end < 
buflim
; beg = end)

235 if (!
start_ptr
)

238 if (
kwset
)

241 
size_t
 
offset
 = 
	`kwsexec
 (
kwset
, 
beg
, 
buflim
 - beg, &
kwsm
);

242 if (
offset
 == (
size_t
) -1)

243 goto 
failure
;

244 
beg
 += 
offset
;

247 if ((
end
 = 
	`memchr
(
beg
, 
eol
, 
buflim
 - beg)) != 
NULL
)

248 
end
++;

250 
end
 = 
buflim
;

251 
match
 = 
beg
;

252 while (
beg
 > 
buf
 && beg[-1] != 
eol
)

253 --
beg
;

254 if (
kwsm
.
index
 < 
kwset_exact_matches
)

256 if (!
MBS_SUPPORT
)

257 goto 
success
;

259 if (
mb_start
 < 
beg
)

260 
mb_start
 = 
beg
;

261 if (
MB_CUR_MAX
 == 1

262 || !
	`is_mb_middle
 (&
mb_start
, 
match
, 
buflim
,

263 
kwsm
.
size
[0]))

264 goto 
success
;

266 if (
	`dfaexec
 (
dfa
, 
beg
, (char *) 
end
, 0, 
NULL
, &
backref
) == NULL)

272 char const *
next_beg
 = 
	`dfaexec
 (
dfa
, 
beg
, (char *) 
buflim
,

273 0, 
NULL
, &
backref
);

274 if (
next_beg
 == 
NULL
)

277 
beg
 = 
next_beg
;

278 if ((
end
 = 
	`memchr
(
beg
, 
eol
, 
buflim
 - beg)) != 
NULL
)

279 
end
++;

281 
end
 = 
buflim
;

282 while (
beg
 > 
buf
 && beg[-1] != 
eol
)

283 --
beg
;

286 if (!
backref
)

287 goto 
success
;

293 
beg
 = 
start_ptr
;

294 
end
 = 
buflim
;

299 
best_match
 = 
end
;

300 
best_len
 = 0;

301 for (
i
 = 0; i < 
pcount
; i++)

303 
patterns
[
i
].
regexbuf
.
not_eol
 = 0;

304 if (0 <= (
start
 = 
	`re_search
 (&(
patterns
[
i
].
regexbuf
),

305 
buf
, 
end
 - buf - 1,

306 
beg
 - 
buf
, 
end
 - beg - 1,

307 &(
patterns
[
i
].
regs
))))

309 
len
 = 
patterns
[
i
].
regs
.
end
[0] - 
start
;

310 
match
 = 
buf
 + 
start
;

311 if (
match
 > 
best_match
)

313 if (
start_ptr
 && !
match_words
)

314 goto 
assess_pattern_match
;

315 if ((!
match_lines
 && !
match_words
)

316 || (
match_lines
 && 
len
 == 
end
 - 
beg
 - 1))

318 
match
 = 
beg
;

319 
len
 = 
end
 - 
beg
;

320 goto 
assess_pattern_match
;

329 if (
match_words
)

330 while (
match
 <= 
best_match
)

332 if ((
match
 == 
buf
 || !
	`WCHAR
 ((unsigned char) match[-1]))

333 && (
start
 + 
len
 == 
end
 - 
buf
 - 1

334 || !
	`WCHAR
 ((unsigned char) 
match
[
len
])))

335 goto 
assess_pattern_match
;

336 if (
len
 > 0)

339 --
len
;

340 
patterns
[
i
].
regexbuf
.
not_eol
 = 1;

341 
len
 = 
	`re_match
 (&(
patterns
[
i
].
regexbuf
),

342 
buf
, 
match
 + 
len
 - 
beg
, match - buf,

343 &(
patterns
[
i
].
regs
));

345 if (
len
 <= 0)

348 if (
match
 == 
end
 - 1)

350 
match
++;

351 
patterns
[
i
].
regexbuf
.
not_eol
 = 0;

352 
start
 = 
	`re_search
 (&(
patterns
[
i
].
regexbuf
),

353 
buf
, 
end
 - buf - 1,

354 
match
 - 
buf
, 
end
 - match - 1,

355 &(
patterns
[
i
].
regs
));

356 if (
start
 < 0)

358 
len
 = 
patterns
[
i
].
regs
.
end
[0] - 
start
;

359 
match
 = 
buf
 + 
start
;

363 
assess_pattern_match
:

364 if (!
start_ptr
)

368 goto 
success
;

370 if (
match
 < 
best_match
 || (match == best_match && 
len
 > 
best_len
))

373 
best_match
 = 
match
;

374 
best_len
 = 
len
;

378 if (
best_match
 < 
end
)

382 
beg
 = 
best_match
;

383 
len
 = 
best_len
;

384 goto 
success_in_len
;

388 
failure
:

389 
ret_val
 = -1;

390 goto 
out
;

392 
success
:

393 
len
 = 
end
 - 
beg
;

394 
success_in_len
:

395 *
match_size
 = 
len
;

396 
ret_val
 = 
beg
 - 
buf
;

397 
out
:

398 return 
ret_val
;

399 
	}
}

	@src/dosbuf.c

31 #include 
	~<config.h
>

34 
	mUNKNOWN
, 
	mDOS_BINARY
, 
	mDOS_TEXT
, 
	mUNIX_TEXT


35 } 
	tFile_type
;

37 struct 
	sdos_map
 {

38 
off_t
 
	mpos
;

39 
off_t
 
	madd
;

42 static int 
	gdos_report_unix_offset
 = 0;

44 static 
File_type
 
	gdos_file_type
 = 
UNKNOWN
;

45 static 
File_type
 
	gdos_use_file_type
 = 
UNKNOWN
;

46 static 
off_t
 
	gdos_stripped_crs
 = 0;

47 static struct 
dos_map
 *
	gdos_pos_map
;

48 static int 
	gdos_pos_map_size
 = 0;

49 static int 
	gdos_pos_map_used
 = 0;

50 static int 
	ginp_map_idx
 = 0, 
	gout_map_idx
 = 1;

53 static 
inline
 
File_type


54 
	$guess_type
 (char *
buf
, 
size_t
 
buflen
)

56 int 
crlf_seen
 = 0;

57 char *
bp
 = 
buf
;

59 while (
buflen
--)

62 if (!*
bp
)

63 return 
DOS_BINARY
;

67 else if (*
bp
 == '\r' && 
buflen
 && bp[1] == '\n')

68 
crlf_seen
 = 1;

70 
bp
++;

73 return 
crlf_seen
 ? 
DOS_TEXT
 : 
UNIX_TEXT
;

74 
	}
}

79 static 
inline
 int

80 
	$undossify_input
 (char *
buf
, 
size_t
 
buflen
)

82 int 
chars_left
 = 0;

84 if (
totalcc
 == 0)

88 
inp_map_idx
 = 0;

89 
out_map_idx
 = 1;

90 
dos_pos_map_used
 = 0;

91 
dos_stripped_crs
 = 0;

92 
dos_file_type
 = 
dos_use_file_type
;

96 if (
dos_file_type
 == 
UNKNOWN
)

97 
dos_file_type
 = 
	`guess_type
(
buf
, 
buflen
);

101 if (
dos_file_type
 == 
DOS_TEXT
)

103 char *
destp
 = 
buf
;

105 while (
buflen
--)

107 if (*
buf
 != '\r')

109 *
destp
++ = *
buf
++;

110 
chars_left
++;

114 
buf
++;

115 if (
out_byte
 && !
dos_report_unix_offset
)

117 
dos_stripped_crs
++;

118 while (
buflen
 && *
buf
 == '\r')

120 
dos_stripped_crs
++;

121 
buflen
--;

122 
buf
++;

124 if (
inp_map_idx
 >= 
dos_pos_map_size
 - 1)

126 
dos_pos_map_size
 = 
inp_map_idx
 ? inp_map_idx * 2 : 1000;

127 
dos_pos_map
 = 
	`xrealloc
(dos_pos_map,

128 
dos_pos_map_size
 *

129 sizeof(struct 
dos_map
));

132 if (!
inp_map_idx
)

135 
dos_pos_map
[
inp_map_idx
].
pos
 = 0;

136 
dos_pos_map
[
inp_map_idx
++].
add
 = 0;

139 
dos_pos_map
[
inp_map_idx
].
add
 = 0;

148 
inp_map_idx
++;

149 
dos_pos_map
[
inp_map_idx
-1].
pos
 =

150 (*
buf
 == '\n' ? 
destp
 + 1 : destp ) - 
bufbeg
 + 
totalcc
;

151 
dos_pos_map
[
inp_map_idx
].
add
 = 
dos_stripped_crs
;

152 
dos_pos_map_used
 = 
inp_map_idx
;

155 
dos_pos_map
[
inp_map_idx
].
pos
 = 
destp
 - 
bufbeg
 + 
totalcc
 + 1;

160 return 
chars_left
;

163 return 
buflen
;

164 
	}
}

167 static 
inline
 
off_t


168 
	$dossified_pos
 (
off_t
 
byteno
)

170 
off_t
 
pos_lo
;

171 
off_t
 
pos_hi
;

173 if (
dos_file_type
 != 
DOS_TEXT
 || 
dos_report_unix_offset
)

174 return 
byteno
;

179 
pos_lo
 = 
dos_pos_map
[
out_map_idx
-1].
pos
;

180 
pos_hi
 = 
dos_pos_map
[
out_map_idx
].
pos
;

184 if (
byteno
 >= 
pos_hi
)

186 
out_map_idx
++;

187 while (
out_map_idx
 < 
dos_pos_map_used
 &&

188 
byteno
 >= 
dos_pos_map
[
out_map_idx
].
pos
)

189 
out_map_idx
++;

192 else if (
byteno
 < 
pos_lo
)

194 
out_map_idx
--;

195 while (
out_map_idx
 > 1 && 
byteno
 < 
dos_pos_map
[out_map_idx-1].
pos
)

196 
out_map_idx
--;

199 return 
byteno
 + 
dos_pos_map
[
out_map_idx
].
add
;

200 
	}
}

	@src/egrep.c

1 #include 
	~<config.h
>

2 #include 
	~"search.h
"

5 
	$Ecompile
 (char const *
pattern
, 
size_t
 
size
)

7 
	`GEAcompile
 (
pattern
, 
size
, 
RE_SYNTAX_POSIX_EGREP
 | 
RE_NO_EMPTY_RANGES
);

8 
	}
}

10 struct 
matcher
 const 
	gmatchers
[] = {

11 { "egrep", 
Ecompile
, 
EGexecute
 },

12 { 
NULL
, NULL, NULL },

15 const char 
	gbefore_options
[] =

16 
N_
("PATTERN is an extended regular expression (ERE).\n");

17 const char 
	gafter_options
[] =

18 
N_
("Invocation as `egrep' is deprecated; use `grep -E' instead.\n");

	@src/fgrep.c

1 #include 
	~<config.h
>

2 #include 
	~"search.h
"

4 struct 
matcher
 const 
	gmatchers
[] = {

5 { "fgrep", 
Fcompile
, 
Fexecute
 },

6 { 
NULL
, NULL, NULL },

9 const char 
	gbefore_options
[] =

10 
N_
("PATTERN is a set of newline-separated fixed strings.\n");

11 const char 
	gafter_options
[] =

12 
N_
("Invocation as `fgrep' is deprecated; use `grep -F' instead.\n");

	@src/grep.c

1 #include 
	~<config.h
>

2 #include 
	~"search.h
"

5 
	$Gcompile
 (char const *
pattern
, 
size_t
 
size
)

7 
	`GEAcompile
 (
pattern
, 
size
, 
RE_SYNTAX_GREP
 | 
RE_NO_EMPTY_RANGES
);

8 
	}
}

11 
	$Ecompile
 (char const *
pattern
, 
size_t
 
size
)

13 
	`GEAcompile
 (
pattern
, 
size
, 
RE_SYNTAX_POSIX_EGREP
 | 
RE_NO_EMPTY_RANGES
);

14 
	}
}

17 
	$Acompile
 (char const *
pattern
, 
size_t
 
size
)

19 
	`GEAcompile
 (
pattern
, 
size
, 
RE_SYNTAX_AWK
);

20 
	}
}

22 struct 
matcher
 const 
	gmatchers
[] = {

23 { "grep", 
Gcompile
, 
EGexecute
 },

24 { "egrep", 
Ecompile
, 
EGexecute
 },

25 { "awk", 
Acompile
, 
EGexecute
 },

26 { "fgrep", 
Fcompile
, 
Fexecute
 },

27 { "perl", 
Pcompile
, 
Pexecute
 },

28 { 
NULL
, NULL, NULL },

31 const char 
	gbefore_options
[] =

32 
N_
("PATTERN is, by default, a basic regular expression (BRE).\n");

33 const char 
	gafter_options
[] =

34 
N_
("`egrep' means `grep -E'. `fgrep' means `grep -F'.\n\
Direct invocation as either `egrep' or `fgrep' is deprecated.\n");

	@src/grep.h

20 #ifndef 
GREP_GREP_H


21 #define 
	#GREP_GREP_H
 1

	)

23 #if 
__GNUC__
 < 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 < 6) || 
__STRICT_ANSI__


24 #define 
	#__attribute__
(
x
)

	)

28 typedef void (*
	tcompile_fp_t
) (char const *, 
	tsize_t
);

29 typedef 
	$size_t
 (*
	texecute_fp_t
) (char const *, 
	tsize_t
, size_t *, char const *);

33 struct 
	smatcher


35 const char *
name
;

36 
compile_fp_t
 
compile
;

37 
execute_fp_t
 
execute
;

39 extern const struct 
matcher
 
matchers
[];

41 extern const char 
before_options
[];

42 extern const char 
after_options
[];

46 extern int 
match_icase
;

47 extern int 
match_words
;

48 extern int 
match_lines
;

49 extern unsigned char 
eolbyte
;

	@src/kwsearch.c

21 #include 
	~<config.h
>

22 #include 
	~"search.h
"

25 #define 
	#WCHAR
(
C
) (
	`isalnum
 (C) || (C) == '_')

	)

30 static 
kwset_t
 
	gkwset
;

33 
	$Fcompile
 (char const *
pattern
, 
size_t
 
size
)

35 char const *
err
;

36 
size_t
 
psize
 = 
size
;

37 char const *
pat
 = (
match_icase
 && 
MB_CUR_MAX
 > 1

38 ? 
	`mbtolower
 (
pattern
, &
psize
)

39 : 
pattern
);

41 
	`kwsinit
 (&
kwset
);

43 char const *
beg
 = 
pat
;

46 char const *
lim
;

47 char const *
end
;

48 for (
lim
 = 
beg
;; ++lim)

50 
end
 = 
lim
;

51 if (
lim
 >= 
pat
 + 
psize
)

53 if (*
lim
 == '\n')

55 
lim
++;

58 #if 
HAVE_DOS_FILE_CONTENTS


59 if (*
lim
 == '\r' && lim + 1 < 
pat
 + 
psize
 && lim[1] == '\n')

61 
lim
 += 2;

67 if ((
err
 = 
	`kwsincr
 (
kwset
, 
beg
, 
end
 - beg)) != 
NULL
)

68 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
err
);

69 
beg
 = 
lim
;

71 while (
beg
 < 
pat
 + 
psize
);

73 if ((
err
 = 
	`kwsprep
 (
kwset
)) != 
NULL
)

74 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
err
);

75 
	}
}

77 
size_t


78 
	$Fexecute
 (char const *
buf
, 
size_t
 
size
, size_t *
match_size
,

79 char const *
start_ptr
)

81 char const *
beg
, *
try
, *
end
, *
mb_start
;

82 
size_t
 
len
;

83 char 
eol
 = 
eolbyte
;

84 struct 
kwsmatch
 kwsmatch;

85 
size_t
 
ret_val
;

86 if (
MB_CUR_MAX
 > 1)

88 if (
match_icase
)

90 char *
case_buf
 = 
	`mbtolower
 (
buf
, &
size
);

91 if (
start_ptr
)

92 
start_ptr
 = 
case_buf
 + (start_ptr - 
buf
);

93 
buf
 = 
case_buf
;

97 for (
mb_start
 = 
beg
 = 
start_ptr
 ? start_ptr : 
buf
; beg <= buf + 
size
; beg++)

99 
size_t
 
offset
 = 
	`kwsexec
 (
kwset
, 
beg
, 
buf
 + 
size
 - beg, &
kwsmatch
);

100 if (
offset
 == (
size_t
) -1)

101 goto 
failure
;

102 
len
 = 
kwsmatch
.
size
[0];

103 if (
MB_CUR_MAX
 > 1

104 && 
	`is_mb_middle
 (&
mb_start
, 
beg
 + 
offset
, 
buf
 + 
size
, 
len
))

108 
mbstate_t
 
s
;

109 
	`memset
 (&
s
, 0, sizeof s);

110 
size_t
 
mb_len
 = 
	`mbrlen
 (
mb_start
, (
buf
 + 
size
) - (
beg
 + 
offset
), &
s
);

111 if (
mb_len
 == (
size_t
) -2)

112 goto 
failure
;

113 
beg
 = 
mb_start
;

114 if (
mb_len
 != (
size_t
) -1)

115 
beg
 += 
mb_len
 - 1;

118 
beg
 += 
offset
;

119 if (
start_ptr
 && !
match_words
)

120 goto 
success_in_beg_and_len
;

121 if (
match_lines
)

123 if (
beg
 > 
buf
 && beg[-1] != 
eol
)

125 if (
beg
 + 
len
 < 
buf
 + 
size
 && beg[len] != 
eol
)

127 goto 
success
;

129 else if (
match_words
)

130 for (
try
 = 
beg
; ; )

132 if (
try
 > 
buf
 && 
	`WCHAR
((unsigned char) try[-1]))

134 if (
try
 + 
len
 < 
buf
 + 
size
 && 
	`WCHAR
((unsigned char) try[len]))

136 if (!
len
)

138 
offset
 = 
	`kwsexec
 (
kwset
, 
beg
, --
len
, &
kwsmatch
);

139 if (
offset
 == (
size_t
) -1)

141 
try
 = 
beg
 + 
offset
;

142 
len
 = 
kwsmatch
.
size
[0];

144 else if (!
start_ptr
)

145 goto 
success
;

147 goto 
success_in_beg_and_len
;

150 goto 
success
;

153 
failure
:

154 
ret_val
 = -1;

155 goto 
out
;

157 
success
:

158 if ((
end
 = 
	`memchr
 (
beg
 + 
len
, 
eol
, (
buf
 + 
size
) - (beg + len))) != 
NULL
)

159 
end
++;

161 
end
 = 
buf
 + 
size
;

162 while (
buf
 < 
beg
 && beg[-1] != 
eol
)

163 --
beg
;

164 
len
 = 
end
 - 
beg
;

165 
success_in_beg_and_len
:

166 *
match_size
 = 
len
;

167 
ret_val
 = 
beg
 - 
buf
;

168 
out
:

169 return 
ret_val
;

170 
	}
}

	@src/kwset.c

32 #include 
	~<config.h
>

33 #include 
	~<sys/types.h
>

34 #include 
	~"system.h
"

35 #include 
	~"kwset.h
"

36 #include 
	~"obstack.h
"

38 #define 
	#link
 
kwset_link


	)

40 #ifdef 
GREP


41 #include 
	~"xalloc.h
"

42 #undef 
malloc


43 #define 
	#malloc
 
xmalloc


	)

46 #define 
	#NCHAR
 (
UCHAR_MAX
 + 1)

	)

47 #define 
	#obstack_chunk_alloc
 
malloc


	)

48 #define 
	#obstack_chunk_free
 
free


	)

50 #define 
	#U
(
c
) ((unsigned char) (c))

	)

53 struct 
	stree


55 struct 
tree
 *
	mllink
;

56 struct 
tree
 *
	mrlink
;

57 struct 
trie
 *
	mtrie
;

58 unsigned char 
	mlabel
;

59 char 
	mbalance
;

63 struct 
	strie


65 unsigned int 
	maccepting
;

66 struct 
tree
 *
	mlinks
;

67 struct 
trie
 *
	mparent
;

68 struct 
trie
 *
	mnext
;

69 struct 
trie
 *
	mfail
;

70 int 
	mdepth
;

71 int 
	mshift
;

72 int 
	mmaxshift
;

76 struct 
	skwset


78 struct 
obstack
 
	mobstack
;

79 int 
	mwords
;

80 struct 
trie
 *
	mtrie
;

81 int 
	mmind
;

82 int 
	mmaxd
;

83 unsigned char 
	mdelta
[
NCHAR
];

84 struct 
trie
 *
	mnext
[
NCHAR
];

85 char *
	mtarget
;

86 int 
	mmind2
;

87 char const *
	mtrans
;

92 
kwset_t


93 
	$kwsalloc
 (char const *
trans
)

95 struct 
kwset
 *kwset;

97 
kwset
 = (struct kwset *) 
	`malloc
(sizeof (struct kwset));

98 if (!
kwset
)

99 return 
NULL
;

101 
	`obstack_init
(&
kwset
->
obstack
);

102 
kwset
->
words
 = 0;

103 
kwset
->
trie


104 = (struct 
trie
 *) 
	`obstack_alloc
(&
kwset
->
obstack
, sizeof (struct trie));

105 if (!
kwset
->
trie
)

107 
	`kwsfree
((
kwset_t
) 
kwset
);

108 return 
NULL
;

110 
kwset
->
trie
->
accepting
 = 0;

111 
kwset
->
trie
->
links
 = 
NULL
;

112 
kwset
->
trie
->
parent
 = 
NULL
;

113 
kwset
->
trie
->
next
 = 
NULL
;

114 
kwset
->
trie
->
fail
 = 
NULL
;

115 
kwset
->
trie
->
depth
 = 0;

116 
kwset
->
trie
->
shift
 = 0;

117 
kwset
->
mind
 = 
INT_MAX
;

118 
kwset
->
maxd
 = -1;

119 
kwset
->
target
 = 
NULL
;

120 
kwset
->
trans
 = trans;

122 return (
kwset_t
) 
kwset
;

123 
	}
}

127 #define 
	#DEPTH_SIZE
 (
CHAR_BIT
 + CHAR_BIT/2)

	)

132 
	$kwsincr
 (
kwset_t
 
kws
, char const *
text
, 
size_t
 
len
)

134 struct 
kwset
 *kwset;

135 struct 
trie
 *trie;

136 unsigned char 
label
;

137 struct 
tree
 *
link
;

138 int 
depth
;

139 struct 
tree
 *
links
[
DEPTH_SIZE
];

140 enum { 
L
, 
R
 } 
dirs
[
DEPTH_SIZE
];

141 struct 
tree
 *
t
, *
r
, *
l
, *
rl
, *
lr
;

143 
kwset
 = (struct kwset *) 
kws
;

144 
trie
 = 
kwset
->trie;

145 
text
 += 
len
;

149 while (
len
--)

151 
label
 = 
kwset
->
trans
 ? kwset->trans[
	`U
(*--
text
)] : *--text;

156 
link
 = 
trie
->
links
;

157 
links
[0] = (struct 
tree
 *) &
trie
->links;

158 
dirs
[0] = 
L
;

159 
depth
 = 1;

161 while (
link
 && 
label
 != link->label)

163 
links
[
depth
] = 
link
;

164 if (
label
 < 
link
->label)

165 
dirs
[
depth
++] = 
L
, 
link
 = link->
llink
;

167 
dirs
[
depth
++] = 
R
, 
link
 = link->
rlink
;

173 if (!
link
)

175 
link
 = (struct 
tree
 *) 
	`obstack_alloc
(&
kwset
->
obstack
,

176 sizeof (struct 
tree
));

177 if (!
link
)

178 return 
	`_
("memory exhausted");

179 
link
->
llink
 = 
NULL
;

180 
link
->
rlink
 = 
NULL
;

181 
link
->
trie
 = (struct trie *) 
	`obstack_alloc
(&
kwset
->
obstack
,

182 sizeof (struct 
trie
));

183 if (!
link
->
trie
)

185 
	`obstack_free
(&
kwset
->
obstack
, 
link
);

186 return 
	`_
("memory exhausted");

188 
link
->
trie
->
accepting
 = 0;

189 
link
->
trie
->
links
 = 
NULL
;

190 
link
->
trie
->
parent
 = trie;

191 
link
->
trie
->
next
 = 
NULL
;

192 
link
->
trie
->
fail
 = 
NULL
;

193 
link
->
trie
->
depth
 = trie->depth + 1;

194 
link
->
trie
->
shift
 = 0;

195 
link
->
label
 = label;

196 
link
->
balance
 = 0;

199 if (
dirs
[--
depth
] == 
L
)

200 
links
[
depth
]->
llink
 = 
link
;

202 
links
[
depth
]->
rlink
 = 
link
;

205 while (
depth
 && !
links
[depth]->
balance
)

207 if (
dirs
[
depth
] == 
L
)

208 --
links
[
depth
]->
balance
;

210 ++
links
[
depth
]->
balance
;

211 --
depth
;

215 if (
depth
 && ((
dirs
[depth] == 
L
 && --
links
[depth]->
balance
)

216 || (
dirs
[
depth
] == 
R
 && ++
links
[depth]->
balance
)))

218 switch (
links
[
depth
]->
balance
)

221 switch (
dirs
[
depth
 + 1])

223 case 
L
:

224 
r
 = 
links
[
depth
], 
t
 = r->
llink
, 
rl
 = t->
rlink
;

225 
t
->
rlink
 = 
r
, r->
llink
 = 
rl
;

226 
t
->
balance
 = 
r
->balance = 0;

228 case 
R
:

229 
r
 = 
links
[
depth
], 
l
 = r->
llink
, 
t
 = l->
rlink
;

230 
rl
 = 
t
->
rlink
, 
lr
 = t->
llink
;

231 
t
->
llink
 = 
l
, l->
rlink
 = 
lr
, t->rlink = 
r
, r->llink = 
rl
;

232 
l
->
balance
 = 
t
->balance != 1 ? 0 : -1;

233 
r
->
balance
 = 
t
->balance != (char) -1 ? 0 : 1;

234 
t
->
balance
 = 0;

237 
	`abort
 ();

241 switch (
dirs
[
depth
 + 1])

243 case 
R
:

244 
l
 = 
links
[
depth
], 
t
 = l->
rlink
, 
lr
 = t->
llink
;

245 
t
->
llink
 = 
l
, l->
rlink
 = 
lr
;

246 
t
->
balance
 = 
l
->balance = 0;

248 case 
L
:

249 
l
 = 
links
[
depth
], 
r
 = l->
rlink
, 
t
 = r->
llink
;

250 
lr
 = 
t
->
llink
, 
rl
 = t->
rlink
;

251 
t
->
llink
 = 
l
, l->
rlink
 = 
lr
, t->rlink = 
r
, r->llink = 
rl
;

252 
l
->
balance
 = 
t
->balance != 1 ? 0 : -1;

253 
r
->
balance
 = 
t
->balance != (char) -1 ? 0 : 1;

254 
t
->
balance
 = 0;

257 
	`abort
 ();

261 
	`abort
 ();

264 if (
dirs
[
depth
 - 1] == 
L
)

265 
links
[
depth
 - 1]->
llink
 = 
t
;

267 
links
[
depth
 - 1]->
rlink
 = 
t
;

271 
trie
 = 
link
->trie;

276 if (!
trie
->
accepting
)

277 
trie
->
accepting
 = 1 + 2 * 
kwset
->
words
;

278 ++
kwset
->
words
;

281 if (
trie
->
depth
 < 
kwset
->
mind
)

282 
kwset
->
mind
 = 
trie
->
depth
;

283 if (
trie
->
depth
 > 
kwset
->
maxd
)

284 
kwset
->
maxd
 = 
trie
->
depth
;

286 return 
NULL
;

287 
	}
}

292 
	$enqueue
 (struct 
tree
 *tree, struct 
trie
 **
last
)

294 if (!
tree
)

296 
	`enqueue
(
tree
->
llink
, 
last
);

297 
	`enqueue
(
tree
->
rlink
, 
last
);

298 (*
last
) = (*last)->
next
 = 
tree
->
trie
;

299 
	}
}

305 
	$treefails
 (struct 
tree
 const *tree, struct 
trie
 const *
fail
,

306 struct 
trie
 *
recourse
)

308 struct 
tree
 *
link
;

310 if (!
tree
)

313 
	`treefails
(
tree
->
llink
, 
fail
, 
recourse
);

314 
	`treefails
(
tree
->
rlink
, 
fail
, 
recourse
);

318 while (
fail
)

320 
link
 = 
fail
->
links
;

321 while (
link
 && 
tree
->
label
 != link->label)

322 if (
tree
->
label
 < 
link
->label)

323 
link
 = link->
llink
;

325 
link
 = link->
rlink
;

326 if (
link
)

328 
tree
->
trie
->
fail
 = 
link
->trie;

331 
fail
 = fail->fail;

334 
tree
->
trie
->
fail
 = 
recourse
;

335 
	}
}

340 
	$treedelta
 (struct 
tree
 const *tree,

341 unsigned int 
depth
,

342 unsigned char 
delta
[])

344 if (!
tree
)

346 
	`treedelta
(
tree
->
llink
, 
depth
, 
delta
);

347 
	`treedelta
(
tree
->
rlink
, 
depth
, 
delta
);

348 if (
depth
 < 
delta
[
tree
->
label
])

349 
delta
[
tree
->
label
] = 
depth
;

350 
	}
}

354 
	$hasevery
 (struct 
tree
 const *
a
, struct tree const *
b
)

356 if (!
b
)

358 if (!
	`hasevery
(
a
, 
b
->
llink
))

360 if (!
	`hasevery
(
a
, 
b
->
rlink
))

362 while (
a
 && 
b
->
label
 != a->label)

363 if (
b
->
label
 < 
a
->label)

364 
a
 = a->
llink
;

366 
a
 = a->
rlink
;

367 return !!
a
;

368 
	}
}

373 
	$treenext
 (struct 
tree
 const *tree, struct 
trie
 *
next
[])

375 if (!
tree
)

377 
	`treenext
(
tree
->
llink
, 
next
);

378 
	`treenext
(
tree
->
rlink
, 
next
);

379 
next
[
tree
->
label
] = tree->
trie
;

380 
	}
}

385 
	$kwsprep
 (
kwset_t
 
kws
)

387 struct 
kwset
 *kwset;

388 int 
i
;

389 struct 
trie
 *
curr
;

390 char const *
trans
;

391 unsigned char 
delta
[
NCHAR
];

393 
kwset
 = (struct kwset *) 
kws
;

398 
	`memset
(
delta
, 
kwset
->
mind
 < 
UCHAR_MAX
 ? kwset->mind : UCHAR_MAX, 
NCHAR
);

402 if (
kwset
->
words
 == 1 && kwset->
trans
 == 
NULL
)

404 char 
c
;

407 
kwset
->
target
 = 
	`obstack_alloc
(&kwset->
obstack
, kwset->
mind
);

408 if (!
kwset
->
target
)

409 return 
	`_
("memory exhausted");

410 for (
i
 = 
kwset
->
mind
 - 1, 
curr
 = kwset->
trie
; i >= 0; --i)

412 
kwset
->
target
[
i
] = 
curr
->
links
->
label
;

413 
curr
 = curr->
links
->
trie
;

416 for (
i
 = 0; i < 
kwset
->
mind
; ++i)

417 
delta
[
	`U
(
kwset
->
target
[
i
])] = kwset->
mind
 - (i + 1);

420 
c
 = 
kwset
->
target
[kwset->
mind
 - 1];

421 for (
i
 = 
kwset
->
mind
 - 2; i >= 0; --i)

422 if (
kwset
->
target
[
i
] == 
c
)

424 
kwset
->
mind2
 = kwset->
mind
 - (
i
 + 1);

428 struct 
trie
 *
fail
;

429 struct 
trie
 *
last
, *
next
[
NCHAR
];

433 for (
curr
 = 
last
 = 
kwset
->
trie
; curr; curr = curr->
next
)

436 
	`enqueue
(
curr
->
links
, &
last
);

438 
curr
->
shift
 = 
kwset
->
mind
;

439 
curr
->
maxshift
 = 
kwset
->
mind
;

442 
	`treedelta
(
curr
->
links
, curr->
depth
, 
delta
);

445 
	`treefails
(
curr
->
links
, curr->
fail
, 
kwset
->
trie
);

449 for (
fail
 = 
curr
->fail; fail; fail = fail->fail)

454 if (!
	`hasevery
(
fail
->
links
, 
curr
->links))

455 if (
curr
->
depth
 - 
fail
->depth < fail->
shift
)

456 
fail
->
shift
 = 
curr
->
depth
 - fail->depth;

461 if (
curr
->
accepting
 && 
fail
->
maxshift
 > curr->
depth
 - fail->depth)

462 
fail
->
maxshift
 = 
curr
->
depth
 - fail->depth;

468 for (
curr
 = 
kwset
->
trie
->
next
; curr; curr = curr->next)

470 if (
curr
->
maxshift
 > curr->
parent
->maxshift)

471 
curr
->
maxshift
 = curr->
parent
->maxshift;

472 if (
curr
->
shift
 > curr->
maxshift
)

473 
curr
->
shift
 = curr->
maxshift
;

478 for (
i
 = 0; i < 
NCHAR
; ++i)

479 
next
[
i
] = 
NULL
;

480 
	`treenext
(
kwset
->
trie
->
links
, 
next
);

482 if ((
trans
 = 
kwset
->trans) != 
NULL
)

483 for (
i
 = 0; i < 
NCHAR
; ++i)

484 
kwset
->
next
[
i
] = next[
	`U
(
trans
[i])];

486 
	`memcpy
(
kwset
->
next
, next, 
NCHAR
 * sizeof(struct 
trie
 *));

490 if ((
trans
 = 
kwset
->trans) != 
NULL
)

491 for (
i
 = 0; i < 
NCHAR
; ++i)

492 
kwset
->
delta
[
i
] = delta[
	`U
(
trans
[i])];

494 
	`memcpy
(
kwset
->
delta
, delta, 
NCHAR
);

496 return 
NULL
;

497 
	}
}

500 static 
size_t


501 
	$bmexec
 (
kwset_t
 
kws
, char const *
text
, 
size_t
 
size
)

503 struct 
kwset
 const *kwset;

504 unsigned char const *
d1
;

505 char const *
ep
, *
sp
, *
tp
;

506 int 
d
, 
gc
, 
i
, 
len
, 
md2
;

508 
kwset
 = (struct kwset const *) 
kws
;

509 
len
 = 
kwset
->
mind
;

511 if (
len
 == 0)

513 if (
len
 > 
size
)

515 if (
len
 == 1)

517 
tp
 = 
	`memchr
 (
text
, 
kwset
->
target
[0], 
size
);

518 return 
tp
 ? tp - 
text
 : -1;

521 
d1
 = 
kwset
->
delta
;

522 
sp
 = 
kwset
->
target
 + 
len
;

523 
gc
 = 
	`U
(
sp
[-2]);

524 
md2
 = 
kwset
->
mind2
;

525 
tp
 = 
text
 + 
len
;

528 if (
size
 > 12 * 
len
)

530 for (
ep
 = 
text
 + 
size
 - 11 * 
len
;;)

532 while (
tp
 <= 
ep
)

534 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

535 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

536 if (
d
 == 0)

537 goto 
found
;

538 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

539 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

540 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

541 if (
d
 == 0)

542 goto 
found
;

543 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

544 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

545 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

546 if (
d
 == 0)

547 goto 
found
;

548 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

549 
d
 = 
d1
[
	`U
(
tp
[-1])], tp += d;

552 
found
:

553 if (
	`U
(
tp
[-2]) == 
gc
)

555 for (
i
 = 3; i <= 
len
 && 
	`U
(
tp
[-i]) == U(
sp
[-i]); ++i)

557 if (
i
 > 
len
)

558 return 
tp
 - 
len
 - 
text
;

560 
tp
 += 
md2
;

565 
ep
 = 
text
 + 
size
;

566 
d
 = 
d1
[
	`U
(
tp
[-1])];

567 while (
d
 <= 
ep
 - 
tp
)

569 
d
 = 
d1
[
	`U
((
tp
 += d)[-1])];

570 if (
d
 != 0)

572 if (
	`U
(
tp
[-2]) == 
gc
)

574 for (
i
 = 3; i <= 
len
 && 
	`U
(
tp
[-i]) == U(
sp
[-i]); ++i)

576 if (
i
 > 
len
)

577 return 
tp
 - 
len
 - 
text
;

579 
d
 = 
md2
;

583 
	}
}

586 static 
size_t
 
_GL_ARG_NONNULL
 ((4))

587 
	$cwexec
 (
kwset_t
 
kws
, char const *
text
, 
size_t
 
len
, struct 
kwsmatch
 *kwsmatch)

589 struct 
kwset
 const *kwset;

590 struct 
trie
 * const *
next
;

591 struct 
trie
 const *trie;

592 struct 
trie
 const *
accept
;

593 char const *
beg
, *
lim
, *
mch
, *
lmch
;

594 unsigned char 
c
;

595 unsigned char const *
delta
;

596 int 
d
;

597 char const *
end
, *
qlim
;

598 struct 
tree
 const *tree;

599 char const *
trans
;

601 #ifdef 
lint


602 
accept
 = 
NULL
;

606 
kwset
 = (struct kwset *) 
kws
;

607 if (
len
 < 
kwset
->
mind
)

609 
next
 = 
kwset
->next;

610 
delta
 = 
kwset
->delta;

611 
trans
 = 
kwset
->trans;

612 
lim
 = 
text
 + 
len
;

613 
end
 = 
text
;

614 if ((
d
 = 
kwset
->
mind
) != 0)

615 
mch
 = 
NULL
;

618 
mch
 = 
text
, 
accept
 = 
kwset
->
trie
;

619 goto 
match
;

622 if (
len
 >= 4 * 
kwset
->
mind
)

623 
qlim
 = 
lim
 - 4 * 
kwset
->
mind
;

625 
qlim
 = 
NULL
;

627 while (
lim
 - 
end
 >= 
d
)

629 if (
qlim
 && 
end
 <= qlim)

631 
end
 += 
d
 - 1;

632 while ((
d
 = 
delta
[
c
 = *
end
]) && end < 
qlim
)

634 
end
 += 
d
;

635 
end
 += 
delta
[
	`U
(*end)];

636 
end
 += 
delta
[
	`U
(*end)];

638 ++
end
;

641 
d
 = 
delta
[
c
 = (
end
 += d)[-1]];

642 if (
d
)

644 
beg
 = 
end
 - 1;

645 
trie
 = 
next
[
c
];

646 if (
trie
->
accepting
)

648 
mch
 = 
beg
;

649 
accept
 = 
trie
;

651 
d
 = 
trie
->
shift
;

652 while (
beg
 > 
text
)

654 
c
 = 
trans
 ? trans[
	`U
(*--
beg
)] : *--beg;

655 
tree
 = 
trie
->
links
;

656 while (
tree
 && 
c
 != tree->
label
)

657 if (
c
 < 
tree
->
label
)

658 
tree
 = tree->
llink
;

660 
tree
 = tree->
rlink
;

661 if (
tree
)

663 
trie
 = 
tree
->trie;

664 if (
trie
->
accepting
)

666 
mch
 = 
beg
;

667 
accept
 = 
trie
;

672 
d
 = 
trie
->
shift
;

674 if (
mch
)

675 goto 
match
;

679 
match
:

683 if (
lim
 - 
mch
 > 
kwset
->
maxd
)

684 
lim
 = 
mch
 + 
kwset
->
maxd
;

685 
lmch
 = 0;

686 
d
 = 1;

687 while (
lim
 - 
end
 >= 
d
)

689 if ((
d
 = 
delta
[
c
 = (
end
 += d)[-1]]) != 0)

691 
beg
 = 
end
 - 1;

692 if (!(
trie
 = 
next
[
c
]))

694 
d
 = 1;

697 if (
trie
->
accepting
 && 
beg
 <= 
mch
)

699 
lmch
 = 
beg
;

700 
accept
 = 
trie
;

702 
d
 = 
trie
->
shift
;

703 while (
beg
 > 
text
)

705 
c
 = 
trans
 ? trans[
	`U
(*--
beg
)] : *--beg;

706 
tree
 = 
trie
->
links
;

707 while (
tree
 && 
c
 != tree->
label
)

708 if (
c
 < 
tree
->
label
)

709 
tree
 = tree->
llink
;

711 
tree
 = tree->
rlink
;

712 if (
tree
)

714 
trie
 = 
tree
->trie;

715 if (
trie
->
accepting
 && 
beg
 <= 
mch
)

717 
lmch
 = 
beg
;

718 
accept
 = 
trie
;

723 
d
 = 
trie
->
shift
;

725 if (
lmch
)

727 
mch
 = 
lmch
;

728 goto 
match
;

730 if (!
d
)

731 
d
 = 1;

734 
kwsmatch
->
index
 = 
accept
->
accepting
 / 2;

735 
kwsmatch
->
offset
[0] = 
mch
 - 
text
;

736 
kwsmatch
->
size
[0] = 
accept
->
depth
;

738 return 
mch
 - 
text
;

739 
	}
}

746 
size_t


747 
	$kwsexec
 (
kwset_t
 
kws
, char const *
text
, 
size_t
 
size
, struct 
kwsmatch
 *kwsmatch)

749 struct 
kwset
 const *kwset = (struct kwset *) 
kws
;

750 if (
kwset
->
words
 == 1 && kwset->
trans
 == 
NULL
)

752 
size_t
 
ret
 = 
	`bmexec
 (
kws
, 
text
, 
size
);

753 if (
ret
 != (
size_t
) -1)

755 
kwsmatch
->
index
 = 0;

756 
kwsmatch
->
offset
[0] = 
ret
;

757 
kwsmatch
->
size
[0] = 
kwset
->
mind
;

759 return 
ret
;

762 return 
	`cwexec
(
kws
, 
text
, 
size
, 
kwsmatch
);

763 
	}
}

767 
	$kwsfree
 (
kwset_t
 
kws
)

769 struct 
kwset
 *kwset;

771 
kwset
 = (struct kwset *) 
kws
;

772 
	`obstack_free
(&
kwset
->
obstack
, 
NULL
);

773 
	`free
(
kws
);

774 
	}
}

	@src/kwset.h

24 struct 
	skwsmatch


26 int 
	mindex
;

27 
size_t
 
	moffset
[1];

28 
size_t
 
	msize
[1];

31 #include 
	~"arg-nonnull.h
"

33 struct 
	gkwset
;

34 typedef struct 
kwset
 *
	tkwset_t
;

40 extern 
kwset_t
 
kwsalloc
 (char const *);

45 extern const char *
kwsincr
 (
kwset_t
, char const *, 
size_t
);

49 extern const char *
kwsprep
 (
kwset_t
);

57 extern 
size_t
 
	$kwsexec
 (
kwset_t
, char const *, 
size_t
, struct 
kwsmatch
 *)

58 
	`_GL_ARG_NONNULL
 ((4));

61 extern void 
	`kwsfree
 (
kwset_t
);

	@src/main.c

21 #include 
	~<config.h
>

22 #include 
	~<sys/types.h
>

23 #include 
	~<sys/stat.h
>

24 #if 
defined
 
HAVE_SETRLIMIT


25 #include 
	~<sys/time.h
>

26 #include 
	~<sys/resource.h
>

28 #include 
	~"mbsupport.h
"

29 #include 
	~<wchar.h
>

30 #include 
	~<wctype.h
>

31 #include 
	~<fcntl.h
>

32 #include 
	~<stdio.h
>

33 #include 
	~"system.h
"

35 #include 
	~"argmatch.h
"

36 #include 
	~"c-ctype.h
"

37 #include 
	~"closeout.h
"

38 #include 
	~"error.h
"

39 #include 
	~"exclude.h
"

40 #include 
	~"exitfail.h
"

41 #include 
	~"getopt.h
"

42 #include 
	~"grep.h
"

43 #include 
	~"intprops.h
"

44 #include 
	~"isdir.h
"

45 #include 
	~"progname.h
"

46 #include 
	~"propername.h
"

47 #include 
	~"quote.h
"

48 #include 
	~"savedir.h
"

49 #include 
	~"version-etc.h
"

50 #include 
	~"xalloc.h
"

51 #include 
	~"xstrtol.h
"

53 #define 
	#SEP_CHAR_SELECTED
 ':'

	)

54 #define 
	#SEP_CHAR_REJECTED
 '-'

	)

55 #define 
	#SEP_STR_GROUP
 "--"

	)

57 #define 
	#STREQ
(
a
, 
b
) (
	`strcmp
 (a, b) == 0)

	)

59 #define 
	#AUTHORS
 \

60 
	`proper_name
 ("Mike Haertel"), \

61 
	`_
("others, see <http://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS>")

	)

66 static struct 
stat
 
	gout_stat
;

68 struct 
	sstats


70 struct 
stats
 const *
	mparent
;

71 struct 
stat
 
	mstat
;

75 static struct 
stats
 
	gstats_base
;

78 static int 
	gshow_help
;

81 static int 
	gshow_version
;

84 static int 
	gsuppress_errors
;

87 static int 
	gcolor_option
;

90 static int 
	gonly_matching
;

93 static int 
	galign_tabs
;

96 static const char *
	ggroup_separator
 = 
SEP_STR_GROUP
;

143 static const char *
	gselected_match_color
 = "01;31";

144 static const char *
	gcontext_match_color
 = "01;31";

147 static const char *
	gfilename_color
 = "35";

148 static const char *
	gline_num_color
 = "32";

149 static const char *
	gbyte_num_color
 = "32";

150 static const char *
	gsep_color
 = "36";

151 static const char *
	gselected_line_color
 = "";

152 static const char *
	gcontext_line_color
 = "";

211 static const char *
	gsgr_start
 = "\33[%sm\33[K";

212 #define 
	#SGR_START
 
sgr_start


	)

213 static const char *
	gsgr_end
 = "\33[m\33[K";

214 #define 
	#SGR_END
 
sgr_end


	)

217 #define 
	#PR_SGR_FMT
(
fmt
, 
s
) do { if (*(s)) 
	`printf
((fmt), (s)); } while (0)

	)

218 #define 
	#PR_SGR_FMT_IF
(
fmt
, 
s
) \

219 do { if (
color_option
 && *(
s
)) 
	`printf
((
fmt
), (s)); } while (0)

	)

220 #define 
	#PR_SGR_START
(
s
) 
	`PR_SGR_FMT
( 
SGR_START
, (s))

	)

221 #define 
	#PR_SGR_END
(
s
) 
	`PR_SGR_FMT
( 
SGR_END
, (s))

	)

222 #define 
	#PR_SGR_START_IF
(
s
) 
	`PR_SGR_FMT_IF
(
SGR_START
, (s))

	)

223 #define 
	#PR_SGR_END_IF
(
s
) 
	`PR_SGR_FMT_IF
(
SGR_END
, (s))

	)

225 struct 
	scolor_cap


227 const char *
	mname
;

228 const char **
	mvar
;

229 const char *(*
	mfct
)(void);

233 
	$color_cap_mt_fct
(void)

236 
context_match_color
 = 
selected_match_color
;

238 return 
NULL
;

239 
	}
}

242 
	$color_cap_rv_fct
(void)

245 
color_option
 = -1;

247 return 
NULL
;

248 
	}
}

251 
	$color_cap_ne_fct
(void)

253 
sgr_start
 = "\33[%sm";

254 
sgr_end
 = "\33[m";

256 return 
NULL
;

257 
	}
}

260 static struct 
color_cap
 
	gcolor_dict
[] =

262 { "mt", &
selected_match_color
, 
color_cap_mt_fct
 },

263 { "ms", &
selected_match_color
, 
NULL
 },

264 { "mc", &
context_match_color
, 
NULL
 },

265 { "fn", &
filename_color
, 
NULL
 },

266 { "ln", &
line_num_color
, 
NULL
 },

267 { "bn", &
byte_num_color
, 
NULL
 },

268 { "se", &
sep_color
, 
NULL
 },

269 { "sl", &
selected_line_color
, 
NULL
 },

270 { "cx", &
context_line_color
, 
NULL
 },

271 { "rv", 
NULL
, 
color_cap_rv_fct
 },

272 { "ne", 
NULL
, 
color_cap_ne_fct
 },

273 { 
NULL
, NULL, NULL }

276 static struct 
exclude
 *
	gexcluded_patterns
;

277 static struct 
exclude
 *
	gincluded_patterns
;

278 static struct 
exclude
 *
	gexcluded_directory_patterns
;

280 static char const 
	gshort_options
[] =

286 
	mBINARY_FILES_OPTION
 = 
CHAR_MAX
 + 1,

287 
	mCOLOR_OPTION
,

288 
	mINCLUDE_OPTION
,

289 
	mEXCLUDE_OPTION
,

290 
	mEXCLUDE_FROM_OPTION
,

291 
	mLINE_BUFFERED_OPTION
,

292 
	mLABEL_OPTION
,

293 
	mEXCLUDE_DIRECTORY_OPTION
,

294 
	mGROUP_SEPARATOR_OPTION
,

295 
	mMMAP_OPTION


299 static struct 
option
 const 
	glong_options
[] =

301 {"basic-regexp", 
no_argument
, 
NULL
, 'G'},

302 {"extended-regexp", 
no_argument
, 
NULL
, 'E'},

303 {"fixed-regexp", 
no_argument
, 
NULL
, 'F'},

304 {"fixed-strings", 
no_argument
, 
NULL
, 'F'},

305 {"perl-regexp", 
no_argument
, 
NULL
, 'P'},

306 {"after-context", 
required_argument
, 
NULL
, 'A'},

307 {"before-context", 
required_argument
, 
NULL
, 'B'},

308 {"binary-files", 
required_argument
, 
NULL
, 
BINARY_FILES_OPTION
},

309 {"byte-offset", 
no_argument
, 
NULL
, 'b'},

310 {"context", 
required_argument
, 
NULL
, 'C'},

311 {"color", 
optional_argument
, 
NULL
, 
COLOR_OPTION
},

312 {"colour", 
optional_argument
, 
NULL
, 
COLOR_OPTION
},

313 {"count", 
no_argument
, 
NULL
, 'c'},

314 {"devices", 
required_argument
, 
NULL
, 'D'},

315 {"directories", 
required_argument
, 
NULL
, 'd'},

316 {"exclude", 
required_argument
, 
NULL
, 
EXCLUDE_OPTION
},

317 {"exclude-from", 
required_argument
, 
NULL
, 
EXCLUDE_FROM_OPTION
},

318 {"exclude-dir", 
required_argument
, 
NULL
, 
EXCLUDE_DIRECTORY_OPTION
},

319 {"file", 
required_argument
, 
NULL
, 'f'},

320 {"files-with-matches", 
no_argument
, 
NULL
, 'l'},

321 {"files-without-match", 
no_argument
, 
NULL
, 'L'},

322 {"group-separator", 
required_argument
, 
NULL
, 
GROUP_SEPARATOR_OPTION
},

323 {"help", 
no_argument
, &
show_help
, 1},

324 {"include", 
required_argument
, 
NULL
, 
INCLUDE_OPTION
},

325 {"ignore-case", 
no_argument
, 
NULL
, 'i'},

326 {"initial-tab", 
no_argument
, 
NULL
, 'T'},

327 {"label", 
required_argument
, 
NULL
, 
LABEL_OPTION
},

328 {"line-buffered", 
no_argument
, 
NULL
, 
LINE_BUFFERED_OPTION
},

329 {"line-number", 
no_argument
, 
NULL
, 'n'},

330 {"line-regexp", 
no_argument
, 
NULL
, 'x'},

331 {"max-count", 
required_argument
, 
NULL
, 'm'},

334 {"mmap", 
no_argument
, 
NULL
, 
MMAP_OPTION
},

335 {"no-filename", 
no_argument
, 
NULL
, 'h'},

336 {"no-group-separator", 
no_argument
, 
NULL
, 
GROUP_SEPARATOR_OPTION
},

337 {"no-messages", 
no_argument
, 
NULL
, 's'},

338 {"null", 
no_argument
, 
NULL
, 'Z'},

339 {"null-data", 
no_argument
, 
NULL
, 'z'},

340 {"only-matching", 
no_argument
, 
NULL
, 'o'},

341 {"quiet", 
no_argument
, 
NULL
, 'q'},

342 {"recursive", 
no_argument
, 
NULL
, 'r'},

343 {"recursive", 
no_argument
, 
NULL
, 'R'},

344 {"regexp", 
required_argument
, 
NULL
, 'e'},

345 {"invert-match", 
no_argument
, 
NULL
, 'v'},

346 {"silent", 
no_argument
, 
NULL
, 'q'},

347 {"text", 
no_argument
, 
NULL
, 'a'},

348 {"binary", 
no_argument
, 
NULL
, 'U'},

349 {"unix-byte-offsets", 
no_argument
, 
NULL
, 'u'},

350 {"version", 
no_argument
, 
NULL
, 'V'},

351 {"with-filename", 
no_argument
, 
NULL
, 'H'},

352 {"word-regexp", 
no_argument
, 
NULL
, 'w'},

357 int 
	gmatch_icase
;

358 int 
	gmatch_words
;

359 int 
	gmatch_lines
;

360 unsigned char 
	geolbyte
;

364 static char const *
	gfilename
;

365 static int 
	gerrseen
;

367 enum 
	edirectories_type


369 
	mREAD_DIRECTORIES
 = 2,

370 
	mRECURSE_DIRECTORIES
,

371 
	mSKIP_DIRECTORIES


375 static char const *const 
	gdirectories_args
[] =

377 "read", "recurse", "skip", 
NULL


379 static enum 
directories_type
 const 
	gdirectories_types
[] =

381 
READ_DIRECTORIES
, 
RECURSE_DIRECTORIES
, 
SKIP_DIRECTORIES


383 
ARGMATCH_VERIFY
 (
directories_args
, 
directories_types
);

385 static enum 
directories_type
 
	gdirectories
 = 
READ_DIRECTORIES
;

390 
	mREAD_DEVICES
,

391 
	mSKIP_DEVICES


392 } 
	gdevices
 = 
READ_DEVICES
;

394 static int 
grepdir
 (char const *, struct 
stats
 const *);

395 #if 
defined
 
HAVE_DOS_FILE_CONTENTS


396 static 
inline
 int 
undossify_input
 (char *, 
size_t
);

400 static 
compile_fp_t
 
	gcompile
;

401 static 
execute_fp_t
 
	gexecute
;

405 
	$suppressible_error
 (char const *
mesg
, int 
errnum
)

407 if (! 
suppress_errors
)

408 
	`error
 (0, 
errnum
, "%s", 
mesg
);

409 
errseen
 = 1;

410 
	}
}

416 
	$context_length_arg
 (char const *
str
, int *
out
)

418 
uintmax_t
 
value
;

419 if (! (
	`xstrtoumax
 (
str
, 0, 10, &
value
, "") == 
LONGINT_OK


420 && 0 <= (*
out
 = 
value
)

421 && *
out
 == 
value
))

423 
	`error
 (
EXIT_TROUBLE
, 0, "%s: %s", 
str
,

424 
	`_
("invalid context length argument"));

426 
	}
}

433 static char *
	gbuffer
;

434 static 
size_t
 
	gbufalloc
;

435 #define 
	#INITIAL_BUFSIZE
 32768

	)

436 static int 
	gbufdesc
;

437 static char *
	gbufbeg
;

438 static char *
	gbuflim
;

439 static 
size_t
 
	gpagesize
;

440 static 
off_t
 
	gbufoffset
;

441 static 
off_t
 
	gafter_last_match
;

447 #define 
	#ALIGN_TO
(
val
, 
alignment
) \

448 ((
size_t
) (
val
) % (
alignment
) == 0 \

449 ? (
val
) \

450 : (
val
) + ((
alignment
) - (
size_t
) (val) % (alignment)))

	)

455 
	$reset
 (int 
fd
, char const *
file
, struct 
stats
 *stats)

457 if (! 
pagesize
)

459 
pagesize
 = 
	`getpagesize
 ();

460 if (
pagesize
 == 0 || 2 * pagesize + 1 <= pagesize)

461 
	`abort
 ();

462 
bufalloc
 = 
	`ALIGN_TO
 (
INITIAL_BUFSIZE
, 
pagesize
) + pagesize + 1;

463 
buffer
 = 
	`xmalloc
 (
bufalloc
);

466 
bufbeg
 = 
buflim
 = 
	`ALIGN_TO
 (
buffer
 + 1, 
pagesize
);

467 
bufbeg
[-1] = 
eolbyte
;

468 
bufdesc
 = 
fd
;

470 if (
	`S_ISREG
 (
stats
->
stat
.
st_mode
))

472 if (
file
)

473 
bufoffset
 = 0;

476 
bufoffset
 = 
	`lseek
 (
fd
, 0, 
SEEK_CUR
);

477 if (
bufoffset
 < 0)

479 
	`error
 (0, 
errno
, 
	`_
("lseek failed"));

485 
	}
}

492 
	$fillbuf
 (
size_t
 
save
, struct 
stats
 const *stats)

494 
size_t
 
fillsize
 = 0;

495 int 
cc
 = 1;

496 char *
readbuf
;

497 
size_t
 
readsize
;

501 
size_t
 
saved_offset
 = 
buflim
 - 
save
 - 
buffer
;

503 if (
pagesize
 <= 
buffer
 + 
bufalloc
 - 
buflim
)

505 
readbuf
 = 
buflim
;

506 
bufbeg
 = 
buflim
 - 
save
;

510 
size_t
 
minsize
 = 
save
 + 
pagesize
;

511 
size_t
 
newsize
;

512 
size_t
 
newalloc
;

513 char *
newbuf
;

516 for (
newsize
 = 
bufalloc
 - 
pagesize
 - 1; newsize < 
minsize
; newsize *= 2)

517 if (
newsize
 * 2 < newsize || newsize * 2 + 
pagesize
 + 1 < newsize * 2)

518 
	`xalloc_die
 ();

525 if (
	`S_ISREG
 (
stats
->
stat
.
st_mode
))

527 
off_t
 
to_be_read
 = 
stats
->
stat
.
st_size
 - 
bufoffset
;

528 
off_t
 
maxsize_off
 = 
save
 + 
to_be_read
;

529 if (0 <= 
to_be_read
 && to_be_read <= 
maxsize_off


530 && 
maxsize_off
 == (
size_t
) maxsize_off

531 && 
minsize
 <= (
size_t
) 
maxsize_off


532 && (
size_t
) 
maxsize_off
 < 
newsize
)

533 
newsize
 = 
maxsize_off
;

538 
newalloc
 = 
newsize
 + 
pagesize
 + 1;

540 
newbuf
 = 
bufalloc
 < 
newalloc
 ? 
	`xmalloc
 (bufalloc = newalloc) : 
buffer
;

541 
readbuf
 = 
	`ALIGN_TO
 (
newbuf
 + 1 + 
save
, 
pagesize
);

542 
bufbeg
 = 
readbuf
 - 
save
;

543 
	`memmove
 (
bufbeg
, 
buffer
 + 
saved_offset
, 
save
);

544 
bufbeg
[-1] = 
eolbyte
;

545 if (
newbuf
 != 
buffer
)

547 
	`free
 (
buffer
);

548 
buffer
 = 
newbuf
;

552 
readsize
 = 
buffer
 + 
bufalloc
 - 
readbuf
;

553 
readsize
 -= readsize % 
pagesize
;

555 if (! 
fillsize
)

557 
ssize_t
 
bytesread
;

558 while ((
bytesread
 = 
	`read
 (
bufdesc
, 
readbuf
, 
readsize
)) < 0

559 && 
errno
 == 
EINTR
)

561 if (
bytesread
 < 0)

562 
cc
 = 0;

564 
fillsize
 = 
bytesread
;

567 
bufoffset
 += 
fillsize
;

568 #if 
defined
 
HAVE_DOS_FILE_CONTENTS


569 if (
fillsize
)

570 
fillsize
 = 
	`undossify_input
 (
readbuf
, fillsize);

572 
buflim
 = 
readbuf
 + 
fillsize
;

573 return 
cc
;

574 
	}
}

579 
	mBINARY_BINARY_FILES
,

580 
	mTEXT_BINARY_FILES
,

581 
	mWITHOUT_MATCH_BINARY_FILES


582 } 
	gbinary_files
;

584 static int 
	gfilename_mask
;

585 static int 
	gout_quiet
;

586 static int 
	gout_invert
;

587 static int 
	gout_file
;

588 static int 
	gout_line
;

589 static int 
	gout_byte
;

590 static int 
	gout_before
;

591 static int 
	gout_after
;

592 static int 
	gcount_matches
;

593 static int 
	glist_files
;

594 static int 
	gno_filenames
;

595 static 
off_t
 
	gmax_count
;

597 static int 
	gline_buffered
;

599 static char *
	glabel
 = 
NULL
;

603 static 
uintmax_t
 
	gtotalcc
;

604 static char const *
	glastnl
;

605 static char const *
	glastout
;

608 static 
uintmax_t
 
	gtotalnl
;

609 static 
off_t
 
	goutleft
;

610 static int 
	gpending
;

612 static int 
	gdone_on_match
;

613 static int 
	gexit_on_match
;

615 #if 
defined
 
HAVE_DOS_FILE_CONTENTS


616 #include 
	~"dosbuf.c
"

621 static 
uintmax_t


622 
	$add_count
 (
uintmax_t
 
a
, uintmax_t 
b
)

624 
uintmax_t
 
sum
 = 
a
 + 
b
;

625 if (
sum
 < 
a
)

626 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("input is too large to count"));

627 return 
sum
;

628 
	}
}

631 
	$nlscan
 (char const *
lim
)

633 
size_t
 
newlines
 = 0;

634 char const *
beg
;

635 for (
beg
 = 
lastnl
; beg < 
lim
; beg++)

637 
beg
 = 
	`memchr
 (beg, 
eolbyte
, 
lim
 - beg);

638 if (!
beg
)

640 
newlines
++;

642 
totalnl
 = 
	`add_count
 (totalnl, 
newlines
);

643 
lastnl
 = 
lim
;

644 
	}
}

648 
	$print_filename
 (void)

650 
	`PR_SGR_START_IF
(
filename_color
);

651 
	`fputs
(
filename
, 
stdout
);

652 
	`PR_SGR_END_IF
(
filename_color
);

653 
	}
}

657 
	$print_sep
 (char 
sep
)

659 
	`PR_SGR_START_IF
(
sep_color
);

660 
	`fputc
(
sep
, 
stdout
);

661 
	`PR_SGR_END_IF
(
sep_color
);

662 
	}
}

666 
	$print_offset
 (
uintmax_t
 
pos
, int 
min_width
, const char *
color
)

671 char 
buf
[sizeof 
pos
 * 
CHAR_BIT
];

672 char *
p
 = 
buf
 + sizeof buf;

676 *--
p
 = '0' + 
pos
 % 10;

677 --
min_width
;

679 while ((
pos
 /= 10) != 0);

682 if (
align_tabs
)

683 while (--
min_width
 >= 0)

684 *--
p
 = ' ';

686 
	`PR_SGR_START_IF
(
color
);

687 
	`fwrite
 (
p
, 1, 
buf
 + sizeof buf - p, 
stdout
);

688 
	`PR_SGR_END_IF
(
color
);

689 
	}
}

693 
	$print_line_head
 (char const *
beg
, char const *
lim
, int 
sep
)

695 int 
pending_sep
 = 0;

697 if (
out_file
)

699 
	`print_filename
();

700 if (
filename_mask
)

701 
pending_sep
 = 1;

703 
	`fputc
(0, 
stdout
);

706 if (
out_line
)

708 if (
lastnl
 < 
lim
)

710 
	`nlscan
 (
beg
);

711 
totalnl
 = 
	`add_count
 (totalnl, 1);

712 
lastnl
 = 
lim
;

714 if (
pending_sep
)

715 
	`print_sep
(
sep
);

716 
	`print_offset
 (
totalnl
, 4, 
line_num_color
);

717 
pending_sep
 = 1;

720 if (
out_byte
)

722 
uintmax_t
 
pos
 = 
	`add_count
 (
totalcc
, 
beg
 - 
bufbeg
);

723 #if 
defined
 
HAVE_DOS_FILE_CONTENTS


724 
pos
 = 
	`dossified_pos
 (pos);

726 if (
pending_sep
)

727 
	`print_sep
(
sep
);

728 
	`print_offset
 (
pos
, 6, 
byte_num_color
);

729 
pending_sep
 = 1;

732 if (
pending_sep
)

738 if (
align_tabs
)

739 
	`fputs
("\t\b", 
stdout
);

741 
	`print_sep
(
sep
);

743 
	}
}

746 
	$print_line_middle
 (const char *
beg
, const char *
lim
,

747 const char *
line_color
, const char *
match_color
)

749 
size_t
 
match_size
;

750 
size_t
 
match_offset
;

751 const char *
cur
 = 
beg
;

752 const char *
mid
 = 
NULL
;

754 while (
cur
 < 
lim


755 && ((
match_offset
 = 
	`execute
(
beg
, 
lim
 - beg, &
match_size
,

756 
beg
 + (
cur
 - beg))) != (
size_t
) -1))

758 char const *
b
 = 
beg
 + 
match_offset
;

761 if (
b
 == 
lim
)

765 if (
match_size
 == 0)

769 
match_size
 = 1;

770 if (!
mid
)

771 
mid
 = 
cur
;

777 if (
only_matching
)

778 
	`print_line_head
(
b
, 
lim
, 
out_invert
 ? 
SEP_CHAR_REJECTED


779 : 
SEP_CHAR_SELECTED
);

782 
	`PR_SGR_START
(
line_color
);

783 if (
mid
)

785 
cur
 = 
mid
;

786 
mid
 = 
NULL
;

788 
	`fwrite
 (
cur
, sizeof (char), 
b
 - cur, 
stdout
);

791 
	`PR_SGR_START_IF
(
match_color
);

792 
	`fwrite
 (
b
, sizeof (char), 
match_size
, 
stdout
);

793 
	`PR_SGR_END_IF
(
match_color
);

794 if (
only_matching
)

795 
	`fputs
("\n", 
stdout
);

797 
cur
 = 
b
 + 
match_size
;

800 if (
only_matching
)

801 
cur
 = 
lim
;

802 else if (
mid
)

803 
cur
 = 
mid
;

805 return 
cur
;

806 
	}
}

809 
	$print_line_tail
 (const char *
beg
, const char *
lim
, const char *
line_color
)

811 
size_t
 
eol_size
;

812 
size_t
 
tail_size
;

814 
eol_size
 = (
lim
 > 
beg
 && lim[-1] == 
eolbyte
);

815 
eol_size
 += (
lim
 - eol_size > 
beg
 && lim[-(1 + eol_size)] == '\r');

816 
tail_size
 = 
lim
 - 
eol_size
 - 
beg
;

818 if (
tail_size
 > 0)

820 
	`PR_SGR_START
(
line_color
);

821 
	`fwrite
(
beg
, 1, 
tail_size
, 
stdout
);

822 
beg
 += 
tail_size
;

823 
	`PR_SGR_END
(
line_color
);

826 return 
beg
;

827 
	}
}

830 
	$prline
 (char const *
beg
, char const *
lim
, int 
sep
)

832 int 
matching
;

833 const char *
line_color
;

834 const char *
match_color
;

836 if (!
only_matching
)

837 
	`print_line_head
(
beg
, 
lim
, 
sep
);

839 
matching
 = (
sep
 == 
SEP_CHAR_SELECTED
) ^ !!
out_invert
;

841 if (
color_option
)

843 
line_color
 = ( (
sep
 == 
SEP_CHAR_SELECTED
)

844 ^ (
out_invert
 && (
color_option
 < 0)))

845 ? 
selected_line_color
 : 
context_line_color
;

846 
match_color
 = (
sep
 == 
SEP_CHAR_SELECTED
)

847 ? 
selected_match_color
 : 
context_match_color
;

850 
line_color
 = 
match_color
 = 
NULL
;

852 if ( (
only_matching
 && 
matching
)

853 || (
color_option
 && (*
line_color
 || *
match_color
)))

856 if (
matching
 && (
only_matching
 || *
match_color
))

857 
beg
 = 
	`print_line_middle
(beg, 
lim
, 
line_color
, 
match_color
);

860 if (!
only_matching
 && *
line_color
)

861 
beg
 = 
	`print_line_tail
(beg, 
lim
, 
line_color
);

864 if (!
only_matching
 && 
lim
 > 
beg
)

865 
	`fwrite
 (
beg
, 1, 
lim
 - beg, 
stdout
);

867 if (
	`ferror
 (
stdout
))

868 
	`error
 (0, 
errno
, 
	`_
("writing output"));

870 
lastout
 = 
lim
;

872 if (
line_buffered
)

873 
	`fflush
 (
stdout
);

874 
	}
}

879 
	$prpending
 (char const *
lim
)

881 if (!
lastout
)

882 
lastout
 = 
bufbeg
;

883 while (
pending
 > 0 && 
lastout
 < 
lim
)

885 char const *
nl
 = 
	`memchr
 (
lastout
, 
eolbyte
, 
lim
 - lastout);

886 
size_t
 
match_size
;

887 --
pending
;

888 if (
outleft


889 || ((
	`execute
(
lastout
, 
nl
 + 1 - lastout,

890 &
match_size
, 
NULL
) == (
size_t
) -1)

891 == !
out_invert
))

892 
	`prline
 (
lastout
, 
nl
 + 1, 
SEP_CHAR_REJECTED
);

894 
pending
 = 0;

896 
	}
}

901 
	$prtext
 (char const *
beg
, char const *
lim
, int *
nlinesp
)

903 static int 
used
;

904 char const *
bp
, *
p
;

905 char 
eol
 = 
eolbyte
;

906 int 
i
, 
n
;

908 if (!
out_quiet
 && 
pending
 > 0)

909 
	`prpending
 (
beg
);

911 
p
 = 
beg
;

913 if (!
out_quiet
)

917 
bp
 = 
lastout
 ? lastout : 
bufbeg
;

918 for (
i
 = 0; i < 
out_before
; ++i)

919 if (
p
 > 
bp
)

921 --
p
;

922 while (
p
[-1] != 
eol
);

926 if ((
out_before
 || 
out_after
) && 
used
 && 
p
 != 
lastout
 && 
group_separator
)

928 
	`PR_SGR_START_IF
(
sep_color
);

929 
	`fputs
 (
group_separator
, 
stdout
);

930 
	`PR_SGR_END_IF
(
sep_color
);

931 
	`fputc
('\n', 
stdout
);

934 while (
p
 < 
beg
)

936 char const *
nl
 = 
	`memchr
 (
p
, 
eol
, 
beg
 - p);

937 
nl
++;

938 
	`prline
 (
p
, 
nl
, 
SEP_CHAR_REJECTED
);

939 
p
 = 
nl
;

943 if (
nlinesp
)

946 for (
n
 = 0; 
p
 < 
lim
 && n < 
outleft
; n++)

948 char const *
nl
 = 
	`memchr
 (
p
, 
eol
, 
lim
 - p);

949 
nl
++;

950 if (!
out_quiet
)

951 
	`prline
 (
p
, 
nl
, 
SEP_CHAR_SELECTED
);

952 
p
 = 
nl
;

954 *
nlinesp
 = 
n
;

957 
after_last_match
 = 
bufoffset
 - (
buflim
 - 
p
);

960 if (!
out_quiet
)

961 
	`prline
 (
beg
, 
lim
, 
SEP_CHAR_SELECTED
);

963 
pending
 = 
out_quiet
 ? 0 : 
out_after
;

964 
used
 = 1;

965 
	}
}

967 static 
size_t


968 
	$do_execute
 (char const *
buf
, 
size_t
 
size
, size_t *
match_size
, char const *
start_ptr
)

970 
size_t
 
result
;

971 const char *
line_next
;

985 if (
MB_CUR_MAX
 == 1 || !
match_icase
)

986 return 
	`execute
(
buf
, 
size
, 
match_size
, 
start_ptr
);

988 for (
line_next
 = 
buf
; line_next < buf + 
size
; )

990 const char *
line_buf
 = 
line_next
;

991 const char *
line_end
 = 
	`memchr
 (
line_buf
, 
eolbyte
, (
buf
 + 
size
) - line_buf);

992 if (
line_end
 == 
NULL
)

993 
line_next
 = 
line_end
 = 
buf
 + 
size
;

995 
line_next
 = 
line_end
 + 1;

997 if (
start_ptr
 && start_ptr >= 
line_end
)

1000 
result
 = 
	`execute
 (
line_buf
, 
line_next
 - line_buf, 
match_size
, 
start_ptr
);

1001 if (
result
 != (
size_t
) -1)

1002 return (
line_buf
 - 
buf
) + 
result
;

1005 return (
size_t
) -1;

1006 
	}
}

1012 
	$grepbuf
 (char const *
beg
, char const *
lim
)

1014 int 
nlines
, 
n
;

1015 char const *
p
;

1016 
size_t
 
match_offset
;

1017 
size_t
 
match_size
;

1019 
nlines
 = 0;

1020 
p
 = 
beg
;

1021 while ((
match_offset
 = 
	`do_execute
(
p
, 
lim
 - p, &
match_size
,

1022 
NULL
)) != (
size_t
) -1)

1024 char const *
b
 = 
p
 + 
match_offset
;

1025 char const *
endp
 = 
b
 + 
match_size
;

1027 if (
b
 == 
lim
)

1029 if (!
out_invert
)

1031 
	`prtext
 (
b
, 
endp
, (int *) 0);

1032 
nlines
++;

1033 
outleft
--;

1034 if (!
outleft
 || 
done_on_match
)

1036 if (
exit_on_match
)

1037 
	`exit
 (
EXIT_SUCCESS
);

1038 
after_last_match
 = 
bufoffset
 - (
buflim
 - 
endp
);

1039 return 
nlines
;

1042 else if (
p
 < 
b
)

1044 
	`prtext
 (
p
, 
b
, &
n
);

1045 
nlines
 += 
n
;

1046 
outleft
 -= 
n
;

1047 if (!
outleft
)

1048 return 
nlines
;

1050 
p
 = 
endp
;

1052 if (
out_invert
 && 
p
 < 
lim
)

1054 
	`prtext
 (
p
, 
lim
, &
n
);

1055 
nlines
 += 
n
;

1056 
outleft
 -= 
n
;

1058 return 
nlines
;

1059 
	}
}

1065 
	$grep
 (int 
fd
, char const *
file
, struct 
stats
 *stats)

1067 int 
nlines
, 
i
;

1068 int 
not_text
;

1069 
size_t
 
residue
, 
save
;

1070 char 
oldc
;

1071 char *
beg
;

1072 char *
lim
;

1073 char 
eol
 = 
eolbyte
;

1075 if (!
	`reset
 (
fd
, 
file
, 
stats
))

1078 if (
file
 && 
directories
 == 
RECURSE_DIRECTORIES


1079 && 
	`S_ISDIR
 (
stats
->
stat
.
st_mode
))

1083 if (
	`close
 (
fd
) != 0)

1084 
	`error
 (0, 
errno
, "%s", 
file
);

1085 return 
	`grepdir
 (
file
, 
stats
) - 2;

1088 
totalcc
 = 0;

1089 
lastout
 = 0;

1090 
totalnl
 = 0;

1091 
outleft
 = 
max_count
;

1092 
after_last_match
 = 0;

1093 
pending
 = 0;

1095 
nlines
 = 0;

1096 
residue
 = 0;

1097 
save
 = 0;

1099 if (! 
	`fillbuf
 (
save
, 
stats
))

1101 if (! 
	`is_EISDIR
 (
errno
, 
file
))

1102 
	`suppressible_error
 (
filename
, 
errno
);

1106 
not_text
 = (((
binary_files
 == 
BINARY_BINARY_FILES
 && !
out_quiet
)

1107 || 
binary_files
 == 
WITHOUT_MATCH_BINARY_FILES
)

1108 && 
	`memchr
 (
bufbeg
, 
eol
 ? '\0' : '\200', 
buflim
 - bufbeg));

1109 if (
not_text
 && 
binary_files
 == 
WITHOUT_MATCH_BINARY_FILES
)

1111 
done_on_match
 += 
not_text
;

1112 
out_quiet
 += 
not_text
;

1116 
lastnl
 = 
bufbeg
;

1117 if (
lastout
)

1118 
lastout
 = 
bufbeg
;

1120 
beg
 = 
bufbeg
 + 
save
;

1123 if (
beg
 == 
buflim
)

1128 
oldc
 = 
beg
[-1];

1129 
beg
[-1] = 
eol
;

1130 for (
lim
 = 
buflim
; lim[-1] != 
eol
; lim--)

1132 
beg
[-1] = 
oldc
;

1133 if (
lim
 == 
beg
)

1134 
lim
 = 
beg
 - 
residue
;

1135 
beg
 -= 
residue
;

1136 
residue
 = 
buflim
 - 
lim
;

1138 if (
beg
 < 
lim
)

1140 if (
outleft
)

1141 
nlines
 += 
	`grepbuf
 (
beg
, 
lim
);

1142 if (
pending
)

1143 
	`prpending
 (
lim
);

1144 if((!
outleft
 && !
pending
) || (
nlines
 && 
done_on_match
 && !
out_invert
))

1145 goto 
finish_grep
;

1151 
i
 = 0;

1152 
beg
 = 
lim
;

1153 while (
i
 < 
out_before
 && 
beg
 > 
bufbeg
 && beg != 
lastout
)

1155 ++
i
;

1157 --
beg
;

1158 while (
beg
[-1] != 
eol
);

1162 if (
beg
 != 
lastout
)

1163 
lastout
 = 0;

1166 
save
 = 
residue
 + 
lim
 - 
beg
;

1167 if (
out_byte
)

1168 
totalcc
 = 
	`add_count
 (totalcc, 
buflim
 - 
bufbeg
 - 
save
);

1169 if (
out_line
)

1170 
	`nlscan
 (
beg
);

1171 if (! 
	`fillbuf
 (
save
, 
stats
))

1173 if (! 
	`is_EISDIR
 (
errno
, 
file
))

1174 
	`suppressible_error
 (
filename
, 
errno
);

1175 goto 
finish_grep
;

1178 if (
residue
)

1180 *
buflim
++ = 
eol
;

1181 if (
outleft
)

1182 
nlines
 += 
	`grepbuf
 (
bufbeg
 + 
save
 - 
residue
, 
buflim
);

1183 if (
pending
)

1184 
	`prpending
 (
buflim
);

1187 
finish_grep
:

1188 
done_on_match
 -= 
not_text
;

1189 
out_quiet
 -= 
not_text
;

1190 if ((
not_text
 & ~
out_quiet
) && 
nlines
 != 0)

1191 
	`printf
 (
	`_
("Binary file %s matches\n"), 
filename
);

1192 return 
nlines
;

1193 
	}
}

1196 
	$grepfile
 (char const *
file
, struct 
stats
 *stats)

1198 int 
desc
;

1199 int 
count
;

1200 int 
status
;

1202 if (! 
file
)

1204 
desc
 = 0;

1205 
filename
 = 
label
 ? label : 
	`_
("(standard input)");

1209 if (
	`stat
 (
file
, &
stats
->
stat
) != 0)

1211 
	`suppressible_error
 (
file
, 
errno
);

1214 if (
directories
 == 
SKIP_DIRECTORIES
 && 
	`S_ISDIR
 (
stats
->
stat
.
st_mode
))

1216 if (
devices
 == 
SKIP_DEVICES
 && (
	`S_ISCHR
 (
stats
->
stat
.
st_mode
)

1217 || 
	`S_ISBLK
 (
stats
->
stat
.
st_mode
)

1218 || 
	`S_ISSOCK
 (
stats
->
stat
.
st_mode
)

1219 || 
	`S_ISFIFO
 (
stats
->
stat
.
st_mode
)))

1229 if (
	`S_ISREG
 (
stats
->
stat
.
st_mode
) && 
out_stat
.
st_ino


1230 && 
	`SAME_REGULAR_FILE
 (
stats
->
stat
, 
out_stat
))

1232 
	`error
 (0, 0, 
	`_
("input file %s is also the output"), 
	`quote
 (
file
));

1233 
errseen
 = 1;

1237 while ((
desc
 = 
	`open
 (
file
, 
O_RDONLY
)) < 0 && 
errno
 == 
EINTR
)

1240 if (
desc
 < 0)

1242 int 
e
 = 
errno
;

1244 if (
	`is_EISDIR
 (
e
, 
file
) && 
directories
 == 
RECURSE_DIRECTORIES
)

1246 if (
	`stat
 (
file
, &
stats
->
stat
) != 0)

1248 
	`error
 (0, 
errno
, "%s", 
file
);

1252 return 
	`grepdir
 (
file
, 
stats
);

1255 if (!
suppress_errors
)

1257 if (
directories
 == 
SKIP_DIRECTORIES
)

1258 switch (
e
)

1260 #if 
defined
 
EISDIR


1261 case 
EISDIR
:

1264 case 
EACCES
:

1267 if (
	`isdir
 (
file
))

1273 
	`suppressible_error
 (
file
, 
e
);

1277 
filename
 = 
file
;

1280 #if 
defined
 
SET_BINARY


1283 if (!
	`isatty
 (
desc
))

1284 
	`SET_BINARY
 (
desc
);

1287 
count
 = 
	`grep
 (
desc
, 
file
, 
stats
);

1288 if (
count
 < 0)

1289 
status
 = 
count
 + 2;

1292 if (
count_matches
)

1294 if (
out_file
)

1296 
	`print_filename
();

1297 if (
filename_mask
)

1298 
	`print_sep
(
SEP_CHAR_SELECTED
);

1300 
	`fputc
(0, 
stdout
);

1302 
	`printf
 ("%d\n", 
count
);

1305 
status
 = !
count
;

1306 if (
list_files
 == 1 - 2 * 
status
)

1308 
	`print_filename
();

1309 
	`fputc
('\n' & 
filename_mask
, 
stdout
);

1312 if (! 
file
)

1314 
off_t
 
required_offset
 = 
outleft
 ? 
bufoffset
 : 
after_last_match
;

1315 if (
required_offset
 != 
bufoffset


1316 && 
	`lseek
 (
desc
, 
required_offset
, 
SEEK_SET
) < 0

1317 && 
	`S_ISREG
 (
stats
->
stat
.
st_mode
))

1318 
	`error
 (0, 
errno
, "%s", 
filename
);

1321 while (
	`close
 (
desc
) != 0)

1322 if (
errno
 != 
EINTR
)

1324 
	`error
 (0, 
errno
, "%s", 
file
);

1329 return 
status
;

1330 
	}
}

1333 
	$grepdir
 (char const *
dir
, struct 
stats
 const *stats)

1335 struct 
stats
 const *
ancestor
;

1336 char *
name_space
;

1337 int 
status
 = 1;

1338 if ( 
excluded_directory_patterns
 &&

1339 
	`excluded_file_name
 (
excluded_directory_patterns
, 
dir
) ) {

1346 if (
stats
->
stat
.
st_ino
)

1347 for (
ancestor
 = 
stats
; (ancestor = ancestor->
parent
) != 0; )

1348 if (
ancestor
->
stat
.
st_ino
 == 
stats
->stat.st_ino

1349 && 
ancestor
->
stat
.
st_dev
 == 
stats
->stat.st_dev)

1351 if (!
suppress_errors
)

1352 
	`error
 (0, 0, 
	`_
("warning: %s: %s"), 
dir
,

1353 
	`_
("recursive directory loop"));

1357 
name_space
 = 
	`savedir
 (
dir
, 
stats
->
stat
.
st_size
, 
included_patterns
,

1358 
excluded_patterns
, 
excluded_directory_patterns
);

1360 if (! 
name_space
)

1362 if (
errno
)

1363 
	`suppressible_error
 (
dir
, 
errno
);

1365 
	`xalloc_die
 ();

1369 
size_t
 
dirlen
 = 
	`strlen
 (
dir
);

1370 int 
needs_slash
 = ! (
dirlen
 == 
	`FILE_SYSTEM_PREFIX_LEN
 (
dir
)

1371 || 
	`ISSLASH
 (
dir
[
dirlen
 - 1]));

1372 char *
file
 = 
NULL
;

1373 char const *
namep
 = 
name_space
;

1374 struct 
stats
 
child
;

1375 
child
.
parent
 = 
stats
;

1376 
out_file
 += !
no_filenames
;

1377 while (*
namep
)

1379 
size_t
 
namelen
 = 
	`strlen
 (
namep
);

1380 
file
 = 
	`xrealloc
 (file, 
dirlen
 + 1 + 
namelen
 + 1);

1381 
	`strcpy
 (
file
, 
dir
);

1382 
file
[
dirlen
] = '/';

1383 
	`strcpy
 (
file
 + 
dirlen
 + 
needs_slash
, 
namep
);

1384 
namep
 += 
namelen
 + 1;

1385 
status
 &= 
	`grepfile
 (
file
, &
child
);

1387 
out_file
 -= !
no_filenames
;

1388 
	`free
 (
file
);

1389 
	`free
 (
name_space
);

1392 return 
status
;

1393 
	}
}

1395 void 
	$usage
 (int 
status
) 
	`__attribute__
 ((
noreturn
));

1397 
	$usage
 (int 
status
)

1399 if (
status
 != 0)

1401 
	`fprintf
 (
stderr
, 
	`_
("Usage: %s [OPTION]... PATTERN [FILE]...\n"),

1402 
program_name
);

1403 
	`fprintf
 (
stderr
, 
	`_
("Try `%s --help' for more information.\n"),

1404 
program_name
);

1408 
	`printf
 (
	`_
("Usage: %s [OPTION]... PATTERN [FILE]...\n"), 
program_name
);

1409 
	`printf
 (
	`_
("\
Search for PATTERN in each FILE or standard input.\n"));

1411 
	`printf
 ("%s", 
	`gettext
 (
before_options
));

1412 
	`printf
 (
	`_
("\
Example: %s -i 'hello world' menu.h main.c\n\
\n\
Regexp selection and interpretation:\n"), 
program_name
);

1416 if (
matchers
[1].
name
)

1417 
	`printf
 (
	`_
("\
 -E, --extended-regexp PATTERN is an extended regular expression (ERE)\n\
 -F, --fixed-strings PATTERN is a set of newline-separated fixed strings\n\
 -G, --basic-regexp PATTERN is a basic regular expression (BRE)\n\
 -P, --perl-regexp PATTERN is a Perl regular expression\n"));

1423 
	`printf
 (
	`_
("\
 -e, --regexp=PATTERN use PATTERN for matching\n\
 -f, --file=FILE obtain PATTERN from FILE\n\
 -i, --ignore-case ignore case distinctions\n\
 -w, --word-regexp force PATTERN to match only whole words\n\
 -x, --line-regexp force PATTERN to match only whole lines\n\
 -z, --null-data a data line ends in 0 byte, not newline\n"));

1430 
	`printf
 (
	`_
("\
\n\
Miscellaneous:\n\
 -s, --no-messages suppress error messages\n\
 -v, --invert-match select non-matching lines\n\
 -V, --version print version information and exit\n\
 --help display this help and exit\n\
 --mmap ignored for backwards compatibility\n"));

1438 
	`printf
 (
	`_
("\
\n\
Output control:\n\
 -m, --max-count=NUM stop after NUM matches\n\
 -b, --byte-offset print the byte offset with output lines\n\
 -n, --line-number print line number with output lines\n\
 --line-buffered flush output on every line\n\
 -H, --with-filename print the file name for each match\n\
 -h, --no-filename suppress the file name prefix on output\n\
 --label=LABEL use LABEL as the standard input file name prefix\n\
"));

1449 
	`printf
 (
	`_
("\
 -o, --only-matching show only the part of a line matching PATTERN\n\
 -q, --quiet, --silent suppress all normal output\n\
 --binary-files=TYPE assume that binary files are TYPE;\n\
 TYPE is `binary', `text', or `without-match'\n\
 -a, --text equivalent to --binary-files=text\n\
"));

1456 
	`printf
 (
	`_
("\
 -I equivalent to --binary-files=without-match\n\
 -d, --directories=ACTION how to handle directories;\n\
 ACTION is `read', `recurse', or `skip'\n\
 -D, --devices=ACTION how to handle devices, FIFOs and sockets;\n\
 ACTION is `read' or `skip'\n\
 -R, -r, --recursive equivalent to --directories=recurse\n\
"));

1464 
	`printf
 (
	`_
("\
 --include=FILE_PATTERN search only files that match FILE_PATTERN\n\
 --exclude=FILE_PATTERN skip files and directories matching FILE_PATTERN\n\
 --exclude-from=FILE skip files matching any file pattern from FILE\n\
 --exclude-dir=PATTERN directories that match PATTERN will be skipped.\n\
"));

1470 
	`printf
 (
	`_
("\
 -L, --files-without-match print only names of FILEs containing no match\n\
 -l, --files-with-matches print only names of FILEs containing matches\n\
 -c, --count print only a count of matching lines per FILE\n\
 -T, --initial-tab make tabs line up (if needed)\n\
 -Z, --null print 0 byte after FILE name\n"));

1476 
	`printf
 (
	`_
("\
\n\
Context control:\n\
 -B, --before-context=NUM print NUM lines of leading context\n\
 -A, --after-context=NUM print NUM lines of trailing context\n\
 -C, --context=NUM print NUM lines of output context\n\
"));

1483 
	`printf
 (
	`_
("\
 -NUM same as --context=NUM\n\
 --color[=WHEN],\n\
 --colour[=WHEN] use markers to highlight the matching strings;\n\
 WHEN is `always', `never', or `auto'\n\
 -U, --binary do not strip CR characters at EOL (MSDOS)\n\
 -u, --unix-byte-offsets report offsets as if CRs were not there (MSDOS)\n\
\n"));

1491 
	`printf
 ("%s", 
	`_
(
after_options
));

1492 
	`printf
 (
	`_
("\
With no FILE, or when FILE is -, read standard input. If less than two FILEs\n\
are given, assume -h. Exit status is 0 if any line was selected, 1 otherwise;\n\
if any error occurs and -q was not given, the exit status is 2.\n"));

1496 
	`printf
 (
	`_
("\nReport bugs to: %s\n"), 
PACKAGE_BUGREPORT
);

1497 
	`printf
 (
	`_
("GNU Grep home page: <%s>\n"),

1499 
	`fputs
 (
	`_
("General help using GNU software: <http://www.gnu.org/gethelp/>\n"),

1500 
stdout
);

1503 
	`exit
 (
status
);

1504 
	}
}

1510 
	$setmatcher
 (char const *
m
)

1512 static char const *
matcher
;

1513 unsigned int 
i
;

1515 if (!
m
)

1517 
compile
 = 
matchers
[0].compile;

1518 
execute
 = 
matchers
[0].execute;

1519 if (!
matchers
[1].
name
)

1520 
matcher
 = 
matchers
[0].
name
;

1523 else if (
matcher
)

1525 if (
matcher
 && 
	`STREQ
 (matcher, 
m
))

1528 else if (!
matchers
[1].
name
)

1529 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("%s can only use the %s pattern syntax"),

1530 
program_name
, 
matcher
);

1532 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("conflicting matchers specified"));

1537 for (
i
 = 0; 
matchers
[i].
name
; i++)

1538 if (
	`STREQ
 (
m
, 
matchers
[
i
].
name
))

1540 
compile
 = 
matchers
[
i
].compile;

1541 
execute
 = 
matchers
[
i
].execute;

1542 
matcher
 = 
m
;

1546 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("invalid matcher %s"), 
m
);

1548 
	}
}

1551 
	$set_limits
(void)

1553 #if 
defined
 
HAVE_SETRLIMIT
 && defined 
RLIMIT_STACK


1554 struct 
rlimit
 
rlim
;

1562 if (!
	`getrlimit
 (
RLIMIT_STACK
, &
rlim
))

1564 long 
newlim
;

1565 extern long int 
re_max_failures
;

1568 
newlim
 = 
re_max_failures
 * 2 * 20 * sizeof (char *);

1569 if (
newlim
 > 
rlim
.
rlim_max
)

1571 
newlim
 = 
rlim
.
rlim_max
;

1572 
re_max_failures
 = 
newlim
 / (2 * 20 * sizeof (char *));

1574 if (
rlim
.
rlim_cur
 < 
newlim
)

1576 
rlim
.
rlim_cur
 = 
newlim
;

1577 
	`setrlimit
 (
RLIMIT_STACK
, &
rlim
);

1581 
	}
}

1589 
	$prepend_args
 (char const *
options
, char *
buf
, char **
argv
)

1591 char const *
o
 = 
options
;

1592 char *
b
 = 
buf
;

1593 int 
n
 = 0;

1597 while (
	`c_isspace
 ((unsigned char) *
o
))

1598 
o
++;

1599 if (!*
o
)

1600 return 
n
;

1601 if (
argv
)

1602 
argv
[
n
] = 
b
;

1603 
n
++;

1606 if ((*
b
++ = *
o
++) == '\\' && *o)

1607 
b
[-1] = *
o
++;

1608 while (*
o
 && ! 
	`c_isspace
 ((unsigned char) *o));

1610 *
b
++ = '\0';

1612 
	}
}

1618 
	$prepend_default_options
 (char const *
options
, int *
pargc
, char ***
pargv
)

1620 if (
options
 && *options)

1622 char *
buf
 = 
	`xmalloc
 (
	`strlen
 (
options
) + 1);

1623 int 
prepended
 = 
	`prepend_args
 (
options
, 
buf
, (char **) 
NULL
);

1624 int 
argc
 = *
pargc
;

1625 char * const *
argv
 = *
pargv
;

1626 char **
pp
 = 
	`xmalloc
 ((
prepended
 + 
argc
 + 1) * sizeof *pp);

1627 *
pargc
 = 
prepended
 + 
argc
;

1628 *
pargv
 = 
pp
;

1629 *
pp
++ = *
argv
++;

1630 
pp
 += 
	`prepend_args
 (
options
, 
buf
, pp);

1631 while ((*
pp
++ = *
argv
++))

1634 
	}
}

1641 
	$get_nondigit_option
 (int 
argc
, char *const *
argv
, int *
default_context
)

1643 static int 
prev_digit_optind
 = -1;

1644 int 
opt
, 
this_digit_optind
, 
was_digit
;

1645 char 
buf
[sizeof (
uintmax_t
) * 
CHAR_BIT
 + 4];

1646 char *
p
 = 
buf
;

1648 
was_digit
 = 0;

1649 
this_digit_optind
 = 
optind
;

1650 while (
opt
 = 
	`getopt_long
 (
argc
, (char **) 
argv
, 
short_options
, 
long_options
,

1651 
NULL
),

1652 '0' <= 
opt
 && opt <= '9')

1654 if (
prev_digit_optind
 != 
this_digit_optind
 || !
was_digit
)

1657 
p
 = 
buf
;

1663 
p
 -= 
buf
[0] == '0';

1666 if (
p
 == 
buf
 + sizeof buf - 4)

1671 
	`strcpy
 (
p
, "...");

1672 
p
 += 3;

1675 *
p
++ = 
opt
;

1677 
was_digit
 = 1;

1678 
prev_digit_optind
 = 
this_digit_optind
;

1679 
this_digit_optind
 = 
optind
;

1681 if (
p
 != 
buf
)

1683 *
p
 = '\0';

1684 
	`context_length_arg
 (
buf
, 
default_context
);

1687 return 
opt
;

1688 
	}
}

1695 
	$parse_grep_colors
 (void)

1697 const char *
p
;

1698 char *
q
;

1699 char *
name
;

1700 char *
val
;

1702 
p
 = 
	`getenv
("GREP_COLORS");

1703 if (
p
 == 
NULL
 || *p == '\0')

1707 
q
 = 
	`xstrdup
(
p
);

1709 
name
 = 
q
;

1710 
val
 = 
NULL
;

1713 if (*
q
 == ':' || *q == '\0')

1715 char 
c
 = *
q
;

1716 struct 
color_cap
 *
cap
;

1718 *
q
++ = '\0';

1721 for (
cap
 = 
color_dict
; cap->
name
; cap++)

1722 if (
	`STREQ
 (
cap
->
name
, name))

1725 if (
cap
->
name
)

1727 if (
cap
->
var
)

1729 if (
val
)

1730 *(
cap
->
var
) = 
val
;

1732 
	`error
(0, 0, 
	`_
("in GREP_COLORS=\"%s\", the \"%s\" capacity "

1733 "needs a value (\"=...\"); skipped"), 
p
, 
name
);

1735 else if (
val
)

1736 
	`error
(0, 0, 
	`_
("in GREP_COLORS=\"%s\", the \"%s\" capacity "

1738 
p
, 
name
, 
val
);

1740 if (
cap
->
fct
)

1742 const char *
err_str
 = 
cap
->
	`fct
();

1744 if (
err_str
)

1745 
	`error
(0, 0, 
	`_
("in GREP_COLORS=\"%s\", the \"%s\" capacity %s"),

1746 
p
, 
name
, 
err_str
);

1748 if (
c
 == '\0')

1750 
name
 = 
q
;

1751 
val
 = 
NULL
;

1753 else if (*
q
 == '=')

1755 if (
q
 == 
name
 || 
val
)

1756 goto 
ill_formed
;

1757 *
q
++ = '\0';

1758 
val
 = 
q
;

1760 else if (
val
 == 
NULL
)

1761 
q
++;

1762 else if (*
q
 == ';' || (*q >= '0' && *q <= '9'))

1763 
q
++;

1765 goto 
ill_formed
;

1767 
ill_formed
:

1768 
	`error
(0, 0, 
	`_
("stopped processing of ill-formed GREP_COLORS=\"%s\" "

1769 "at remaining substring \"%s\""), 
p
, 
q
);

1770 
	}
}

1773 
	$main
 (int 
argc
, char **
argv
)

1775 char *
keys
;

1776 
size_t
 
keycc
, 
oldcc
, 
keyalloc
;

1777 int 
with_filenames
;

1778 int 
opt
, 
cc
, 
status
;

1779 int 
default_context
;

1780 
FILE
 *
fp
;

1782 
exit_failure
 = 
EXIT_TROUBLE
;

1783 
	`initialize_main
 (&
argc
, &
argv
);

1784 
	`set_program_name
 (
argv
[0]);

1785 
program_name
 = 
argv
[0];

1787 
keys
 = 
NULL
;

1788 
keycc
 = 0;

1789 
with_filenames
 = 0;

1790 
eolbyte
 = '\n';

1791 
filename_mask
 = ~0;

1793 
max_count
 = 
	`TYPE_MAXIMUM
 (
off_t
);

1796 
out_after
 = 
out_before
 = -1;

1798 
default_context
 = 0;

1800 
only_matching
 = 0;

1803 #if 
defined
 
HAVE_SETLOCALE


1804 
	`setlocale
 (
LC_ALL
, "");

1806 #if 
defined
 
ENABLE_NLS


1807 
	`bindtextdomain
 (
PACKAGE
, 
LOCALEDIR
);

1808 
	`textdomain
 (
PACKAGE
);

1811 
exit_failure
 = 
EXIT_TROUBLE
;

1812 
	`atexit
 (
close_stdout
);

1814 
	`prepend_default_options
 (
	`getenv
 ("GREP_OPTIONS"), &
argc
, &
argv
);

1815 
	`setmatcher
 (
NULL
);

1817 while ((
opt
 = 
	`get_nondigit_option
 (
argc
, 
argv
, &
default_context
)) != -1)

1818 switch (
opt
)

1821 
	`context_length_arg
 (
optarg
, &
out_after
);

1825 
	`context_length_arg
 (
optarg
, &
out_before
);

1831 
	`context_length_arg
 (
optarg
, &
default_context
);

1835 if (
	`STREQ
 (
optarg
, "read"))

1836 
devices
 = 
READ_DEVICES
;

1837 else if (
	`STREQ
 (
optarg
, "skip"))

1838 
devices
 = 
SKIP_DEVICES
;

1840 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("unknown devices method"));

1844 
	`setmatcher
 ("egrep");

1848 
	`setmatcher
 ("fgrep");

1852 
	`setmatcher
 ("perl");

1856 
	`setmatcher
 ("grep");

1860 
	`setmatcher
 (
optarg
);

1864 
with_filenames
 = 1;

1865 
no_filenames
 = 0;

1869 
binary_files
 = 
WITHOUT_MATCH_BINARY_FILES
;

1873 
align_tabs
 = 1;

1877 #if 
defined
 
HAVE_DOS_FILE_CONTENTS


1878 
dos_use_file_type
 = 
DOS_BINARY
;

1883 #if 
defined
 
HAVE_DOS_FILE_CONTENTS


1884 
dos_report_unix_offset
 = 1;

1889 
show_version
 = 1;

1893 
binary_files
 = 
TEXT_BINARY_FILES
;

1897 
out_byte
 = 1;

1901 
count_matches
 = 1;

1905 
directories
 = 
	`XARGMATCH
 ("--directories", 
optarg
,

1906 
directories_args
, 
directories_types
);

1910 
cc
 = 
	`strlen
 (
optarg
);

1911 
keys
 = 
	`xrealloc
 (keys, 
keycc
 + 
cc
 + 1);

1912 
	`strcpy
 (&
keys
[
keycc
], 
optarg
);

1913 
keycc
 += 
cc
;

1914 
keys
[
keycc
++] = '\n';

1918 
fp
 = 
	`STREQ
 (
optarg
, "-") ? 
stdin
 : 
	`fopen
 (optarg, "r");

1919 if (!
fp
)

1920 
	`error
 (
EXIT_TROUBLE
, 
errno
, "%s", 
optarg
);

1921 for (
keyalloc
 = 1; keyalloc <= 
keycc
 + 1; keyalloc *= 2)

1923 
keys
 = 
	`xrealloc
 (keys, 
keyalloc
);

1924 
oldcc
 = 
keycc
;

1925 while (!
	`feof
 (
fp
)

1926 && (
cc
 = 
	`fread
 (
keys
 + 
keycc
, 1, 
keyalloc
 - 1 - keycc, 
fp
)) > 0)

1928 
keycc
 += 
cc
;

1929 if (
keycc
 == 
keyalloc
 - 1)

1930 
keys
 = 
	`x2nrealloc
 (keys, &
keyalloc
, sizeof *keys);

1932 if (
fp
 != 
stdin
)

1933 
	`fclose
(
fp
);

1935 if (
oldcc
 != 
keycc
 && 
keys
[keycc - 1] != '\n')

1936 
keys
[
keycc
++] = '\n';

1940 
with_filenames
 = 0;

1941 
no_filenames
 = 1;

1946 
match_icase
 = 1;

1952 
list_files
 = -1;

1956 
list_files
 = 1;

1961 
uintmax_t
 
value
;

1962 switch (
	`xstrtoumax
 (
optarg
, 0, 10, &
value
, ""))

1964 case 
LONGINT_OK
:

1965 
max_count
 = 
value
;

1966 if (0 <= 
max_count
 && max_count == 
value
)

1969 case 
LONGINT_OVERFLOW
:

1970 
max_count
 = 
	`TYPE_MAXIMUM
 (
off_t
);

1974 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("invalid max count"));

1980 
out_line
 = 1;

1984 
only_matching
 = 1;

1988 
exit_on_match
 = 1;

1989 
exit_failure
 = 0;

1994 
directories
 = 
RECURSE_DIRECTORIES
;

1998 
suppress_errors
 = 1;

2002 
out_invert
 = 1;

2006 
match_words
 = 1;

2010 
match_lines
 = 1;

2014 
filename_mask
 = 0;

2018 
eolbyte
 = '\0';

2021 case 
BINARY_FILES_OPTION
:

2022 if (
	`STREQ
 (
optarg
, "binary"))

2023 
binary_files
 = 
BINARY_BINARY_FILES
;

2024 else if (
	`STREQ
 (
optarg
, "text"))

2025 
binary_files
 = 
TEXT_BINARY_FILES
;

2026 else if (
	`STREQ
 (
optarg
, "without-match"))

2027 
binary_files
 = 
WITHOUT_MATCH_BINARY_FILES
;

2029 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("unknown binary-files type"));

2032 case 
COLOR_OPTION
:

2033 if(
optarg
) {

2034 if(!
	`strcasecmp
(
optarg
, "always") || !strcasecmp(optarg, "yes") ||

2035 !
	`strcasecmp
(
optarg
, "force"))

2036 
color_option
 = 1;

2037 else if(!
	`strcasecmp
(
optarg
, "never") || !strcasecmp(optarg, "no") ||

2038 !
	`strcasecmp
(
optarg
, "none"))

2039 
color_option
 = 0;

2040 else if(!
	`strcasecmp
(
optarg
, "auto") || !strcasecmp(optarg, "tty") ||

2041 !
	`strcasecmp
(
optarg
, "if-tty"))

2042 
color_option
 = 2;

2044 
show_help
 = 1;

2046 
color_option
 = 2;

2047 if (
color_option
 == 2)

2049 char const *
t
;

2050 if (
	`isatty
 (
STDOUT_FILENO
) && (
t
 = 
	`getenv
 ("TERM"))

2051 && !
	`STREQ
 (
t
, "dumb"))

2052 
color_option
 = 1;

2054 
color_option
 = 0;

2058 case 
EXCLUDE_OPTION
:

2059 if (!
excluded_patterns
)

2060 
excluded_patterns
 = 
	`new_exclude
 ();

2061 
	`add_exclude
 (
excluded_patterns
, 
optarg
, 
EXCLUDE_WILDCARDS
);

2063 case 
EXCLUDE_FROM_OPTION
:

2064 if (!
excluded_patterns
)

2065 
excluded_patterns
 = 
	`new_exclude
 ();

2066 if (
	`add_exclude_file
 (
add_exclude
, 
excluded_patterns
, 
optarg
,

2067 
EXCLUDE_WILDCARDS
, '\n') != 0)

2069 
	`error
 (
EXIT_TROUBLE
, 
errno
, "%s", 
optarg
);

2073 case 
EXCLUDE_DIRECTORY_OPTION
:

2074 if (!
excluded_directory_patterns
)

2075 
excluded_directory_patterns
 = 
	`new_exclude
 ();

2076 
	`add_exclude
 (
excluded_directory_patterns
, 
optarg
, 
EXCLUDE_WILDCARDS
);

2079 case 
INCLUDE_OPTION
:

2080 if (!
included_patterns
)

2081 
included_patterns
 = 
	`new_exclude
 ();

2082 
	`add_exclude
 (
included_patterns
, 
optarg
,

2083 
EXCLUDE_WILDCARDS
 | 
EXCLUDE_INCLUDE
);

2086 case 
GROUP_SEPARATOR_OPTION
:

2087 
group_separator
 = 
optarg
;

2090 case 
LINE_BUFFERED_OPTION
:

2091 
line_buffered
 = 1;

2094 case 
LABEL_OPTION
:

2095 
label
 = 
optarg
;

2098 case 
MMAP_OPTION
:

2104 
	`usage
 (
EXIT_TROUBLE
);

2111 if (
exit_on_match
)

2112 
list_files
 = 0;

2113 if (
exit_on_match
 | 
list_files
)

2115 
count_matches
 = 0;

2116 
done_on_match
 = 1;

2118 
out_quiet
 = 
count_matches
 | 
done_on_match
;

2120 if (
out_after
 < 0)

2121 
out_after
 = 
default_context
;

2122 if (
out_before
 < 0)

2123 
out_before
 = 
default_context
;

2125 if (
color_option
)

2128 char *
userval
 = 
	`getenv
 ("GREP_COLOR");

2129 if (
userval
 != 
NULL
 && *userval != '\0')

2130 
selected_match_color
 = 
context_match_color
 = 
userval
;

2133 
	`parse_grep_colors
();

2136 if (
show_version
)

2138 
	`version_etc
 (
stdout
, 
program_name
, 
PACKAGE_NAME
, 
VERSION
, 
AUTHORS
, \

2139 (char *) 
NULL
); \

2140 
	`exit
 (
EXIT_SUCCESS
); \

2143 if (
show_help
)

2144 
	`usage
 (
EXIT_SUCCESS
);

2146 struct 
stat
 
tmp_stat
;

2147 if (
	`fstat
 (
STDOUT_FILENO
, &
tmp_stat
) == 0 && 
	`S_ISREG
 (tmp_stat.
st_mode
))

2148 
out_stat
 = 
tmp_stat
;

2150 if (
keys
)

2152 if (
keycc
 == 0)

2155 
out_invert
 ^= 1;

2156 
match_lines
 = 
match_words
 = 0;

2160 --
keycc
;

2163 if (
optind
 < 
argc
)

2166 
keycc
 = 
	`strlen
(
argv
[
optind
]);

2167 
keys
 = 
	`xmalloc
(
keycc
 + 1);

2168 
	`strcpy
(
keys
, 
argv
[
optind
++]);

2171 
	`usage
 (
EXIT_TROUBLE
);

2173 
	`set_limits
();

2174 
	`compile
(
keys
, 
keycc
);

2175 
	`free
 (
keys
);

2177 if ((
argc
 - 
optind
 > 1 && !
no_filenames
) || 
with_filenames
)

2178 
out_file
 = 1;

2180 #ifdef 
SET_BINARY


2183 if (!
	`isatty
 (1))

2184 
	`SET_BINARY
 (1);

2187 if (
max_count
 == 0)

2188 
	`exit
 (
EXIT_FAILURE
);

2190 if (
optind
 < 
argc
)

2192 
status
 = 1;

2195 char *
file
 = 
argv
[
optind
];

2196 if ((
included_patterns
 || 
excluded_patterns
)

2197 && !
	`isdir
 (
file
))

2199 if (
included_patterns


2200 && 
	`excluded_file_name
 (
included_patterns
, 
file
))

2202 if (
excluded_patterns


2203 && 
	`excluded_file_name
 (
excluded_patterns
, 
file
))

2206 
status
 &= 
	`grepfile
 (
	`STREQ
 (
file
, "-") ? (char *) 
NULL
 : file,

2207 &
stats_base
);

2209 while ( ++
optind
 < 
argc
);

2212 
status
 = 
	`grepfile
 ((char *) 
NULL
, &
stats_base
);

2215 
	`exit
 (
errseen
 ? 
EXIT_TROUBLE
 : 
status
);

2216 
	}
}

	@src/mbsupport.h

29 #include 
	~<stdlib.h
>

31 #if 
defined
 
HAVE_WCSCOLL
 && defined 
HAVE_ISWCTYPE


32 #define 
	#MBS_SUPPORT
 1

	)

34 #define 
	#MBS_SUPPORT
 0

	)

37 #if ! 
MBS_SUPPORT


38 #undef 
MB_CUR_MAX


39 #define 
	#MB_CUR_MAX
 1

	)

	@src/pcresearch.c

21 #include 
	~<config.h
>

22 #include 
	~"search.h
"

23 #if 
HAVE_PCRE_H


24 #include 
	~<pcre.h
>

25 #elif 
HAVE_PCRE_PCRE_H


26 #include 
	~<pcre/pcre.h
>

29 #if 
HAVE_LIBPCRE


31 static 
pcre
 *
	gcre
;

34 static 
pcre_extra
 *
	gextra
;

38 
	$Pcompile
 (char const *
pattern
, 
size_t
 
size
)

40 #if !
HAVE_LIBPCRE


41 
	`error
 (
EXIT_TROUBLE
, 0, "%s",

42 
	`_
("support for the -P option is not compiled into "

45 int 
e
;

46 char const *
ep
;

47 char *
re
 = 
	`xnmalloc
 (4, 
size
 + 7);

48 int 
flags
 = 
PCRE_MULTILINE
 | (
match_icase
 ? 
PCRE_CASELESS
 : 0);

49 char const *
patlim
 = 
pattern
 + 
size
;

50 char *
n
 = 
re
;

51 char const *
p
;

52 char const *
pnul
;

55 if (
	`memchr
(
pattern
, '\n', 
size
))

56 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("the -P option only supports a single pattern"));

58 *
n
 = '\0';

59 if (
match_lines
)

60 
	`strcpy
 (
n
, "^(");

61 if (
match_words
)

62 
	`strcpy
 (
n
, "\\b(");

63 
n
 += 
	`strlen
 (n);

73 for (
p
 = 
pattern
; (
pnul
 = 
	`memchr
 (p, '\0', 
patlim
 - p)); p = pnul + 1)

75 
	`memcpy
 (
n
, 
p
, 
pnul
 - p);

76 
n
 += 
pnul
 - 
p
;

77 for (
p
 = 
pnul
; 
pattern
 < p && p[-1] == '\\'; p--)

79 
n
 -= (
pnul
 - 
p
) & 1;

80 
	`strcpy
 (
n
, "\\000");

81 
n
 += 4;

84 
	`memcpy
 (
n
, 
p
, 
patlim
 - p);

85 
n
 += 
patlim
 - 
p
;

86 *
n
 = '\0';

87 if (
match_words
)

88 
	`strcpy
 (
n
, ")\\b");

89 if (
match_lines
)

90 
	`strcpy
 (
n
, ")$");

92 
cre
 = 
	`pcre_compile
 (
re
, 
flags
, &
ep
, &
e
, 
	`pcre_maketables
 ());

93 if (!
cre
)

94 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
ep
);

96 
extra
 = 
	`pcre_study
 (
cre
, 0, &
ep
);

97 if (
ep
)

98 
	`error
 (
EXIT_TROUBLE
, 0, "%s", 
ep
);

100 
	`free
 (
re
);

102 
	}
}

104 
size_t


105 
	$Pexecute
 (char const *
buf
, 
size_t
 
size
, size_t *
match_size
,

106 char const *
start_ptr
)

108 #if !
HAVE_LIBPCRE


110 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("internal error"));

115 int 
sub
[300];

117 const char *
line_buf
, *
line_end
, *
line_next
;

118 int 
e
 = 
PCRE_ERROR_NOMATCH
;

119 
ptrdiff_t
 
start_ofs
 = 
start_ptr
 ? start_ptr - 
buf
 : 0;

123 for (
line_next
 = 
buf
;

124 
e
 == 
PCRE_ERROR_NOMATCH
 && 
line_next
 < 
buf
 + 
size
;

125 
start_ofs
 -= 
line_next
 - 
line_buf
)

127 
line_buf
 = 
line_next
;

128 
line_end
 = 
	`memchr
 (
line_buf
, 
eolbyte
, (
buf
 + 
size
) - line_buf);

129 if (
line_end
 == 
NULL
)

130 
line_next
 = 
line_end
 = 
buf
 + 
size
;

132 
line_next
 = 
line_end
 + 1;

134 if (
start_ptr
 && start_ptr >= 
line_end
)

137 
e
 = 
	`pcre_exec
 (
cre
, 
extra
, 
line_buf
, 
line_end
 - line_buf,

138 
start_ofs
 < 0 ? 0 : start_ofs, 0,

139 
sub
, sizeof sub / sizeof *sub);

142 if (
e
 <= 0)

144 switch (
e
)

146 case 
PCRE_ERROR_NOMATCH
:

149 case 
PCRE_ERROR_NOMEMORY
:

150 
	`error
 (
EXIT_TROUBLE
, 0, 
	`_
("memory exhausted"));

152 case 
PCRE_ERROR_MATCHLIMIT
:

153 
	`error
 (
EXIT_TROUBLE
, 0,

154 
	`_
("exceeded PCRE's backtracking limit"));

157 
	`abort
 ();

163 char const *
beg
 = 
line_buf
 + 
sub
[0];

164 char const *
end
 = 
line_buf
 + 
sub
[1];

165 char const *
buflim
 = 
buf
 + 
size
;

166 char 
eol
 = 
eolbyte
;

167 if (!
start_ptr
)

173 if (!(
end
 = 
	`memchr
 (end, 
eol
, 
buflim
 - end)))

174 
end
 = 
buflim
;

176 
end
++;

177 while (
buf
 < 
beg
 && beg[-1] != 
eol
)

178 --
beg
;

181 *
match_size
 = 
end
 - 
beg
;

182 return 
beg
 - 
buf
;

185 
	}
}

	@src/search.h

19 #ifndef 
GREP_SEARCH_H


20 #define 
	#GREP_SEARCH_H
 1

	)

22 #include 
	~<config.h
>

24 #include 
	~<sys/types.h
>

26 #include 
	~"mbsupport.h
"

28 #include 
	~<wchar.h
>

29 #include 
	~<wctype.h
>

30 #include 
	~<regex.h
>

32 #include 
	~"system.h
"

33 #include 
	~"error.h
"

34 #include 
	~"grep.h
"

35 #include 
	~"kwset.h
"

36 #include 
	~"xalloc.h
"

39 extern void 
kwsinit
 (
kwset_t
 *);

41 extern char *
mbtolower
 (const char *, 
size_t
 *);

42 extern 
bool
 
is_mb_middle
 (const char **, const char *, const char *, 
size_t
);

45 extern void 
GEAcompile
 (char const *, 
size_t
, 
reg_syntax_t
);

46 extern 
size_t
 
EGexecute
 (char const *, size_t, size_t *, char const *);

49 extern void 
Fcompile
 (char const *, 
size_t
);

50 extern 
size_t
 
Fexecute
 (char const *, size_t, size_t *, char const *);

53 extern void 
Pcompile
 (char const *, 
size_t
);

54 extern 
size_t
 
Pexecute
 (char const *, size_t, size_t *, char const *);

	@src/searchutils.c

19 #include 
	~<config.h
>

20 #include 
	~<assert.h
>

21 #include 
	~"search.h
"

23 #define 
	#NCHAR
 (
UCHAR_MAX
 + 1)

	)

26 
	$kwsinit
 (
kwset_t
 *
kwset
)

28 static char 
trans
[
NCHAR
];

29 int 
i
;

31 if (
match_icase
 && 
MB_CUR_MAX
 == 1)

33 for (
i
 = 0; i < 
NCHAR
; ++i)

34 
trans
[
i
] = 
	`tolower
 (i);

36 *
kwset
 = 
	`kwsalloc
 (
trans
);

39 *
kwset
 = 
	`kwsalloc
 (
NULL
);

41 if (!*
kwset
)

42 
	`xalloc_die
 ();

43 
	}
}

45 #if 
MBS_SUPPORT


58 
	$mbtolower
 (const char *
beg
, 
size_t
 *
n
)

60 static char *
out
;

61 static 
size_t
 
outalloc
;

62 
size_t
 
outlen
, 
mb_cur_max
;

63 
mbstate_t
 
is
, 
os
;

64 const char *
end
;

65 char *
p
;

67 if (*
n
 > 
outalloc
 || outalloc == 0)

69 
outalloc
 = 
	`MAX
(1, *
n
);

70 
out
 = 
	`xrealloc
 (out, 
outalloc
);

74 
	`assert
 (
out
);

75 if (*
n
 == 0)

76 return 
out
;

78 
	`memset
 (&
is
, 0, sizeof (is));

79 
	`memset
 (&
os
, 0, sizeof (os));

80 
end
 = 
beg
 + *
n
;

82 
mb_cur_max
 = 
MB_CUR_MAX
;

83 
p
 = 
out
;

84 
outlen
 = 0;

85 while (
beg
 < 
end
)

87 
wchar_t
 
wc
;

88 
size_t
 
mbclen
 = 
	`mbrtowc
(&
wc
, 
beg
, 
end
 - beg, &
is
);

89 if (
outlen
 + 
mb_cur_max
 >= 
outalloc
)

91 
out
 = 
	`x2nrealloc
 (out, &
outalloc
, 1);

92 
p
 = 
out
 + 
outlen
;

95 if (
mbclen
 == (
size_t
) -1 || mbclen == (size_t) -2 || mbclen == 0)

99 *
p
++ = *
beg
++;

100 
outlen
++;

101 
	`memset
 (&
is
, 0, sizeof (is));

102 
	`memset
 (&
os
, 0, sizeof (os));

106 
beg
 += 
mbclen
;

107 
mbclen
 = 
	`wcrtomb
 (
p
, 
	`towlower
 ((
wint_t
) 
wc
), &
os
);

108 
p
 += 
mbclen
;

109 
outlen
 += 
mbclen
;

113 *
n
 = 
p
 - 
out
;

114 *
p
 = 0;

115 return 
out
;

116 
	}
}

119 
bool


120 
	$is_mb_middle
 (const char **
good
, const char *
buf
, const char *
end
,

121 
size_t
 
match_len
)

123 const char *
p
 = *
good
;

124 const char *
prev
 = 
p
;

125 
mbstate_t
 
cur_state
;

128 
	`memset
(&
cur_state
, 0, sizeof(
mbstate_t
));

129 while (
p
 < 
buf
)

131 
size_t
 
mbclen
 = 
	`mbrlen
(
p
, 
end
 - p, &
cur_state
);

134 if (
mbclen
 != (
size_t
) -2)

135 
prev
 = 
p
;

137 if (
mbclen
 == (
size_t
) -1 || mbclen == (size_t) -2 || mbclen == 0)

141 
mbclen
 = 1;

142 
	`memset
(&
cur_state
, 0, sizeof cur_state);

144 
p
 += 
mbclen
;

147 *
good
 = 
prev
;

149 if (
p
 > 
buf
)

150 return 
true
;

153 return 0 < 
match_len
 && match_len < 
	`mbrlen
 (
p
, 
end
 - p, &
cur_state
);

154 
	}
}

	@src/system.h

19 #ifndef 
GREP_SYSTEM_H


20 #define 
	#GREP_SYSTEM_H
 1

	)

22 #include 
	~<fcntl.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<errno.h
>

26 #include 
	~"binary-io.h
"

27 #include 
	~"configmake.h
"

28 #include 
	~"dirname.h
"

29 #include 
	~"minmax.h
"

30 #include 
	~"same-inode.h
"

32 #if 
O_BINARY


33 #define 
	#HAVE_DOS_FILE_CONTENTS
 1

	)

36 #ifdef 
EISDIR


37 #define 
	#is_EISDIR
(
e
, 
f
) ((e) == 
EISDIR
)

	)

39 #define 
	#is_EISDIR
(
e
, 
f
) 0

	)

42 #include 
	~<stdlib.h
>

43 #include 
	~<stddef.h
>

44 #include 
	~<limits.h
>

45 #include 
	~<string.h
>

46 #include 
	~<ctype.h
>

48 enum { 
	mEXIT_TROUBLE
 = 2 };

50 #include 
	~<gettext.h
>

51 #define 
	#N_
(
String
) 
	`gettext_noop
(String)

	)

52 #define 
	#_
(
String
) 
	`gettext
(String)

	)

54 #include 
	~<locale.h
>

56 #ifndef 
initialize_main


57 #define 
	#initialize_main
(
argcp
, 
argvp
)

	)

85 #ifndef 
same_file_attributes


86 #define 
	#same_file_attributes
(
s
, 
t
) \

87 ((
s
)->
st_mode
 == (
t
)->st_mode \

88 && (
s
)->
st_nlink
 == (
t
)->st_nlink \

89 && (
s
)->
st_uid
 == (
t
)->st_uid \

90 && (
s
)->
st_gid
 == (
t
)->st_gid \

91 && (
s
)->
st_size
 == (
t
)->st_size \

92 && (
s
)->
st_mtime
 == (
t
)->st_mtime \

93 && (
s
)->
st_ctime
 == (
t
)->st_ctime)

	)

96 #define 
	#SAME_REGULAR_FILE
(
s
, 
t
) \

97 (
	`SAME_INODE
 (
s
, 
t
) && 
	`same_file_attributes
 (&s, &t))

	)

99 #include 
	~"unlocked-io.h
"

	@tests/get-mb-cur-max.c

19 #include 
	~<config.h
>

20 #include 
	~<locale.h
>

21 #include 
	~<stdio.h
>

22 #include 
	~<stdlib.h
>

24 #include 
	~"progname.h
"

27 
	$main
 (int 
argc
, char **
argv
)

29 
	`set_program_name
 (
argv
[0]);

30 if (1 < 
argc
 && 
	`setlocale
 (
LC_ALL
, 
argv
[1]))

32 
	`printf
 ("%d\n", (int) 
MB_CUR_MAX
);

33 
	`exit
 (
EXIT_SUCCESS
);

36 
	`exit
 (
EXIT_FAILURE
);

37 
	}
}

	@/usr/include/alloca.h

19 #ifndef 
_ALLOCA_H


20 #define 
	#_ALLOCA_H
 1

	)

22 #include 
	~<features.h
>

24 #define 
	#__need_size_t


	)

25 #include 
	~<stddef.h
>

27 
	g__BEGIN_DECLS


30 #undef 
alloca


33 extern void *
	$alloca
 (
size_t
 
__size
) 
__THROW
;

35 #ifdef 
__GNUC__


36 #define 
	#alloca
(
size
) 
	`__builtin_alloca
 (size)

	)

39 
__END_DECLS


	@/usr/include/assert.h

24 #ifdef 
_ASSERT_H


26 #undef 
_ASSERT_H


27 #undef 
assert


28 #undef 
__ASSERT_VOID_CAST


30 #ifdef 
__USE_GNU


31 #undef 
assert_perror


36 #define 
	#_ASSERT_H
 1

	)

37 #include 
	~<features.h
>

39 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,95)

40 #define 
	#__ASSERT_VOID_CAST
 
static_cast
<void>

	)

42 #define 
	#__ASSERT_VOID_CAST
 (void)

	)

50 #ifdef 
NDEBUG


52 #define 
	#assert
(
expr
) (
	`__ASSERT_VOID_CAST
 (0))

	)

60 #ifdef 
__USE_GNU


61 #define 
	#assert_perror
(
errnum
) (
	`__ASSERT_VOID_CAST
 (0))

	)

66 #ifndef 
_ASSERT_H_DECLS


67 #define 
	#_ASSERT_H_DECLS


	)

68 
__BEGIN_DECLS


71 extern void 
	$__assert_fail
 (
__const
 char *
__assertion
, __const char *
__file
,

72 unsigned int 
__line
, 
__const
 char *
__function
)

73 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

76 extern void 
	$__assert_perror_fail
 (int 
__errnum
, 
__const
 char *
__file
,

77 unsigned int 
__line
,

78 
__const
 char *
__function
)

79 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

84 extern void 
	$__assert
 (const char *
__assertion
, const char *
__file
, int 
__line
)

85 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

88 
__END_DECLS


91 #define 
	#assert
(
expr
) \

92 ((
expr
) \

93 ? 
	`__ASSERT_VOID_CAST
 (0) \

94 : 
	`__assert_fail
 (
	`__STRING
(
expr
), 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
))

	)

96 #ifdef 
__USE_GNU


97 #define 
	#assert_perror
(
errnum
) \

98 (!(
errnum
) \

99 ? 
	`__ASSERT_VOID_CAST
 (0) \

100 : 
	`__assert_perror_fail
 ((
errnum
), 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
))

	)

108 #if 
defined
 
__cplusplus
 ? 
	`__GNUC_PREREQ
 (2, 6) : __GNUC_PREREQ (2, 4)

109 #define 
	#__ASSERT_FUNCTION
 
__PRETTY_FUNCTION__


	)

111 #if 
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

112 #define 
	#__ASSERT_FUNCTION
 
__func__


	)

114 #define 
	#__ASSERT_FUNCTION
 ((
__const
 char *) 0)

	)

	@/usr/include/ctype.h

24 #ifndef 
_CTYPE_H


25 #define 
	#_CTYPE_H
 1

	)

27 #include 
	~<features.h
>

28 #include 
	~<bits/types.h
>

30 
	g__BEGIN_DECLS


32 #ifndef 
_ISbit


41 #include 
	~<endian.h
>

42 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


43 #define 
	#_ISbit
(
bit
) (1 << (bit))

	)

45 #define 
	#_ISbit
(
bit
) ((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))

	)

50 
	m_ISupper
 = 
_ISbit
 (0),

51 
	m_ISlower
 = 
_ISbit
 (1),

52 
	m_ISalpha
 = 
_ISbit
 (2),

53 
	m_ISdigit
 = 
_ISbit
 (3),

54 
	m_ISxdigit
 = 
_ISbit
 (4),

55 
	m_ISspace
 = 
_ISbit
 (5),

56 
	m_ISprint
 = 
_ISbit
 (6),

57 
	m_ISgraph
 = 
_ISbit
 (7),

58 
	m_ISblank
 = 
_ISbit
 (8),

59 
	m_IScntrl
 = 
_ISbit
 (9),

60 
	m_ISpunct
 = 
_ISbit
 (10),

61 
	m_ISalnum
 = 
_ISbit
 (11)

81 extern 
__const
 unsigned short int **
	$__ctype_b_loc
 (void)

82 
__THROW
 
	`__attribute__
 ((
__const
));

83 extern 
__const
 
__int32_t
 **
	$__ctype_tolower_loc
 (void)

84 
__THROW
 
	`__attribute__
 ((
__const
));

85 extern 
__const
 
__int32_t
 **
	$__ctype_toupper_loc
 (void)

86 
__THROW
 
	`__attribute__
 ((
__const
));

88 #define 
	#__isctype
(
c
, 
type
) \

89 ((*
	`__ctype_b_loc
 ())[(int) (
c
)] & (unsigned short int) 
type
)

	)

91 #define 
	#__isascii
(
c
) (((c) & ~0x7f) == 0)

	)

92 #define 
	#__toascii
(
c
) ((c) & 0x7f)

	)

94 #define 
	#__exctype
(
name
) extern int 
	`name
 (int) 
__THROW


	)

96 
__BEGIN_NAMESPACE_STD


102 
	`__exctype
 (
isalnum
);

103 
	`__exctype
 (
isalpha
);

104 
	`__exctype
 (
iscntrl
);

105 
	`__exctype
 (
isdigit
);

106 
	`__exctype
 (
islower
);

107 
	`__exctype
 (
isgraph
);

108 
	`__exctype
 (
isprint
);

109 
	`__exctype
 (
ispunct
);

110 
	`__exctype
 (
isspace
);

111 
	`__exctype
 (
isupper
);

112 
	`__exctype
 (
isxdigit
);

116 extern int 
	$tolower
 (int 
__c
) 
__THROW
;

119 extern int 
	$toupper
 (int 
__c
) 
__THROW
;

121 
__END_NAMESPACE_STD


125 #ifdef 
__USE_ISOC99


126 
__BEGIN_NAMESPACE_C99


128 
	`__exctype
 (
isblank
);

130 
__END_NAMESPACE_C99


133 #ifdef 
__USE_GNU


135 extern int 
	$isctype
 (int 
__c
, int 
__mask
) 
__THROW
;

138 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


142 extern int 
	$isascii
 (int 
__c
) 
__THROW
;

146 extern int 
	$toascii
 (int 
__c
) 
__THROW
;

150 
	`__exctype
 (
_toupper
);

151 
	`__exctype
 (
_tolower
);

155 #define 
	#__tobody
(
c
, 
f
, 
a
, 
args
) \

156 (
__extension__
 \

157 ({ int 
__res
; \

158 if (sizeof (
c
) > 1) \

160 if (
	`__builtin_constant_p
 (
c
)) \

162 int 
__c
 = (
c
); \

163 
__res
 = 
__c
 < -128 || __c > 255 ? __c : (
a
)[__c]; \

166 
__res
 = 
f
 
args
; \

169 
__res
 = (
a
)[(int) (
c
)]; \

170 
__res
; 
	}
}))

	)

172 #if !
defined
 
__NO_CTYPE
 && !defined 
__cplusplus


173 #define 
	#isalnum
(
c
) 
	`__isctype
((c), 
_ISalnum
)

	)

174 #define 
	#isalpha
(
c
) 
	`__isctype
((c), 
_ISalpha
)

	)

175 #define 
	#iscntrl
(
c
) 
	`__isctype
((c), 
_IScntrl
)

	)

176 #define 
	#isdigit
(
c
) 
	`__isctype
((c), 
_ISdigit
)

	)

177 #define 
	#islower
(
c
) 
	`__isctype
((c), 
_ISlower
)

	)

178 #define 
	#isgraph
(
c
) 
	`__isctype
((c), 
_ISgraph
)

	)

179 #define 
	#isprint
(
c
) 
	`__isctype
((c), 
_ISprint
)

	)

180 #define 
	#ispunct
(
c
) 
	`__isctype
((c), 
_ISpunct
)

	)

181 #define 
	#isspace
(
c
) 
	`__isctype
((c), 
_ISspace
)

	)

182 #define 
	#isupper
(
c
) 
	`__isctype
((c), 
_ISupper
)

	)

183 #define 
	#isxdigit
(
c
) 
	`__isctype
((c), 
_ISxdigit
)

	)

185 #ifdef 
__USE_ISOC99


186 #define 
	#isblank
(
c
) 
	`__isctype
((c), 
_ISblank
)

	)

189 #ifdef 
__USE_EXTERN_INLINES


190 
__extern_inline
 int

191 
__NTH
 (
	$tolower
 (int 
__c
))

193 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_tolower_loc
 ())[__c] : __c;

194 
	}
}

196 
__extern_inline
 int

197 
__NTH
 (
	$toupper
 (int 
__c
))

199 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_toupper_loc
 ())[__c] : __c;

200 
	}
}

203 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


204 #define 
	#tolower
(
c
) 
	`__tobody
 (c, 
tolower
, *
	`__ctype_tolower_loc
 (), (c))

	)

205 #define 
	#toupper
(
c
) 
	`__tobody
 (c, 
toupper
, *
	`__ctype_toupper_loc
 (), (c))

	)

208 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


209 #define 
	#isascii
(
c
) 
	`__isascii
 (c)

	)

210 #define 
	#toascii
(
c
) 
	`__toascii
 (c)

	)

212 #define 
	#_tolower
(
c
) ((int) (*
	`__ctype_tolower_loc
 ())[(int) (c)])

	)

213 #define 
	#_toupper
(
c
) ((int) (*
	`__ctype_toupper_loc
 ())[(int) (c)])

	)

219 #ifdef 
__USE_XOPEN2K8


233 #include 
	~<xlocale.h
>

237 #define 
	#__isctype_l
(
c
, 
type
, 
locale
) \

238 ((
locale
)->
__ctype_b
[(int) (
c
)] & (unsigned short int) 
type
)

	)

240 #define 
	#__exctype_l
(
name
) \

241 extern int 
	`name
 (int, 
__locale_t
) 
__THROW


	)

247 
__exctype_l
 (
isalnum_l
);

248 
__exctype_l
 (
isalpha_l
);

249 
__exctype_l
 (
iscntrl_l
);

250 
__exctype_l
 (
isdigit_l
);

251 
__exctype_l
 (
islower_l
);

252 
__exctype_l
 (
isgraph_l
);

253 
__exctype_l
 (
isprint_l
);

254 
__exctype_l
 (
ispunct_l
);

255 
__exctype_l
 (
isspace_l
);

256 
__exctype_l
 (
isupper_l
);

257 
__exctype_l
 (
isxdigit_l
);

259 
__exctype_l
 (
isblank_l
);

263 extern int 
	$__tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

264 extern int 
	$tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

267 extern int 
	$__toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

268 extern int 
	$toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

270 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


271 #define 
	#__tolower_l
(
c
, 
locale
) \

272 
	`__tobody
 (
c
, 
__tolower_l
, (
locale
)->
__ctype_tolower
, (c, locale))

	)

273 #define 
	#__toupper_l
(
c
, 
locale
) \

274 
	`__tobody
 (
c
, 
__toupper_l
, (
locale
)->
__ctype_toupper
, (c, locale))

	)

275 #define 
	#tolower_l
(
c
, 
locale
) 
	`__tolower_l
 ((c), (locale))

	)

276 #define 
	#toupper_l
(
c
, 
locale
) 
	`__toupper_l
 ((c), (locale))

	)

280 #ifndef 
__NO_CTYPE


281 #define 
	#__isalnum_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalnum
, (l))

	)

282 #define 
	#__isalpha_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalpha
, (l))

	)

283 #define 
	#__iscntrl_l
(
c
,
l
) 
	`__isctype_l
((c), 
_IScntrl
, (l))

	)

284 #define 
	#__isdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISdigit
, (l))

	)

285 #define 
	#__islower_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISlower
, (l))

	)

286 #define 
	#__isgraph_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISgraph
, (l))

	)

287 #define 
	#__isprint_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISprint
, (l))

	)

288 #define 
	#__ispunct_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISpunct
, (l))

	)

289 #define 
	#__isspace_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISspace
, (l))

	)

290 #define 
	#__isupper_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISupper
, (l))

	)

291 #define 
	#__isxdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISxdigit
, (l))

	)

293 #define 
	#__isblank_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISblank
, (l))

	)

295 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC


296 #define 
	#__isascii_l
(
c
,
l
) ((l), 
	`__isascii
 (c))

	)

297 #define 
	#__toascii_l
(
c
,
l
) ((l), 
	`__toascii
 (c))

	)

300 #define 
	#isalnum_l
(
c
,
l
) 
	`__isalnum_l
 ((c), (l))

	)

301 #define 
	#isalpha_l
(
c
,
l
) 
	`__isalpha_l
 ((c), (l))

	)

302 #define 
	#iscntrl_l
(
c
,
l
) 
	`__iscntrl_l
 ((c), (l))

	)

303 #define 
	#isdigit_l
(
c
,
l
) 
	`__isdigit_l
 ((c), (l))

	)

304 #define 
	#islower_l
(
c
,
l
) 
	`__islower_l
 ((c), (l))

	)

305 #define 
	#isgraph_l
(
c
,
l
) 
	`__isgraph_l
 ((c), (l))

	)

306 #define 
	#isprint_l
(
c
,
l
) 
	`__isprint_l
 ((c), (l))

	)

307 #define 
	#ispunct_l
(
c
,
l
) 
	`__ispunct_l
 ((c), (l))

	)

308 #define 
	#isspace_l
(
c
,
l
) 
	`__isspace_l
 ((c), (l))

	)

309 #define 
	#isupper_l
(
c
,
l
) 
	`__isupper_l
 ((c), (l))

	)

310 #define 
	#isxdigit_l
(
c
,
l
) 
	`__isxdigit_l
 ((c), (l))

	)

312 #define 
	#isblank_l
(
c
,
l
) 
	`__isblank_l
 ((c), (l))

	)

314 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC


315 #define 
	#isascii_l
(
c
,
l
) 
	`__isascii_l
 ((c), (l))

	)

316 #define 
	#toascii_l
(
c
,
l
) 
	`__toascii_l
 ((c), (l))

	)

323 
__END_DECLS


	@/usr/include/dirent.h

23 #ifndef 
_DIRENT_H


24 #define 
	#_DIRENT_H
 1

	)

26 #include 
	~<features.h
>

28 
	g__BEGIN_DECLS


30 #include 
	~<bits/types.h
>

32 #ifdef 
__USE_XOPEN


33 #ifndef 
__ino_t_defined


34 #ifndef 
__USE_FILE_OFFSET64


35 typedef 
__ino_t
 
	tino_t
;

37 typedef 
__ino64_t
 
	tino_t
;

39 #define 
	#__ino_t_defined


	)

41 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__ino64_t_defined


42 typedef 
__ino64_t
 
	tino64_t
;

43 #define 
	#__ino64_t_defined


	)

62 #include 
	~<bits/dirent.h
>

64 #if (
defined
 
__USE_BSD
 || defined 
__USE_MISC
) && !defined 
d_fileno


65 #define 
	#d_ino
 
d_fileno


	)

82 #ifdef 
_DIRENT_HAVE_D_NAMLEN


83 #define 
	#_D_EXACT_NAMLEN
(
d
) ((d)->
d_namlen
)

	)

84 #define 
	#_D_ALLOC_NAMLEN
(
d
) (
	`_D_EXACT_NAMLEN
 (d) + 1)

	)

86 #define 
	#_D_EXACT_NAMLEN
(
d
) (
	`strlen
 ((d)->
d_name
))

	)

87 #ifdef 
_DIRENT_HAVE_D_RECLEN


88 #define 
	#_D_ALLOC_NAMLEN
(
d
) (((char *) (d) + (d)->
d_reclen
) - &(d)->
d_name
[0])

	)

90 #define 
	#_D_ALLOC_NAMLEN
(
d
) (sizeof (d)->
d_name
 > 1 ? sizeof (d)->d_name : \

91 
	`_D_EXACT_NAMLEN
 (
d
) + 1)

	)

96 #ifdef 
__USE_BSD


100 
	mDT_UNKNOWN
 = 0,

101 #define 
	#DT_UNKNOWN
 
DT_UNKNOWN


	)

102 
	mDT_FIFO
 = 1,

103 #define 
	#DT_FIFO
 
DT_FIFO


	)

104 
	mDT_CHR
 = 2,

105 #define 
	#DT_CHR
 
DT_CHR


	)

106 
	mDT_DIR
 = 4,

107 #define 
	#DT_DIR
 
DT_DIR


	)

108 
	mDT_BLK
 = 6,

109 #define 
	#DT_BLK
 
DT_BLK


	)

110 
	mDT_REG
 = 8,

111 #define 
	#DT_REG
 
DT_REG


	)

112 
	mDT_LNK
 = 10,

113 #define 
	#DT_LNK
 
DT_LNK


	)

114 
	mDT_SOCK
 = 12,

115 #define 
	#DT_SOCK
 
DT_SOCK


	)

116 
	mDT_WHT
 = 14

117 #define 
	#DT_WHT
 
DT_WHT


	)

121 #define 
	#IFTODT
(
mode
) (((mode) & 0170000) >> 12)

	)

122 #define 
	#DTTOIF
(
dirtype
) ((dirtype) << 12)

	)

128 typedef struct 
__dirstream
 
	tDIR
;

135 extern 
DIR
 *
	$opendir
 (
__const
 char *
__name
) 
	`__nonnull
 ((1));

137 #ifdef 
__USE_XOPEN2K8


142 extern 
DIR
 *
	`fdopendir
 (int 
__fd
);

150 extern int 
	$closedir
 (
DIR
 *
__dirp
) 
	`__nonnull
 ((1));

162 #ifndef 
__USE_FILE_OFFSET64


163 extern struct 
dirent
 *
	$readdir
 (
DIR
 *
__dirp
) 
	`__nonnull
 ((1));

165 #ifdef 
__REDIRECT


166 extern struct 
dirent
 *
	`__REDIRECT
 (
readdir
, (
DIR
 *
__dirp
), 
readdir64
)

167 
	`__nonnull
 ((1));

169 #define 
	#readdir
 
readdir64


	)

173 #ifdef 
__USE_LARGEFILE64


174 extern struct 
dirent64
 *
	$readdir64
 (
DIR
 *
__dirp
) 
	`__nonnull
 ((1));

177 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


183 #ifndef 
__USE_FILE_OFFSET64


184 extern int 
	$readdir_r
 (
DIR
 *
__restrict
 
__dirp
,

185 struct 
dirent
 *
__restrict
 
__entry
,

186 struct 
dirent
 **
__restrict
 
__result
)

187 
	`__nonnull
 ((1, 2, 3));

189 #ifdef 
__REDIRECT


190 extern int 
	`__REDIRECT
 (
readdir_r
,

191 (
DIR
 *
__restrict
 
__dirp
,

192 struct 
dirent
 *
__restrict
 
__entry
,

193 struct 
dirent
 **
__restrict
 
__result
),

194 
readdir64_r
) 
	`__nonnull
 ((1, 2, 3));

196 #define 
	#readdir_r
 
readdir64_r


	)

200 #ifdef 
__USE_LARGEFILE64


201 extern int 
	$readdir64_r
 (
DIR
 *
__restrict
 
__dirp
,

202 struct 
dirent64
 *
__restrict
 
__entry
,

203 struct 
dirent64
 **
__restrict
 
__result
)

204 
	`__nonnull
 ((1, 2, 3));

209 extern void 
	$rewinddir
 (
DIR
 *
__dirp
) 
__THROW
 
	`__nonnull
 ((1));

211 #if 
defined
 
__USE_BSD
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


212 #include 
	~<bits/types.h
>

215 extern void 
	$seekdir
 (
DIR
 *
__dirp
, long int 
__pos
) 
__THROW
 
	`__nonnull
 ((1));

218 extern long int 
	$telldir
 (
DIR
 *
__dirp
) 
__THROW
 
	`__nonnull
 ((1));

221 #if 
defined
 
__USE_BSD
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN2K8


224 extern int 
	$dirfd
 (
DIR
 *
__dirp
) 
__THROW
 
	`__nonnull
 ((1));

226 #if 
defined
 
__OPTIMIZE__
 && defined 
_DIR_dirfd


227 #define 
	#dirfd
(
dirp
) 
	`_DIR_dirfd
 (dirp)

	)

230 #if 
defined
 
__USE_BSD
 || defined 
__USE_MISC


231 #ifndef 
MAXNAMLEN


233 #include 
	~<bits/posix1_lim.h
>

236 #ifdef 
NAME_MAX


237 #define 
	#MAXNAMLEN
 
NAME_MAX


	)

239 #define 
	#MAXNAMLEN
 255

	)

244 #define 
	#__need_size_t


	)

245 #include 
	~<stddef.h
>

251 #ifndef 
__USE_FILE_OFFSET64


252 extern int 
	`scandir
 (
__const
 char *
__restrict
 
__dir
,

253 struct 
dirent
 ***
__restrict
 
__namelist
,

254 int (*
__selector
) (
__const
 struct 
dirent
 *),

255 int (*
__cmp
) (
__const
 struct 
dirent
 **,

256 
__const
 struct 
dirent
 **))

257 
	`__nonnull
 ((1, 2));

259 #ifdef 
__REDIRECT


260 extern int 
	`__REDIRECT
 (
scandir
,

261 (
__const
 char *
__restrict
 
__dir
,

262 struct 
dirent
 ***
__restrict
 
__namelist
,

263 int (*
__selector
) (
__const
 struct 
dirent
 *),

264 int (*
__cmp
) (
__const
 struct 
dirent
 **,

265 
__const
 struct 
dirent
 **)),

266 
scandir64
) 
	`__nonnull
 ((1, 2));

268 #define 
	#scandir
 
scandir64


	)

272 #if 
defined
 
__USE_GNU
 && defined 
__USE_LARGEFILE64


275 extern int 
	`scandir64
 (
__const
 char *
__restrict
 
__dir
,

276 struct 
dirent64
 ***
__restrict
 
__namelist
,

277 int (*
__selector
) (
__const
 struct 
dirent64
 *),

278 int (*
__cmp
) (
__const
 struct 
dirent64
 **,

279 
__const
 struct 
dirent64
 **))

280 
	`__nonnull
 ((1, 2));

284 #ifndef 
__USE_FILE_OFFSET64


285 extern int 
	$alphasort
 (
__const
 struct 
dirent
 **
__e1
,

286 
__const
 struct 
dirent
 **
__e2
)

287 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

289 #ifdef 
__REDIRECT


290 extern int 
	`__REDIRECT_NTH
 (
alphasort
,

291 (
__const
 struct 
dirent
 **
__e1
,

292 
__const
 struct 
dirent
 **
__e2
),

293 
alphasort64
) 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

295 #define 
	#alphasort
 
alphasort64


	)

299 #if 
defined
 
__USE_GNU
 && defined 
__USE_LARGEFILE64


300 extern int 
	$alphasort64
 (
__const
 struct 
dirent64
 **
__e1
,

301 
__const
 struct 
dirent64
 **
__e2
)

302 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

307 #if 
defined
 
__USE_BSD
 || defined 
__USE_MISC


312 #ifndef 
__USE_FILE_OFFSET64


313 extern 
__ssize_t
 
	$getdirentries
 (int 
__fd
, char *
__restrict
 
__buf
,

314 
size_t
 
__nbytes
,

315 
__off_t
 *
__restrict
 
__basep
)

316 
__THROW
 
	`__nonnull
 ((2, 4));

318 #ifdef 
__REDIRECT


319 extern 
__ssize_t
 
	`__REDIRECT_NTH
 (
getdirentries
,

320 (int 
__fd
, char *
__restrict
 
__buf
,

321 
size_t
 
__nbytes
,

322 
__off64_t
 *
__restrict
 
__basep
),

323 
getdirentries64
) 
	`__nonnull
 ((2, 4));

325 #define 
	#getdirentries
 
getdirentries64


	)

329 #ifdef 
__USE_LARGEFILE64


330 extern 
__ssize_t
 
	$getdirentries64
 (int 
__fd
, char *
__restrict
 
__buf
,

331 
size_t
 
__nbytes
,

332 
__off64_t
 *
__restrict
 
__basep
)

333 
__THROW
 
	`__nonnull
 ((2, 4));

337 #ifdef 
__USE_GNU


339 #ifndef 
__USE_FILE_OFFSET64


340 extern int 
	$versionsort
 (
__const
 struct 
dirent
 **
__e1
,

341 
__const
 struct 
dirent
 **
__e2
)

342 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

344 #ifdef 
__REDIRECT


345 extern int 
	`__REDIRECT_NTH
 (
versionsort
,

346 (
__const
 struct 
dirent
 **
__e1
,

347 
__const
 struct 
dirent
 **
__e2
),

348 
versionsort64
)

349 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

351 #define 
	#versionsort
 
versionsort64


	)

355 #ifdef 
__USE_LARGEFILE64


356 extern int 
	$versionsort64
 (
__const
 struct 
dirent64
 **
__e1
,

357 
__const
 struct 
dirent64
 **
__e2
)

358 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

362 
__END_DECLS


	@/usr/include/errno.h

23 #ifndef 
_ERRNO_H


27 #ifndef 
__need_Emath


28 #define 
	#_ERRNO_H
 1

	)

29 #include 
	~<features.h
>

32 
	g__BEGIN_DECLS


36 #include 
	~<bits/errno.h
>

37 #undef 
__need_Emath


39 #ifdef 
_ERRNO_H


46 #ifndef 
errno


47 extern int 
errno
;

50 #ifdef 
__USE_GNU


55 extern char *
program_invocation_name
, *
program_invocation_short_name
;

59 
	g__END_DECLS


67 #if 
defined
 
__USE_GNU
 || defined 
__need_error_t


68 #ifndef 
__error_t_defined


69 typedef int 
	terror_t
;

70 #define 
	#__error_t_defined
 1

	)

72 #undef 
__need_error_t


	@/usr/include/error.h

20 #ifndef 
_ERROR_H


21 #define 
	#_ERROR_H
 1

	)

23 #include 
	~<features.h
>

26 
__BEGIN_DECLS


32 extern void 
	$error
 (int 
__status
, int 
__errnum
, 
__const
 char *
__format
, ...)

33 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

35 extern void 
	$error_at_line
 (int 
__status
, int 
__errnum
, 
__const
 char *
__fname
,

36 unsigned int 
__lineno
, 
__const
 char *
__format
, ...)

37 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 5, 6)));

42 extern void (*
error_print_progname
) (void);

45 extern unsigned int 
error_message_count
;

49 extern int 
error_one_per_line
;

52 #if 
defined
 
__extern_always_inline
 && defined 
__va_arg_pack


53 #include 
	~<bits/error.h
>

56 
__END_DECLS


	@/usr/include/fcntl.h

24 #ifndef 
_FCNTL_H


25 #define 
	#_FCNTL_H
 1

	)

27 #include 
	~<features.h
>

30 
	g__BEGIN_DECLS


34 #include 
	~<bits/fcntl.h
>

37 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


38 #include 
	~<bits/types.h
>

39 #define 
	#__need_timespec


	)

40 #include 
	~<time.h
>

41 #include 
	~<bits/stat.h
>

43 #define 
	#S_IFMT
 
__S_IFMT


	)

44 #define 
	#S_IFDIR
 
__S_IFDIR


	)

45 #define 
	#S_IFCHR
 
__S_IFCHR


	)

46 #define 
	#S_IFBLK
 
__S_IFBLK


	)

47 #define 
	#S_IFREG
 
__S_IFREG


	)

48 #ifdef 
__S_IFIFO


49 #define 
	#S_IFIFO
 
__S_IFIFO


	)

51 #ifdef 
__S_IFLNK


52 #define 
	#S_IFLNK
 
__S_IFLNK


	)

54 #if (
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8
) && defined 
__S_IFSOCK


55 #define 
	#S_IFSOCK
 
__S_IFSOCK


	)

60 #define 
	#S_ISUID
 
__S_ISUID


	)

61 #define 
	#S_ISGID
 
__S_ISGID


	)

63 #if 
defined
 
__USE_BSD
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


65 #define 
	#S_ISVTX
 
__S_ISVTX


	)

68 #define 
	#S_IRUSR
 
__S_IREAD


	)

69 #define 
	#S_IWUSR
 
__S_IWRITE


	)

70 #define 
	#S_IXUSR
 
__S_IEXEC


	)

72 #define 
	#S_IRWXU
 (
__S_IREAD
|
__S_IWRITE
|
__S_IEXEC
)

	)

74 #define 
	#S_IRGRP
 (
S_IRUSR
 >> 3)

	)

75 #define 
	#S_IWGRP
 (
S_IWUSR
 >> 3)

	)

76 #define 
	#S_IXGRP
 (
S_IXUSR
 >> 3)

	)

78 #define 
	#S_IRWXG
 (
S_IRWXU
 >> 3)

	)

80 #define 
	#S_IROTH
 (
S_IRGRP
 >> 3)

	)

81 #define 
	#S_IWOTH
 (
S_IWGRP
 >> 3)

	)

82 #define 
	#S_IXOTH
 (
S_IXGRP
 >> 3)

	)

84 #define 
	#S_IRWXO
 (
S_IRWXG
 >> 3)

	)

87 #ifdef 
__USE_MISC


88 #ifndef 
R_OK


91 #define 
	#R_OK
 4

	)

92 #define 
	#W_OK
 2

	)

93 #define 
	#X_OK
 1

	)

94 #define 
	#F_OK
 0

	)

99 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


100 #define 
	#SEEK_SET
 0

	)

101 #define 
	#SEEK_CUR
 1

	)

102 #define 
	#SEEK_END
 2

	)

110 extern int 
fcntl
 (int 
__fd
, int 
__cmd
, ...);

118 #ifndef 
__USE_FILE_OFFSET64


119 extern int 
	$open
 (
__const
 char *
__file
, int 
__oflag
, ...) 
	`__nonnull
 ((1));

121 #ifdef 
__REDIRECT


122 extern int 
	`__REDIRECT
 (
open
, (
__const
 char *
__file
, int 
__oflag
, ...), 
open64
)

123 
	`__nonnull
 ((1));

125 #define 
	#open
 
open64


	)

128 #ifdef 
__USE_LARGEFILE64


129 extern int 
	$open64
 (
__const
 char *
__file
, int 
__oflag
, ...) 
	`__nonnull
 ((1));

132 #ifdef 
__USE_ATFILE


142 #ifndef 
__USE_FILE_OFFSET64


143 extern int 
	$openat
 (int 
__fd
, 
__const
 char *
__file
, int 
__oflag
, ...)

144 
	`__nonnull
 ((2));

146 #ifdef 
__REDIRECT


147 extern int 
	`__REDIRECT
 (
openat
, (int 
__fd
, 
__const
 char *
__file
, int 
__oflag
,

148 ...), 
openat64
) 
	`__nonnull
 ((2));

150 #define 
	#openat
 
openat64


	)

153 #ifdef 
__USE_LARGEFILE64


154 extern int 
	$openat64
 (int 
__fd
, 
__const
 char *
__file
, int 
__oflag
, ...)

155 
	`__nonnull
 ((2));

164 #ifndef 
__USE_FILE_OFFSET64


165 extern int 
	$creat
 (
__const
 char *
__file
, 
__mode_t
 
__mode
) 
	`__nonnull
 ((1));

167 #ifdef 
__REDIRECT


168 extern int 
	`__REDIRECT
 (
creat
, (
__const
 char *
__file
, 
__mode_t
 
__mode
),

169 
creat64
) 
	`__nonnull
 ((1));

171 #define 
	#creat
 
creat64


	)

174 #ifdef 
__USE_LARGEFILE64


175 extern int 
	$creat64
 (
__const
 char *
__file
, 
__mode_t
 
__mode
) 
	`__nonnull
 ((1));

178 #if !
defined
 
F_LOCK
 && (defined 
__USE_MISC
 || (defined 
__USE_XOPEN_EXTENDED
 \

179 && !
defined
 
__USE_POSIX
))

188 #define 
	#F_ULOCK
 0

	)

189 #define 
	#F_LOCK
 1

	)

190 #define 
	#F_TLOCK
 2

	)

191 #define 
	#F_TEST
 3

	)

193 #ifndef 
__USE_FILE_OFFSET64


194 extern int 
	`lockf
 (int 
__fd
, int 
__cmd
, 
__off_t
 
__len
);

196 #ifdef 
__REDIRECT


197 extern int 
	`__REDIRECT
 (
lockf
, (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
), 
lockf64
);

199 #define 
	#lockf
 
lockf64


	)

202 #ifdef 
__USE_LARGEFILE64


203 extern int 
	`lockf64
 (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
);

207 #ifdef 
__USE_XOPEN2K


210 #ifndef 
__USE_FILE_OFFSET64


211 extern int 
	$posix_fadvise
 (int 
__fd
, 
__off_t
 
__offset
, __off_t 
__len
,

212 int 
__advise
) 
__THROW
;

214 #ifdef 
__REDIRECT_NTH


215 extern int 
	`__REDIRECT_NTH
 (
posix_fadvise
, (int 
__fd
, 
__off64_t
 
__offset
,

216 
__off64_t
 
__len
, int 
__advise
),

217 
posix_fadvise64
);

219 #define 
	#posix_fadvise
 
posix_fadvise64


	)

222 #ifdef 
__USE_LARGEFILE64


223 extern int 
	$posix_fadvise64
 (int 
__fd
, 
__off64_t
 
__offset
, __off64_t 
__len
,

224 int 
__advise
) 
__THROW
;

232 #ifndef 
__USE_FILE_OFFSET64


233 extern int 
	`posix_fallocate
 (int 
__fd
, 
__off_t
 
__offset
, __off_t 
__len
);

235 #ifdef 
__REDIRECT


236 extern int 
	`__REDIRECT
 (
posix_fallocate
, (int 
__fd
, 
__off64_t
 
__offset
,

237 
__off64_t
 
__len
),

238 
posix_fallocate64
);

240 #define 
	#posix_fallocate
 
posix_fallocate64


	)

243 #ifdef 
__USE_LARGEFILE64


244 extern int 
	`posix_fallocate64
 (int 
__fd
, 
__off64_t
 
__offset
, __off64_t 
__len
);

250 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline
 \

251 && 
defined
 
__va_arg_pack_len


252 #include 
	~<bits/fcntl2.h
>

255 
__END_DECLS


	@/usr/include/features.h

20 #ifndef 
_FEATURES_H


21 #define 
	#_FEATURES_H
 1

	)

97 #undef 
__USE_ISOC99


98 #undef 
__USE_ISOC95


99 #undef 
__USE_POSIX


100 #undef 
__USE_POSIX2


101 #undef 
__USE_POSIX199309


102 #undef 
__USE_POSIX199506


103 #undef 
__USE_XOPEN


104 #undef 
__USE_XOPEN_EXTENDED


105 #undef 
__USE_UNIX98


106 #undef 
__USE_XOPEN2K


107 #undef 
__USE_XOPEN2KXSI


108 #undef 
__USE_XOPEN2K8


109 #undef 
__USE_XOPEN2K8XSI


110 #undef 
__USE_LARGEFILE


111 #undef 
__USE_LARGEFILE64


112 #undef 
__USE_FILE_OFFSET64


113 #undef 
__USE_BSD


114 #undef 
__USE_SVID


115 #undef 
__USE_MISC


116 #undef 
__USE_ATFILE


117 #undef 
__USE_GNU


118 #undef 
__USE_REENTRANT


119 #undef 
__USE_FORTIFY_LEVEL


120 #undef 
__FAVOR_BSD


121 #undef 
__KERNEL_STRICT_NAMES


125 #ifndef 
_LOOSE_KERNEL_NAMES


126 #define 
	#__KERNEL_STRICT_NAMES


	)

130 #define 
	#__USE_ANSI
 1

	)

139 #if 
defined
 
__GNUC__
 && defined 
__GNUC_MINOR__


140 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) \

141 ((
__GNUC__
 << 16) + 
__GNUC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

143 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) 0

	)

148 #if 
defined
 
_BSD_SOURCE
 && \

149 !(
defined
 
	g_POSIX_SOURCE
 || defined 
	g_POSIX_C_SOURCE
 || \

150 
defined
 
	g_XOPEN_SOURCE
 || defined 
	g_GNU_SOURCE
 || defined 
	g_SVID_SOURCE
)

151 #define 
	#__FAVOR_BSD
 1

	)

155 #ifdef 
_GNU_SOURCE


156 #undef 
_ISOC95_SOURCE


157 #define 
	#_ISOC95_SOURCE
 1

	)

158 #undef 
_ISOC99_SOURCE


159 #define 
	#_ISOC99_SOURCE
 1

	)

160 #undef 
_POSIX_SOURCE


161 #define 
	#_POSIX_SOURCE
 1

	)

162 #undef 
_POSIX_C_SOURCE


163 #define 
	#_POSIX_C_SOURCE
 200809L

	)

164 #undef 
_XOPEN_SOURCE


165 #define 
	#_XOPEN_SOURCE
 700

	)

166 #undef 
_XOPEN_SOURCE_EXTENDED


167 #define 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

168 #undef 
_LARGEFILE64_SOURCE


169 #define 
	#_LARGEFILE64_SOURCE
 1

	)

170 #undef 
_BSD_SOURCE


171 #define 
	#_BSD_SOURCE
 1

	)

172 #undef 
_SVID_SOURCE


173 #define 
	#_SVID_SOURCE
 1

	)

174 #undef 
_ATFILE_SOURCE


175 #define 
	#_ATFILE_SOURCE
 1

	)

180 #if (!
defined
 
__STRICT_ANSI__
 && !defined 
_ISOC99_SOURCE
 && \

181 !
defined
 
	g_POSIX_SOURCE
 && !defined 
	g_POSIX_C_SOURCE
 && \

182 !
defined
 
	g_XOPEN_SOURCE
 && !defined 
	g_BSD_SOURCE
 && !defined 
	g_SVID_SOURCE
)

183 #define 
	#_BSD_SOURCE
 1

	)

184 #define 
	#_SVID_SOURCE
 1

	)

191 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC9X_SOURCE
 \

192 || (
defined
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

193 #define 
	#__USE_ISOC99
 1

	)

197 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC9X_SOURCE
 \

198 || (
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

199 #define 
	#__USE_ISOC95
 1

	)

204 #if ((!
defined
 
__STRICT_ANSI__
 || (
_XOPEN_SOURCE
 - 0) >= 500) && \

205 !
defined
 
_POSIX_SOURCE
 && !defined 
_POSIX_C_SOURCE
)

206 #define 
	#_POSIX_SOURCE
 1

	)

207 #if 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

208 #define 
	#_POSIX_C_SOURCE
 2

	)

209 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

210 #define 
	#_POSIX_C_SOURCE
 199506L

	)

211 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

212 #define 
	#_POSIX_C_SOURCE
 200112L

	)

214 #define 
	#_POSIX_C_SOURCE
 200809L

	)

216 #define 
	#__USE_POSIX_IMPLICITLY
 1

	)

219 #if 
defined
 
_POSIX_SOURCE
 || 
_POSIX_C_SOURCE
 >= 1 || defined 
_XOPEN_SOURCE


220 #define 
	#__USE_POSIX
 1

	)

223 #if 
defined
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >= 2 || defined 
_XOPEN_SOURCE


224 #define 
	#__USE_POSIX2
 1

	)

227 #if (
_POSIX_C_SOURCE
 - 0) >= 199309L

228 #define 
	#__USE_POSIX199309
 1

	)

231 #if (
_POSIX_C_SOURCE
 - 0) >= 199506L

232 #define 
	#__USE_POSIX199506
 1

	)

235 #if (
_POSIX_C_SOURCE
 - 0) >= 200112L

236 #define 
	#__USE_XOPEN2K
 1

	)

237 #undef 
__USE_ISOC95


238 #define 
	#__USE_ISOC95
 1

	)

239 #undef 
__USE_ISOC99


240 #define 
	#__USE_ISOC99
 1

	)

243 #if (
_POSIX_C_SOURCE
 - 0) >= 200809L

244 #define 
	#__USE_XOPEN2K8
 1

	)

245 #undef 
_ATFILE_SOURCE


246 #define 
	#_ATFILE_SOURCE
 1

	)

249 #ifdef 
_XOPEN_SOURCE


250 #define 
	#__USE_XOPEN
 1

	)

251 #if (
_XOPEN_SOURCE
 - 0) >= 500

252 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

253 #define 
	#__USE_UNIX98
 1

	)

254 #undef 
_LARGEFILE_SOURCE


255 #define 
	#_LARGEFILE_SOURCE
 1

	)

256 #if (
_XOPEN_SOURCE
 - 0) >= 600

257 #if (
_XOPEN_SOURCE
 - 0) >= 700

258 #define 
	#__USE_XOPEN2K8
 1

	)

259 #define 
	#__USE_XOPEN2K8XSI
 1

	)

261 #define 
	#__USE_XOPEN2K
 1

	)

262 #define 
	#__USE_XOPEN2KXSI
 1

	)

263 #undef 
__USE_ISOC95


264 #define 
	#__USE_ISOC95
 1

	)

265 #undef 
__USE_ISOC99


266 #define 
	#__USE_ISOC99
 1

	)

269 #ifdef 
_XOPEN_SOURCE_EXTENDED


270 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

275 #ifdef 
_LARGEFILE_SOURCE


276 #define 
	#__USE_LARGEFILE
 1

	)

279 #ifdef 
_LARGEFILE64_SOURCE


280 #define 
	#__USE_LARGEFILE64
 1

	)

283 #if 
defined
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

284 #define 
	#__USE_FILE_OFFSET64
 1

	)

287 #if 
defined
 
_BSD_SOURCE
 || defined 
_SVID_SOURCE


288 #define 
	#__USE_MISC
 1

	)

291 #ifdef 
_BSD_SOURCE


292 #define 
	#__USE_BSD
 1

	)

295 #ifdef 
_SVID_SOURCE


296 #define 
	#__USE_SVID
 1

	)

299 #ifdef 
_ATFILE_SOURCE


300 #define 
	#__USE_ATFILE
 1

	)

303 #ifdef 
_GNU_SOURCE


304 #define 
	#__USE_GNU
 1

	)

307 #if 
defined
 
_REENTRANT
 || defined 
_THREAD_SAFE


308 #define 
	#__USE_REENTRANT
 1

	)

311 #if 
defined
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

312 && 
__GNUC_PREREQ
 (4, 1) && 
defined
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

313 #if 
_FORTIFY_SOURCE
 > 1

314 #define 
	#__USE_FORTIFY_LEVEL
 2

	)

316 #define 
	#__USE_FORTIFY_LEVEL
 1

	)

319 #define 
	#__USE_FORTIFY_LEVEL
 0

	)

323 #include 
	~<bits/predefs.h
>

326 #define 
	#__STDC_ISO_10646__
 200009L

	)

334 #undef 
__GNU_LIBRARY__


335 #define 
	#__GNU_LIBRARY__
 6

	)

339 #define 
	#__GLIBC__
 2

	)

340 #define 
	#__GLIBC_MINOR__
 13

	)

342 #define 
	#__GLIBC_PREREQ
(
maj
, 
min
) \

343 ((
__GLIBC__
 << 16) + 
__GLIBC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

346 #if 
defined
 
__GNUC__
 \

347 || (
defined
 
	g__PGI
 && defined 
	g__i386__
 ) \

348 || (
defined
 
	g__INTEL_COMPILER
 && (defined 
	g__i386__
 || defined 
	g__ia64__
)) \

349 || (
defined
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L)

350 #define 
	#__GLIBC_HAVE_LONG_LONG
 1

	)

354 #ifndef 
__ASSEMBLER__


355 #ifndef 
_SYS_CDEFS_H


356 #include 
	~<sys/cdefs.h
>

361 #if 
defined
 
__USE_FILE_OFFSET64
 && !defined 
__REDIRECT


362 #define 
	#__USE_LARGEFILE
 1

	)

363 #define 
	#__USE_LARGEFILE64
 1

	)

369 #if 
__GNUC_PREREQ
 (2, 7) && 
defined
 
__OPTIMIZE__
 \

370 && !
defined
 
	g__OPTIMIZE_SIZE__
 && !defined 
	g__NO_INLINE__
 \

371 && 
defined
 
	g__extern_inline


372 #define 
	#__USE_EXTERN_INLINES
 1

	)

377 #if 
__GNUC_PREREQ
 (2, 7) && 
defined
 
__OPTIMIZE__
 \

378 && (
defined
 
	g_LIBC
 || !defined 
	g__OPTIMIZE_SIZE__
) && !defined 
	g__NO_INLINE__
 \

379 && 
defined
 
	g__extern_inline


380 #define 
	#__USE_EXTERN_INLINES_IN_LIBC
 1

	)

388 #include 
	~<gnu/stubs.h
>

	@/usr/include/fnmatch.h

19 #ifndef 
_FNMATCH_H


20 #define 
	#_FNMATCH_H
 1

	)

22 #ifdef 
__cplusplus


27 #if (
defined
 
__STDC__
 && __STDC__) || defined 
__cplusplus


28 #define 
	#__const
 const

	)

30 #define 
	#__const


	)

36 #undef 
FNM_PATHNAME


37 #undef 
FNM_NOESCAPE


38 #undef 
FNM_PERIOD


41 #define 
	#FNM_PATHNAME
 (1 << 0)

	)

42 #define 
	#FNM_NOESCAPE
 (1 << 1)

	)

43 #define 
	#FNM_PERIOD
 (1 << 2)

	)

45 #if !
defined
 
_POSIX_C_SOURCE
 || _POSIX_C_SOURCE < 2 || defined 
_GNU_SOURCE


46 #define 
	#FNM_FILE_NAME
 
FNM_PATHNAME


	)

47 #define 
	#FNM_LEADING_DIR
 (1 << 3)

	)

48 #define 
	#FNM_CASEFOLD
 (1 << 4)

	)

49 #define 
	#FNM_EXTMATCH
 (1 << 5)

	)

53 #define 
	#FNM_NOMATCH
 1

	)

59 #ifdef 
_XOPEN_SOURCE


60 #define 
	#FNM_NOSYS
 (-1)

	)

65 extern int 
fnmatch
 (
__const
 char *
__pattern
, __const char *
__name
,

66 int 
__flags
);

68 #ifdef 
__cplusplus


	@/usr/include/getopt.h

21 #ifndef 
_GETOPT_H


23 #ifndef 
__need_getopt


24 #define 
	#_GETOPT_H
 1

	)

34 #if !
defined
 
__GNU_LIBRARY__


35 #include 
	~<ctype.h
>

38 #ifndef 
__THROW


39 #ifndef 
__GNUC_PREREQ


40 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) (0)

	)

42 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,8)

43 #define 
	#__THROW
 
	`throw
 ()

	)

45 #define 
	#__THROW


	)

49 #ifdef 
__cplusplus


59 extern char *
optarg
;

73 extern int 
optind
;

78 extern int 
opterr
;

82 extern int 
optopt
;

84 #ifndef 
__need_getopt


106 struct 
	soption


108 const char *
	gname
;

111 int 
	ghas_arg
;

112 int *
	gflag
;

113 int 
	gval
;

118 #define 
	#no_argument
 0

	)

119 #define 
	#required_argument
 1

	)

120 #define 
	#optional_argument
 2

	)

148 #ifdef 
__GNU_LIBRARY__


152 extern int 
getopt
 (int 
___argc
, char *const *
___argv
, const char *
__shortopts
)

153 
__THROW
;

155 #if 
defined
 
__need_getopt
 && defined 
__USE_POSIX2
 \

156 && !
defined
 
	g__USE_POSIX_IMPLICITLY
 && !defined 
	g__USE_GNU


160 #ifdef 
__REDIRECT


161 extern int 
__REDIRECT_NTH
 (
getopt
, (int 
___argc
, char *const *
___argv
,

162 const char *
__shortopts
),

163 
__posix_getopt
);

165 extern int 
__posix_getopt
 (int 
___argc
, char *const *
___argv
,

166 const char *
__shortopts
) 
__THROW
;

167 #define 
	#getopt
 
__posix_getopt


	)

171 extern int 
getopt
 ();

174 #ifndef 
__need_getopt


175 extern int 
getopt_long
 (int 
___argc
, char *const *
___argv
,

176 const char *
__shortopts
,

177 const struct 
option
 *
__longopts
, int *
__longind
)

178 
__THROW
;

179 extern int 
getopt_long_only
 (int 
___argc
, char *const *
___argv
,

180 const char *
__shortopts
,

181 const struct 
option
 *
__longopts
, int *
__longind
)

182 
__THROW
;

186 #ifdef 
__cplusplus


191 #undef 
__need_getopt


	@/usr/include/gnu-versions.h

20 #ifndef 
_GNU_VERSIONS_H


21 #define 
	#_GNU_VERSIONS_H
 1

	)

47 #define 
	#_GNU_OBSTACK_INTERFACE_VERSION
 1

	)

48 #define 
	#_GNU_REGEX_INTERFACE_VERSION
 1

	)

49 #define 
	#_GNU_GLOB_INTERFACE_VERSION
 1

	)

50 #define 
	#_GNU_GETOPT_INTERFACE_VERSION
 2

	)

	@/usr/include/iconv.h

19 #ifndef 
_ICONV_H


20 #define 
	#_ICONV_H
 1

	)

22 #include 
	~<features.h
>

23 #define 
	#__need_size_t


	)

24 #include 
	~<stddef.h
>

27 
__BEGIN_DECLS


30 typedef void *
	ticonv_t
;

38 extern 
iconv_t
 
iconv_open
 (
__const
 char *
__tocode
, __const char *
__fromcode
);

43 extern 
size_t
 
iconv
 (
iconv_t
 
__cd
, char **
__restrict
 
__inbuf
,

44 
size_t
 *
__restrict
 
__inbytesleft
,

45 char **
__restrict
 
__outbuf
,

46 
size_t
 *
__restrict
 
__outbytesleft
);

52 extern int 
iconv_close
 (
iconv_t
 
__cd
);

54 
	g__END_DECLS


	@/usr/include/inttypes.h

23 #ifndef 
_INTTYPES_H


24 #define 
	#_INTTYPES_H
 1

	)

26 #include 
	~<features.h
>

28 #include 
	~<stdint.h
>

31 #ifndef 
____gwchar_t_defined


32 #ifdef 
__cplusplus


33 #define 
	#__gwchar_t
 
wchar_t


	)

34 #elif 
defined
 
__WCHAR_TYPE__


35 typedef 
__WCHAR_TYPE__
 
	t__gwchar_t
;

37 #define 
	#__need_wchar_t


	)

38 #include 
	~<stddef.h
>

39 typedef 
wchar_t
 
	t__gwchar_t
;

41 #define 
	#____gwchar_t_defined
 1

	)

47 #if !
defined
 
__cplusplus
 || defined 
__STDC_FORMAT_MACROS


49 #if 
__WORDSIZE
 == 64

50 #define 
	#__PRI64_PREFIX
 "l"

	)

51 #define 
	#__PRIPTR_PREFIX
 "l"

	)

53 #define 
	#__PRI64_PREFIX
 "ll"

	)

54 #define 
	#__PRIPTR_PREFIX


	)

60 #define 
	#PRId8
 "d"

	)

61 #define 
	#PRId16
 "d"

	)

62 #define 
	#PRId32
 "d"

	)

63 #define 
	#PRId64
 
__PRI64_PREFIX
 "d"

	)

65 #define 
	#PRIdLEAST8
 "d"

	)

66 #define 
	#PRIdLEAST16
 "d"

	)

67 #define 
	#PRIdLEAST32
 "d"

	)

68 #define 
	#PRIdLEAST64
 
__PRI64_PREFIX
 "d"

	)

70 #define 
	#PRIdFAST8
 "d"

	)

71 #define 
	#PRIdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

72 #define 
	#PRIdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

73 #define 
	#PRIdFAST64
 
__PRI64_PREFIX
 "d"

	)

76 #define 
	#PRIi8
 "i"

	)

77 #define 
	#PRIi16
 "i"

	)

78 #define 
	#PRIi32
 "i"

	)

79 #define 
	#PRIi64
 
__PRI64_PREFIX
 "i"

	)

81 #define 
	#PRIiLEAST8
 "i"

	)

82 #define 
	#PRIiLEAST16
 "i"

	)

83 #define 
	#PRIiLEAST32
 "i"

	)

84 #define 
	#PRIiLEAST64
 
__PRI64_PREFIX
 "i"

	)

86 #define 
	#PRIiFAST8
 "i"

	)

87 #define 
	#PRIiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

88 #define 
	#PRIiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

89 #define 
	#PRIiFAST64
 
__PRI64_PREFIX
 "i"

	)

92 #define 
	#PRIo8
 "o"

	)

93 #define 
	#PRIo16
 "o"

	)

94 #define 
	#PRIo32
 "o"

	)

95 #define 
	#PRIo64
 
__PRI64_PREFIX
 "o"

	)

97 #define 
	#PRIoLEAST8
 "o"

	)

98 #define 
	#PRIoLEAST16
 "o"

	)

99 #define 
	#PRIoLEAST32
 "o"

	)

100 #define 
	#PRIoLEAST64
 
__PRI64_PREFIX
 "o"

	)

102 #define 
	#PRIoFAST8
 "o"

	)

103 #define 
	#PRIoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

104 #define 
	#PRIoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

105 #define 
	#PRIoFAST64
 
__PRI64_PREFIX
 "o"

	)

108 #define 
	#PRIu8
 "u"

	)

109 #define 
	#PRIu16
 "u"

	)

110 #define 
	#PRIu32
 "u"

	)

111 #define 
	#PRIu64
 
__PRI64_PREFIX
 "u"

	)

113 #define 
	#PRIuLEAST8
 "u"

	)

114 #define 
	#PRIuLEAST16
 "u"

	)

115 #define 
	#PRIuLEAST32
 "u"

	)

116 #define 
	#PRIuLEAST64
 
__PRI64_PREFIX
 "u"

	)

118 #define 
	#PRIuFAST8
 "u"

	)

119 #define 
	#PRIuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

120 #define 
	#PRIuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

121 #define 
	#PRIuFAST64
 
__PRI64_PREFIX
 "u"

	)

124 #define 
	#PRIx8
 "x"

	)

125 #define 
	#PRIx16
 "x"

	)

126 #define 
	#PRIx32
 "x"

	)

127 #define 
	#PRIx64
 
__PRI64_PREFIX
 "x"

	)

129 #define 
	#PRIxLEAST8
 "x"

	)

130 #define 
	#PRIxLEAST16
 "x"

	)

131 #define 
	#PRIxLEAST32
 "x"

	)

132 #define 
	#PRIxLEAST64
 
__PRI64_PREFIX
 "x"

	)

134 #define 
	#PRIxFAST8
 "x"

	)

135 #define 
	#PRIxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

136 #define 
	#PRIxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

137 #define 
	#PRIxFAST64
 
__PRI64_PREFIX
 "x"

	)

140 #define 
	#PRIX8
 "X"

	)

141 #define 
	#PRIX16
 "X"

	)

142 #define 
	#PRIX32
 "X"

	)

143 #define 
	#PRIX64
 
__PRI64_PREFIX
 "X"

	)

145 #define 
	#PRIXLEAST8
 "X"

	)

146 #define 
	#PRIXLEAST16
 "X"

	)

147 #define 
	#PRIXLEAST32
 "X"

	)

148 #define 
	#PRIXLEAST64
 
__PRI64_PREFIX
 "X"

	)

150 #define 
	#PRIXFAST8
 "X"

	)

151 #define 
	#PRIXFAST16
 
__PRIPTR_PREFIX
 "X"

	)

152 #define 
	#PRIXFAST32
 
__PRIPTR_PREFIX
 "X"

	)

153 #define 
	#PRIXFAST64
 
__PRI64_PREFIX
 "X"

	)

157 #define 
	#PRIdMAX
 
__PRI64_PREFIX
 "d"

	)

158 #define 
	#PRIiMAX
 
__PRI64_PREFIX
 "i"

	)

159 #define 
	#PRIoMAX
 
__PRI64_PREFIX
 "o"

	)

160 #define 
	#PRIuMAX
 
__PRI64_PREFIX
 "u"

	)

161 #define 
	#PRIxMAX
 
__PRI64_PREFIX
 "x"

	)

162 #define 
	#PRIXMAX
 
__PRI64_PREFIX
 "X"

	)

166 #define 
	#PRIdPTR
 
__PRIPTR_PREFIX
 "d"

	)

167 #define 
	#PRIiPTR
 
__PRIPTR_PREFIX
 "i"

	)

168 #define 
	#PRIoPTR
 
__PRIPTR_PREFIX
 "o"

	)

169 #define 
	#PRIuPTR
 
__PRIPTR_PREFIX
 "u"

	)

170 #define 
	#PRIxPTR
 
__PRIPTR_PREFIX
 "x"

	)

171 #define 
	#PRIXPTR
 
__PRIPTR_PREFIX
 "X"

	)

177 #define 
	#SCNd8
 "hhd"

	)

178 #define 
	#SCNd16
 "hd"

	)

179 #define 
	#SCNd32
 "d"

	)

180 #define 
	#SCNd64
 
__PRI64_PREFIX
 "d"

	)

182 #define 
	#SCNdLEAST8
 "hhd"

	)

183 #define 
	#SCNdLEAST16
 "hd"

	)

184 #define 
	#SCNdLEAST32
 "d"

	)

185 #define 
	#SCNdLEAST64
 
__PRI64_PREFIX
 "d"

	)

187 #define 
	#SCNdFAST8
 "hhd"

	)

188 #define 
	#SCNdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

189 #define 
	#SCNdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

190 #define 
	#SCNdFAST64
 
__PRI64_PREFIX
 "d"

	)

193 #define 
	#SCNi8
 "hhi"

	)

194 #define 
	#SCNi16
 "hi"

	)

195 #define 
	#SCNi32
 "i"

	)

196 #define 
	#SCNi64
 
__PRI64_PREFIX
 "i"

	)

198 #define 
	#SCNiLEAST8
 "hhi"

	)

199 #define 
	#SCNiLEAST16
 "hi"

	)

200 #define 
	#SCNiLEAST32
 "i"

	)

201 #define 
	#SCNiLEAST64
 
__PRI64_PREFIX
 "i"

	)

203 #define 
	#SCNiFAST8
 "hhi"

	)

204 #define 
	#SCNiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

205 #define 
	#SCNiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

206 #define 
	#SCNiFAST64
 
__PRI64_PREFIX
 "i"

	)

209 #define 
	#SCNu8
 "hhu"

	)

210 #define 
	#SCNu16
 "hu"

	)

211 #define 
	#SCNu32
 "u"

	)

212 #define 
	#SCNu64
 
__PRI64_PREFIX
 "u"

	)

214 #define 
	#SCNuLEAST8
 "hhu"

	)

215 #define 
	#SCNuLEAST16
 "hu"

	)

216 #define 
	#SCNuLEAST32
 "u"

	)

217 #define 
	#SCNuLEAST64
 
__PRI64_PREFIX
 "u"

	)

219 #define 
	#SCNuFAST8
 "hhu"

	)

220 #define 
	#SCNuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

221 #define 
	#SCNuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

222 #define 
	#SCNuFAST64
 
__PRI64_PREFIX
 "u"

	)

225 #define 
	#SCNo8
 "hho"

	)

226 #define 
	#SCNo16
 "ho"

	)

227 #define 
	#SCNo32
 "o"

	)

228 #define 
	#SCNo64
 
__PRI64_PREFIX
 "o"

	)

230 #define 
	#SCNoLEAST8
 "hho"

	)

231 #define 
	#SCNoLEAST16
 "ho"

	)

232 #define 
	#SCNoLEAST32
 "o"

	)

233 #define 
	#SCNoLEAST64
 
__PRI64_PREFIX
 "o"

	)

235 #define 
	#SCNoFAST8
 "hho"

	)

236 #define 
	#SCNoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

237 #define 
	#SCNoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

238 #define 
	#SCNoFAST64
 
__PRI64_PREFIX
 "o"

	)

241 #define 
	#SCNx8
 "hhx"

	)

242 #define 
	#SCNx16
 "hx"

	)

243 #define 
	#SCNx32
 "x"

	)

244 #define 
	#SCNx64
 
__PRI64_PREFIX
 "x"

	)

246 #define 
	#SCNxLEAST8
 "hhx"

	)

247 #define 
	#SCNxLEAST16
 "hx"

	)

248 #define 
	#SCNxLEAST32
 "x"

	)

249 #define 
	#SCNxLEAST64
 
__PRI64_PREFIX
 "x"

	)

251 #define 
	#SCNxFAST8
 "hhx"

	)

252 #define 
	#SCNxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

253 #define 
	#SCNxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

254 #define 
	#SCNxFAST64
 
__PRI64_PREFIX
 "x"

	)

258 #define 
	#SCNdMAX
 
__PRI64_PREFIX
 "d"

	)

259 #define 
	#SCNiMAX
 
__PRI64_PREFIX
 "i"

	)

260 #define 
	#SCNoMAX
 
__PRI64_PREFIX
 "o"

	)

261 #define 
	#SCNuMAX
 
__PRI64_PREFIX
 "u"

	)

262 #define 
	#SCNxMAX
 
__PRI64_PREFIX
 "x"

	)

265 #define 
	#SCNdPTR
 
__PRIPTR_PREFIX
 "d"

	)

266 #define 
	#SCNiPTR
 
__PRIPTR_PREFIX
 "i"

	)

267 #define 
	#SCNoPTR
 
__PRIPTR_PREFIX
 "o"

	)

268 #define 
	#SCNuPTR
 
__PRIPTR_PREFIX
 "u"

	)

269 #define 
	#SCNxPTR
 
__PRIPTR_PREFIX
 "x"

	)

274 
	g__BEGIN_DECLS


276 #if 
__WORDSIZE
 == 64

281 long int 
	mquot
;

282 long int 
	mrem
;

283 } 
	timaxdiv_t
;

290 long long int 
	mquot
;

291 long long int 
	mrem
;

292 } 
	timaxdiv_t
;

298 extern 
intmax_t
 
	$imaxabs
 (
intmax_t
 
__n
) 
__THROW
 
	`__attribute__
 ((
__const__
));

301 extern 
imaxdiv_t
 
	$imaxdiv
 (
intmax_t
 
__numer
, intmax_t 
__denom
)

302 
__THROW
 
	`__attribute__
 ((
__const__
));

305 extern 
intmax_t
 
	$strtoimax
 (
__const
 char *
__restrict
 
__nptr
,

306 char **
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

309 extern 
uintmax_t
 
	$strtoumax
 (
__const
 char *
__restrict
 
__nptr
,

310 char ** 
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

313 extern 
intmax_t
 
	$wcstoimax
 (
__const
 
__gwchar_t
 *
__restrict
 
__nptr
,

314 
__gwchar_t
 **
__restrict
 
__endptr
, int 
__base
)

315 
__THROW
;

318 extern 
uintmax_t
 
	$wcstoumax
 (
__const
 
__gwchar_t
 *
__restrict
 
__nptr
,

319 
__gwchar_t
 ** 
__restrict
 
__endptr
, int 
__base
)

320 
__THROW
;

322 #ifdef 
__USE_EXTERN_INLINES


324 #if 
__WORDSIZE
 == 64

326 extern long int 
	$__strtol_internal
 (
__const
 char *
__restrict
 
__nptr
,

327 char **
__restrict
 
__endptr
,

328 int 
__base
, int 
__group
)

329 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

331 
__extern_inline
 
intmax_t


332 
	`__NTH
 (
	$strtoimax
 (
__const
 char *
__restrict
 
nptr
, char **__restrict 
endptr
,

333 int 
base
))

335 return 
	`__strtol_internal
 (
nptr
, 
endptr
, 
base
, 0);

336 
	}
}

338 extern unsigned long int 
	$__strtoul_internal
 (
__const
 char *

339 
__restrict
 
__nptr
,

340 char ** 
__restrict
 
__endptr
,

341 int 
__base
, int 
__group
)

342 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

344 
__extern_inline
 
uintmax_t


345 
	`__NTH
 (
	$strtoumax
 (
__const
 char *
__restrict
 
nptr
, char **__restrict 
endptr
,

346 int 
base
))

348 return 
	`__strtoul_internal
 (
nptr
, 
endptr
, 
base
, 0);

349 
	}
}

351 extern long int 
	$__wcstol_internal
 (
__const
 
__gwchar_t
 * 
__restrict
 
__nptr
,

352 
__gwchar_t
 **
__restrict
 
__endptr
,

353 int 
__base
, int 
__group
)

354 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

356 
__extern_inline
 
intmax_t


357 
	`__NTH
 (
	$wcstoimax
 (
__const
 
__gwchar_t
 *
__restrict
 
nptr
,

358 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

360 return 
	`__wcstol_internal
 (
nptr
, 
endptr
, 
base
, 0);

361 
	}
}

363 extern unsigned long int 
	$__wcstoul_internal
 (
__const
 
__gwchar_t
 *

364 
__restrict
 
__nptr
,

365 
__gwchar_t
 **

366 
__restrict
 
__endptr
,

367 int 
__base
, int 
__group
)

368 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

370 
__extern_inline
 
uintmax_t


371 
	`__NTH
 (
	$wcstoumax
 (
__const
 
__gwchar_t
 *
__restrict
 
nptr
,

372 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

374 return 
	`__wcstoul_internal
 (
nptr
, 
endptr
, 
base
, 0);

375 
	}
}

379 
__extension__


380 extern long long int 
	$__strtoll_internal
 (
__const
 char *
__restrict
 
__nptr
,

381 char **
__restrict
 
__endptr
,

382 int 
__base
, int 
__group
)

383 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

385 
__extern_inline
 
intmax_t


386 
	`__NTH
 (
	$strtoimax
 (
__const
 char *
__restrict
 
nptr
, char **__restrict 
endptr
,

387 int 
base
))

389 return 
	`__strtoll_internal
 (
nptr
, 
endptr
, 
base
, 0);

390 
	}
}

392 
__extension__


393 extern unsigned long long int 
	$__strtoull_internal
 (
__const
 char *

394 
__restrict
 
__nptr
,

396 
__restrict
 
__endptr
,

397 int 
__base
,

398 int 
__group
)

399 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

401 
__extern_inline
 
uintmax_t


402 
	`__NTH
 (
	$strtoumax
 (
__const
 char *
__restrict
 
nptr
, char **__restrict 
endptr
,

403 int 
base
))

405 return 
	`__strtoull_internal
 (
nptr
, 
endptr
, 
base
, 0);

406 
	}
}

408 
__extension__


409 extern long long int 
	$__wcstoll_internal
 (
__const
 
__gwchar_t
 *

410 
__restrict
 
__nptr
,

411 
__gwchar_t
 **
__restrict
 
__endptr
,

412 int 
__base
, int 
__group
)

413 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

415 
__extern_inline
 
intmax_t


416 
	`__NTH
 (
	$wcstoimax
 (
__const
 
__gwchar_t
 *
__restrict
 
nptr
,

417 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

419 return 
	`__wcstoll_internal
 (
nptr
, 
endptr
, 
base
, 0);

420 
	}
}

423 
__extension__


424 extern unsigned long long int 
	$__wcstoull_internal
 (
__const
 
__gwchar_t
 *

425 
__restrict
 
__nptr
,

426 
__gwchar_t
 **

427 
__restrict
 
__endptr
,

428 int 
__base
,

429 int 
__group
)

430 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

432 
__extern_inline
 
uintmax_t


433 
	`__NTH
 (
	$wcstoumax
 (
__const
 
__gwchar_t
 *
__restrict
 
nptr
,

434 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

436 return 
	`__wcstoull_internal
 (
nptr
, 
endptr
, 
base
, 0);

437 
	}
}

442 
	g__END_DECLS


	@/usr/include/langinfo.h

20 #ifndef 
_LANGINFO_H


21 #define 
	#_LANGINFO_H
 1

	)

24 #include 
	~<nl_types.h
>

26 #include 
	~<bits/locale.h
>

29 
	g__BEGIN_DECLS


35 #define 
	#_NL_ITEM
(
category
, 
index
) (((category) << 16) | (index))

	)

38 #define 
	#_NL_ITEM_CATEGORY
(
item
) ((int) (item) >> 16)

	)

39 #define 
	#_NL_ITEM_INDEX
(
item
) ((int) (item) & 0xffff)

	)

47 
	mABDAY_1
 = 
_NL_ITEM
 (
__LC_TIME
, 0),

48 #define 
	#ABDAY_1
 
ABDAY_1


	)

49 
	mABDAY_2
,

50 #define 
	#ABDAY_2
 
ABDAY_2


	)

51 
	mABDAY_3
,

52 #define 
	#ABDAY_3
 
ABDAY_3


	)

53 
	mABDAY_4
,

54 #define 
	#ABDAY_4
 
ABDAY_4


	)

55 
	mABDAY_5
,

56 #define 
	#ABDAY_5
 
ABDAY_5


	)

57 
	mABDAY_6
,

58 #define 
	#ABDAY_6
 
ABDAY_6


	)

59 
	mABDAY_7
,

60 #define 
	#ABDAY_7
 
ABDAY_7


	)

63 
	mDAY_1
,

64 #define 
	#DAY_1
 
DAY_1


	)

65 
	mDAY_2
,

66 #define 
	#DAY_2
 
DAY_2


	)

67 
	mDAY_3
,

68 #define 
	#DAY_3
 
DAY_3


	)

69 
	mDAY_4
,

70 #define 
	#DAY_4
 
DAY_4


	)

71 
	mDAY_5
,

72 #define 
	#DAY_5
 
DAY_5


	)

73 
	mDAY_6
,

74 #define 
	#DAY_6
 
DAY_6


	)

75 
	mDAY_7
,

76 #define 
	#DAY_7
 
DAY_7


	)

79 
	mABMON_1
,

80 #define 
	#ABMON_1
 
ABMON_1


	)

81 
	mABMON_2
,

82 #define 
	#ABMON_2
 
ABMON_2


	)

83 
	mABMON_3
,

84 #define 
	#ABMON_3
 
ABMON_3


	)

85 
	mABMON_4
,

86 #define 
	#ABMON_4
 
ABMON_4


	)

87 
	mABMON_5
,

88 #define 
	#ABMON_5
 
ABMON_5


	)

89 
	mABMON_6
,

90 #define 
	#ABMON_6
 
ABMON_6


	)

91 
	mABMON_7
,

92 #define 
	#ABMON_7
 
ABMON_7


	)

93 
	mABMON_8
,

94 #define 
	#ABMON_8
 
ABMON_8


	)

95 
	mABMON_9
,

96 #define 
	#ABMON_9
 
ABMON_9


	)

97 
	mABMON_10
,

98 #define 
	#ABMON_10
 
ABMON_10


	)

99 
	mABMON_11
,

100 #define 
	#ABMON_11
 
ABMON_11


	)

101 
	mABMON_12
,

102 #define 
	#ABMON_12
 
ABMON_12


	)

105 
	mMON_1
,

106 #define 
	#MON_1
 
MON_1


	)

107 
	mMON_2
,

108 #define 
	#MON_2
 
MON_2


	)

109 
	mMON_3
,

110 #define 
	#MON_3
 
MON_3


	)

111 
	mMON_4
,

112 #define 
	#MON_4
 
MON_4


	)

113 
	mMON_5
,

114 #define 
	#MON_5
 
MON_5


	)

115 
	mMON_6
,

116 #define 
	#MON_6
 
MON_6


	)

117 
	mMON_7
,

118 #define 
	#MON_7
 
MON_7


	)

119 
	mMON_8
,

120 #define 
	#MON_8
 
MON_8


	)

121 
	mMON_9
,

122 #define 
	#MON_9
 
MON_9


	)

123 
	mMON_10
,

124 #define 
	#MON_10
 
MON_10


	)

125 
	mMON_11
,

126 #define 
	#MON_11
 
MON_11


	)

127 
	mMON_12
,

128 #define 
	#MON_12
 
MON_12


	)

130 
	mAM_STR
,

131 #define 
	#AM_STR
 
AM_STR


	)

132 
	mPM_STR
,

133 #define 
	#PM_STR
 
PM_STR


	)

135 
	mD_T_FMT
,

136 #define 
	#D_T_FMT
 
D_T_FMT


	)

137 
	mD_FMT
,

138 #define 
	#D_FMT
 
D_FMT


	)

139 
	mT_FMT
,

140 #define 
	#T_FMT
 
T_FMT


	)

141 
	mT_FMT_AMPM
,

142 #define 
	#T_FMT_AMPM
 
T_FMT_AMPM


	)

144 
	mERA
,

145 #define 
	#ERA
 
ERA


	)

146 
	m__ERA_YEAR
,

147 #ifdef 
__USE_GNU


148 #define 
	#ERA_YEAR
 
__ERA_YEAR


	)

150 
	mERA_D_FMT
,

151 #define 
	#ERA_D_FMT
 
ERA_D_FMT


	)

152 
	mALT_DIGITS
,

153 #define 
	#ALT_DIGITS
 
ALT_DIGITS


	)

154 
	mERA_D_T_FMT
,

155 #define 
	#ERA_D_T_FMT
 
ERA_D_T_FMT


	)

156 
	mERA_T_FMT
,

157 #define 
	#ERA_T_FMT
 
ERA_T_FMT


	)

159 
	m_NL_TIME_ERA_NUM_ENTRIES
,

160 
	m_NL_TIME_ERA_ENTRIES
,

162 
	m_NL_WABDAY_1
,

163 
	m_NL_WABDAY_2
,

164 
	m_NL_WABDAY_3
,

165 
	m_NL_WABDAY_4
,

166 
	m_NL_WABDAY_5
,

167 
	m_NL_WABDAY_6
,

168 
	m_NL_WABDAY_7
,

171 
	m_NL_WDAY_1
,

172 
	m_NL_WDAY_2
,

173 
	m_NL_WDAY_3
,

174 
	m_NL_WDAY_4
,

175 
	m_NL_WDAY_5
,

176 
	m_NL_WDAY_6
,

177 
	m_NL_WDAY_7
,

180 
	m_NL_WABMON_1
,

181 
	m_NL_WABMON_2
,

182 
	m_NL_WABMON_3
,

183 
	m_NL_WABMON_4
,

184 
	m_NL_WABMON_5
,

185 
	m_NL_WABMON_6
,

186 
	m_NL_WABMON_7
,

187 
	m_NL_WABMON_8
,

188 
	m_NL_WABMON_9
,

189 
	m_NL_WABMON_10
,

190 
	m_NL_WABMON_11
,

191 
	m_NL_WABMON_12
,

194 
	m_NL_WMON_1
,

195 
	m_NL_WMON_2
,

196 
	m_NL_WMON_3
,

197 
	m_NL_WMON_4
,

198 
	m_NL_WMON_5
,

199 
	m_NL_WMON_6
,

200 
	m_NL_WMON_7
,

201 
	m_NL_WMON_8
,

202 
	m_NL_WMON_9
,

203 
	m_NL_WMON_10
,

204 
	m_NL_WMON_11
,

205 
	m_NL_WMON_12
,

207 
	m_NL_WAM_STR
,

208 
	m_NL_WPM_STR
,

210 
	m_NL_WD_T_FMT
,

211 
	m_NL_WD_FMT
,

212 
	m_NL_WT_FMT
,

213 
	m_NL_WT_FMT_AMPM
,

215 
	m_NL_WERA_YEAR
,

216 
	m_NL_WERA_D_FMT
,

217 
	m_NL_WALT_DIGITS
,

218 
	m_NL_WERA_D_T_FMT
,

219 
	m_NL_WERA_T_FMT
,

221 
	m_NL_TIME_WEEK_NDAYS
,

222 
	m_NL_TIME_WEEK_1STDAY
,

223 
	m_NL_TIME_WEEK_1STWEEK
,

224 
	m_NL_TIME_FIRST_WEEKDAY
,

225 
	m_NL_TIME_FIRST_WORKDAY
,

226 
	m_NL_TIME_CAL_DIRECTION
,

227 
	m_NL_TIME_TIMEZONE
,

229 
	m_DATE_FMT
,

230 #define 
	#_DATE_FMT
 
_DATE_FMT


	)

231 
	m_NL_W_DATE_FMT
,

233 
	m_NL_TIME_CODESET
,

235 
	m_NL_NUM_LC_TIME
,

240 
	m_NL_COLLATE_NRULES
 = 
_NL_ITEM
 (
__LC_COLLATE
, 0),

241 
	m_NL_COLLATE_RULESETS
,

242 
	m_NL_COLLATE_TABLEMB
,

243 
	m_NL_COLLATE_WEIGHTMB
,

244 
	m_NL_COLLATE_EXTRAMB
,

245 
	m_NL_COLLATE_INDIRECTMB
,

246 
	m_NL_COLLATE_GAP1
,

247 
	m_NL_COLLATE_GAP2
,

248 
	m_NL_COLLATE_GAP3
,

249 
	m_NL_COLLATE_TABLEWC
,

250 
	m_NL_COLLATE_WEIGHTWC
,

251 
	m_NL_COLLATE_EXTRAWC
,

252 
	m_NL_COLLATE_INDIRECTWC
,

253 
	m_NL_COLLATE_SYMB_HASH_SIZEMB
,

254 
	m_NL_COLLATE_SYMB_TABLEMB
,

255 
	m_NL_COLLATE_SYMB_EXTRAMB
,

256 
	m_NL_COLLATE_COLLSEQMB
,

257 
	m_NL_COLLATE_COLLSEQWC
,

258 
	m_NL_COLLATE_CODESET
,

259 
	m_NL_NUM_LC_COLLATE
,

264 
	m_NL_CTYPE_CLASS
 = 
_NL_ITEM
 (
__LC_CTYPE
, 0),

265 
	m_NL_CTYPE_TOUPPER
,

266 
	m_NL_CTYPE_GAP1
,

267 
	m_NL_CTYPE_TOLOWER
,

268 
	m_NL_CTYPE_GAP2
,

269 
	m_NL_CTYPE_CLASS32
,

270 
	m_NL_CTYPE_GAP3
,

271 
	m_NL_CTYPE_GAP4
,

272 
	m_NL_CTYPE_GAP5
,

273 
	m_NL_CTYPE_GAP6
,

274 
	m_NL_CTYPE_CLASS_NAMES
,

275 
	m_NL_CTYPE_MAP_NAMES
,

276 
	m_NL_CTYPE_WIDTH
,

277 
	m_NL_CTYPE_MB_CUR_MAX
,

278 
	m_NL_CTYPE_CODESET_NAME
,

279 
	mCODESET
 = 
_NL_CTYPE_CODESET_NAME
,

280 #define 
	#CODESET
 
CODESET


	)

281 
	m_NL_CTYPE_TOUPPER32
,

282 
	m_NL_CTYPE_TOLOWER32
,

283 
	m_NL_CTYPE_CLASS_OFFSET
,

284 
	m_NL_CTYPE_MAP_OFFSET
,

285 
	m_NL_CTYPE_INDIGITS_MB_LEN
,

286 
	m_NL_CTYPE_INDIGITS0_MB
,

287 
	m_NL_CTYPE_INDIGITS1_MB
,

288 
	m_NL_CTYPE_INDIGITS2_MB
,

289 
	m_NL_CTYPE_INDIGITS3_MB
,

290 
	m_NL_CTYPE_INDIGITS4_MB
,

291 
	m_NL_CTYPE_INDIGITS5_MB
,

292 
	m_NL_CTYPE_INDIGITS6_MB
,

293 
	m_NL_CTYPE_INDIGITS7_MB
,

294 
	m_NL_CTYPE_INDIGITS8_MB
,

295 
	m_NL_CTYPE_INDIGITS9_MB
,

296 
	m_NL_CTYPE_INDIGITS_WC_LEN
,

297 
	m_NL_CTYPE_INDIGITS0_WC
,

298 
	m_NL_CTYPE_INDIGITS1_WC
,

299 
	m_NL_CTYPE_INDIGITS2_WC
,

300 
	m_NL_CTYPE_INDIGITS3_WC
,

301 
	m_NL_CTYPE_INDIGITS4_WC
,

302 
	m_NL_CTYPE_INDIGITS5_WC
,

303 
	m_NL_CTYPE_INDIGITS6_WC
,

304 
	m_NL_CTYPE_INDIGITS7_WC
,

305 
	m_NL_CTYPE_INDIGITS8_WC
,

306 
	m_NL_CTYPE_INDIGITS9_WC
,

307 
	m_NL_CTYPE_OUTDIGIT0_MB
,

308 
	m_NL_CTYPE_OUTDIGIT1_MB
,

309 
	m_NL_CTYPE_OUTDIGIT2_MB
,

310 
	m_NL_CTYPE_OUTDIGIT3_MB
,

311 
	m_NL_CTYPE_OUTDIGIT4_MB
,

312 
	m_NL_CTYPE_OUTDIGIT5_MB
,

313 
	m_NL_CTYPE_OUTDIGIT6_MB
,

314 
	m_NL_CTYPE_OUTDIGIT7_MB
,

315 
	m_NL_CTYPE_OUTDIGIT8_MB
,

316 
	m_NL_CTYPE_OUTDIGIT9_MB
,

317 
	m_NL_CTYPE_OUTDIGIT0_WC
,

318 
	m_NL_CTYPE_OUTDIGIT1_WC
,

319 
	m_NL_CTYPE_OUTDIGIT2_WC
,

320 
	m_NL_CTYPE_OUTDIGIT3_WC
,

321 
	m_NL_CTYPE_OUTDIGIT4_WC
,

322 
	m_NL_CTYPE_OUTDIGIT5_WC
,

323 
	m_NL_CTYPE_OUTDIGIT6_WC
,

324 
	m_NL_CTYPE_OUTDIGIT7_WC
,

325 
	m_NL_CTYPE_OUTDIGIT8_WC
,

326 
	m_NL_CTYPE_OUTDIGIT9_WC
,

327 
	m_NL_CTYPE_TRANSLIT_TAB_SIZE
,

328 
	m_NL_CTYPE_TRANSLIT_FROM_IDX
,

329 
	m_NL_CTYPE_TRANSLIT_FROM_TBL
,

330 
	m_NL_CTYPE_TRANSLIT_TO_IDX
,

331 
	m_NL_CTYPE_TRANSLIT_TO_TBL
,

332 
	m_NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN
,

333 
	m_NL_CTYPE_TRANSLIT_DEFAULT_MISSING
,

334 
	m_NL_CTYPE_TRANSLIT_IGNORE_LEN
,

335 
	m_NL_CTYPE_TRANSLIT_IGNORE
,

336 
	m_NL_CTYPE_MAP_TO_NONASCII
,

337 
	m_NL_CTYPE_NONASCII_CASE
,

338 
	m_NL_CTYPE_EXTRA_MAP_1
,

339 
	m_NL_CTYPE_EXTRA_MAP_2
,

340 
	m_NL_CTYPE_EXTRA_MAP_3
,

341 
	m_NL_CTYPE_EXTRA_MAP_4
,

342 
	m_NL_CTYPE_EXTRA_MAP_5
,

343 
	m_NL_CTYPE_EXTRA_MAP_6
,

344 
	m_NL_CTYPE_EXTRA_MAP_7
,

345 
	m_NL_CTYPE_EXTRA_MAP_8
,

346 
	m_NL_CTYPE_EXTRA_MAP_9
,

347 
	m_NL_CTYPE_EXTRA_MAP_10
,

348 
	m_NL_CTYPE_EXTRA_MAP_11
,

349 
	m_NL_CTYPE_EXTRA_MAP_12
,

350 
	m_NL_CTYPE_EXTRA_MAP_13
,

351 
	m_NL_CTYPE_EXTRA_MAP_14
,

352 
	m_NL_NUM_LC_CTYPE
,

357 
	m__INT_CURR_SYMBOL
 = 
_NL_ITEM
 (
__LC_MONETARY
, 0),

358 #ifdef 
__USE_GNU


359 #define 
	#INT_CURR_SYMBOL
 
__INT_CURR_SYMBOL


	)

361 
	m__CURRENCY_SYMBOL
,

362 #ifdef 
__USE_GNU


363 #define 
	#CURRENCY_SYMBOL
 
__CURRENCY_SYMBOL


	)

365 
	m__MON_DECIMAL_POINT
,

366 #ifdef 
__USE_GNU


367 #define 
	#MON_DECIMAL_POINT
 
__MON_DECIMAL_POINT


	)

369 
	m__MON_THOUSANDS_SEP
,

370 #ifdef 
__USE_GNU


371 #define 
	#MON_THOUSANDS_SEP
 
__MON_THOUSANDS_SEP


	)

373 
	m__MON_GROUPING
,

374 #ifdef 
__USE_GNU


375 #define 
	#MON_GROUPING
 
__MON_GROUPING


	)

377 
	m__POSITIVE_SIGN
,

378 #ifdef 
__USE_GNU


379 #define 
	#POSITIVE_SIGN
 
__POSITIVE_SIGN


	)

381 
	m__NEGATIVE_SIGN
,

382 #ifdef 
__USE_GNU


383 #define 
	#NEGATIVE_SIGN
 
__NEGATIVE_SIGN


	)

385 
	m__INT_FRAC_DIGITS
,

386 #ifdef 
__USE_GNU


387 #define 
	#INT_FRAC_DIGITS
 
__INT_FRAC_DIGITS


	)

389 
	m__FRAC_DIGITS
,

390 #ifdef 
__USE_GNU


391 #define 
	#FRAC_DIGITS
 
__FRAC_DIGITS


	)

393 
	m__P_CS_PRECEDES
,

394 #ifdef 
__USE_GNU


395 #define 
	#P_CS_PRECEDES
 
__P_CS_PRECEDES


	)

397 
	m__P_SEP_BY_SPACE
,

398 #ifdef 
__USE_GNU


399 #define 
	#P_SEP_BY_SPACE
 
__P_SEP_BY_SPACE


	)

401 
	m__N_CS_PRECEDES
,

402 #ifdef 
__USE_GNU


403 #define 
	#N_CS_PRECEDES
 
__N_CS_PRECEDES


	)

405 
	m__N_SEP_BY_SPACE
,

406 #ifdef 
__USE_GNU


407 #define 
	#N_SEP_BY_SPACE
 
__N_SEP_BY_SPACE


	)

409 
	m__P_SIGN_POSN
,

410 #ifdef 
__USE_GNU


411 #define 
	#P_SIGN_POSN
 
__P_SIGN_POSN


	)

413 
	m__N_SIGN_POSN
,

414 #ifdef 
__USE_GNU


415 #define 
	#N_SIGN_POSN
 
__N_SIGN_POSN


	)

417 
	m_NL_MONETARY_CRNCYSTR
,

418 #define 
	#CRNCYSTR
 
_NL_MONETARY_CRNCYSTR


	)

419 
	m__INT_P_CS_PRECEDES
,

420 #ifdef 
__USE_GNU


421 #define 
	#INT_P_CS_PRECEDES
 
__INT_P_CS_PRECEDES


	)

423 
	m__INT_P_SEP_BY_SPACE
,

424 #ifdef 
__USE_GNU


425 #define 
	#INT_P_SEP_BY_SPACE
 
__INT_P_SEP_BY_SPACE


	)

427 
	m__INT_N_CS_PRECEDES
,

428 #ifdef 
__USE_GNU


429 #define 
	#INT_N_CS_PRECEDES
 
__INT_N_CS_PRECEDES


	)

431 
	m__INT_N_SEP_BY_SPACE
,

432 #ifdef 
__USE_GNU


433 #define 
	#INT_N_SEP_BY_SPACE
 
__INT_N_SEP_BY_SPACE


	)

435 
	m__INT_P_SIGN_POSN
,

436 #ifdef 
__USE_GNU


437 #define 
	#INT_P_SIGN_POSN
 
__INT_P_SIGN_POSN


	)

439 
	m__INT_N_SIGN_POSN
,

440 #ifdef 
__USE_GNU


441 #define 
	#INT_N_SIGN_POSN
 
__INT_N_SIGN_POSN


	)

443 
	m_NL_MONETARY_DUO_INT_CURR_SYMBOL
,

444 
	m_NL_MONETARY_DUO_CURRENCY_SYMBOL
,

445 
	m_NL_MONETARY_DUO_INT_FRAC_DIGITS
,

446 
	m_NL_MONETARY_DUO_FRAC_DIGITS
,

447 
	m_NL_MONETARY_DUO_P_CS_PRECEDES
,

448 
	m_NL_MONETARY_DUO_P_SEP_BY_SPACE
,

449 
	m_NL_MONETARY_DUO_N_CS_PRECEDES
,

450 
	m_NL_MONETARY_DUO_N_SEP_BY_SPACE
,

451 
	m_NL_MONETARY_DUO_INT_P_CS_PRECEDES
,

452 
	m_NL_MONETARY_DUO_INT_P_SEP_BY_SPACE
,

453 
	m_NL_MONETARY_DUO_INT_N_CS_PRECEDES
,

454 
	m_NL_MONETARY_DUO_INT_N_SEP_BY_SPACE
,

455 
	m_NL_MONETARY_DUO_P_SIGN_POSN
,

456 
	m_NL_MONETARY_DUO_N_SIGN_POSN
,

457 
	m_NL_MONETARY_DUO_INT_P_SIGN_POSN
,

458 
	m_NL_MONETARY_DUO_INT_N_SIGN_POSN
,

459 
	m_NL_MONETARY_UNO_VALID_FROM
,

460 
	m_NL_MONETARY_UNO_VALID_TO
,

461 
	m_NL_MONETARY_DUO_VALID_FROM
,

462 
	m_NL_MONETARY_DUO_VALID_TO
,

463 
	m_NL_MONETARY_CONVERSION_RATE
,

464 
	m_NL_MONETARY_DECIMAL_POINT_WC
,

465 
	m_NL_MONETARY_THOUSANDS_SEP_WC
,

466 
	m_NL_MONETARY_CODESET
,

467 
	m_NL_NUM_LC_MONETARY
,

471 
	m__DECIMAL_POINT
 = 
_NL_ITEM
 (
__LC_NUMERIC
, 0),

472 #ifdef 
__USE_GNU


473 #define 
	#DECIMAL_POINT
 
__DECIMAL_POINT


	)

475 
	mRADIXCHAR
 = 
__DECIMAL_POINT
,

476 #define 
	#RADIXCHAR
 
RADIXCHAR


	)

477 
	m__THOUSANDS_SEP
,

478 #ifdef 
__USE_GNU


479 #define 
	#THOUSANDS_SEP
 
__THOUSANDS_SEP


	)

481 
	mTHOUSEP
 = 
__THOUSANDS_SEP
,

482 #define 
	#THOUSEP
 
THOUSEP


	)

483 
	m__GROUPING
,

484 #ifdef 
__USE_GNU


485 #define 
	#GROUPING
 
__GROUPING


	)

487 
	m_NL_NUMERIC_DECIMAL_POINT_WC
,

488 
	m_NL_NUMERIC_THOUSANDS_SEP_WC
,

489 
	m_NL_NUMERIC_CODESET
,

490 
	m_NL_NUM_LC_NUMERIC
,

492 
	m__YESEXPR
 = 
_NL_ITEM
 (
__LC_MESSAGES
, 0),

493 #define 
	#YESEXPR
 
__YESEXPR


	)

494 
	m__NOEXPR
,

495 #define 
	#NOEXPR
 
__NOEXPR


	)

496 
	m__YESSTR
,

497 #if 
defined
 
__USE_GNU
 || (defined 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

498 #define 
	#YESSTR
 
__YESSTR


	)

500 
	m__NOSTR
,

501 #if 
defined
 
__USE_GNU
 || (defined 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

502 #define 
	#NOSTR
 
__NOSTR


	)

504 
	m_NL_MESSAGES_CODESET
,

505 
	m_NL_NUM_LC_MESSAGES
,

507 
	m_NL_PAPER_HEIGHT
 = 
_NL_ITEM
 (
__LC_PAPER
, 0),

508 
	m_NL_PAPER_WIDTH
,

509 
	m_NL_PAPER_CODESET
,

510 
	m_NL_NUM_LC_PAPER
,

512 
	m_NL_NAME_NAME_FMT
 = 
_NL_ITEM
 (
__LC_NAME
, 0),

513 
	m_NL_NAME_NAME_GEN
,

514 
	m_NL_NAME_NAME_MR
,

515 
	m_NL_NAME_NAME_MRS
,

516 
	m_NL_NAME_NAME_MISS
,

517 
	m_NL_NAME_NAME_MS
,

518 
	m_NL_NAME_CODESET
,

519 
	m_NL_NUM_LC_NAME
,

521 
	m_NL_ADDRESS_POSTAL_FMT
 = 
_NL_ITEM
 (
__LC_ADDRESS
, 0),

522 
	m_NL_ADDRESS_COUNTRY_NAME
,

523 
	m_NL_ADDRESS_COUNTRY_POST
,

524 
	m_NL_ADDRESS_COUNTRY_AB2
,

525 
	m_NL_ADDRESS_COUNTRY_AB3
,

526 
	m_NL_ADDRESS_COUNTRY_CAR
,

527 
	m_NL_ADDRESS_COUNTRY_NUM
,

528 
	m_NL_ADDRESS_COUNTRY_ISBN
,

529 
	m_NL_ADDRESS_LANG_NAME
,

530 
	m_NL_ADDRESS_LANG_AB
,

531 
	m_NL_ADDRESS_LANG_TERM
,

532 
	m_NL_ADDRESS_LANG_LIB
,

533 
	m_NL_ADDRESS_CODESET
,

534 
	m_NL_NUM_LC_ADDRESS
,

536 
	m_NL_TELEPHONE_TEL_INT_FMT
 = 
_NL_ITEM
 (
__LC_TELEPHONE
, 0),

537 
	m_NL_TELEPHONE_TEL_DOM_FMT
,

538 
	m_NL_TELEPHONE_INT_SELECT
,

539 
	m_NL_TELEPHONE_INT_PREFIX
,

540 
	m_NL_TELEPHONE_CODESET
,

541 
	m_NL_NUM_LC_TELEPHONE
,

543 
	m_NL_MEASUREMENT_MEASUREMENT
 = 
_NL_ITEM
 (
__LC_MEASUREMENT
, 0),

544 
	m_NL_MEASUREMENT_CODESET
,

545 
	m_NL_NUM_LC_MEASUREMENT
,

547 
	m_NL_IDENTIFICATION_TITLE
 = 
_NL_ITEM
 (
__LC_IDENTIFICATION
, 0),

548 
	m_NL_IDENTIFICATION_SOURCE
,

549 
	m_NL_IDENTIFICATION_ADDRESS
,

550 
	m_NL_IDENTIFICATION_CONTACT
,

551 
	m_NL_IDENTIFICATION_EMAIL
,

552 
	m_NL_IDENTIFICATION_TEL
,

553 
	m_NL_IDENTIFICATION_FAX
,

554 
	m_NL_IDENTIFICATION_LANGUAGE
,

555 
	m_NL_IDENTIFICATION_TERRITORY
,

556 
	m_NL_IDENTIFICATION_AUDIENCE
,

557 
	m_NL_IDENTIFICATION_APPLICATION
,

558 
	m_NL_IDENTIFICATION_ABBREVIATION
,

559 
	m_NL_IDENTIFICATION_REVISION
,

560 
	m_NL_IDENTIFICATION_DATE
,

561 
	m_NL_IDENTIFICATION_CATEGORY
,

562 
	m_NL_IDENTIFICATION_CODESET
,

563 
	m_NL_NUM_LC_IDENTIFICATION
,

566 
	m_NL_NUM


571 #define 
	#_NL_LOCALE_NAME
(
category
) 
	`_NL_ITEM
 ((category), \

572 
	`_NL_ITEM_INDEX
 (-1))

	)

573 #ifdef 
__USE_GNU


574 #define 
	#NL_LOCALE_NAME
(
category
) 
	`_NL_LOCALE_NAME
 (category)

	)

584 extern char *
	$nl_langinfo
 (
nl_item
 
__item
) 
__THROW
;

587 #ifdef 
__USE_XOPEN2K


592 #include 
	~<xlocale.h
>

595 extern char *
	`nl_langinfo_l
 (
nl_item
 
__item
, 
__locale_t
 
__l
);

598 
__END_DECLS


	@/usr/include/libintl.h

21 #ifndef 
_LIBINTL_H


22 #define 
	#_LIBINTL_H
 1

	)

24 #include 
	~<features.h
>

28 #define 
	#__USE_GNU_GETTEXT
 1

	)

32 #define 
	#__GNU_GETTEXT_SUPPORTED_REVISION
(
major
) \

33 ((
major
) == 0 ? 1 : -1)

	)

35 
__BEGIN_DECLS


40 extern char *
	$gettext
 (
__const
 char *
__msgid
)

41 
__THROW
 
	`__attribute_format_arg__
 (1);

45 extern char *
	$dgettext
 (
__const
 char *
__domainname
, __const char *
__msgid
)

46 
__THROW
 
	`__attribute_format_arg__
 (2);

47 extern char *
	$__dgettext
 (
__const
 char *
__domainname
, __const char *
__msgid
)

48 
__THROW
 
	`__attribute_format_arg__
 (2);

52 extern char *
	$dcgettext
 (
__const
 char *
__domainname
,

53 
__const
 char *
__msgid
, int 
__category
)

54 
__THROW
 
	`__attribute_format_arg__
 (2);

55 extern char *
	$__dcgettext
 (
__const
 char *
__domainname
,

56 
__const
 char *
__msgid
, int 
__category
)

57 
__THROW
 
	`__attribute_format_arg__
 (2);

62 extern char *
	$ngettext
 (
__const
 char *
__msgid1
, __const char *
__msgid2
,

63 unsigned long int 
__n
)

64 
__THROW
 
	$__attribute_format_arg__
 (1) 
	`__attribute_format_arg__
 (2);

68 extern char *
	$dngettext
 (
__const
 char *
__domainname
, __const char *
__msgid1
,

69 
__const
 char *
__msgid2
, unsigned long int 
__n
)

70 
__THROW
 
	$__attribute_format_arg__
 (2) 
	`__attribute_format_arg__
 (3);

74 extern char *
	$dcngettext
 (
__const
 char *
__domainname
, __const char *
__msgid1
,

75 
__const
 char *
__msgid2
, unsigned long int 
__n
,

76 int 
__category
)

77 
__THROW
 
	$__attribute_format_arg__
 (2) 
	`__attribute_format_arg__
 (3);

83 extern char *
	$textdomain
 (
__const
 char *
__domainname
) 
__THROW
;

87 extern char *
	$bindtextdomain
 (
__const
 char *
__domainname
,

88 
__const
 char *
__dirname
) 
__THROW
;

92 extern char *
	$bind_textdomain_codeset
 (
__const
 char *
__domainname
,

93 
__const
 char *
__codeset
) 
__THROW
;

97 #if 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


100 #define 
	#__need_NULL


	)

101 #include 
	~<stddef.h
>

104 #include 
	~<locale.h
>

110 #define 
	#gettext
(
msgid
) 
	`dgettext
 (
NULL
, msgid)

	)

112 #define 
	#dgettext
(
domainname
, 
msgid
) \

113 
	`dcgettext
 (
domainname
, 
msgid
, 
LC_MESSAGES
)

	)

115 #define 
	#ngettext
(
msgid1
, 
msgid2
, 
n
) 
	`dngettext
 (
NULL
, msgid1, msgid2, n)

	)

117 #define 
	#dngettext
(
domainname
, 
msgid1
, 
msgid2
, 
n
) \

118 
	`dcngettext
 (
domainname
, 
msgid1
, 
msgid2
, 
n
, 
LC_MESSAGES
)

	)

122 
__END_DECLS


	@/usr/include/limits.h

24 #ifndef 
_LIBC_LIMITS_H_


25 #define 
	#_LIBC_LIMITS_H_
 1

	)

27 #include 
	~<features.h
>

33 #define 
	#MB_LEN_MAX
 16

	)

38 #if !
defined
 
__GNUC__
 || __GNUC__ < 2

43 #ifndef 
_LIMITS_H


44 #define 
	#_LIMITS_H
 1

	)

46 #include 
	~<bits/wordsize.h
>

55 #define 
	#CHAR_BIT
 8

	)

58 #define 
	#SCHAR_MIN
 (-128)

	)

59 #define 
	#SCHAR_MAX
 127

	)

62 #define 
	#UCHAR_MAX
 255

	)

65 #ifdef 
__CHAR_UNSIGNED__


66 #define 
	#CHAR_MIN
 0

	)

67 #define 
	#CHAR_MAX
 
UCHAR_MAX


	)

69 #define 
	#CHAR_MIN
 
SCHAR_MIN


	)

70 #define 
	#CHAR_MAX
 
SCHAR_MAX


	)

74 #define 
	#SHRT_MIN
 (-32768)

	)

75 #define 
	#SHRT_MAX
 32767

	)

78 #define 
	#USHRT_MAX
 65535

	)

81 #define 
	#INT_MIN
 (-
INT_MAX
 - 1)

	)

82 #define 
	#INT_MAX
 2147483647

	)

85 #define 
	#UINT_MAX
 4294967295U

	)

88 #if 
__WORDSIZE
 == 64

89 #define 
	#LONG_MAX
 9223372036854775807L

	)

91 #define 
	#LONG_MAX
 2147483647L

	)

93 #define 
	#LONG_MIN
 (-
LONG_MAX
 - 1L)

	)

96 #if 
__WORDSIZE
 == 64

97 #define 
	#ULONG_MAX
 18446744073709551615UL

	)

99 #define 
	#ULONG_MAX
 4294967295UL

	)

102 #ifdef 
__USE_ISOC99


105 #define 
	#LLONG_MAX
 9223372036854775807LL

	)

106 #define 
	#LLONG_MIN
 (-
LLONG_MAX
 - 1LL)

	)

109 #define 
	#ULLONG_MAX
 18446744073709551615ULL

	)

123 #if 
defined
 
__GNUC__
 && !defined 
_GCC_LIMITS_H_


125 #include_next <
limits
.
h
>

131 #if 
defined
 
__USE_ISOC99
 && defined 
__GNUC__


132 #ifndef 
LLONG_MIN


133 #define 
	#LLONG_MIN
 (-
LLONG_MAX
-1)

	)

135 #ifndef 
LLONG_MAX


136 #define 
	#LLONG_MAX
 
__LONG_LONG_MAX__


	)

138 #ifndef 
ULLONG_MAX


139 #define 
	#ULLONG_MAX
 (
LLONG_MAX
 * 2ULL + 1)

	)

143 #ifdef 
__USE_POSIX


145 #include 
	~<bits/posix1_lim.h
>

148 #ifdef 
__USE_POSIX2


149 #include 
	~<bits/posix2_lim.h
>

152 #ifdef 
__USE_XOPEN


153 #include 
	~<bits/xopen_lim.h
>

	@/usr/include/locale.h

23 #ifndef 
_LOCALE_H


24 #define 
	#_LOCALE_H
 1

	)

26 #include 
	~<features.h
>

28 #define 
	#__need_NULL


	)

29 #include 
	~<stddef.h
>

30 #include 
	~<bits/locale.h
>

32 
	g__BEGIN_DECLS


36 #define 
	#LC_CTYPE
 
__LC_CTYPE


	)

37 #define 
	#LC_NUMERIC
 
__LC_NUMERIC


	)

38 #define 
	#LC_TIME
 
__LC_TIME


	)

39 #define 
	#LC_COLLATE
 
__LC_COLLATE


	)

40 #define 
	#LC_MONETARY
 
__LC_MONETARY


	)

41 #define 
	#LC_MESSAGES
 
__LC_MESSAGES


	)

42 #define 
	#LC_ALL
 
__LC_ALL


	)

43 #define 
	#LC_PAPER
 
__LC_PAPER


	)

44 #define 
	#LC_NAME
 
__LC_NAME


	)

45 #define 
	#LC_ADDRESS
 
__LC_ADDRESS


	)

46 #define 
	#LC_TELEPHONE
 
__LC_TELEPHONE


	)

47 #define 
	#LC_MEASUREMENT
 
__LC_MEASUREMENT


	)

48 #define 
	#LC_IDENTIFICATION
 
__LC_IDENTIFICATION


	)

51 
__BEGIN_NAMESPACE_STD


54 struct 
	slconv


58 char *
	mdecimal_point
;

59 char *
	mthousands_sep
;

65 char *
	mgrouping
;

71 char *
	mint_curr_symbol
;

72 char *
	mcurrency_symbol
;

73 char *
	mmon_decimal_point
;

74 char *
	mmon_thousands_sep
;

75 char *
	mmon_grouping
;

76 char *
	mpositive_sign
;

77 char *
	mnegative_sign
;

78 char 
	mint_frac_digits
;

79 char 
	mfrac_digits
;

81 char 
	mp_cs_precedes
;

83 char 
	mp_sep_by_space
;

85 char 
	mn_cs_precedes
;

87 char 
	mn_sep_by_space
;

94 char 
	mp_sign_posn
;

95 char 
	mn_sign_posn
;

96 #ifdef 
__USE_ISOC99


98 char 
	mint_p_cs_precedes
;

100 char 
	mint_p_sep_by_space
;

102 char 
	mint_n_cs_precedes
;

104 char 
	mint_n_sep_by_space
;

111 char 
	mint_p_sign_posn
;

112 char 
	mint_n_sign_posn
;

114 char 
	m__int_p_cs_precedes
;

115 char 
	m__int_p_sep_by_space
;

116 char 
	m__int_n_cs_precedes
;

117 char 
	m__int_n_sep_by_space
;

118 char 
	m__int_p_sign_posn
;

119 char 
	m__int_n_sign_posn
;

125 extern char *
	$setlocale
 (int 
__category
, 
__const
 char *
__locale
) 
__THROW
;

128 extern struct 
lconv
 *
	$localeconv
 (void) 
__THROW
;

130 
__END_NAMESPACE_STD


133 #ifdef 
__USE_XOPEN2K8


146 #include 
	~<xlocale.h
>

152 extern 
__locale_t
 
	$newlocale
 (int 
__category_mask
, 
__const
 char *
__locale
,

153 
__locale_t
 
__base
) 
__THROW
;

159 #define 
	#LC_CTYPE_MASK
 (1 << 
__LC_CTYPE
)

	)

160 #define 
	#LC_NUMERIC_MASK
 (1 << 
__LC_NUMERIC
)

	)

161 #define 
	#LC_TIME_MASK
 (1 << 
__LC_TIME
)

	)

162 #define 
	#LC_COLLATE_MASK
 (1 << 
__LC_COLLATE
)

	)

163 #define 
	#LC_MONETARY_MASK
 (1 << 
__LC_MONETARY
)

	)

164 #define 
	#LC_MESSAGES_MASK
 (1 << 
__LC_MESSAGES
)

	)

165 #define 
	#LC_PAPER_MASK
 (1 << 
__LC_PAPER
)

	)

166 #define 
	#LC_NAME_MASK
 (1 << 
__LC_NAME
)

	)

167 #define 
	#LC_ADDRESS_MASK
 (1 << 
__LC_ADDRESS
)

	)

168 #define 
	#LC_TELEPHONE_MASK
 (1 << 
__LC_TELEPHONE
)

	)

169 #define 
	#LC_MEASUREMENT_MASK
 (1 << 
__LC_MEASUREMENT
)

	)

170 #define 
	#LC_IDENTIFICATION_MASK
 (1 << 
__LC_IDENTIFICATION
)

	)

171 #define 
	#LC_ALL_MASK
 (
LC_CTYPE_MASK
 \

172 | 
LC_NUMERIC_MASK
 \

173 | 
LC_TIME_MASK
 \

174 | 
LC_COLLATE_MASK
 \

175 | 
LC_MONETARY_MASK
 \

176 | 
LC_MESSAGES_MASK
 \

177 | 
LC_PAPER_MASK
 \

178 | 
LC_NAME_MASK
 \

179 | 
LC_ADDRESS_MASK
 \

180 | 
LC_TELEPHONE_MASK
 \

181 | 
LC_MEASUREMENT_MASK
 \

182 | 
LC_IDENTIFICATION_MASK
 \

183 )

	)

187 extern 
__locale_t
 
	$duplocale
 (
__locale_t
 
__dataset
) 
__THROW
;

191 extern void 
	$freelocale
 (
__locale_t
 
__dataset
) 
__THROW
;

198 extern 
__locale_t
 
	$uselocale
 (
__locale_t
 
__dataset
) 
__THROW
;

202 #define 
	#LC_GLOBAL_LOCALE
 ((
__locale_t
) -1L)

	)

206 
__END_DECLS


	@/usr/include/malloc.h

21 #ifndef 
_MALLOC_H


22 #define 
	#_MALLOC_H
 1

	)

24 #include 
	~<features.h
>

25 #include 
	~<stddef.h
>

26 #include 
	~<stdio.h
>

27 #define 
	#__malloc_ptr_t
 void *

	)

30 #define 
	#__malloc_size_t
 
size_t


	)

31 #define 
	#__malloc_ptrdiff_t
 
ptrdiff_t


	)

33 #ifdef 
__GNUC__


35 #define 
	#__MALLOC_P
(
args
) args 
__THROW


	)

38 #define 
	#__MALLOC_PMT
(
args
) 
	)
args

42 #define 
	#__MALLOC_P
(
args
) 
	)
args

43 #define 
	#__MALLOC_PMT
(
args
) 
	)
args

48 
__BEGIN_DECLS


51 extern void *
malloc
 
__MALLOC_P
 ((
size_t
 
__size
)) 
__attribute_malloc__
 
__wur
;

54 extern void *
calloc
 
__MALLOC_P
 ((
size_t
 
__nmemb
, size_t 
__size
))

55 
__attribute_malloc__
 
__wur
;

62 extern void *
realloc
 
__MALLOC_P
 ((void *
__ptr
, 
size_t
 
__size
))

63 
__attribute_warn_unused_result__
;

66 extern void 
free
 
__MALLOC_P
 ((void *
__ptr
));

69 extern void 
cfree
 
__MALLOC_P
 ((void *
__ptr
));

72 extern void *
memalign
 
__MALLOC_P
 ((
size_t
 
__alignment
, size_t 
__size
))

73 
__attribute_malloc__
 
__wur
;

76 extern void *
valloc
 
__MALLOC_P
 ((
size_t
 
__size
))

77 
__attribute_malloc__
 
__wur
;

81 extern void * 
pvalloc
 
__MALLOC_P
 ((
size_t
 
__size
))

82 
__attribute_malloc__
 
__wur
;

86 extern void *(*
__morecore
) 
__MALLOC_PMT
 ((
ptrdiff_t
 
__size
));

89 extern void *
__default_morecore
 
__MALLOC_P
 ((
ptrdiff_t
 
__size
))

90 
__attribute_malloc__
;

94 struct 
	smallinfo
 {

95 int 
	marena
;

96 int 
	mordblks
;

97 int 
	msmblks
;

98 int 
	mhblks
;

99 int 
	mhblkhd
;

100 int 
	musmblks
;

101 int 
	mfsmblks
;

102 int 
	muordblks
;

103 int 
	mfordblks
;

104 int 
	mkeepcost
;

108 extern struct 
mallinfo
 mallinfo 
__MALLOC_P
 ((void));

111 #ifndef 
M_MXFAST


112 #define 
	#M_MXFAST
 1

	)

114 #ifndef 
M_NLBLKS


115 #define 
	#M_NLBLKS
 2

	)

117 #ifndef 
M_GRAIN


118 #define 
	#M_GRAIN
 3

	)

120 #ifndef 
M_KEEP


121 #define 
	#M_KEEP
 4

	)

125 #define 
	#M_TRIM_THRESHOLD
 -1

	)

126 #define 
	#M_TOP_PAD
 -2

	)

127 #define 
	#M_MMAP_THRESHOLD
 -3

	)

128 #define 
	#M_MMAP_MAX
 -4

	)

129 #define 
	#M_CHECK_ACTION
 -5

	)

130 #define 
	#M_PERTURB
 -6

	)

131 #define 
	#M_ARENA_TEST
 -7

	)

132 #define 
	#M_ARENA_MAX
 -8

	)

135 extern int 
mallopt
 
__MALLOC_P
 ((int 
__param
, int 
__val
));

139 extern int 
malloc_trim
 
__MALLOC_P
 ((
size_t
 
__pad
));

143 extern 
size_t
 
malloc_usable_size
 
__MALLOC_P
 ((void *
__ptr
));

146 extern void 
malloc_stats
 
__MALLOC_P
 ((void));

149 extern int 
malloc_info
 (int 
__options
, 
FILE
 *
__fp
);

152 extern void *
malloc_get_state
 
__MALLOC_P
 ((void));

156 extern int 
malloc_set_state
 
__MALLOC_P
 ((void *
__ptr
));

161 extern void (*
__malloc_initialize_hook
) 
	`__MALLOC_PMT
 ((void));

163 extern void (*
__free_hook
) 
	`__MALLOC_PMT
 ((void *
__ptr
,

164 
__const
 
__malloc_ptr_t
));

165 extern void *(*
__malloc_hook
) 
	`__MALLOC_PMT
 ((
size_t
 
__size
,

166 
__const
 
__malloc_ptr_t
));

167 extern void *(*
__realloc_hook
) 
	`__MALLOC_PMT
 ((void *
__ptr
, 
size_t
 
__size
,

168 
__const
 
__malloc_ptr_t
));

169 extern void *(*
__memalign_hook
) 
	`__MALLOC_PMT
 ((
size_t
 
__alignment
,

170 
size_t
 
__size
,

171 
__const
 
__malloc_ptr_t
));

172 extern void (*
__after_morecore_hook
) 
	`__MALLOC_PMT
 ((void));

175 extern void 
__malloc_check_init
 
	`__MALLOC_P
 ((void));

178 
__END_DECLS


	@/usr/include/math.h

25 #ifndef 
_MATH_H


26 #define 
	#_MATH_H
 1

	)

28 #include 
	~<features.h
>

30 
	g__BEGIN_DECLS


34 #include 
	~<bits/huge_val.h
>

35 #ifdef 
__USE_ISOC99


36 #include 
	~<bits/huge_valf.h
>

37 #include 
	~<bits/huge_vall.h
>

40 #include 
	~<bits/inf.h
>

43 #include 
	~<bits/nan.h
>

47 #include 
	~<bits/mathdef.h
>

54 #define 
	#__MATHCALL
(
function
,
suffix
, 
args
) \

55 
	`__MATHDECL
 (
_Mdouble_
,
function
,
suffix
, 
args
)

	)

56 #define 
	#__MATHDECL
(
type
, 
function
,
suffix
, 
args
) \

57 
	`__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
); \

58 
	`__MATHDECL_1
(
type
, 
	`__CONCAT
(
__
,
function
),
suffix
, 
args
)

	)

59 #define 
	#__MATHCALLX
(
function
,
suffix
, 
args
, 
attrib
) \

60 
	`__MATHDECLX
 (
_Mdouble_
,
function
,
suffix
, 
args
, 
attrib
)

	)

61 #define 
	#__MATHDECLX
(
type
, 
function
,
suffix
, 
args
, 
attrib
) \

62 
	`__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) 
	`__attribute__
 (
attrib
); \

63 
	`__MATHDECL_1
(
type
, 
	`__CONCAT
(
__
,
function
),
suffix
, 
args
) 
	`__attribute__
 (
attrib
)

	)

64 #define 
	#__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) \

65 extern 
type
 
	`__MATH_PRECNAME
(
function
,
suffix
) 
args
 
__THROW


	)

67 #define 
	#_Mdouble_
 double

	)

68 #define 
	#__MATH_PRECNAME
(
name
,
r
) 
	`__CONCAT
(name,r)

	)

69 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_STD


	)

70 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_STD


	)

71 #include 
	~<bits/mathcalls.h
>

72 #undef 
_Mdouble_


73 #undef 
_Mdouble_BEGIN_NAMESPACE


74 #undef 
_Mdouble_END_NAMESPACE


75 #undef 
__MATH_PRECNAME


77 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


83 #ifndef 
_Mfloat_


84 #define 
	#_Mfloat_
 float

	)

86 #define 
	#_Mdouble_
 
_Mfloat_


	)

87 #ifdef 
__STDC__


88 #define 
	#__MATH_PRECNAME
(
name
,
r
) name##
f
##
	)
r

90 #define 
	#__MATH_PRECNAME
(
name
,
r
) name 
f
 
	)
r

92 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

93 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

94 #include 
	~<bits/mathcalls.h
>

95 #undef 
_Mdouble_


96 #undef 
_Mdouble_BEGIN_NAMESPACE


97 #undef 
_Mdouble_END_NAMESPACE


98 #undef 
__MATH_PRECNAME


100 #if (
__STDC__
 - 0 || 
__GNUC__
 - 0) \

101 && (!
defined
 
__NO_LONG_DOUBLE_MATH
 \

102 || 
defined
 
__LDBL_COMPAT
 \

103 || !
defined
 
_LIBC
)

104 #ifdef 
__LDBL_COMPAT


106 #ifdef 
__USE_ISOC99


107 extern float 
	$__nldbl_nexttowardf
 (float 
__x
, long double 
__y
)

108 
__THROW
 
	`__attribute__
 ((
__const__
));

109 #ifdef 
__REDIRECT_NTH


110 extern float 
	`__REDIRECT_NTH
 (
nexttowardf
, (float 
__x
, long double 
__y
),

111 
__nldbl_nexttowardf
)

112 
	`__attribute__
 ((
__const__
));

113 extern double 
	`__REDIRECT_NTH
 (
nexttoward
, (double 
__x
, long double 
__y
),

114 
nextafter
) 
	`__attribute__
 ((
__const__
));

115 extern long double 
	`__REDIRECT_NTH
 (
nexttowardl
,

116 (long double 
__x
, long double 
__y
),

117 
nextafter
) 
	`__attribute__
 ((
__const__
));

122 #if 
defined
 
__LDBL_COMPAT
 || defined 
__NO_LONG_DOUBLE_MATH


124 #undef 
__MATHDECL_1


125 #define 
	#__MATHDECL_2
(
type
, 
function
,
suffix
, 
args
, 
alias
) \

126 extern 
type
 
	`__REDIRECT_NTH
(
	`__MATH_PRECNAME
(
function
,
suffix
), \

127 
args
, 
alias
)

	)

128 #define 
	#__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) \

129 
	`__MATHDECL_2
(
type
, 
function
,
suffix
, 
args
, 
	`__CONCAT
(function,suffix))

	)

134 #ifndef 
_Mlong_double_


135 #define 
	#_Mlong_double_
 long double

	)

137 #define 
	#_Mdouble_
 
_Mlong_double_


	)

138 #ifdef 
__STDC__


139 #define 
	#__MATH_PRECNAME
(
name
,
r
) name##
l
##
	)
r

141 #define 
	#__MATH_PRECNAME
(
name
,
r
) name 
l
 
	)
r

143 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

144 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

145 #include 
	~<bits/mathcalls.h
>

146 #undef 
_Mdouble_


147 #undef 
_Mdouble_BEGIN_NAMESPACE


148 #undef 
_Mdouble_END_NAMESPACE


149 #undef 
__MATH_PRECNAME


154 #undef 
__MATHDECL_1


155 #undef 
__MATHDECL


156 #undef 
__MATHCALL


159 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


161 extern int 
signgam
;

166 #ifdef 
__USE_ISOC99


204 
FP_NAN
,

205 #define 
	#FP_NAN
 
FP_NAN


	)

206 
FP_INFINITE
,

207 #define 
	#FP_INFINITE
 
FP_INFINITE


	)

208 
FP_ZERO
,

209 #define 
	#FP_ZERO
 
FP_ZERO


	)

210 
FP_SUBNORMAL
,

211 #define 
	#FP_SUBNORMAL
 
FP_SUBNORMAL


	)

212 
FP_NORMAL


213 #define 
	#FP_NORMAL
 
FP_NORMAL


	)

217 #ifdef 
__NO_LONG_DOUBLE_MATH


218 #define 
	#fpclassify
(
x
) \

219 (sizeof (
x
) == sizeof (float) ? 
	`__fpclassifyf
 (x) : 
	`__fpclassify
 (x))

	)

221 #define 
	#fpclassify
(
x
) \

222 (sizeof (
x
) == sizeof (float) \

223 ? 
	`__fpclassifyf
 (
x
) \

224 : sizeof (
x
) == sizeof (double) \

225 ? 
	`__fpclassify
 (
x
) : 
	`__fpclassifyl
 (x))

	)

229 #ifdef 
__NO_LONG_DOUBLE_MATH


230 #define 
	#signbit
(
x
) \

231 (sizeof (
x
) == sizeof (float) ? 
	`__signbitf
 (x) : 
	`__signbit
 (x))

	)

233 #define 
	#signbit
(
x
) \

234 (sizeof (
x
) == sizeof (float) \

235 ? 
	`__signbitf
 (
x
) \

236 : sizeof (
x
) == sizeof (double) \

237 ? 
	`__signbit
 (
x
) : 
	`__signbitl
 (x))

	)

241 #ifdef 
__NO_LONG_DOUBLE_MATH


242 #define 
	#isfinite
(
x
) \

243 (sizeof (
x
) == sizeof (float) ? 
	`__finitef
 (x) : 
	`__finite
 (x))

	)

245 #define 
	#isfinite
(
x
) \

246 (sizeof (
x
) == sizeof (float) \

247 ? 
	`__finitef
 (
x
) \

248 : sizeof (
x
) == sizeof (double) \

249 ? 
	`__finite
 (
x
) : 
	`__finitel
 (x))

	)

253 #define 
	#isnormal
(
x
) (
	`fpclassify
 (x) == 
FP_NORMAL
)

	)

257 #ifdef 
__NO_LONG_DOUBLE_MATH


258 #define 
	#isnan
(
x
) \

259 (sizeof (
x
) == sizeof (float) ? 
	`__isnanf
 (x) : 
	`__isnan
 (x))

	)

261 #define 
	#isnan
(
x
) \

262 (sizeof (
x
) == sizeof (float) \

263 ? 
	`__isnanf
 (
x
) \

264 : sizeof (
x
) == sizeof (double) \

265 ? 
	`__isnan
 (
x
) : 
	`__isnanl
 (x))

	)

269 #ifdef 
__NO_LONG_DOUBLE_MATH


270 #define 
	#isinf
(
x
) \

271 (sizeof (
x
) == sizeof (float) ? 
	`__isinff
 (x) : 
	`__isinf
 (x))

	)

273 #define 
	#isinf
(
x
) \

274 (sizeof (
x
) == sizeof (float) \

275 ? 
	`__isinff
 (
x
) \

276 : sizeof (
x
) == sizeof (double) \

277 ? 
	`__isinf
 (
x
) : 
	`__isinfl
 (x))

	)

281 #define 
	#MATH_ERRNO
 1

	)

282 #define 
	#MATH_ERREXCEPT
 2

	)

287 #ifndef 
__FAST_MATH__


288 #define 
	#math_errhandling
 (
MATH_ERRNO
 | 
MATH_ERREXCEPT
)

	)

293 #ifdef 
__USE_MISC


297 
_IEEE_
 = -1,

298 
_SVID_
,

299 
_XOPEN_
,

300 
_POSIX_
,

301 
_ISOC_


302 } 
	t_LIB_VERSION_TYPE
;

307 extern 
_LIB_VERSION_TYPE
 
_LIB_VERSION
;

311 #ifdef 
__USE_SVID


317 #ifdef 
__cplusplus


318 struct 
__exception


320 struct 
exception


323 int 
type
;

324 char *
name
;

325 double 
arg1
;

326 double 
arg2
;

327 double 
retval
;

328 
	}
};

330 #ifdef 
__cplusplus


331 extern int 
	$matherr
 (struct 
__exception
 *
__exc
) 
	`throw
 ();

333 extern int 
	`matherr
 (struct 
exception
 *
__exc
);

336 #define 
	#X_TLOSS
 1.41484755040568800000e+16

	)

339 #define 
	#DOMAIN
 1

	)

340 #define 
	#SING
 2

	)

341 #define 
	#OVERFLOW
 3

	)

342 #define 
	#UNDERFLOW
 4

	)

343 #define 
	#TLOSS
 5

	)

344 #define 
	#PLOSS
 6

	)

347 #define 
	#HUGE
 3.40282347e+38F

	)

351 #ifdef 
__USE_XOPEN


353 #define 
	#MAXFLOAT
 3.40282347e+38F

	)

360 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN


361 #define 
	#M_E
 2.7182818284590452354

	)

362 #define 
	#M_LOG2E
 1.4426950408889634074

	)

363 #define 
	#M_LOG10E
 0.43429448190325182765

	)

364 #define 
	#M_LN2
 0.69314718055994530942

	)

365 #define 
	#M_LN10
 2.30258509299404568402

	)

366 #define 
	#M_PI
 3.14159265358979323846

	)

367 #define 
	#M_PI_2
 1.57079632679489661923

	)

368 #define 
	#M_PI_4
 0.78539816339744830962

	)

369 #define 
	#M_1_PI
 0.31830988618379067154

	)

370 #define 
	#M_2_PI
 0.63661977236758134308

	)

371 #define 
	#M_2_SQRTPI
 1.12837916709551257390

	)

372 #define 
	#M_SQRT2
 1.41421356237309504880

	)

373 #define 
	#M_SQRT1_2
 0.70710678118654752440

	)

379 #ifdef 
__USE_GNU


380 #define 
	#M_El
 2.7182818284590452353602874713526625L

	)

381 #define 
	#M_LOG2El
 1.4426950408889634073599246810018921L

	)

382 #define 
	#M_LOG10El
 0.4342944819032518276511289189166051L

	)

383 #define 
	#M_LN2l
 0.6931471805599453094172321214581766L

	)

384 #define 
	#M_LN10l
 2.3025850929940456840179914546843642L

	)

385 #define 
	#M_PIl
 3.1415926535897932384626433832795029L

	)

386 #define 
	#M_PI_2l
 1.5707963267948966192313216916397514L

	)

387 #define 
	#M_PI_4l
 0.7853981633974483096156608458198757L

	)

388 #define 
	#M_1_PIl
 0.3183098861837906715377675267450287L

	)

389 #define 
	#M_2_PIl
 0.6366197723675813430755350534900574L

	)

390 #define 
	#M_2_SQRTPIl
 1.1283791670955125738961589031215452L

	)

391 #define 
	#M_SQRT2l
 1.4142135623730950488016887242096981L

	)

392 #define 
	#M_SQRT1_2l
 0.7071067811865475244008443621048490L

	)

399 #if 
defined
 
__STRICT_ANSI__
 && !defined 
__NO_MATH_INLINES


400 #define 
	#__NO_MATH_INLINES
 1

	)

403 #if 
defined
 
__USE_ISOC99
 && 
	`__GNUC_PREREQ
(2,97)

410 #define 
	#isgreater
(
x
, 
y
) 
	`__builtin_isgreater
(x, y)

	)

411 #define 
	#isgreaterequal
(
x
, 
y
) 
	`__builtin_isgreaterequal
(x, y)

	)

412 #define 
	#isless
(
x
, 
y
) 
	`__builtin_isless
(x, y)

	)

413 #define 
	#islessequal
(
x
, 
y
) 
	`__builtin_islessequal
(x, y)

	)

414 #define 
	#islessgreater
(
x
, 
y
) 
	`__builtin_islessgreater
(x, y)

	)

415 #define 
	#isunordered
(
u
, 
v
) 
	`__builtin_isunordered
(u, v)

	)

419 #ifdef 
__USE_EXTERN_INLINES


420 #include 
	~<bits/mathinline.h
>

423 #ifdef 
__USE_ISOC99


427 #ifndef 
isgreater


428 #define 
	#isgreater
(
x
, 
y
) \

429 (
__extension__
 \

430 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

431 !
	`isunordered
 (
__x
, 
__y
) && __x > __y; 
	}
}))

	)

435 #ifndef 
isgreaterequal


436 #define 
	#isgreaterequal
(
x
, 
y
) \

437 (
__extension__
 \

438 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

439 !
	`isunordered
 (
__x
, 
__y
) && __x >= __y; }))

	)

443 #ifndef 
isless


444 #define 
	#isless
(
x
, 
y
) \

445 (
__extension__
 \

446 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

447 !
	`isunordered
 (
__x
, 
__y
) && __x < __y; }))

	)

451 #ifndef 
islessequal


452 #define 
	#islessequal
(
x
, 
y
) \

453 (
__extension__
 \

454 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

455 !
	`isunordered
 (
__x
, 
__y
) && __x <= __y; }))

	)

459 #ifndef 
islessgreater


460 #define 
	#islessgreater
(
x
, 
y
) \

461 (
__extension__
 \

462 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

463 !
	`isunordered
 (
__x
, 
__y
) && (__x < __y || __y < __x); }))

	)

467 #ifndef 
isunordered


468 #define 
	#isunordered
(
u
, 
v
) \

469 (
__extension__
 \

470 ({ 
	`__typeof__
(
u
) 
__u
 = (u); __typeof__(
v
) 
__v
 = (v); \

471 
	`fpclassify
 (
__u
) == 
FP_NAN
 || fpclassify (
__v
) == FP_NAN; }))

	)

476 
	g__END_DECLS


	@/usr/include/netdb.h

23 #ifndef 
_NETDB_H


24 #define 
	#_NETDB_H
 1

	)

26 #include 
	~<features.h
>

28 #include 
	~<netinet/in.h
>

29 #include 
	~<stdint.h
>

30 #ifdef 
__USE_MISC


33 #include 
	~<rpc/netdb.h
>

36 #ifdef 
__USE_GNU


37 #define 
	#__need_sigevent_t


	)

38 #include 
	~<bits/siginfo.h
>

39 #define 
	#__need_timespec


	)

40 #include 
	~<time.h
>

43 #include 
	~<bits/netdb.h
>

46 #define 
	#_PATH_HEQUIV
 "/etc/hosts.equiv"

	)

47 #define 
	#_PATH_HOSTS
 "/etc/hosts"

	)

48 #define 
	#_PATH_NETWORKS
 "/etc/networks"

	)

49 #define 
	#_PATH_NSSWITCH_CONF
 "/etc/nsswitch.conf"

	)

50 #define 
	#_PATH_PROTOCOLS
 "/etc/protocols"

	)

51 #define 
	#_PATH_SERVICES
 "/etc/services"

	)

54 
	g__BEGIN_DECLS


56 #if 
defined
 
__USE_MISC
 || !defined 
__USE_XOPEN2K8


59 #define 
	#h_errno
 (*
	`__h_errno_location
 ())

	)

62 extern int *
	$__h_errno_location
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

66 #define 
	#HOST_NOT_FOUND
 1

	)

67 #define 
	#TRY_AGAIN
 2

	)

69 #define 
	#NO_RECOVERY
 3

	)

71 #define 
	#NO_DATA
 4

	)

74 #if 
defined
 
__USE_MISC
 || defined 
__USE_GNU


75 #define 
	#NETDB_INTERNAL
 -1

	)

76 #define 
	#NETDB_SUCCESS
 0

	)

77 #define 
	#NO_ADDRESS
 
NO_DATA


	)

80 #ifdef 
__USE_XOPEN2K


82 #define 
	#IPPORT_RESERVED
 1024

	)

85 #ifdef 
__USE_GNU


87 #define 
	#SCOPE_DELIMITER
 '%'

	)

90 #ifdef 
__USE_MISC


93 extern void 
	$herror
 (
__const
 char *
__str
) 
__THROW
;

96 extern 
__const
 char *
	$hstrerror
 (int 
__err_num
) 
__THROW
;

101 struct 
	shostent


103 char *
h_name
;

104 char **
h_aliases
;

105 int 
h_addrtype
;

106 int 
h_length
;

107 char **
h_addr_list
;

108 #if 
defined
 
__USE_MISC
 || defined 
__USE_GNU


109 #define 
	#h_addr
 
h_addr_list
[0]

	)

118 extern void 
	`sethostent
 (int 
__stay_open
);

124 extern void 
	`endhostent
 (void);

131 extern struct 
hostent
 *
	`gethostent
 (void);

138 extern struct 
hostent
 *
	`gethostbyaddr
 (
__const
 void *
__addr
, 
__socklen_t
 
__len
,

139 int 
__type
);

145 extern struct 
hostent
 *
	`gethostbyname
 (
__const
 char *
__name
);

147 #ifdef 
__USE_MISC


156 extern struct 
hostent
 *
	`gethostbyname2
 (
__const
 char *
__name
, int 
__af
);

168 extern int 
	`gethostent_r
 (struct 
hostent
 *
__restrict
 
__result_buf
,

169 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

170 struct 
hostent
 **
__restrict
 
__result
,

171 int *
__restrict
 
__h_errnop
);

173 extern int 
	`gethostbyaddr_r
 (
__const
 void *
__restrict
 
__addr
, 
__socklen_t
 
__len
,

174 int 
__type
,

175 struct 
hostent
 *
__restrict
 
__result_buf
,

176 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

177 struct 
hostent
 **
__restrict
 
__result
,

178 int *
__restrict
 
__h_errnop
);

180 extern int 
	`gethostbyname_r
 (
__const
 char *
__restrict
 
__name
,

181 struct 
hostent
 *
__restrict
 
__result_buf
,

182 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

183 struct 
hostent
 **
__restrict
 
__result
,

184 int *
__restrict
 
__h_errnop
);

186 extern int 
	`gethostbyname2_r
 (
__const
 char *
__restrict
 
__name
, int 
__af
,

187 struct 
hostent
 *
__restrict
 
__result_buf
,

188 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

189 struct 
hostent
 **
__restrict
 
__result
,

190 int *
__restrict
 
__h_errnop
);

199 extern void 
	`setnetent
 (int 
__stay_open
);

205 extern void 
	`endnetent
 (void);

212 extern struct 
netent
 *
	`getnetent
 (void);

219 extern struct 
netent
 *
	`getnetbyaddr
 (
uint32_t
 
__net
, int 
__type
);

225 extern struct 
netent
 *
	`getnetbyname
 (
__const
 char *
__name
);

227 #ifdef 
__USE_MISC


238 extern int 
	`getnetent_r
 (struct 
netent
 *
__restrict
 
__result_buf
,

239 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

240 struct 
netent
 **
__restrict
 
__result
,

241 int *
__restrict
 
__h_errnop
);

243 extern int 
	`getnetbyaddr_r
 (
uint32_t
 
__net
, int 
__type
,

244 struct 
netent
 *
__restrict
 
__result_buf
,

245 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

246 struct 
netent
 **
__restrict
 
__result
,

247 int *
__restrict
 
__h_errnop
);

249 extern int 
	`getnetbyname_r
 (
__const
 char *
__restrict
 
__name
,

250 struct 
netent
 *
__restrict
 
__result_buf
,

251 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

252 struct 
netent
 **
__restrict
 
__result
,

253 int *
__restrict
 
__h_errnop
);

258 struct 
	sservent


260 char *
s_name
;

261 char **
s_aliases
;

262 int 
s_port
;

263 char *
s_proto
;

271 extern void 
	`setservent
 (int 
__stay_open
);

277 extern void 
	`endservent
 (void);

284 extern struct 
servent
 *
	`getservent
 (void);

291 extern struct 
servent
 *
	`getservbyname
 (
__const
 char *
__name
,

292 
__const
 char *
__proto
);

299 extern struct 
servent
 *
	`getservbyport
 (int 
__port
, 
__const
 char *
__proto
);

302 #ifdef 
__USE_MISC


310 extern int 
	`getservent_r
 (struct 
servent
 *
__restrict
 
__result_buf
,

311 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

312 struct 
servent
 **
__restrict
 
__result
);

314 extern int 
	`getservbyname_r
 (
__const
 char *
__restrict
 
__name
,

315 
__const
 char *
__restrict
 
__proto
,

316 struct 
servent
 *
__restrict
 
__result_buf
,

317 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

318 struct 
servent
 **
__restrict
 
__result
);

320 extern int 
	`getservbyport_r
 (int 
__port
, 
__const
 char *
__restrict
 
__proto
,

321 struct 
servent
 *
__restrict
 
__result_buf
,

322 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

323 struct 
servent
 **
__restrict
 
__result
);

328 struct 
	sprotoent


330 char *
p_name
;

331 char **
p_aliases
;

332 int 
p_proto
;

340 extern void 
	`setprotoent
 (int 
__stay_open
);

346 extern void 
	`endprotoent
 (void);

353 extern struct 
protoent
 *
	`getprotoent
 (void);

359 extern struct 
protoent
 *
	`getprotobyname
 (
__const
 char *
__name
);

365 extern struct 
protoent
 *
	`getprotobynumber
 (int 
__proto
);

368 #ifdef 
__USE_MISC


376 extern int 
	`getprotoent_r
 (struct 
protoent
 *
__restrict
 
__result_buf
,

377 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

378 struct 
protoent
 **
__restrict
 
__result
);

380 extern int 
	`getprotobyname_r
 (
__const
 char *
__restrict
 
__name
,

381 struct 
protoent
 *
__restrict
 
__result_buf
,

382 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

383 struct 
protoent
 **
__restrict
 
__result
);

385 extern int 
	`getprotobynumber_r
 (int 
__proto
,

386 struct 
protoent
 *
__restrict
 
__result_buf
,

387 char *
__restrict
 
__buf
, 
size_t
 
__buflen
,

388 struct 
protoent
 **
__restrict
 
__result
);

397 extern int 
	`setnetgrent
 (
__const
 char *
__netgroup
);

405 extern void 
	`endnetgrent
 (void);

414 extern int 
	`getnetgrent
 (char **
__restrict
 
__hostp
,

415 char **
__restrict
 
__userp
,

416 char **
__restrict
 
__domainp
);

425 extern int 
	`innetgr
 (
__const
 char *
__netgroup
, __const char *
__host
,

426 
__const
 char *
__user
, __const char *
__domain
);

434 extern int 
	`getnetgrent_r
 (char **
__restrict
 
__hostp
,

435 char **
__restrict
 
__userp
,

436 char **
__restrict
 
__domainp
,

437 char *
__restrict
 
__buffer
, 
size_t
 
__buflen
);

441 #ifdef 
__USE_BSD


453 extern int 
	`rcmd
 (char **
__restrict
 
__ahost
, unsigned short int 
__rport
,

454 
__const
 char *
__restrict
 
__locuser
,

455 
__const
 char *
__restrict
 
__remuser
,

456 
__const
 char *
__restrict
 
__cmd
, int *__restrict 
__fd2p
);

465 extern int 
	`rcmd_af
 (char **
__restrict
 
__ahost
, unsigned short int 
__rport
,

466 
__const
 char *
__restrict
 
__locuser
,

467 
__const
 char *
__restrict
 
__remuser
,

468 
__const
 char *
__restrict
 
__cmd
, int *__restrict 
__fd2p
,

469 
sa_family_t
 
__af
);

481 extern int 
	`rexec
 (char **
__restrict
 
__ahost
, int 
__rport
,

482 
__const
 char *
__restrict
 
__name
,

483 
__const
 char *
__restrict
 
__pass
,

484 
__const
 char *
__restrict
 
__cmd
, int *__restrict 
__fd2p
);

493 extern int 
	`rexec_af
 (char **
__restrict
 
__ahost
, int 
__rport
,

494 
__const
 char *
__restrict
 
__name
,

495 
__const
 char *
__restrict
 
__pass
,

496 
__const
 char *
__restrict
 
__cmd
, int *__restrict 
__fd2p
,

497 
sa_family_t
 
__af
);

507 extern int 
	`ruserok
 (
__const
 char *
__rhost
, int 
__suser
,

508 
__const
 char *
__remuser
, __const char *
__locuser
);

517 extern int 
	`ruserok_af
 (
__const
 char *
__rhost
, int 
__suser
,

518 
__const
 char *
__remuser
, __const char *
__locuser
,

519 
sa_family_t
 
__af
);

530 extern int 
	`iruserok
 (
uint32_t
 
__raddr
, int 
__suser
,

531 
__const
 char *
__remuser
, __const char *
__locuser
);

541 extern int 
	`iruserok_af
 (
__const
 void *
__raddr
, int 
__suser
,

542 
__const
 char *
__remuser
, __const char *
__locuser
,

543 
sa_family_t
 
__af
);

553 extern int 
	`rresvport
 (int *
__alport
);

562 extern int 
	`rresvport_af
 (int *
__alport
, 
sa_family_t
 
__af
);

567 #ifdef 
__USE_POSIX


569 struct 
	saddrinfo


571 int 
ai_flags
;

572 int 
ai_family
;

573 int 
ai_socktype
;

574 int 
ai_protocol
;

575 
socklen_t
 
ai_addrlen
;

576 struct 
sockaddr
 *
ai_addr
;

577 char *
ai_canonname
;

578 struct 
addrinfo
 *
ai_next
;

581 #ifdef 
__USE_GNU


583 struct 
	sgaicb


585 const char *
ar_name
;

586 const char *
ar_service
;

587 const struct 
addrinfo
 *
ar_request
;

588 struct 
addrinfo
 *
ar_result
;

590 int 
__return
;

591 int 
__unused
[5];

595 #define 
	#GAI_WAIT
 0

	)

596 #define 
	#GAI_NOWAIT
 1

	)

600 #define 
	#AI_PASSIVE
 0x0001

	)

601 #define 
	#AI_CANONNAME
 0x0002

	)

602 #define 
	#AI_NUMERICHOST
 0x0004

	)

603 #define 
	#AI_V4MAPPED
 0x0008

	)

604 #define 
	#AI_ALL
 0x0010

	)

605 #define 
	#AI_ADDRCONFIG
 0x0020

	)

607 #ifdef 
__USE_GNU


608 #define 
	#AI_IDN
 0x0040

	)

611 #define 
	#AI_CANONIDN
 0x0080

	)

612 #define 
	#AI_IDN_ALLOW_UNASSIGNED
 0x0100

	)

614 #define 
	#AI_IDN_USE_STD3_ASCII_RULES
 0x0200

	)

617 #define 
	#AI_NUMERICSERV
 0x0400

	)

620 #define 
	#EAI_BADFLAGS
 -1

	)

621 #define 
	#EAI_NONAME
 -2

	)

622 #define 
	#EAI_AGAIN
 -3

	)

623 #define 
	#EAI_FAIL
 -4

	)

624 #define 
	#EAI_FAMILY
 -6

	)

625 #define 
	#EAI_SOCKTYPE
 -7

	)

626 #define 
	#EAI_SERVICE
 -8

	)

627 #define 
	#EAI_MEMORY
 -10

	)

628 #define 
	#EAI_SYSTEM
 -11

	)

629 #define 
	#EAI_OVERFLOW
 -12

	)

630 #ifdef 
__USE_GNU


631 #define 
	#EAI_NODATA
 -5

	)

632 #define 
	#EAI_ADDRFAMILY
 -9

	)

633 #define 
	#EAI_INPROGRESS
 -100

	)

634 #define 
	#EAI_CANCELED
 -101

	)

635 #define 
	#EAI_NOTCANCELED
 -102

	)

636 #define 
	#EAI_ALLDONE
 -103

	)

637 #define 
	#EAI_INTR
 -104

	)

638 #define 
	#EAI_IDN_ENCODE
 -105

	)

641 #ifdef 
__USE_MISC


642 #define 
	#NI_MAXHOST
 1025

	)

643 #define 
	#NI_MAXSERV
 32

	)

646 #define 
	#NI_NUMERICHOST
 1

	)

647 #define 
	#NI_NUMERICSERV
 2

	)

648 #define 
	#NI_NOFQDN
 4

	)

649 #define 
	#NI_NAMEREQD
 8

	)

650 #define 
	#NI_DGRAM
 16

	)

651 #ifdef 
__USE_GNU


652 #define 
	#NI_IDN
 32

	)

653 #define 
	#NI_IDN_ALLOW_UNASSIGNED
 64

	)

655 #define 
	#NI_IDN_USE_STD3_ASCII_RULES
 128

	)

664 extern int 
	`getaddrinfo
 (
__const
 char *
__restrict
 
__name
,

665 
__const
 char *
__restrict
 
__service
,

666 
__const
 struct 
addrinfo
 *
__restrict
 
__req
,

667 struct 
addrinfo
 **
__restrict
 
__pai
);

670 extern void 
	$freeaddrinfo
 (struct 
addrinfo
 *
__ai
) 
__THROW
;

673 extern 
__const
 char *
	$gai_strerror
 (int 
__ecode
) 
__THROW
;

679 extern int 
	`getnameinfo
 (
__const
 struct 
sockaddr
 *
__restrict
 
__sa
,

680 
socklen_t
 
__salen
, char *
__restrict
 
__host
,

681 
socklen_t
 
__hostlen
, char *
__restrict
 
__serv
,

682 
socklen_t
 
__servlen
, unsigned int 
__flags
);

685 #ifdef 
__USE_GNU


694 extern int 
	`getaddrinfo_a
 (int 
__mode
, struct 
gaicb
 *
__list
[
__restrict_arr
],

695 int 
__ent
, struct 
sigevent
 *
__restrict
 
__sig
);

705 extern int 
	`gai_suspend
 (
__const
 struct 
gaicb
 *__const 
__list
[], int 
__ent
,

706 
__const
 struct 
timespec
 *
__timeout
);

709 extern int 
	$gai_error
 (struct 
gaicb
 *
__req
) 
__THROW
;

712 extern int 
	$gai_cancel
 (struct 
gaicb
 *
__gaicbp
) 
__THROW
;

715 
__END_DECLS


	@/usr/include/obstack.h

106 #ifndef 
_OBSTACK_H


107 #define 
	#_OBSTACK_H
 1

	)

109 #ifdef 
__cplusplus


118 #ifdef 
__PTRDIFF_TYPE__


119 #define 
	#PTR_INT_TYPE
 
__PTRDIFF_TYPE__


	)

121 #include 
	~<stddef.h
>

122 #define 
	#PTR_INT_TYPE
 
ptrdiff_t


	)

129 #define 
	#__BPTR_ALIGN
(
B
, 
P
, 
A
) ((B) + (((P) - (B) + (A)) & ~(A)))

	)

138 #define 
	#__PTR_ALIGN
(
B
, 
P
, 
A
) \

139 
	`__BPTR_ALIGN
 (sizeof (
PTR_INT_TYPE
) < sizeof (void *) ? (
B
) : (char *) 0, \

140 
P
, 
A
)

	)

142 #include 
	~<string.h
>

144 struct 
	s_obstack_chunk


146 char *
limit
;

147 struct 
_obstack_chunk
 *
prev
;

148 char 
contents
[4];

151 struct 
	sobstack


153 long 
chunk_size
;

154 struct 
_obstack_chunk
 *
chunk
;

155 char *
object_base
;

156 char *
next_free
;

157 char *
chunk_limit
;

160 
PTR_INT_TYPE
 
tempint
;

161 void *
tempptr
;

162 } 
temp
;

163 int 
alignment_mask
;

167 struct 
_obstack_chunk
 *(*
chunkfun
) (void *, long);

168 void (*
freefun
) (void *, struct 
_obstack_chunk
 *);

169 void *
extra_arg
;

170 unsigned 
use_extra_arg
:1;

171 unsigned 
maybe_empty_object
:1;

175 unsigned 
alloc_failed
:1;

182 extern void 
_obstack_newchunk
 (struct 
obstack
 *, int);

183 extern int 
_obstack_begin
 (struct 
obstack
 *, int, int,

185 extern int 
_obstack_begin_1
 (struct 
obstack
 *, int, int,

188 extern int 
_obstack_memory_used
 (struct 
obstack
 *);

190 void 
obstack_free
 (struct 
obstack
 *
__obstack
, void *
__block
);

197 extern void (*
obstack_alloc_failed_handler
) (void);

200 extern int 
obstack_exit_failure
;

206 #define 
	#obstack_base
(
h
) ((void *) (h)->
object_base
)

	)

210 #define 
	#obstack_chunk_size
(
h
) ((h)->
chunk_size
)

	)

214 #define 
	#obstack_next_free
(
h
) ((h)->
next_free
)

	)

218 #define 
	#obstack_alignment_mask
(
h
) ((h)->
alignment_mask
)

	)

221 #define 
	#obstack_init
(
h
) \

222 
	`_obstack_begin
 ((
h
), 0, 0, \

223 (void *(*) (long)) 
obstack_chunk_alloc
, \

224 (void (*) (void *)) 
obstack_chunk_free
)

	)

226 #define 
	#obstack_begin
(
h
, 
size
) \

227 
	`_obstack_begin
 ((
h
), (
size
), 0, \

228 (void *(*) (long)) 
obstack_chunk_alloc
, \

229 (void (*) (void *)) 
obstack_chunk_free
)

	)

231 #define 
	#obstack_specify_allocation
(
h
, 
size
, 
alignment
, 
chunkfun
, 
freefun
) \

232 
	`_obstack_begin
 ((
h
), (
size
), (
alignment
), \

233 (void *(*) (long)) (
chunkfun
), \

234 (void (*) (void *)) (
freefun
))

	)

236 #define 
	#obstack_specify_allocation_with_arg
(
h
, 
size
, 
alignment
, 
chunkfun
, 
freefun
, 
arg
) \

237 
	`_obstack_begin_1
 ((
h
), (
size
), (
alignment
), \

238 (void *(*) (void *, long)) (
chunkfun
), \

239 (void (*) (void *, void *)) (
freefun
), (
arg
))

	)

241 #define 
	#obstack_chunkfun
(
h
, 
newchunkfun
) \

242 ((
h
) -> 
chunkfun
 = (struct 
_obstack_chunk
 *(*)(void *, long)) (
newchunkfun
))

	)

244 #define 
	#obstack_freefun
(
h
, 
newfreefun
) \

245 ((
h
) -> 
freefun
 = (void (*)(void *, struct 
_obstack_chunk
 *)) (
newfreefun
))

	)

247 #define 
	#obstack_1grow_fast
(
h
,
achar
) (*((h)->
next_free
)++ = (achar))

	)

249 #define 
	#obstack_blank_fast
(
h
,
n
) ((h)->
next_free
 += (n))

	)

251 #define 
	#obstack_memory_used
(
h
) 
	`_obstack_memory_used
 (h)

	)

253 #if 
defined
 
__GNUC__
 && defined 
__STDC__
 && __STDC__

257 #if 
__GNUC__
 < 2 || (
__NeXT__
 && !
__GNUC_MINOR__
)

258 #define 
	#__extension__


	)

266 #define 
	#obstack_object_size
(
OBSTACK
) \

267 
__extension__
 \

268 ({ struct 
obstack
 const *
__o
 = (
OBSTACK
); \

269 (unsigned) (
__o
->
next_free
 - __o->
object_base
); })

	)

271 #define 
	#obstack_room
(
OBSTACK
) \

272 
__extension__
 \

273 ({ struct 
obstack
 const *
__o
 = (
OBSTACK
); \

274 (unsigned) (
__o
->
chunk_limit
 - __o->
next_free
); })

	)

276 #define 
	#obstack_make_room
(
OBSTACK
,
length
) \

277 
__extension__
 \

278 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

279 int 
__len
 = (
length
); \

280 if (
__o
->
chunk_limit
 - __o->
next_free
 < 
__len
) \

281 
	`_obstack_newchunk
 (
__o
, 
__len
); \

282 (void) 0; })

	)

284 #define 
	#obstack_empty_p
(
OBSTACK
) \

285 
__extension__
 \

286 ({ struct 
obstack
 const *
__o
 = (
OBSTACK
); \

287 (
__o
->
chunk
->
prev
 == 0 \

288 && 
__o
->
next_free
 == 
	`__PTR_ALIGN
 ((char *) __o->
chunk
, \

289 
__o
->
chunk
->
contents
, \

290 
__o
->
alignment_mask
)); })

	)

292 #define 
	#obstack_grow
(
OBSTACK
,
where
,
length
) \

293 
__extension__
 \

294 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

295 int 
__len
 = (
length
); \

296 if (
__o
->
next_free
 + 
__len
 > __o->
chunk_limit
) \

297 
	`_obstack_newchunk
 (
__o
, 
__len
); \

298 
	`memcpy
 (
__o
->
next_free
, 
where
, 
__len
); \

299 
__o
->
next_free
 += 
__len
; \

300 (void) 0; })

	)

302 #define 
	#obstack_grow0
(
OBSTACK
,
where
,
length
) \

303 
__extension__
 \

304 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

305 int 
__len
 = (
length
); \

306 if (
__o
->
next_free
 + 
__len
 + 1 > __o->
chunk_limit
) \

307 
	`_obstack_newchunk
 (
__o
, 
__len
 + 1); \

308 
	`memcpy
 (
__o
->
next_free
, 
where
, 
__len
); \

309 
__o
->
next_free
 += 
__len
; \

310 *(
__o
->
next_free
)++ = 0; \

311 (void) 0; })

	)

313 #define 
	#obstack_1grow
(
OBSTACK
,
datum
) \

314 
__extension__
 \

315 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

316 if (
__o
->
next_free
 + 1 > __o->
chunk_limit
) \

317 
	`_obstack_newchunk
 (
__o
, 1); \

318 
	`obstack_1grow_fast
 (
__o
, 
datum
); \

319 (void) 0; })

	)

325 #define 
	#obstack_ptr_grow
(
OBSTACK
,
datum
) \

326 
__extension__
 \

327 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

328 if (
__o
->
next_free
 + sizeof (void *) > __o->
chunk_limit
) \

329 
	`_obstack_newchunk
 (
__o
, sizeof (void *)); \

330 
	`obstack_ptr_grow_fast
 (
__o
, 
datum
); }) \

331 

	)

332 #define 
	#obstack_int_grow
(
OBSTACK
,
datum
) \

333 
__extension__
 \

334 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

335 if (
__o
->
next_free
 + sizeof (int) > __o->
chunk_limit
) \

336 
	`_obstack_newchunk
 (
__o
, sizeof (int)); \

337 
	`obstack_int_grow_fast
 (
__o
, 
datum
); })

	)

339 #define 
	#obstack_ptr_grow_fast
(
OBSTACK
,
aptr
) \

340 
__extension__
 \

341 ({ struct 
obstack
 *
__o1
 = (
OBSTACK
); \

342 *(const void **) 
__o1
->
next_free
 = (
aptr
); \

343 
__o1
->
next_free
 += sizeof (const void *); \

344 (void) 0; })

	)

346 #define 
	#obstack_int_grow_fast
(
OBSTACK
,
aint
) \

347 
__extension__
 \

348 ({ struct 
obstack
 *
__o1
 = (
OBSTACK
); \

349 *(int *) 
__o1
->
next_free
 = (
aint
); \

350 
__o1
->
next_free
 += sizeof (int); \

351 (void) 0; })

	)

353 #define 
	#obstack_blank
(
OBSTACK
,
length
) \

354 
__extension__
 \

355 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

356 int 
__len
 = (
length
); \

357 if (
__o
->
chunk_limit
 - __o->
next_free
 < 
__len
) \

358 
	`_obstack_newchunk
 (
__o
, 
__len
); \

359 
	`obstack_blank_fast
 (
__o
, 
__len
); \

360 (void) 0; })

	)

362 #define 
	#obstack_alloc
(
OBSTACK
,
length
) \

363 
__extension__
 \

364 ({ struct 
obstack
 *
__h
 = (
OBSTACK
); \

365 
	`obstack_blank
 (
__h
, (
length
)); \

366 
	`obstack_finish
 (
__h
); })

	)

368 #define 
	#obstack_copy
(
OBSTACK
,
where
,
length
) \

369 
__extension__
 \

370 ({ struct 
obstack
 *
__h
 = (
OBSTACK
); \

371 
	`obstack_grow
 (
__h
, (
where
), (
length
)); \

372 
	`obstack_finish
 (
__h
); })

	)

374 #define 
	#obstack_copy0
(
OBSTACK
,
where
,
length
) \

375 
__extension__
 \

376 ({ struct 
obstack
 *
__h
 = (
OBSTACK
); \

377 
	`obstack_grow0
 (
__h
, (
where
), (
length
)); \

378 
	`obstack_finish
 (
__h
); })

	)

382 #define 
	#obstack_finish
(
OBSTACK
) \

383 
__extension__
 \

384 ({ struct 
obstack
 *
__o1
 = (
OBSTACK
); \

385 void *
__value
 = (void *) 
__o1
->
object_base
; \

386 if (
__o1
->
next_free
 == 
__value
) \

387 
__o1
->
maybe_empty_object
 = 1; \

388 
__o1
->
next_free
 \

389 = 
	`__PTR_ALIGN
 (
__o1
->
object_base
, __o1->
next_free
, \

390 
__o1
->
alignment_mask
); \

391 if (
__o1
->
next_free
 - (char *)__o1->
chunk
 \

392 > 
__o1
->
chunk_limit
 - (char *)__o1->
chunk
) \

393 
__o1
->
next_free
 = __o1->
chunk_limit
; \

394 
__o1
->
object_base
 = __o1->
next_free
; \

395 
__value
; })

	)

397 #define 
	#obstack_free
(
OBSTACK
, 
OBJ
) \

398 
__extension__
 \

399 ({ struct 
obstack
 *
__o
 = (
OBSTACK
); \

400 void *
__obj
 = (
OBJ
); \

401 if (
__obj
 > (void *)
__o
->
chunk
 && __obj < (void *)__o->
chunk_limit
) \

402 
__o
->
next_free
 = __o->
object_base
 = (char *)
__obj
; \

403 else (
obstack_free
) (
__o
, 
__obj
); })

	)

407 #define 
	#obstack_object_size
(
h
) \

408 (unsigned) ((
h
)->
next_free
 - (h)->
object_base
)

	)

410 #define 
	#obstack_room
(
h
) \

411 (unsigned) ((
h
)->
chunk_limit
 - (h)->
next_free
)

	)

413 #define 
	#obstack_empty_p
(
h
) \

414 ((
h
)->
chunk
->
prev
 == 0 \

415 && (
h
)->
next_free
 == 
	`__PTR_ALIGN
 ((char *) (h)->
chunk
, \

416 (
h
)->
chunk
->
contents
, \

417 (
h
)->
alignment_mask
))

	)

425 #define 
	#obstack_make_room
(
h
,
length
) \

426 ( (
h
)->
temp
.
tempint
 = (
length
), \

427 (((
h
)->
next_free
 + (h)->
temp
.
tempint
 > (h)->
chunk_limit
) \

428 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
), 0) : 0))

	)

430 #define 
	#obstack_grow
(
h
,
where
,
length
) \

431 ( (
h
)->
temp
.
tempint
 = (
length
), \

432 (((
h
)->
next_free
 + (h)->
temp
.
tempint
 > (h)->
chunk_limit
) \

433 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
), 0) : 0), \

434 
	`memcpy
 ((
h
)->
next_free
, 
where
, (h)->
temp
.
tempint
), \

435 (
h
)->
next_free
 += (h)->
temp
.
tempint
)

	)

437 #define 
	#obstack_grow0
(
h
,
where
,
length
) \

438 ( (
h
)->
temp
.
tempint
 = (
length
), \

439 (((
h
)->
next_free
 + (h)->
temp
.
tempint
 + 1 > (h)->
chunk_limit
) \

440 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
 + 1), 0) : 0), \

441 
	`memcpy
 ((
h
)->
next_free
, 
where
, (h)->
temp
.
tempint
), \

442 (
h
)->
next_free
 += (h)->
temp
.
tempint
, \

443 *((
h
)->
next_free
)++ = 0)

	)

445 #define 
	#obstack_1grow
(
h
,
datum
) \

446 ( (((
h
)->
next_free
 + 1 > (h)->
chunk_limit
) \

447 ? (
	`_obstack_newchunk
 ((
h
), 1), 0) : 0), \

448 
	`obstack_1grow_fast
 (
h
, 
datum
))

	)

450 #define 
	#obstack_ptr_grow
(
h
,
datum
) \

451 ( (((
h
)->
next_free
 + sizeof (char *) > (h)->
chunk_limit
) \

452 ? (
	`_obstack_newchunk
 ((
h
), sizeof (char *)), 0) : 0), \

453 
	`obstack_ptr_grow_fast
 (
h
, 
datum
))

	)

455 #define 
	#obstack_int_grow
(
h
,
datum
) \

456 ( (((
h
)->
next_free
 + sizeof (int) > (h)->
chunk_limit
) \

457 ? (
	`_obstack_newchunk
 ((
h
), sizeof (int)), 0) : 0), \

458 
	`obstack_int_grow_fast
 (
h
, 
datum
))

	)

460 #define 
	#obstack_ptr_grow_fast
(
h
,
aptr
) \

461 (((const void **) ((
h
)->
next_free
 += sizeof (void *)))[-1] = (
aptr
))

	)

463 #define 
	#obstack_int_grow_fast
(
h
,
aint
) \

464 (((int *) ((
h
)->
next_free
 += sizeof (int)))[-1] = (
aint
))

	)

466 #define 
	#obstack_blank
(
h
,
length
) \

467 ( (
h
)->
temp
.
tempint
 = (
length
), \

468 (((
h
)->
chunk_limit
 - (h)->
next_free
 < (h)->
temp
.
tempint
) \

469 ? (
	`_obstack_newchunk
 ((
h
), (h)->
temp
.
tempint
), 0) : 0), \

470 
	`obstack_blank_fast
 (
h
, (h)->
temp
.
tempint
))

	)

472 #define 
	#obstack_alloc
(
h
,
length
) \

473 (
	`obstack_blank
 ((
h
), (
length
)), 
	`obstack_finish
 ((h)))

	)

475 #define 
	#obstack_copy
(
h
,
where
,
length
) \

476 (
	`obstack_grow
 ((
h
), (
where
), (
length
)), 
	`obstack_finish
 ((h)))

	)

478 #define 
	#obstack_copy0
(
h
,
where
,
length
) \

479 (
	`obstack_grow0
 ((
h
), (
where
), (
length
)), 
	`obstack_finish
 ((h)))

	)

481 #define 
	#obstack_finish
(
h
) \

482 ( ((
h
)->
next_free
 == (h)->
object_base
 \

483 ? (((
h
)->
maybe_empty_object
 = 1), 0) \

485 (
h
)->
temp
.
tempptr
 = (h)->
object_base
, \

486 (
h
)->
next_free
 \

487 = 
	`__PTR_ALIGN
 ((
h
)->
object_base
, (h)->
next_free
, \

488 (
h
)->
alignment_mask
), \

489 (((
h
)->
next_free
 - (char *) (h)->
chunk
 \

490 > (
h
)->
chunk_limit
 - (char *) (h)->
chunk
) \

491 ? ((
h
)->
next_free
 = (h)->
chunk_limit
) : 0), \

492 (
h
)->
object_base
 = (h)->
next_free
, \

493 (
h
)->
temp
.
tempptr
)

	)

495 #define 
	#obstack_free
(
h
,
obj
) \

496 ( (
h
)->
temp
.
tempint
 = (char *) (
obj
) - (char *) (h)->
chunk
, \

497 ((((
h
)->
temp
.
tempint
 > 0 \

498 && (
h
)->
temp
.
tempint
 < (h)->
chunk_limit
 - (char *) (h)->
chunk
)) \

499 ? (int) ((
h
)->
next_free
 = (h)->
object_base
 \

500 = (
h
)->
temp
.
tempint
 + (char *) (h)->
chunk
) \

501 : (((
obstack_free
) ((
h
), (h)->
temp
.
tempint
 + (char *) (h)->
chunk
), 0), 0)))

	)

505 #ifdef 
__cplusplus


	@/usr/include/pthread.h

20 #ifndef 
_PTHREAD_H


21 #define 
	#_PTHREAD_H
 1

	)

23 #include 
	~<features.h
>

24 #include 
	~<endian.h
>

25 #include 
	~<sched.h
>

26 #include 
	~<time.h
>

28 #include 
	~<bits/pthreadtypes.h
>

29 #include 
	~<bits/setjmp.h
>

30 #include 
	~<bits/wordsize.h
>

36 
	mPTHREAD_CREATE_JOINABLE
,

37 #define 
	#PTHREAD_CREATE_JOINABLE
 
PTHREAD_CREATE_JOINABLE


	)

38 
	mPTHREAD_CREATE_DETACHED


39 #define 
	#PTHREAD_CREATE_DETACHED
 
PTHREAD_CREATE_DETACHED


	)

46 
	mPTHREAD_MUTEX_TIMED_NP
,

47 
	mPTHREAD_MUTEX_RECURSIVE_NP
,

48 
	mPTHREAD_MUTEX_ERRORCHECK_NP
,

49 
	mPTHREAD_MUTEX_ADAPTIVE_NP


50 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


52 
	mPTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

53 
	mPTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

54 
	mPTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

55 
	mPTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


57 #ifdef 
__USE_GNU


59 , 
	mPTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


64 #ifdef 
__USE_XOPEN2K


68 
	mPTHREAD_MUTEX_STALLED
,

69 
	mPTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

70 
	mPTHREAD_MUTEX_ROBUST
,

71 
	mPTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


76 #ifdef 
__USE_UNIX98


80 
	mPTHREAD_PRIO_NONE
,

81 
	mPTHREAD_PRIO_INHERIT
,

82 
	mPTHREAD_PRIO_PROTECT


88 #if 
__WORDSIZE
 == 64

89 #define 
	#PTHREAD_MUTEX_INITIALIZER
 \

90 { { 0, 0, 0, 0, 0, 0, { 0, 0 } } }

	)

91 #ifdef 
__USE_GNU


92 #define 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

93 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 0, 0 } } }

	)

94 #define 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

95 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 0, 0 } } }

	)

96 #define 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

97 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 0, 0 } } }

	)

100 #define 
	#PTHREAD_MUTEX_INITIALIZER
 \

101 { { 0, 0, 0, 0, 0, { 0 } } }

	)

102 #ifdef 
__USE_GNU


103 #define 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

104 { { 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 0 } } }

	)

105 #define 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

106 { { 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 0 } } }

	)

107 #define 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

108 { { 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 0 } } }

	)

114 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


117 
	mPTHREAD_RWLOCK_PREFER_READER_NP
,

118 
	mPTHREAD_RWLOCK_PREFER_WRITER_NP
,

119 
	mPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

120 
	mPTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


124 #define 
	#PTHREAD_RWLOCK_INITIALIZER
 \

125 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }

	)

126 #ifdef 
__USE_GNU


127 #if 
__WORDSIZE
 == 64

128 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

130 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
 } }

	)

132 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


133 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

134 { { 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
, \

135 0, 0, 0, 0 } }

	)

137 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

138 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,\

139 0 } }

	)

149 
	mPTHREAD_INHERIT_SCHED
,

150 #define 
	#PTHREAD_INHERIT_SCHED
 
PTHREAD_INHERIT_SCHED


	)

151 
	mPTHREAD_EXPLICIT_SCHED


152 #define 
	#PTHREAD_EXPLICIT_SCHED
 
PTHREAD_EXPLICIT_SCHED


	)

159 
	mPTHREAD_SCOPE_SYSTEM
,

160 #define 
	#PTHREAD_SCOPE_SYSTEM
 
PTHREAD_SCOPE_SYSTEM


	)

161 
	mPTHREAD_SCOPE_PROCESS


162 #define 
	#PTHREAD_SCOPE_PROCESS
 
PTHREAD_SCOPE_PROCESS


	)

169 
	mPTHREAD_PROCESS_PRIVATE
,

170 #define 
	#PTHREAD_PROCESS_PRIVATE
 
PTHREAD_PROCESS_PRIVATE


	)

171 
	mPTHREAD_PROCESS_SHARED


172 #define 
	#PTHREAD_PROCESS_SHARED
 
PTHREAD_PROCESS_SHARED


	)

178 #define 
	#PTHREAD_COND_INITIALIZER
 { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }

	)

182 struct 
	s_pthread_cleanup_buffer


184 void (*
	m__routine
) (void *);

185 void *
	m__arg
;

186 int 
	m__canceltype
;

187 struct 
_pthread_cleanup_buffer
 *
	m__prev
;

193 
	mPTHREAD_CANCEL_ENABLE
,

194 #define 
	#PTHREAD_CANCEL_ENABLE
 
PTHREAD_CANCEL_ENABLE


	)

195 
	mPTHREAD_CANCEL_DISABLE


196 #define 
	#PTHREAD_CANCEL_DISABLE
 
PTHREAD_CANCEL_DISABLE


	)

200 
	mPTHREAD_CANCEL_DEFERRED
,

201 #define 
	#PTHREAD_CANCEL_DEFERRED
 
PTHREAD_CANCEL_DEFERRED


	)

202 
	mPTHREAD_CANCEL_ASYNCHRONOUS


203 #define 
	#PTHREAD_CANCEL_ASYNCHRONOUS
 
PTHREAD_CANCEL_ASYNCHRONOUS


	)

205 #define 
	#PTHREAD_CANCELED
 ((void *) -1)

	)

209 #define 
	#PTHREAD_ONCE_INIT
 0

	)

212 #ifdef 
__USE_XOPEN2K


216 #define 
	#PTHREAD_BARRIER_SERIAL_THREAD
 -1

	)

220 
__BEGIN_DECLS


225 extern int 
pthread_create
 (
pthread_t
 *
__restrict
 
__newthread
,

226 
__const
 
pthread_attr_t
 *
__restrict
 
__attr
,

227 void *(*
__start_routine
) (void *),

228 void *
__restrict
 
__arg
) 
__THROW
 
__nonnull
 ((1, 3));

234 extern void 
	$pthread_exit
 (void *
__retval
) 
	`__attribute__
 ((
__noreturn__
));

242 extern int 
	`pthread_join
 (
pthread_t
 
__th
, void **
__thread_return
);

244 #ifdef 
__USE_GNU


247 extern int 
	$pthread_tryjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
) 
__THROW
;

255 extern int 
	`pthread_timedjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
,

256 
__const
 struct 
timespec
 *
__abstime
);

263 extern int 
	$pthread_detach
 (
pthread_t
 
__th
) 
__THROW
;

267 extern 
pthread_t
 
	$pthread_self
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

270 extern int 
	$pthread_equal
 (
pthread_t
 
__thread1
, pthread_t 
__thread2
) 
__THROW
;

278 extern int 
	$pthread_attr_init
 (
pthread_attr_t
 *
__attr
) 
__THROW
 
	`__nonnull
 ((1));

281 extern int 
	$pthread_attr_destroy
 (
pthread_attr_t
 *
__attr
)

282 
__THROW
 
	`__nonnull
 ((1));

285 extern int 
	$pthread_attr_getdetachstate
 (
__const
 
pthread_attr_t
 *
__attr
,

286 int *
__detachstate
)

287 
__THROW
 
	`__nonnull
 ((1, 2));

290 extern int 
	$pthread_attr_setdetachstate
 (
pthread_attr_t
 *
__attr
,

291 int 
__detachstate
)

292 
__THROW
 
	`__nonnull
 ((1));

296 extern int 
	$pthread_attr_getguardsize
 (
__const
 
pthread_attr_t
 *
__attr
,

297 
size_t
 *
__guardsize
)

298 
__THROW
 
	`__nonnull
 ((1, 2));

301 extern int 
	$pthread_attr_setguardsize
 (
pthread_attr_t
 *
__attr
,

302 
size_t
 
__guardsize
)

303 
__THROW
 
	`__nonnull
 ((1));

307 extern int 
	$pthread_attr_getschedparam
 (
__const
 
pthread_attr_t
 *
__restrict


308 
__attr
,

309 struct 
sched_param
 *
__restrict
 
__param
)

310 
__THROW
 
	`__nonnull
 ((1, 2));

313 extern int 
	$pthread_attr_setschedparam
 (
pthread_attr_t
 *
__restrict
 
__attr
,

314 
__const
 struct 
sched_param
 *
__restrict


315 
__param
) 
__THROW
 
	`__nonnull
 ((1, 2));

318 extern int 
	$pthread_attr_getschedpolicy
 (
__const
 
pthread_attr_t
 *
__restrict


319 
__attr
, int *
__restrict
 
__policy
)

320 
__THROW
 
	`__nonnull
 ((1, 2));

323 extern int 
	$pthread_attr_setschedpolicy
 (
pthread_attr_t
 *
__attr
, int 
__policy
)

324 
__THROW
 
	`__nonnull
 ((1));

327 extern int 
	$pthread_attr_getinheritsched
 (
__const
 
pthread_attr_t
 *
__restrict


328 
__attr
, int *
__restrict
 
__inherit
)

329 
__THROW
 
	`__nonnull
 ((1, 2));

332 extern int 
	$pthread_attr_setinheritsched
 (
pthread_attr_t
 *
__attr
,

333 int 
__inherit
)

334 
__THROW
 
	`__nonnull
 ((1));

338 extern int 
	$pthread_attr_getscope
 (
__const
 
pthread_attr_t
 *
__restrict
 
__attr
,

339 int *
__restrict
 
__scope
)

340 
__THROW
 
	`__nonnull
 ((1, 2));

343 extern int 
	$pthread_attr_setscope
 (
pthread_attr_t
 *
__attr
, int 
__scope
)

344 
__THROW
 
	`__nonnull
 ((1));

347 extern int 
	$pthread_attr_getstackaddr
 (
__const
 
pthread_attr_t
 *
__restrict


348 
__attr
, void **
__restrict
 
__stackaddr
)

349 
__THROW
 
	`__nonnull
 ((1, 2)) 
__attribute_deprecated__
;

355 extern int 
	$pthread_attr_setstackaddr
 (
pthread_attr_t
 *
__attr
,

356 void *
__stackaddr
)

357 
__THROW
 
	`__nonnull
 ((1)) 
__attribute_deprecated__
;

360 extern int 
	$pthread_attr_getstacksize
 (
__const
 
pthread_attr_t
 *
__restrict


361 
__attr
, 
size_t
 *
__restrict
 
__stacksize
)

362 
__THROW
 
	`__nonnull
 ((1, 2));

367 extern int 
	$pthread_attr_setstacksize
 (
pthread_attr_t
 *
__attr
,

368 
size_t
 
__stacksize
)

369 
__THROW
 
	`__nonnull
 ((1));

371 #ifdef 
__USE_XOPEN2K


373 extern int 
	$pthread_attr_getstack
 (
__const
 
pthread_attr_t
 *
__restrict
 
__attr
,

374 void **
__restrict
 
__stackaddr
,

375 
size_t
 *
__restrict
 
__stacksize
)

376 
__THROW
 
	`__nonnull
 ((1, 2, 3));

381 extern int 
	$pthread_attr_setstack
 (
pthread_attr_t
 *
__attr
, void *
__stackaddr
,

382 
size_t
 
__stacksize
) 
__THROW
 
	`__nonnull
 ((1));

385 #ifdef 
__USE_GNU


388 extern int 
	$pthread_attr_setaffinity_np
 (
pthread_attr_t
 *
__attr
,

389 
size_t
 
__cpusetsize
,

390 
__const
 
cpu_set_t
 *
__cpuset
)

391 
__THROW
 
	`__nonnull
 ((1, 3));

395 extern int 
	$pthread_attr_getaffinity_np
 (
__const
 
pthread_attr_t
 *
__attr
,

396 
size_t
 
__cpusetsize
,

397 
cpu_set_t
 *
__cpuset
)

398 
__THROW
 
	`__nonnull
 ((1, 3));

404 extern int 
	$pthread_getattr_np
 (
pthread_t
 
__th
, 
pthread_attr_t
 *
__attr
)

405 
__THROW
 
	`__nonnull
 ((2));

413 extern int 
	$pthread_setschedparam
 (
pthread_t
 
__target_thread
, int 
__policy
,

414 
__const
 struct 
sched_param
 *
__param
)

415 
__THROW
 
	`__nonnull
 ((3));

418 extern int 
	$pthread_getschedparam
 (
pthread_t
 
__target_thread
,

419 int *
__restrict
 
__policy
,

420 struct 
sched_param
 *
__restrict
 
__param
)

421 
__THROW
 
	`__nonnull
 ((2, 3));

424 extern int 
	$pthread_setschedprio
 (
pthread_t
 
__target_thread
, int 
__prio
)

425 
__THROW
;

428 #ifdef 
__USE_GNU


430 extern int 
	$pthread_getname_np
 (
pthread_t
 
__target_thread
, char *
__buf
,

431 
size_t
 
__buflen
)

432 
__THROW
 
	`__nonnull
 ((2));

435 extern int 
	$pthread_setname_np
 (
pthread_t
 
__target_thread
, 
__const
 char *
__name
)

436 
__THROW
 
	`__nonnull
 ((2));

440 #ifdef 
__USE_UNIX98


442 extern int 
	$pthread_getconcurrency
 (void) 
__THROW
;

445 extern int 
	$pthread_setconcurrency
 (int 
__level
) 
__THROW
;

448 #ifdef 
__USE_GNU


453 extern int 
	$pthread_yield
 (void) 
__THROW
;

458 extern int 
	$pthread_setaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

459 
__const
 
cpu_set_t
 *
__cpuset
)

460 
__THROW
 
	`__nonnull
 ((3));

463 extern int 
	$pthread_getaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

464 
cpu_set_t
 *
__cpuset
)

465 
__THROW
 
	`__nonnull
 ((3));

478 extern int 
	`pthread_once
 (
pthread_once_t
 *
__once_control
,

479 void (*
__init_routine
) (void)) 
	`__nonnull
 ((1, 2));

490 extern int 
	`pthread_setcancelstate
 (int 
__state
, int *
__oldstate
);

494 extern int 
	`pthread_setcanceltype
 (int 
__type
, int *
__oldtype
);

497 extern int 
	`pthread_cancel
 (
pthread_t
 
__th
);

502 extern void 
	`pthread_testcancel
 (void);

511 
__jmp_buf
 
__cancel_jmp_buf
;

512 int 
__mask_was_saved
;

513 } 
__cancel_jmp_buf
[1];

514 void *
__pad
[4];

515 } 
	t__pthread_unwind_buf_t
 
	t__attribute__
 ((
	t__aligned__
));

518 #ifndef 
__cleanup_fct_attribute


519 #define 
	#__cleanup_fct_attribute


	)

524 struct 
	s__pthread_cleanup_frame


526 void (*
__cancel_routine
) (void *);

527 void *
__cancel_arg
;

528 int 
__do_it
;

529 int 
__cancel_type
;

532 #if 
defined
 
__GNUC__
 && defined 
__EXCEPTIONS


533 #ifdef 
__cplusplus


535 class 
	c__pthread_cleanup_class


537 void (*
__cancel_routine
) (void *);

538 void *
__cancel_arg
;

539 int 
__do_it
;

540 int 
__cancel_type
;

542 
public
:

543 
	`__pthread_cleanup_class
 (void (*
__fct
) (void *), void *
__arg
)

544 : 
	`__cancel_routine
 (
__fct
), 
	`__cancel_arg
 (
__arg
), 
	$__do_it
 (1) { }

545 ~
	$__pthread_cleanup_class
 () { if (
__do_it
) 
	`__cancel_routine
 (
__cancel_arg
); 
	}
}

546 void 
	$__setdoit
 (int 
__newval
) { 
__do_it
 = __newval; 
	}
}

547 void 
	$__defer
 () { 
	`pthread_setcanceltype
 (
PTHREAD_CANCEL_DEFERRED
,

548 &
__cancel_type
); 
	}
}

549 void 
	$__restore
 () const { 
	`pthread_setcanceltype
 (
__cancel_type
, 0); 
	}
}

559 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

561 
__pthread_cleanup_class
 
	`__clframe
 (
routine
, 
arg
)

	)

565 #define 
	#pthread_cleanup_pop
(
execute
) \

566 
__clframe
.
	`__setdoit
 (
execute
); \

567 } while (0)

	)

569 #ifdef 
__USE_GNU


573 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

575 
__pthread_cleanup_class
 
	`__clframe
 (
routine
, 
arg
); \

576 
__clframe
.
	`__defer
 ()

	)

581 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

582 
__clframe
.
	`__restore
 (); \

583 
__clframe
.
	`__setdoit
 (
execute
); \

584 } while (0)

	)

591 
__extern_inline
 void

592 
	$__pthread_cleanup_routine
 (struct 
__pthread_cleanup_frame
 *
__frame
)

594 if (
__frame
->
__do_it
)

595 
__frame
->
	`__cancel_routine
 (__frame->
__cancel_arg
);

596 
	}
}

605 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

607 struct 
__pthread_cleanup_frame
 
__clframe
 \

608 
	`__attribute__
 ((
	`__cleanup__
 (
__pthread_cleanup_routine
))) \

609 = { .
__cancel_routine
 = (
routine
), .
__cancel_arg
 = (
arg
), \

610 .
__do_it
 = 1 };

	)

614 #define 
	#pthread_cleanup_pop
(
execute
) \

615 
__clframe
.
__do_it
 = (
execute
); \

616 } while (0)

	)

618 #ifdef 
__USE_GNU


622 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

624 struct 
__pthread_cleanup_frame
 
__clframe
 \

625 
	`__attribute__
 ((
	`__cleanup__
 (
__pthread_cleanup_routine
))) \

626 = { .
__cancel_routine
 = (
routine
), .
__cancel_arg
 = (
arg
), \

627 .
__do_it
 = 1 }; \

628 (void) 
	`pthread_setcanceltype
 (
PTHREAD_CANCEL_DEFERRED
, \

629 &
__clframe
.
__cancel_type
)

	)

634 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

635 (void) 
	`pthread_setcanceltype
 (
__clframe
.
__cancel_type
, 
NULL
); \

636 
__clframe
.
__do_it
 = (
execute
); \

637 } while (0)

	)

648 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

650 
__pthread_unwind_buf_t
 
__cancel_buf
; \

651 void (*
__cancel_routine
) (void *) = (
routine
); \

652 void *
__cancel_arg
 = (
arg
); \

653 int 
__not_first_call
 = 
	`__sigsetjmp
 ((struct 
__jmp_buf_tag
 *) (void *) \

654 
__cancel_buf
.
__cancel_jmp_buf
, 0); \

655 if (
	`__builtin_expect
 (
__not_first_call
, 0)) \

657 
	`__cancel_routine
 (
__cancel_arg
); \

658 
	`__pthread_unwind_next
 (&
__cancel_buf
); \

662 
	`__pthread_register_cancel
 (&
__cancel_buf
); \

663 do {

	)

664 extern void 
__pthread_register_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

665 
__cleanup_fct_attribute
;

669 #define 
	#pthread_cleanup_pop
(
execute
) \

672 
	`__pthread_unregister_cancel
 (&
__cancel_buf
); \

673 if (
execute
) \

674 
	`__cancel_routine
 (
__cancel_arg
); \

675 } while (0)

	)

676 extern void 
	$__pthread_unregister_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

677 
__cleanup_fct_attribute
;

679 #ifdef 
__USE_GNU


683 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

685 
__pthread_unwind_buf_t
 
__cancel_buf
; \

686 void (*
__cancel_routine
) (void *) = (
routine
); \

687 void *
__cancel_arg
 = (
arg
); \

688 int 
__not_first_call
 = 
	`__sigsetjmp
 ((struct 
__jmp_buf_tag
 *) (void *) \

689 
__cancel_buf
.
__cancel_jmp_buf
, 0); \

690 if (
	`__builtin_expect
 (
__not_first_call
, 0)) \

692 
	`__cancel_routine
 (
__cancel_arg
); \

693 
	`__pthread_unwind_next
 (&
__cancel_buf
); \

697 
	`__pthread_register_cancel_defer
 (&
__cancel_buf
); \

698 do {

	)

699 extern void 
	`__pthread_register_cancel_defer
 (
__pthread_unwind_buf_t
 *
__buf
)

700 
__cleanup_fct_attribute
;

705 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

708 
	`__pthread_unregister_cancel_restore
 (&
__cancel_buf
); \

709 if (
execute
) \

710 
	`__cancel_routine
 (
__cancel_arg
); \

711 
	}
} while (0)

	)

712 extern void 
	$__pthread_unregister_cancel_restore
 (
__pthread_unwind_buf_t
 *
__buf
)

713 
__cleanup_fct_attribute
;

717 extern void 
	$__pthread_unwind_next
 (
__pthread_unwind_buf_t
 *
__buf
)

718 
__cleanup_fct_attribute
 
	`__attribute__
 ((
__noreturn__
))

719 #ifndef 
SHARED


720 
	`__attribute__
 ((
__weak__
))

726 struct 
__jmp_buf_tag
;

727 extern int 
	$__sigsetjmp
 (struct 
__jmp_buf_tag
 *
__env
, int 
__savemask
) 
__THROW
;

733 extern int 
	$pthread_mutex_init
 (
pthread_mutex_t
 *
__mutex
,

734 
__const
 
pthread_mutexattr_t
 *
__mutexattr
)

735 
__THROW
 
	`__nonnull
 ((1));

738 extern int 
	$pthread_mutex_destroy
 (
pthread_mutex_t
 *
__mutex
)

739 
__THROW
 
	`__nonnull
 ((1));

742 extern int 
	$pthread_mutex_trylock
 (
pthread_mutex_t
 *
__mutex
)

743 
__THROW
 
	`__nonnull
 ((1));

746 extern int 
	$pthread_mutex_lock
 (
pthread_mutex_t
 *
__mutex
)

747 
__THROW
 
	`__nonnull
 ((1));

749 #ifdef 
__USE_XOPEN2K


751 extern int 
	$pthread_mutex_timedlock
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

752 
__const
 struct 
timespec
 *
__restrict


753 
__abstime
) 
__THROW
 
	`__nonnull
 ((1, 2));

757 extern int 
	$pthread_mutex_unlock
 (
pthread_mutex_t
 *
__mutex
)

758 
__THROW
 
	`__nonnull
 ((1));

762 extern int 
	$pthread_mutex_getprioceiling
 (
__const
 
pthread_mutex_t
 *

763 
__restrict
 
__mutex
,

764 int *
__restrict
 
__prioceiling
)

765 
__THROW
 
	`__nonnull
 ((1, 2));

769 extern int 
	$pthread_mutex_setprioceiling
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

770 int 
__prioceiling
,

771 int *
__restrict
 
__old_ceiling
)

772 
__THROW
 
	`__nonnull
 ((1, 3));

775 #ifdef 
__USE_XOPEN2K8


777 extern int 
	$pthread_mutex_consistent
 (
pthread_mutex_t
 *
__mutex
)

778 
__THROW
 
	`__nonnull
 ((1));

779 #ifdef 
__USE_GNU


780 extern int 
	$pthread_mutex_consistent_np
 (
pthread_mutex_t
 *
__mutex
)

781 
__THROW
 
	`__nonnull
 ((1));

790 extern int 
	$pthread_mutexattr_init
 (
pthread_mutexattr_t
 *
__attr
)

791 
__THROW
 
	`__nonnull
 ((1));

794 extern int 
	$pthread_mutexattr_destroy
 (
pthread_mutexattr_t
 *
__attr
)

795 
__THROW
 
	`__nonnull
 ((1));

798 extern int 
	$pthread_mutexattr_getpshared
 (
__const
 
pthread_mutexattr_t
 *

799 
__restrict
 
__attr
,

800 int *
__restrict
 
__pshared
)

801 
__THROW
 
	`__nonnull
 ((1, 2));

804 extern int 
	$pthread_mutexattr_setpshared
 (
pthread_mutexattr_t
 *
__attr
,

805 int 
__pshared
)

806 
__THROW
 
	`__nonnull
 ((1));

808 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


810 extern int 
	$pthread_mutexattr_gettype
 (
__const
 
pthread_mutexattr_t
 *
__restrict


811 
__attr
, int *
__restrict
 
__kind
)

812 
__THROW
 
	`__nonnull
 ((1, 2));

817 extern int 
	$pthread_mutexattr_settype
 (
pthread_mutexattr_t
 *
__attr
, int 
__kind
)

818 
__THROW
 
	`__nonnull
 ((1));

822 extern int 
	$pthread_mutexattr_getprotocol
 (
__const
 
pthread_mutexattr_t
 *

823 
__restrict
 
__attr
,

824 int *
__restrict
 
__protocol
)

825 
__THROW
 
	`__nonnull
 ((1, 2));

829 extern int 
	$pthread_mutexattr_setprotocol
 (
pthread_mutexattr_t
 *
__attr
,

830 int 
__protocol
)

831 
__THROW
 
	`__nonnull
 ((1));

834 extern int 
	$pthread_mutexattr_getprioceiling
 (
__const
 
pthread_mutexattr_t
 *

835 
__restrict
 
__attr
,

836 int *
__restrict
 
__prioceiling
)

837 
__THROW
 
	`__nonnull
 ((1, 2));

840 extern int 
	$pthread_mutexattr_setprioceiling
 (
pthread_mutexattr_t
 *
__attr
,

841 int 
__prioceiling
)

842 
__THROW
 
	`__nonnull
 ((1));

844 #ifdef 
__USE_XOPEN2K


846 extern int 
	$pthread_mutexattr_getrobust
 (
__const
 
pthread_mutexattr_t
 *
__attr
,

847 int *
__robustness
)

848 
__THROW
 
	`__nonnull
 ((1, 2));

849 #ifdef 
__USE_GNU


850 extern int 
	$pthread_mutexattr_getrobust_np
 (
__const
 
pthread_mutexattr_t
 *
__attr
,

851 int *
__robustness
)

852 
__THROW
 
	`__nonnull
 ((1, 2));

856 extern int 
	$pthread_mutexattr_setrobust
 (
pthread_mutexattr_t
 *
__attr
,

857 int 
__robustness
)

858 
__THROW
 
	`__nonnull
 ((1));

859 #ifdef 
__USE_GNU


860 extern int 
	$pthread_mutexattr_setrobust_np
 (
pthread_mutexattr_t
 *
__attr
,

861 int 
__robustness
)

862 
__THROW
 
	`__nonnull
 ((1));

867 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


872 extern int 
	$pthread_rwlock_init
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

873 
__const
 
pthread_rwlockattr_t
 *
__restrict


874 
__attr
) 
__THROW
 
	`__nonnull
 ((1));

877 extern int 
	$pthread_rwlock_destroy
 (
pthread_rwlock_t
 *
__rwlock
)

878 
__THROW
 
	`__nonnull
 ((1));

881 extern int 
	$pthread_rwlock_rdlock
 (
pthread_rwlock_t
 *
__rwlock
)

882 
__THROW
 
	`__nonnull
 ((1));

885 extern int 
	$pthread_rwlock_tryrdlock
 (
pthread_rwlock_t
 *
__rwlock
)

886 
__THROW
 
	`__nonnull
 ((1));

888 #ifdef 
__USE_XOPEN2K


890 extern int 
	$pthread_rwlock_timedrdlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

891 
__const
 struct 
timespec
 *
__restrict


892 
__abstime
) 
__THROW
 
	`__nonnull
 ((1, 2));

896 extern int 
	$pthread_rwlock_wrlock
 (
pthread_rwlock_t
 *
__rwlock
)

897 
__THROW
 
	`__nonnull
 ((1));

900 extern int 
	$pthread_rwlock_trywrlock
 (
pthread_rwlock_t
 *
__rwlock
)

901 
__THROW
 
	`__nonnull
 ((1));

903 #ifdef 
__USE_XOPEN2K


905 extern int 
	$pthread_rwlock_timedwrlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

906 
__const
 struct 
timespec
 *
__restrict


907 
__abstime
) 
__THROW
 
	`__nonnull
 ((1, 2));

911 extern int 
	$pthread_rwlock_unlock
 (
pthread_rwlock_t
 *
__rwlock
)

912 
__THROW
 
	`__nonnull
 ((1));

918 extern int 
	$pthread_rwlockattr_init
 (
pthread_rwlockattr_t
 *
__attr
)

919 
__THROW
 
	`__nonnull
 ((1));

922 extern int 
	$pthread_rwlockattr_destroy
 (
pthread_rwlockattr_t
 *
__attr
)

923 
__THROW
 
	`__nonnull
 ((1));

926 extern int 
	$pthread_rwlockattr_getpshared
 (
__const
 
pthread_rwlockattr_t
 *

927 
__restrict
 
__attr
,

928 int *
__restrict
 
__pshared
)

929 
__THROW
 
	`__nonnull
 ((1, 2));

932 extern int 
	$pthread_rwlockattr_setpshared
 (
pthread_rwlockattr_t
 *
__attr
,

933 int 
__pshared
)

934 
__THROW
 
	`__nonnull
 ((1));

937 extern int 
	$pthread_rwlockattr_getkind_np
 (
__const
 
pthread_rwlockattr_t
 *

938 
__restrict
 
__attr
,

939 int *
__restrict
 
__pref
)

940 
__THROW
 
	`__nonnull
 ((1, 2));

943 extern int 
	$pthread_rwlockattr_setkind_np
 (
pthread_rwlockattr_t
 *
__attr
,

944 int 
__pref
) 
__THROW
 
	`__nonnull
 ((1));

952 extern int 
	$pthread_cond_init
 (
pthread_cond_t
 *
__restrict
 
__cond
,

953 
__const
 
pthread_condattr_t
 *
__restrict


954 
__cond_attr
) 
__THROW
 
	`__nonnull
 ((1));

957 extern int 
	$pthread_cond_destroy
 (
pthread_cond_t
 *
__cond
)

958 
__THROW
 
	`__nonnull
 ((1));

961 extern int 
	$pthread_cond_signal
 (
pthread_cond_t
 *
__cond
)

962 
__THROW
 
	`__nonnull
 ((1));

965 extern int 
	$pthread_cond_broadcast
 (
pthread_cond_t
 *
__cond
)

966 
__THROW
 
	`__nonnull
 ((1));

973 extern int 
	$pthread_cond_wait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

974 
pthread_mutex_t
 *
__restrict
 
__mutex
)

975 
	`__nonnull
 ((1, 2));

984 extern int 
	$pthread_cond_timedwait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

985 
pthread_mutex_t
 *
__restrict
 
__mutex
,

986 
__const
 struct 
timespec
 *
__restrict


987 
__abstime
) 
	`__nonnull
 ((1, 2, 3));

992 extern int 
	$pthread_condattr_init
 (
pthread_condattr_t
 *
__attr
)

993 
__THROW
 
	`__nonnull
 ((1));

996 extern int 
	$pthread_condattr_destroy
 (
pthread_condattr_t
 *
__attr
)

997 
__THROW
 
	`__nonnull
 ((1));

1000 extern int 
	$pthread_condattr_getpshared
 (
__const
 
pthread_condattr_t
 *

1001 
__restrict
 
__attr
,

1002 int *
__restrict
 
__pshared
)

1003 
__THROW
 
	`__nonnull
 ((1, 2));

1006 extern int 
	$pthread_condattr_setpshared
 (
pthread_condattr_t
 *
__attr
,

1007 int 
__pshared
) 
__THROW
 
	`__nonnull
 ((1));

1009 #ifdef 
__USE_XOPEN2K


1011 extern int 
	$pthread_condattr_getclock
 (
__const
 
pthread_condattr_t
 *

1012 
__restrict
 
__attr
,

1013 
__clockid_t
 *
__restrict
 
__clock_id
)

1014 
__THROW
 
	`__nonnull
 ((1, 2));

1017 extern int 
	$pthread_condattr_setclock
 (
pthread_condattr_t
 *
__attr
,

1018 
__clockid_t
 
__clock_id
)

1019 
__THROW
 
	`__nonnull
 ((1));

1023 #ifdef 
__USE_XOPEN2K


1028 extern int 
	$pthread_spin_init
 (
pthread_spinlock_t
 *
__lock
, int 
__pshared
)

1029 
__THROW
 
	`__nonnull
 ((1));

1032 extern int 
	$pthread_spin_destroy
 (
pthread_spinlock_t
 *
__lock
)

1033 
__THROW
 
	`__nonnull
 ((1));

1036 extern int 
	$pthread_spin_lock
 (
pthread_spinlock_t
 *
__lock
)

1037 
__THROW
 
	`__nonnull
 ((1));

1040 extern int 
	$pthread_spin_trylock
 (
pthread_spinlock_t
 *
__lock
)

1041 
__THROW
 
	`__nonnull
 ((1));

1044 extern int 
	$pthread_spin_unlock
 (
pthread_spinlock_t
 *
__lock
)

1045 
__THROW
 
	`__nonnull
 ((1));

1052 extern int 
	$pthread_barrier_init
 (
pthread_barrier_t
 *
__restrict
 
__barrier
,

1053 
__const
 
pthread_barrierattr_t
 *
__restrict


1054 
__attr
, unsigned int 
__count
)

1055 
__THROW
 
	`__nonnull
 ((1));

1058 extern int 
	$pthread_barrier_destroy
 (
pthread_barrier_t
 *
__barrier
)

1059 
__THROW
 
	`__nonnull
 ((1));

1062 extern int 
	$pthread_barrier_wait
 (
pthread_barrier_t
 *
__barrier
)

1063 
__THROW
 
	`__nonnull
 ((1));

1067 extern int 
	$pthread_barrierattr_init
 (
pthread_barrierattr_t
 *
__attr
)

1068 
__THROW
 
	`__nonnull
 ((1));

1071 extern int 
	$pthread_barrierattr_destroy
 (
pthread_barrierattr_t
 *
__attr
)

1072 
__THROW
 
	`__nonnull
 ((1));

1075 extern int 
	$pthread_barrierattr_getpshared
 (
__const
 
pthread_barrierattr_t
 *

1076 
__restrict
 
__attr
,

1077 int *
__restrict
 
__pshared
)

1078 
__THROW
 
	`__nonnull
 ((1, 2));

1081 extern int 
	$pthread_barrierattr_setpshared
 (
pthread_barrierattr_t
 *
__attr
,

1082 int 
__pshared
)

1083 
__THROW
 
	`__nonnull
 ((1));

1095 extern int 
	`pthread_key_create
 (
pthread_key_t
 *
__key
,

1096 void (*
__destr_function
) (void *))

1097 
__THROW
 
	`__nonnull
 ((1));

1100 extern int 
	$pthread_key_delete
 (
pthread_key_t
 
__key
) 
__THROW
;

1103 extern void *
	$pthread_getspecific
 (
pthread_key_t
 
__key
) 
__THROW
;

1106 extern int 
	$pthread_setspecific
 (
pthread_key_t
 
__key
,

1107 
__const
 void *
__pointer
) 
__THROW
 ;

1110 #ifdef 
__USE_XOPEN2K


1112 extern int 
	$pthread_getcpuclockid
 (
pthread_t
 
__thread_id
,

1113 
__clockid_t
 *
__clock_id
)

1114 
__THROW
 
	`__nonnull
 ((2));

1129 extern int 
	`pthread_atfork
 (void (*
__prepare
) (void),

1130 void (*
__parent
) (void),

1131 void (*
__child
) (void)) 
__THROW
;

1134 #ifdef 
__USE_EXTERN_INLINES


1136 
__extern_inline
 int

1137 
	`__NTH
 (
	$pthread_equal
 (
pthread_t
 
__thread1
, pthread_t 
__thread2
))

1139 return 
__thread1
 == 
__thread2
;

1140 
	}
}

1143 
	g__END_DECLS


	@/usr/include/regex.h

22 #ifndef 
_REGEX_H


23 #define 
	#_REGEX_H
 1

	)

25 #include 
	~<sys/types.h
>

26 #include 
	~<gnu/option-groups.h
>

29 #ifdef 
__cplusplus


37 typedef long int 
	ts_reg_t
;

38 typedef unsigned long int 
	tactive_reg_t
;

45 typedef unsigned long int 
	treg_syntax_t
;

47 #ifdef 
__USE_GNU


50 #define 
	#RE_BACKSLASH_ESCAPE_IN_LISTS
 ((unsigned long int) 1)

	)

55 #define 
	#RE_BK_PLUS_QM
 (
RE_BACKSLASH_ESCAPE_IN_LISTS
 << 1)

	)

61 #define 
	#RE_CHAR_CLASSES
 (
RE_BK_PLUS_QM
 << 1)

	)

75 #define 
	#RE_CONTEXT_INDEP_ANCHORS
 (
RE_CHAR_CLASSES
 << 1)

	)

83 #define 
	#RE_CONTEXT_INDEP_OPS
 (
RE_CONTEXT_INDEP_ANCHORS
 << 1)

	)

87 #define 
	#RE_CONTEXT_INVALID_OPS
 (
RE_CONTEXT_INDEP_OPS
 << 1)

	)

91 #define 
	#RE_DOT_NEWLINE
 (
RE_CONTEXT_INVALID_OPS
 << 1)

	)

95 #define 
	#RE_DOT_NOT_NULL
 (
RE_DOT_NEWLINE
 << 1)

	)

99 #define 
	#RE_HAT_LISTS_NOT_NEWLINE
 (
RE_DOT_NOT_NULL
 << 1)

	)

104 #define 
	#RE_INTERVALS
 (
RE_HAT_LISTS_NOT_NEWLINE
 << 1)

	)

108 #define 
	#RE_LIMITED_OPS
 (
RE_INTERVALS
 << 1)

	)

112 #define 
	#RE_NEWLINE_ALT
 (
RE_LIMITED_OPS
 << 1)

	)

117 #define 
	#RE_NO_BK_BRACES
 (
RE_NEWLINE_ALT
 << 1)

	)

121 #define 
	#RE_NO_BK_PARENS
 (
RE_NO_BK_BRACES
 << 1)

	)

125 #define 
	#RE_NO_BK_REFS
 (
RE_NO_BK_PARENS
 << 1)

	)

129 #define 
	#RE_NO_BK_VBAR
 (
RE_NO_BK_REFS
 << 1)

	)

135 #define 
	#RE_NO_EMPTY_RANGES
 (
RE_NO_BK_VBAR
 << 1)

	)

139 #define 
	#RE_UNMATCHED_RIGHT_PAREN_ORD
 (
RE_NO_EMPTY_RANGES
 << 1)

	)

143 #define 
	#RE_NO_POSIX_BACKTRACKING
 (
RE_UNMATCHED_RIGHT_PAREN_ORD
 << 1)

	)

147 #define 
	#RE_NO_GNU_OPS
 (
RE_NO_POSIX_BACKTRACKING
 << 1)

	)

155 #define 
	#RE_DEBUG
 (
RE_NO_GNU_OPS
 << 1)

	)

160 #define 
	#RE_INVALID_INTERVAL_ORD
 (
RE_DEBUG
 << 1)

	)

163 #ifdef 
__OPTION_POSIX_REGEXP_GLIBC


166 #define 
	#RE_ICASE
 (
RE_INVALID_INTERVAL_ORD
 << 1)

	)

171 #define 
	#RE_CARET_ANCHORS_HERE
 (
RE_ICASE
 << 1)

	)

175 #define 
	#RE_CONTEXT_INVALID_DUP
 (
RE_CARET_ANCHORS_HERE
 << 1)

	)

179 #define 
	#RE_NO_SUB
 (
RE_CONTEXT_INVALID_DUP
 << 1)

	)

187 extern 
reg_syntax_t
 
re_syntax_options
;

189 #ifdef 
__USE_GNU


194 #define 
	#RE_SYNTAX_EMACS
 0

	)

196 #define 
	#RE_SYNTAX_AWK
 \

197 (
RE_BACKSLASH_ESCAPE_IN_LISTS
 | 
RE_DOT_NOT_NULL
 \

198 | 
RE_NO_BK_PARENS
 | 
RE_NO_BK_REFS
 \

199 | 
RE_NO_BK_VBAR
 | 
RE_NO_EMPTY_RANGES
 \

200 | 
RE_DOT_NEWLINE
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

201 | 
RE_UNMATCHED_RIGHT_PAREN_ORD
 | 
RE_NO_GNU_OPS
)

	)

203 #define 
	#RE_SYNTAX_GNU_AWK
 \

204 ((
RE_SYNTAX_POSIX_EXTENDED
 | 
RE_BACKSLASH_ESCAPE_IN_LISTS
 | 
RE_DEBUG
) \

205 & ~(
RE_DOT_NOT_NULL
 | 
RE_INTERVALS
 | 
RE_CONTEXT_INDEP_OPS
 \

206 | 
RE_CONTEXT_INVALID_OPS
 ))

	)

208 #define 
	#RE_SYNTAX_POSIX_AWK
 \

209 (
RE_SYNTAX_POSIX_EXTENDED
 | 
RE_BACKSLASH_ESCAPE_IN_LISTS
 \

210 | 
RE_INTERVALS
 | 
RE_NO_GNU_OPS
)

	)

212 #define 
	#RE_SYNTAX_GREP
 \

213 (
RE_BK_PLUS_QM
 | 
RE_CHAR_CLASSES
 \

214 | 
RE_HAT_LISTS_NOT_NEWLINE
 | 
RE_INTERVALS
 \

215 | 
RE_NEWLINE_ALT
)

	)

217 #define 
	#RE_SYNTAX_EGREP
 \

218 (
RE_CHAR_CLASSES
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

219 | 
RE_CONTEXT_INDEP_OPS
 | 
RE_HAT_LISTS_NOT_NEWLINE
 \

220 | 
RE_NEWLINE_ALT
 | 
RE_NO_BK_PARENS
 \

221 | 
RE_NO_BK_VBAR
)

	)

223 #define 
	#RE_SYNTAX_POSIX_EGREP
 \

224 (
RE_SYNTAX_EGREP
 | 
RE_INTERVALS
 | 
RE_NO_BK_BRACES
 \

225 | 
RE_INVALID_INTERVAL_ORD
)

	)

228 #define 
	#RE_SYNTAX_ED
 
RE_SYNTAX_POSIX_BASIC


	)

230 #define 
	#RE_SYNTAX_SED
 
RE_SYNTAX_POSIX_BASIC


	)

233 #define 
	#_RE_SYNTAX_POSIX_COMMON
 \

234 (
RE_CHAR_CLASSES
 | 
RE_DOT_NEWLINE
 | 
RE_DOT_NOT_NULL
 \

235 | 
RE_INTERVALS
 | 
RE_NO_EMPTY_RANGES
)

	)

237 #ifdef 
__OPTION_POSIX_REGEXP_GLIBC


238 #define 
	#RE_SYNTAX_POSIX_BASIC
 \

239 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_BK_PLUS_QM
 | 
RE_CONTEXT_INVALID_DUP
)

	)

241 #define 
	#RE_SYNTAX_POSIX_BASIC
 \

242 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_BK_PLUS_QM
)

	)

248 #define 
	#RE_SYNTAX_POSIX_MINIMAL_BASIC
 \

249 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_LIMITED_OPS
)

	)

251 #define 
	#RE_SYNTAX_POSIX_EXTENDED
 \

252 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

253 | 
RE_CONTEXT_INDEP_OPS
 | 
RE_NO_BK_BRACES
 \

254 | 
RE_NO_BK_PARENS
 | 
RE_NO_BK_VBAR
 \

255 | 
RE_CONTEXT_INVALID_OPS
 | 
RE_UNMATCHED_RIGHT_PAREN_ORD
)

	)

259 #define 
	#RE_SYNTAX_POSIX_MINIMAL_EXTENDED
 \

260 (
_RE_SYNTAX_POSIX_COMMON
 | 
RE_CONTEXT_INDEP_ANCHORS
 \

261 | 
RE_CONTEXT_INVALID_OPS
 | 
RE_NO_BK_BRACES
 \

262 | 
RE_NO_BK_PARENS
 | 
RE_NO_BK_REFS
 \

263 | 
RE_NO_BK_VBAR
 | 
RE_UNMATCHED_RIGHT_PAREN_ORD
)

	)

269 #ifdef 
RE_DUP_MAX


270 #undef 
RE_DUP_MAX


273 #define 
	#RE_DUP_MAX
 (0x7fff)

	)

281 #define 
	#REG_EXTENDED
 1

	)

285 #define 
	#REG_ICASE
 (
REG_EXTENDED
 << 1)

	)

290 #define 
	#REG_NEWLINE
 (
REG_ICASE
 << 1)

	)

294 #define 
	#REG_NOSUB
 (
REG_NEWLINE
 << 1)

	)

304 #define 
	#REG_NOTBOL
 1

	)

307 #define 
	#REG_NOTEOL
 (1 << 1)

	)

309 #ifdef 
__OPTION_POSIX_REGEXP_GLIBC


312 #define 
	#REG_STARTEND
 (1 << 2)

	)

320 #if 
defined
 
_XOPEN_SOURCE
 || defined 
__USE_XOPEN2K


321 
	gREG_ENOSYS
 = -1,

324 
	gREG_NOERROR
 = 0,

325 
	gREG_NOMATCH
,

329 
	gREG_BADPAT
,

330 
	gREG_ECOLLATE
,

331 
	gREG_ECTYPE
,

332 
	gREG_EESCAPE
,

333 
	gREG_ESUBREG
,

334 
	gREG_EBRACK
,

335 
	gREG_EPAREN
,

336 
	gREG_EBRACE
,

337 
	gREG_BADBR
,

338 
	gREG_ERANGE
,

339 
	gREG_ESPACE
,

340 
	gREG_BADRPT
,

343 
	gREG_EEND
,

344 
	gREG_ESIZE
,

345 
	gREG_ERPAREN


346 } 
	treg_errcode_t
;

354 #ifndef 
RE_TRANSLATE_TYPE


355 #define 
	#__RE_TRANSLATE_TYPE
 unsigned char *

	)

356 #ifdef 
__USE_GNU


357 #define 
	#RE_TRANSLATE_TYPE
 
__RE_TRANSLATE_TYPE


	)

361 #ifdef 
__USE_GNU


362 #define 
	#__REPB_PREFIX
(
name
) 
	)
name

364 #define 
	#__REPB_PREFIX
(
name
) 
__
##
	)
name

367 struct 
	sre_pattern_buffer


372 unsigned char *
__REPB_PREFIX
(
buffer
);

375 unsigned long int 
__REPB_PREFIX
(
allocated
);

378 unsigned long int 
__REPB_PREFIX
(
used
);

381 
reg_syntax_t
 
__REPB_PREFIX
(
syntax
);

386 char *
__REPB_PREFIX
(
fastmap
);

392 
__RE_TRANSLATE_TYPE
 
__REPB_PREFIX
(
translate
);

395 
size_t
 
	gre_nsub
;

401 unsigned 
__REPB_PREFIX
(
can_be_null
) : 1;

407 #ifdef 
__USE_GNU


408 #define 
	#REGS_UNALLOCATED
 0

	)

409 #define 
	#REGS_REALLOCATE
 1

	)

410 #define 
	#REGS_FIXED
 2

	)

412 unsigned 
__REPB_PREFIX
(
regs_allocated
) : 2;

416 unsigned 
__REPB_PREFIX
(
fastmap_accurate
) : 1;

420 unsigned 
__REPB_PREFIX
(
no_sub
) : 1;

424 unsigned 
__REPB_PREFIX
(
not_bol
) : 1;

427 unsigned 
__REPB_PREFIX
(
not_eol
) : 1;

430 unsigned 
__REPB_PREFIX
(
newline_anchor
) : 1;

433 typedef struct 
re_pattern_buffer
 
	tregex_t
;

436 typedef int 
	tregoff_t
;

439 #ifdef 
__USE_GNU


442 struct 
	sre_registers


444 unsigned 
	gnum_regs
;

445 
regoff_t
 *
	gstart
;

446 
regoff_t
 *
	gend
;

453 #ifndef 
RE_NREGS


454 #define 
	#RE_NREGS
 30

	)

464 
regoff_t
 
	grm_so
;

465 
regoff_t
 
	grm_eo
;

466 } 
	tregmatch_t
;

470 #ifdef 
__USE_GNU


473 extern 
reg_syntax_t
 
re_set_syntax
 (reg_syntax_t 
__syntax
);

478 extern const char *
re_compile_pattern
 (const char *
__pattern
, 
size_t
 
__length
,

479 struct 
re_pattern_buffer
 *
__buffer
);

485 extern int 
re_compile_fastmap
 (struct 
re_pattern_buffer
 *
__buffer
);

493 extern int 
re_search
 (struct 
re_pattern_buffer
 *
__buffer
, const char *
__string
,

494 int 
__length
, int 
__start
, int 
__range
,

495 struct 
re_registers
 *
__regs
);

500 extern int 
re_search_2
 (struct 
re_pattern_buffer
 *
__buffer
,

501 const char *
__string1
, int 
__length1
,

502 const char *
__string2
, int 
__length2
, int 
__start
,

503 int 
__range
, struct 
re_registers
 *
__regs
, int 
__stop
);

508 extern int 
re_match
 (struct 
re_pattern_buffer
 *
__buffer
, const char *
__string
,

509 int 
__length
, int 
__start
, struct 
re_registers
 *
__regs
);

513 extern int 
re_match_2
 (struct 
re_pattern_buffer
 *
__buffer
,

514 const char *
__string1
, int 
__length1
,

515 const char *
__string2
, int 
__length2
, int 
__start
,

516 struct 
re_registers
 *
__regs
, int 
__stop
);

531 extern void 
re_set_registers
 (struct 
re_pattern_buffer
 *
__buffer
,

532 struct 
re_registers
 *
__regs
,

533 unsigned int 
__num_regs
,

534 
regoff_t
 *
__starts
, regoff_t *
__ends
);

537 #if 
defined
 
_REGEX_RE_COMP
 || (defined 
_LIBC
 && defined 
__USE_BSD
)

538 #ifndef 
_CRAY


540 extern char *
re_comp
 (const char *);

541 extern int 
re_exec
 (const char *);

547 #ifndef 
__restrict


548 #if ! (2 < 
__GNUC__
 || (2 == __GNUC__ && 95 <= 
__GNUC_MINOR__
))

549 #if 
defined
 
restrict
 || 199901L <= 
__STDC_VERSION__


550 #define 
	#__restrict
 
restrict


	)

552 #define 
	#__restrict


	)

557 #ifndef 
__restrict_arr


558 #if (
__GNUC__
 > 3 || (__GNUC__ == 3 && 
__GNUC_MINOR__
 >= 1)) \

559 && !
defined
 
	g__GNUG__


560 #define 
	#__restrict_arr
 
__restrict


	)

562 #define 
	#__restrict_arr


	)

567 extern int 
regcomp
 (
regex_t
 *
__restrict
 
__preg
,

568 const char *
__restrict
 
__pattern
,

569 int 
__cflags
);

571 extern int 
regexec
 (const 
regex_t
 *
__restrict
 
__preg
,

572 const char *
__restrict
 
__string
, 
size_t
 
__nmatch
,

573 
regmatch_t
 
__pmatch
[
__restrict_arr
],

574 int 
__eflags
);

576 extern 
size_t
 
regerror
 (int 
__errcode
, const 
regex_t
 *
__restrict
 
__preg
,

577 char *
__restrict
 
__errbuf
, 
size_t
 
__errbuf_size
);

579 extern void 
regfree
 (
regex_t
 *
__preg
);

582 #ifdef 
__cplusplus


	@/usr/include/sched.h

21 #ifndef 
_SCHED_H


22 #define 
	#_SCHED_H
 1

	)

24 #include 
	~<features.h
>

27 #include 
	~<bits/types.h
>

29 #define 
	#__need_size_t


	)

30 #include 
	~<stddef.h
>

32 #define 
	#__need_time_t


	)

33 #define 
	#__need_timespec


	)

34 #include 
	~<time.h
>

36 #ifndef 
__pid_t_defined


37 typedef 
__pid_t
 
	tpid_t
;

38 #define 
	#__pid_t_defined


	)

43 #include 
	~<bits/sched.h
>

45 #define 
	#sched_priority
 
__sched_priority


	)

48 
__BEGIN_DECLS


51 extern int 
	$sched_setparam
 (
__pid_t
 
__pid
, 
__const
 struct 
sched_param
 *
__param
)

52 
__THROW
;

55 extern int 
	$sched_getparam
 (
__pid_t
 
__pid
, struct 
sched_param
 *
__param
) 
__THROW
;

58 extern int 
	$sched_setscheduler
 (
__pid_t
 
__pid
, int 
__policy
,

59 
__const
 struct 
sched_param
 *
__param
) 
__THROW
;

62 extern int 
	$sched_getscheduler
 (
__pid_t
 
__pid
) 
__THROW
;

65 extern int 
	$sched_yield
 (void) 
__THROW
;

68 extern int 
	$sched_get_priority_max
 (int 
__algorithm
) 
__THROW
;

71 extern int 
	$sched_get_priority_min
 (int 
__algorithm
) 
__THROW
;

74 extern int 
	$sched_rr_get_interval
 (
__pid_t
 
__pid
, struct 
timespec
 *
__t
) 
__THROW
;

77 #ifdef 
__USE_GNU


79 #define 
	#CPU_SETSIZE
 
__CPU_SETSIZE


	)

80 #define 
	#CPU_SET
(
cpu
, 
cpusetp
) 
	`__CPU_SET_S
 (cpu, sizeof (
cpu_set_t
), cpusetp)

	)

81 #define 
	#CPU_CLR
(
cpu
, 
cpusetp
) 
	`__CPU_CLR_S
 (cpu, sizeof (
cpu_set_t
), cpusetp)

	)

82 #define 
	#CPU_ISSET
(
cpu
, 
cpusetp
) 
	`__CPU_ISSET_S
 (cpu, sizeof (
cpu_set_t
), \

83 
cpusetp
)

	)

84 #define 
	#CPU_ZERO
(
cpusetp
) 
	`__CPU_ZERO_S
 (sizeof (
cpu_set_t
), cpusetp)

	)

85 #define 
	#CPU_COUNT
(
cpusetp
) 
	`__CPU_COUNT_S
 (sizeof (
cpu_set_t
), cpusetp)

	)

87 #define 
	#CPU_SET_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_SET_S
 (cpu, setsize, cpusetp)

	)

88 #define 
	#CPU_CLR_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_CLR_S
 (cpu, setsize, cpusetp)

	)

89 #define 
	#CPU_ISSET_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_ISSET_S
 (cpu, setsize, \

90 
cpusetp
)

	)

91 #define 
	#CPU_ZERO_S
(
setsize
, 
cpusetp
) 
	`__CPU_ZERO_S
 (setsize, cpusetp)

	)

92 #define 
	#CPU_COUNT_S
(
setsize
, 
cpusetp
) 
	`__CPU_COUNT_S
 (setsize, cpusetp)

	)

94 #define 
	#CPU_EQUAL
(
cpusetp1
, 
cpusetp2
) \

95 
	`__CPU_EQUAL_S
 (sizeof (
cpu_set_t
), 
cpusetp1
, 
cpusetp2
)

	)

96 #define 
	#CPU_EQUAL_S
(
setsize
, 
cpusetp1
, 
cpusetp2
) \

97 
	`__CPU_EQUAL_S
 (
setsize
, 
cpusetp1
, 
cpusetp2
)

	)

99 #define 
	#CPU_AND
(
destset
, 
srcset1
, 
srcset2
) \

100 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, &)

	)

101 #define 
	#CPU_OR
(
destset
, 
srcset1
, 
srcset2
) \

102 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, |)

	)

103 #define 
	#CPU_XOR
(
destset
, 
srcset1
, 
srcset2
) \

104 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, ^)

	)

105 #define 
	#CPU_AND_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

106 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, &)

	)

107 #define 
	#CPU_OR_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

108 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, |)

	)

109 #define 
	#CPU_XOR_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

110 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, ^)

	)

112 #define 
	#CPU_ALLOC_SIZE
(
count
) 
	`__CPU_ALLOC_SIZE
 (count)

	)

113 #define 
	#CPU_ALLOC
(
count
) 
	`__CPU_ALLOC
 (count)

	)

114 #define 
	#CPU_FREE
(
cpuset
) 
	`__CPU_FREE
 (cpuset)

	)

118 extern int 
	$sched_setaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

119 
__const
 
cpu_set_t
 *
__cpuset
) 
__THROW
;

122 extern int 
	$sched_getaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

123 
cpu_set_t
 *
__cpuset
) 
__THROW
;

126 
__END_DECLS


	@/usr/include/search.h

20 #ifndef 
_SEARCH_H


21 #define 
	#_SEARCH_H
 1

	)

23 #include 
	~<features.h
>

25 #define 
	#__need_size_t


	)

26 #include 
	~<stddef.h
>

28 
	g__BEGIN_DECLS


30 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED


34 #ifdef 
__USE_GNU


35 struct 
	sqelem


37 struct 
qelem
 *
	mq_forw
;

38 struct 
qelem
 *
	mq_back
;

39 char 
	mq_data
[1];

45 extern void 
	$insque
 (void *
__elem
, void *
__prev
) 
__THROW
;

48 extern void 
	$remque
 (void *
__elem
) 
__THROW
;

53 #ifndef 
__COMPAR_FN_T


54 #define 
	#__COMPAR_FN_T


	)

55 typedef int (*
	t__compar_fn_t
) (
	t__const
 void *, __const void *);

57 #ifdef 
__USE_GNU


58 typedef 
__compar_fn_t
 
	tcomparison_fn_t
;

65 
FIND
,

66 
ENTER


68 
	tACTION
;

70 typedef struct 
	sentry


72 char *
key
;

73 void *
data
;

75 
	tENTRY
;

78 struct 
_ENTRY
;

88 extern 
ENTRY
 *
	$hsearch
 (
ENTRY
 
__item
, 
ACTION
 
__action
) 
__THROW
;

91 extern int 
	$hcreate
 (
size_t
 
__nel
) 
__THROW
;

94 extern void 
	$hdestroy
 (void) 
__THROW
;

96 #ifdef 
__USE_GNU


98 struct 
	shsearch_data


100 struct 
_ENTRY
 *
table
;

101 unsigned int 
size
;

102 unsigned int 
filled
;

107 extern int 
	$hsearch_r
 (
ENTRY
 
__item
, 
ACTION
 
__action
, ENTRY **
__retval
,

108 struct 
hsearch_data
 *
__htab
) 
__THROW
;

109 extern int 
	$hcreate_r
 (
size_t
 
__nel
, struct 
hsearch_data
 *
__htab
) 
__THROW
;

110 extern void 
	$hdestroy_r
 (struct 
hsearch_data
 *
__htab
) 
__THROW
;

121 
preorder
,

122 
postorder
,

123 
endorder
,

124 
leaf


126 
	tVISIT
;

130 extern void *
	`tsearch
 (
__const
 void *
__key
, void **
__rootp
,

131 
__compar_fn_t
 
__compar
);

135 extern void *
	`tfind
 (
__const
 void *
__key
, void *__const *
__rootp
,

136 
__compar_fn_t
 
__compar
);

139 extern void *
	`tdelete
 (
__const
 void *
__restrict
 
__key
,

140 void **
__restrict
 
__rootp
,

141 
__compar_fn_t
 
__compar
);

143 #ifndef 
__ACTION_FN_T


144 #define 
	#__ACTION_FN_T


	)

145 typedef void (*
	t__action_fn_t
) (
	t__const
 void *
	t__nodep
, 
	tVISIT
 
	t__value
,

146 int 
	t__level
);

151 extern void 
	`twalk
 (
__const
 void *
__root
, 
__action_fn_t
 
__action
);

153 #ifdef 
__USE_GNU


156 typedef void (*
	t__free_fn_t
) (void *
	t__nodep
);

159 extern void 
	`tdestroy
 (void *
__root
, 
__free_fn_t
 
__freefct
);

165 extern void *
	`lfind
 (
__const
 void *
__key
, __const void *
__base
,

166 
size_t
 *
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
);

170 extern void *
	`lsearch
 (
__const
 void *
__key
, void *
__base
,

171 
size_t
 *
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
);

173 
__END_DECLS


	@/usr/include/setjmp.h

23 #ifndef 
_SETJMP_H


24 #define 
	#_SETJMP_H
 1

	)

26 #include 
	~<features.h
>

28 
	g__BEGIN_DECLS


30 #include 
	~<bits/setjmp.h
>

31 #include 
	~<bits/sigset.h
>

35 struct 
	s__jmp_buf_tag


41 
__jmp_buf
 
	m__jmpbuf
;

42 int 
	m__mask_was_saved
;

43 
__sigset_t
 
	m__saved_mask
;

47 
__BEGIN_NAMESPACE_STD


49 typedef struct 
__jmp_buf_tag
 
	tjmp_buf
[1];

53 extern int 
	$setjmp
 (
jmp_buf
 
__env
) 
__THROW
;

55 
__END_NAMESPACE_STD


60 extern int 
	$__sigsetjmp
 (struct 
__jmp_buf_tag
 
__env
[1], int 
__savemask
) 
__THROW
;

62 #ifndef 
__FAVOR_BSD


65 extern int 
	$_setjmp
 (struct 
__jmp_buf_tag
 
__env
[1]) 
__THROW
;

69 #define 
	#setjmp
(
env
) 
	`_setjmp
 (env)

	)

74 #define 
	#setjmp
(
env
) 
	`setjmp
 (env)

	)

78 
__BEGIN_NAMESPACE_STD


82 extern void 
	$longjmp
 (struct 
__jmp_buf_tag
 
__env
[1], int 
__val
)

83 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

85 
__END_NAMESPACE_STD


87 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN


91 extern void 
	$_longjmp
 (struct 
__jmp_buf_tag
 
__env
[1], int 
__val
)

92 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

96 #ifdef 
__USE_POSIX


100 typedef struct 
__jmp_buf_tag
 
	tsigjmp_buf
[1];

104 #define 
	#sigsetjmp
(
env
, 
savemask
) 
	`__sigsetjmp
 (env, savemask)

	)

110 extern void 
	$siglongjmp
 (
sigjmp_buf
 
__env
, int 
__val
)

111 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

116 #if 
__USE_FORTIFY_LEVEL
 > 0

117 #include 
	~<bits/setjmp2.h
>

120 
__END_DECLS


	@/usr/include/signal.h

23 #ifndef 
_SIGNAL_H


25 #if !
defined
 
__need_sig_atomic_t
 && !defined 
__need_sigset_t


26 #define 
	#_SIGNAL_H


	)

29 #include 
	~<features.h
>

31 
	g__BEGIN_DECLS


33 #include 
	~<bits/sigset.h
>

37 #if 
defined
 
__need_sig_atomic_t
 || defined 
_SIGNAL_H


38 #ifndef 
__sig_atomic_t_defined


39 #define 
	#__sig_atomic_t_defined


	)

40 
__BEGIN_NAMESPACE_STD


41 typedef 
__sig_atomic_t
 
	tsig_atomic_t
;

42 
	g__END_NAMESPACE_STD


44 #undef 
__need_sig_atomic_t


47 #if 
defined
 
__need_sigset_t
 || (defined 
_SIGNAL_H
 && defined 
__USE_POSIX
)

48 #ifndef 
__sigset_t_defined


49 #define 
	#__sigset_t_defined


	)

50 typedef 
__sigset_t
 
	tsigset_t
;

52 #undef 
__need_sigset_t


55 #ifdef 
_SIGNAL_H


57 #include 
	~<bits/types.h
>

58 #include 
	~<bits/signum.h
>

60 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K


61 #ifndef 
__pid_t_defined


62 typedef 
__pid_t
 
	tpid_t
;

63 #define 
	#__pid_t_defined


	)

65 #ifdef 
__USE_XOPEN


67 #ifndef 
__uid_t_defined


68 typedef 
__uid_t
 
	tuid_t
;

69 #define 
	#__uid_t_defined


	)

73 #ifdef 
__USE_POSIX199309


75 #define 
	#__need_timespec


	)

76 #include 
	~<time.h
>

79 #include 
	~<bits/siginfo.h
>

84 typedef void (*
	t__sighandler_t
) (int);

89 extern 
__sighandler_t
 
	$__sysv_signal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

90 
__THROW
;

91 #ifdef 
__USE_GNU


92 extern 
__sighandler_t
 
	$sysv_signal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

93 
__THROW
;

99 
__BEGIN_NAMESPACE_STD


100 #ifdef 
__USE_BSD


101 extern 
__sighandler_t
 
	$signal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

102 
__THROW
;

105 #ifdef 
__REDIRECT_NTH


106 extern 
__sighandler_t
 
	`__REDIRECT_NTH
 (
signal
,

107 (int 
__sig
, 
__sighandler_t
 
__handler
),

108 
__sysv_signal
);

110 #define 
	#signal
 
__sysv_signal


	)

113 
__END_NAMESPACE_STD


115 #ifdef 
__USE_XOPEN


118 extern 
__sighandler_t
 
	$bsd_signal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

119 
__THROW
;

125 #ifdef 
__USE_POSIX


126 extern int 
	$kill
 (
__pid_t
 
__pid
, int 
__sig
) 
__THROW
;

129 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


133 extern int 
	$killpg
 (
__pid_t
 
__pgrp
, int 
__sig
) 
__THROW
;

136 
__BEGIN_NAMESPACE_STD


138 extern int 
	$raise
 (int 
__sig
) 
__THROW
;

139 
__END_NAMESPACE_STD


141 #ifdef 
__USE_SVID


143 extern 
__sighandler_t
 
	$ssignal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

144 
__THROW
;

145 extern int 
	$gsignal
 (int 
__sig
) 
__THROW
;

148 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN2K


150 extern void 
	`psignal
 (int 
__sig
, 
__const
 char *
__s
);

153 #ifdef 
__USE_XOPEN2K


155 extern void 
	`psiginfo
 (
__const
 
siginfo_t
 *
__pinfo
, __const char *
__s
);

168 extern int 
	`__sigpause
 (int 
__sig_or_mask
, int 
__is_sig
);

170 #ifdef 
__FAVOR_BSD


173 extern int 
	$sigpause
 (int 
__mask
) 
__THROW
 
__attribute_deprecated__
;

175 #ifdef 
__USE_XOPEN


176 #ifdef 
__GNUC__


177 extern int 
	$sigpause
 (int 
__sig
) 
	`__asm__
 ("__xpg_sigpause");

180 #define 
	#sigpause
(
sig
) 
	`__sigpause
 ((sig), 1)

	)

186 #ifdef 
__USE_BSD


193 #define 
	#sigmask
(
sig
) 
	`__sigmask
(sig)

	)

196 extern int 
	$sigblock
 (int 
__mask
) 
__THROW
 
__attribute_deprecated__
;

199 extern int 
	$sigsetmask
 (int 
__mask
) 
__THROW
 
__attribute_deprecated__
;

202 extern int 
	$siggetmask
 (void) 
__THROW
 
__attribute_deprecated__
;

206 #ifdef 
__USE_MISC


207 #define 
	#NSIG
 
_NSIG


	)

210 #ifdef 
__USE_GNU


211 typedef 
__sighandler_t
 
	tsighandler_t
;

215 #ifdef 
__USE_BSD


216 typedef 
__sighandler_t
 
	tsig_t
;

219 #ifdef 
__USE_POSIX


222 extern int 
	$sigemptyset
 (
sigset_t
 *
__set
) 
__THROW
 
	`__nonnull
 ((1));

225 extern int 
	$sigfillset
 (
sigset_t
 *
__set
) 
__THROW
 
	`__nonnull
 ((1));

228 extern int 
	$sigaddset
 (
sigset_t
 *
__set
, int 
__signo
) 
__THROW
 
	`__nonnull
 ((1));

231 extern int 
	$sigdelset
 (
sigset_t
 *
__set
, int 
__signo
) 
__THROW
 
	`__nonnull
 ((1));

234 extern int 
	$sigismember
 (
__const
 
sigset_t
 *
__set
, int 
__signo
)

235 
__THROW
 
	`__nonnull
 ((1));

237 #ifdef 
__USE_GNU


239 extern int 
	$sigisemptyset
 (
__const
 
sigset_t
 *
__set
) 
__THROW
 
	`__nonnull
 ((1));

242 extern int 
	$sigandset
 (
sigset_t
 *
__set
, 
__const
 sigset_t *
__left
,

243 
__const
 
sigset_t
 *
__right
) 
__THROW
 
	`__nonnull
 ((1, 2, 3));

246 extern int 
	$sigorset
 (
sigset_t
 *
__set
, 
__const
 sigset_t *
__left
,

247 
__const
 
sigset_t
 *
__right
) 
__THROW
 
	`__nonnull
 ((1, 2, 3));

252 #include 
	~<bits/sigaction.h
>

255 extern int 
	$sigprocmask
 (int 
__how
, 
__const
 
sigset_t
 *
__restrict
 
__set
,

256 
sigset_t
 *
__restrict
 
__oset
) 
__THROW
;

263 extern int 
	$sigsuspend
 (
__const
 
sigset_t
 *
__set
) 
	`__nonnull
 ((1));

266 extern int 
	$sigaction
 (int 
__sig
, 
__const
 struct 
sigaction
 *
__restrict
 
__act
,

267 struct 
sigaction
 *
__restrict
 
__oact
) 
__THROW
;

270 extern int 
	$sigpending
 (
sigset_t
 *
__set
) 
__THROW
 
	`__nonnull
 ((1));

277 extern int 
	$sigwait
 (
__const
 
sigset_t
 *
__restrict
 
__set
, int *__restrict 
__sig
)

278 
	`__nonnull
 ((1, 2));

280 #ifdef 
__USE_POSIX199309


285 extern int 
	$sigwaitinfo
 (
__const
 
sigset_t
 *
__restrict
 
__set
,

286 
siginfo_t
 *
__restrict
 
__info
) 
	`__nonnull
 ((1));

293 extern int 
	$sigtimedwait
 (
__const
 
sigset_t
 *
__restrict
 
__set
,

294 
siginfo_t
 *
__restrict
 
__info
,

295 
__const
 struct 
timespec
 *
__restrict
 
__timeout
)

296 
	`__nonnull
 ((1));

300 extern int 
	$sigqueue
 (
__pid_t
 
__pid
, int 
__sig
, 
__const
 union 
sigval
 
__val
)

301 
__THROW
;

306 #ifdef 
__USE_BSD


310 extern 
__const
 char *__const 
_sys_siglist
[
_NSIG
];

311 extern 
__const
 char *__const 
sys_siglist
[
_NSIG
];

314 struct 
	ssigvec


316 
__sighandler_t
 
sv_handler
;

317 int 
sv_mask
;

319 int 
sv_flags
;

320 #define 
	#sv_onstack
 
sv_flags


	)

324 #define 
	#SV_ONSTACK
 (1 << 0)

	)

325 #define 
	#SV_INTERRUPT
 (1 << 1)

	)

326 #define 
	#SV_RESETHAND
 (1 << 2)

	)

334 extern int 
	$sigvec
 (int 
__sig
, 
__const
 struct 
sigvec
 *
__vec
,

335 struct 
sigvec
 *
__ovec
) 
__THROW
;

339 #include 
	~<bits/sigcontext.h
>

342 extern int 
	$sigreturn
 (struct 
sigcontext
 *
__scp
) 
__THROW
;

347 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


348 #define 
	#__need_size_t


	)

349 #include 
	~<stddef.h
>

354 extern int 
	$siginterrupt
 (int 
__sig
, int 
__interrupt
) 
__THROW
;

356 #include 
	~<bits/sigstack.h
>

357 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


359 #include 
	~<sys/ucontext.h
>

365 extern int 
	$sigstack
 (struct 
sigstack
 *
__ss
, struct sigstack *
__oss
)

366 
__THROW
 
__attribute_deprecated__
;

370 extern int 
	$sigaltstack
 (
__const
 struct 
sigaltstack
 *
__restrict
 
__ss
,

371 struct 
sigaltstack
 *
__restrict
 
__oss
) 
__THROW
;

375 #ifdef 
__USE_XOPEN_EXTENDED


379 extern int 
	$sighold
 (int 
__sig
) 
__THROW
;

382 extern int 
	$sigrelse
 (int 
__sig
) 
__THROW
;

385 extern int 
	$sigignore
 (int 
__sig
) 
__THROW
;

388 extern 
__sighandler_t
 
	$sigset
 (int 
__sig
, 
__sighandler_t
 
__disp
) 
__THROW
;

391 #if 
defined
 
__USE_POSIX199506
 || defined 
__USE_UNIX98


394 #include 
	~<bits/pthreadtypes.h
>

395 #include 
	~<bits/sigthread.h
>

402 extern int 
	$__libc_current_sigrtmin
 (void) 
__THROW
;

404 extern int 
	$__libc_current_sigrtmax
 (void) 
__THROW
;

408 
__END_DECLS


	@/usr/include/stdint.h

23 #ifndef 
_STDINT_H


24 #define 
	#_STDINT_H
 1

	)

26 #include 
	~<features.h
>

27 #include 
	~<bits/wchar.h
>

28 #include 
	~<bits/wordsize.h
>

35 #ifndef 
__int8_t_defined


36 #define 
	#__int8_t_defined


	)

37 typedef signed char 
	tint8_t
;

38 typedef short int 
	tint16_t
;

39 typedef int 
	tint32_t
;

40 #if 
__WORDSIZE
 == 64

41 typedef long int 
	tint64_t
;

43 
__extension__


44 typedef long long int 
	tint64_t
;

49 typedef unsigned char 
	tuint8_t
;

50 typedef unsigned short int 
	tuint16_t
;

51 #ifndef 
__uint32_t_defined


52 typedef unsigned int 
	tuint32_t
;

53 #define 
	#__uint32_t_defined


	)

55 #if 
__WORDSIZE
 == 64

56 typedef unsigned long int 
	tuint64_t
;

58 
__extension__


59 typedef unsigned long long int 
	tuint64_t
;

66 typedef signed char 
	tint_least8_t
;

67 typedef short int 
	tint_least16_t
;

68 typedef int 
	tint_least32_t
;

69 #if 
__WORDSIZE
 == 64

70 typedef long int 
	tint_least64_t
;

72 
__extension__


73 typedef long long int 
	tint_least64_t
;

77 typedef unsigned char 
	tuint_least8_t
;

78 typedef unsigned short int 
	tuint_least16_t
;

79 typedef unsigned int 
	tuint_least32_t
;

80 #if 
__WORDSIZE
 == 64

81 typedef unsigned long int 
	tuint_least64_t
;

83 
__extension__


84 typedef unsigned long long int 
	tuint_least64_t
;

91 typedef signed char 
	tint_fast8_t
;

92 #if 
__WORDSIZE
 == 64

93 typedef long int 
	tint_fast16_t
;

94 typedef long int 
	tint_fast32_t
;

95 typedef long int 
	tint_fast64_t
;

97 typedef int 
	tint_fast16_t
;

98 typedef int 
	tint_fast32_t
;

99 
__extension__


100 typedef long long int 
	tint_fast64_t
;

104 typedef unsigned char 
	tuint_fast8_t
;

105 #if 
__WORDSIZE
 == 64

106 typedef unsigned long int 
	tuint_fast16_t
;

107 typedef unsigned long int 
	tuint_fast32_t
;

108 typedef unsigned long int 
	tuint_fast64_t
;

110 typedef unsigned int 
	tuint_fast16_t
;

111 typedef unsigned int 
	tuint_fast32_t
;

112 
__extension__


113 typedef unsigned long long int 
	tuint_fast64_t
;

118 #if 
__WORDSIZE
 == 64

119 #ifndef 
__intptr_t_defined


120 typedef long int 
	tintptr_t
;

121 #define 
	#__intptr_t_defined


	)

123 typedef unsigned long int 
	tuintptr_t
;

125 #ifndef 
__intptr_t_defined


126 typedef int 
	tintptr_t
;

127 #define 
	#__intptr_t_defined


	)

129 typedef unsigned int 
	tuintptr_t
;

134 #if 
__WORDSIZE
 == 64

135 typedef long int 
	tintmax_t
;

136 typedef unsigned long int 
	tuintmax_t
;

138 
__extension__


139 typedef long long int 
	tintmax_t
;

140 
__extension__


141 typedef unsigned long long int 
	tuintmax_t
;

147 #if !
defined
 
__cplusplus
 || defined 
__STDC_LIMIT_MACROS


149 #if 
__WORDSIZE
 == 64

150 #define 
	#__INT64_C
(
c
) c ## 
L


	)

151 #define 
	#__UINT64_C
(
c
) c ## 
UL


	)

153 #define 
	#__INT64_C
(
c
) c ## 
LL


	)

154 #define 
	#__UINT64_C
(
c
) c ## 
ULL


	)

160 #define 
	#INT8_MIN
 (-128)

	)

161 #define 
	#INT16_MIN
 (-32767-1)

	)

162 #define 
	#INT32_MIN
 (-2147483647-1)

	)

163 #define 
	#INT64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

165 #define 
	#INT8_MAX
 (127)

	)

166 #define 
	#INT16_MAX
 (32767)

	)

167 #define 
	#INT32_MAX
 (2147483647)

	)

168 #define 
	#INT64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

171 #define 
	#UINT8_MAX
 (255)

	)

172 #define 
	#UINT16_MAX
 (65535)

	)

173 #define 
	#UINT32_MAX
 (4294967295U)

	)

174 #define 
	#UINT64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

178 #define 
	#INT_LEAST8_MIN
 (-128)

	)

179 #define 
	#INT_LEAST16_MIN
 (-32767-1)

	)

180 #define 
	#INT_LEAST32_MIN
 (-2147483647-1)

	)

181 #define 
	#INT_LEAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

183 #define 
	#INT_LEAST8_MAX
 (127)

	)

184 #define 
	#INT_LEAST16_MAX
 (32767)

	)

185 #define 
	#INT_LEAST32_MAX
 (2147483647)

	)

186 #define 
	#INT_LEAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

189 #define 
	#UINT_LEAST8_MAX
 (255)

	)

190 #define 
	#UINT_LEAST16_MAX
 (65535)

	)

191 #define 
	#UINT_LEAST32_MAX
 (4294967295U)

	)

192 #define 
	#UINT_LEAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

196 #define 
	#INT_FAST8_MIN
 (-128)

	)

197 #if 
__WORDSIZE
 == 64

198 #define 
	#INT_FAST16_MIN
 (-9223372036854775807L-1)

	)

199 #define 
	#INT_FAST32_MIN
 (-9223372036854775807L-1)

	)

201 #define 
	#INT_FAST16_MIN
 (-2147483647-1)

	)

202 #define 
	#INT_FAST32_MIN
 (-2147483647-1)

	)

204 #define 
	#INT_FAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

206 #define 
	#INT_FAST8_MAX
 (127)

	)

207 #if 
__WORDSIZE
 == 64

208 #define 
	#INT_FAST16_MAX
 (9223372036854775807L)

	)

209 #define 
	#INT_FAST32_MAX
 (9223372036854775807L)

	)

211 #define 
	#INT_FAST16_MAX
 (2147483647)

	)

212 #define 
	#INT_FAST32_MAX
 (2147483647)

	)

214 #define 
	#INT_FAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

217 #define 
	#UINT_FAST8_MAX
 (255)

	)

218 #if 
__WORDSIZE
 == 64

219 #define 
	#UINT_FAST16_MAX
 (18446744073709551615UL)

	)

220 #define 
	#UINT_FAST32_MAX
 (18446744073709551615UL)

	)

222 #define 
	#UINT_FAST16_MAX
 (4294967295U)

	)

223 #define 
	#UINT_FAST32_MAX
 (4294967295U)

	)

225 #define 
	#UINT_FAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

229 #if 
__WORDSIZE
 == 64

230 #define 
	#INTPTR_MIN
 (-9223372036854775807L-1)

	)

231 #define 
	#INTPTR_MAX
 (9223372036854775807L)

	)

232 #define 
	#UINTPTR_MAX
 (18446744073709551615UL)

	)

234 #define 
	#INTPTR_MIN
 (-2147483647-1)

	)

235 #define 
	#INTPTR_MAX
 (2147483647)

	)

236 #define 
	#UINTPTR_MAX
 (4294967295U)

	)

241 #define 
	#INTMAX_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

243 #define 
	#INTMAX_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

246 #define 
	#UINTMAX_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

252 #if 
__WORDSIZE
 == 64

253 #define 
	#PTRDIFF_MIN
 (-9223372036854775807L-1)

	)

254 #define 
	#PTRDIFF_MAX
 (9223372036854775807L)

	)

256 #define 
	#PTRDIFF_MIN
 (-2147483647-1)

	)

257 #define 
	#PTRDIFF_MAX
 (2147483647)

	)

261 #define 
	#SIG_ATOMIC_MIN
 (-2147483647-1)

	)

262 #define 
	#SIG_ATOMIC_MAX
 (2147483647)

	)

265 #if 
__WORDSIZE
 == 64

266 #define 
	#SIZE_MAX
 (18446744073709551615UL)

	)

268 #define 
	#SIZE_MAX
 (4294967295U)

	)

272 #ifndef 
WCHAR_MIN


274 #define 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

275 #define 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

279 #define 
	#WINT_MIN
 (0u)

	)

280 #define 
	#WINT_MAX
 (4294967295u)

	)

287 #if !
defined
 
__cplusplus
 || defined 
__STDC_CONSTANT_MACROS


290 #define 
	#INT8_C
(
c
) 
	)
c

291 #define 
	#INT16_C
(
c
) 
	)
c

292 #define 
	#INT32_C
(
c
) 
	)
c

293 #if 
__WORDSIZE
 == 64

294 #define 
	#INT64_C
(
c
) c ## 
L


	)

296 #define 
	#INT64_C
(
c
) c ## 
LL


	)

300 #define 
	#UINT8_C
(
c
) 
	)
c

301 #define 
	#UINT16_C
(
c
) 
	)
c

302 #define 
	#UINT32_C
(
c
) c ## 
U


	)

303 #if 
__WORDSIZE
 == 64

304 #define 
	#UINT64_C
(
c
) c ## 
UL


	)

306 #define 
	#UINT64_C
(
c
) c ## 
ULL


	)

310 #if 
__WORDSIZE
 == 64

311 #define 
	#INTMAX_C
(
c
) c ## 
L


	)

312 #define 
	#UINTMAX_C
(
c
) c ## 
UL


	)

314 #define 
	#INTMAX_C
(
c
) c ## 
LL


	)

315 #define 
	#UINTMAX_C
(
c
) c ## 
ULL


	)

	@/usr/include/stdio.h

24 #ifndef 
_STDIO_H


26 #if !
defined
 
__need_FILE
 && !defined 
__need___FILE


27 #define 
	#_STDIO_H
 1

	)

28 #include 
	~<features.h
>

30 
	g__BEGIN_DECLS


32 #define 
	#__need_size_t


	)

33 #define 
	#__need_NULL


	)

34 #include 
	~<stddef.h
>

36 #include 
	~<bits/types.h
>

37 #define 
	#__need_FILE


	)

38 #define 
	#__need___FILE


	)

42 #if !
defined
 
__FILE_defined
 && defined 
__need_FILE


45 struct 
	g_IO_FILE
;

47 
__BEGIN_NAMESPACE_STD


49 typedef struct 
_IO_FILE
 
	tFILE
;

50 
	g__END_NAMESPACE_STD


51 #if 
defined
 
__USE_LARGEFILE64
 || defined 
__USE_SVID
 || defined 
__USE_POSIX
 \

52 || 
defined
 
	g__USE_BSD
 || defined 
	g__USE_ISOC99
 || defined 
	g__USE_XOPEN
 \

53 || 
defined
 
__USE_POSIX2


54 
	$__USING_NAMESPACE_STD
(
FILE
)

57 #define 
	#__FILE_defined
 1

	)

59 #undef 
__need_FILE


62 #if !
defined
 
____FILE_defined
 && defined 
__need___FILE


65 typedef struct 
_IO_FILE
 
	t__FILE
;

67 #define 
	#____FILE_defined
 1

	)

69 #undef 
__need___FILE


72 #ifdef 
_STDIO_H


73 #define 
	#_STDIO_USES_IOSTREAM


	)

75 #include 
	~<libio.h
>

77 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


78 #ifdef 
__GNUC__


79 #ifndef 
_VA_LIST_DEFINED


80 typedef 
_G_va_list
 
	tva_list
;

81 #define 
	#_VA_LIST_DEFINED


	)

84 #include 
	~<stdarg.h
>

88 #ifdef 
__USE_XOPEN2K8


89 #ifndef 
__off_t_defined


90 #ifndef 
__USE_FILE_OFFSET64


91 typedef 
__off_t
 
	toff_t
;

93 typedef 
__off64_t
 
	toff_t
;

95 #define 
	#__off_t_defined


	)

97 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


98 typedef 
__off64_t
 
	toff64_t
;

99 #define 
	#__off64_t_defined


	)

102 #ifndef 
__ssize_t_defined


103 typedef 
__ssize_t
 
	tssize_t
;

104 #define 
	#__ssize_t_defined


	)

109 
__BEGIN_NAMESPACE_STD


110 #ifndef 
__USE_FILE_OFFSET64


111 typedef 
_G_fpos_t
 
	tfpos_t
;

113 typedef 
_G_fpos64_t
 
	tfpos_t
;

115 
__END_NAMESPACE_STD


116 #ifdef 
__USE_LARGEFILE64


117 typedef 
_G_fpos64_t
 
	tfpos64_t
;

121 #define 
	#_IOFBF
 0

	)

122 #define 
	#_IOLBF
 1

	)

123 #define 
	#_IONBF
 2

	)

127 #ifndef 
BUFSIZ


128 #define 
	#BUFSIZ
 
_IO_BUFSIZ


	)

134 #ifndef 
EOF


135 #define 
	#EOF
 (-1)

	)

141 #define 
	#SEEK_SET
 0

	)

142 #define 
	#SEEK_CUR
 1

	)

143 #define 
	#SEEK_END
 2

	)

146 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


148 #define 
	#P_tmpdir
 "/tmp"

	)

161 #include 
	~<bits/stdio_lim.h
>

165 extern struct 
_IO_FILE
 *
stdin
;

166 extern struct 
_IO_FILE
 *
stdout
;

167 extern struct 
_IO_FILE
 *
stderr
;

169 #define 
	#stdin
 
stdin


	)

170 #define 
	#stdout
 
stdout


	)

171 #define 
	#stderr
 
stderr


	)

173 
__BEGIN_NAMESPACE_STD


175 extern int 
	$remove
 (
__const
 char *
__filename
) 
__THROW
;

177 extern int 
	$rename
 (
__const
 char *
__old
, __const char *
__new
) 
__THROW
;

178 
__END_NAMESPACE_STD


180 #ifdef 
__USE_ATFILE


182 extern int 
	$renameat
 (int 
__oldfd
, 
__const
 char *
__old
, int 
__newfd
,

183 
__const
 char *
__new
) 
__THROW
;

186 
__BEGIN_NAMESPACE_STD


191 #ifndef 
__USE_FILE_OFFSET64


192 extern 
FILE
 *
	$tmpfile
 (void) 
__wur
;

194 #ifdef 
__REDIRECT


195 extern 
FILE
 *
	`__REDIRECT
 (
tmpfile
, (void), 
tmpfile64
) 
__wur
;

197 #define 
	#tmpfile
 
tmpfile64


	)

201 #ifdef 
__USE_LARGEFILE64


202 extern 
FILE
 *
	$tmpfile64
 (void) 
__wur
;

206 extern char *
	$tmpnam
 (char *
__s
) 
__THROW
 
__wur
;

207 
__END_NAMESPACE_STD


209 #ifdef 
__USE_MISC


212 extern char *
	$tmpnam_r
 (char *
__s
) 
__THROW
 
__wur
;

216 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


224 extern char *
	$tempnam
 (
__const
 char *
__dir
, __const char *
__pfx
)

225 
__THROW
 
__attribute_malloc__
 
__wur
;

229 
__BEGIN_NAMESPACE_STD


234 extern int 
	`fclose
 (
FILE
 *
__stream
);

239 extern int 
	`fflush
 (
FILE
 *
__stream
);

240 
__END_NAMESPACE_STD


242 #ifdef 
__USE_MISC


249 extern int 
	`fflush_unlocked
 (
FILE
 *
__stream
);

252 #ifdef 
__USE_GNU


259 extern int 
	`fcloseall
 (void);

263 
__BEGIN_NAMESPACE_STD


264 #ifndef 
__USE_FILE_OFFSET64


269 extern 
FILE
 *
	$fopen
 (
__const
 char *
__restrict
 
__filename
,

270 
__const
 char *
__restrict
 
__modes
) 
__wur
;

275 extern 
FILE
 *
	$freopen
 (
__const
 char *
__restrict
 
__filename
,

276 
__const
 char *
__restrict
 
__modes
,

277 
FILE
 *
__restrict
 
__stream
) 
__wur
;

279 #ifdef 
__REDIRECT


280 extern 
FILE
 *
	`__REDIRECT
 (
fopen
, (
__const
 char *
__restrict
 
__filename
,

281 
__const
 char *
__restrict
 
__modes
), 
fopen64
)

282 
__wur
;

283 extern 
FILE
 *
	`__REDIRECT
 (
freopen
, (
__const
 char *
__restrict
 
__filename
,

284 
__const
 char *
__restrict
 
__modes
,

285 
FILE
 *
__restrict
 
__stream
), 
freopen64
)

286 
__wur
;

288 #define 
	#fopen
 
fopen64


	)

289 #define 
	#freopen
 
freopen64


	)

292 
__END_NAMESPACE_STD


293 #ifdef 
__USE_LARGEFILE64


294 extern 
FILE
 *
	$fopen64
 (
__const
 char *
__restrict
 
__filename
,

295 
__const
 char *
__restrict
 
__modes
) 
__wur
;

296 extern 
FILE
 *
	$freopen64
 (
__const
 char *
__restrict
 
__filename
,

297 
__const
 char *
__restrict
 
__modes
,

298 
FILE
 *
__restrict
 
__stream
) 
__wur
;

301 #ifdef 
__USE_POSIX


303 extern 
FILE
 *
	$fdopen
 (int 
__fd
, 
__const
 char *
__modes
) 
__THROW
 
__wur
;

306 #ifdef 
__USE_GNU


309 extern 
FILE
 *
	$fopencookie
 (void *
__restrict
 
__magic_cookie
,

310 
__const
 char *
__restrict
 
__modes
,

311 
_IO_cookie_io_functions_t
 
__io_funcs
) 
__THROW
 
__wur
;

314 #ifdef 
__USE_XOPEN2K8


316 extern 
FILE
 *
	$fmemopen
 (void *
__s
, 
size_t
 
__len
, 
__const
 char *
__modes
)

317 
__THROW
 
__wur
;

322 extern 
FILE
 *
	$open_memstream
 (char **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
 
__wur
;

326 
__BEGIN_NAMESPACE_STD


329 extern void 
	$setbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
) 
__THROW
;

333 extern int 
	$setvbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

334 int 
__modes
, 
size_t
 
__n
) 
__THROW
;

335 
__END_NAMESPACE_STD


337 #ifdef 
__USE_BSD


340 extern void 
	$setbuffer
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

341 
size_t
 
__size
) 
__THROW
;

344 extern void 
	$setlinebuf
 (
FILE
 *
__stream
) 
__THROW
;

348 
__BEGIN_NAMESPACE_STD


353 extern int 
	`fprintf
 (
FILE
 *
__restrict
 
__stream
,

354 
__const
 char *
__restrict
 
__format
, ...);

359 extern int 
	`printf
 (
__const
 char *
__restrict
 
__format
, ...);

361 extern int 
	$sprintf
 (char *
__restrict
 
__s
,

362 
__const
 char *
__restrict
 
__format
, ...) 
__THROW
;

368 extern int 
	`vfprintf
 (
FILE
 *
__restrict
 
__s
, 
__const
 char *__restrict 
__format
,

369 
_G_va_list
 
__arg
);

374 extern int 
	`vprintf
 (
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
);

376 extern int 
	$vsprintf
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__format
,

377 
_G_va_list
 
__arg
) 
__THROW
;

378 
__END_NAMESPACE_STD


380 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


381 
__BEGIN_NAMESPACE_C99


383 extern int 
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

384 
__const
 char *
__restrict
 
__format
, ...)

385 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

387 extern int 
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

388 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

389 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

390 
__END_NAMESPACE_C99


393 #ifdef 
__USE_GNU


396 extern int 
	$vasprintf
 (char **
__restrict
 
__ptr
, 
__const
 char *__restrict 
__f
,

397 
_G_va_list
 
__arg
)

398 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 0))) 
__wur
;

399 extern int 
	$__asprintf
 (char **
__restrict
 
__ptr
,

400 
__const
 char *
__restrict
 
__fmt
, ...)

401 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

402 extern int 
	$asprintf
 (char **
__restrict
 
__ptr
,

403 
__const
 char *
__restrict
 
__fmt
, ...)

404 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

407 #ifdef 
__USE_XOPEN2K8


414 extern int 
	$vdprintf
 (int 
__fd
, 
__const
 char *
__restrict
 
__fmt
,

415 
_G_va_list
 
__arg
)

416 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

417 extern int 
	$dprintf
 (int 
__fd
, 
__const
 char *
__restrict
 
__fmt
, ...)

418 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

422 
__BEGIN_NAMESPACE_STD


427 extern int 
	$fscanf
 (
FILE
 *
__restrict
 
__stream
,

428 
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

433 extern int 
	$scanf
 (
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

435 extern int 
	$sscanf
 (
__const
 char *
__restrict
 
__s
,

436 
__const
 char *
__restrict
 
__format
, ...) 
__THROW
;

438 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

439 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

440 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

441 #ifdef 
__REDIRECT


445 extern int 
	`__REDIRECT
 (
fscanf
, (
FILE
 *
__restrict
 
__stream
,

446 
__const
 char *
__restrict
 
__format
, ...),

447 
__isoc99_fscanf
) 
__wur
;

448 extern int 
	`__REDIRECT
 (
scanf
, (
__const
 char *
__restrict
 
__format
, ...),

449 
__isoc99_scanf
) 
__wur
;

450 extern int 
	`__REDIRECT_NTH
 (
sscanf
, (
__const
 char *
__restrict
 
__s
,

451 
__const
 char *
__restrict
 
__format
, ...),

452 
__isoc99_sscanf
);

454 extern int 
	$__isoc99_fscanf
 (
FILE
 *
__restrict
 
__stream
,

455 
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

456 extern int 
	$__isoc99_scanf
 (
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

457 extern int 
	$__isoc99_sscanf
 (
__const
 char *
__restrict
 
__s
,

458 
__const
 char *
__restrict
 
__format
, ...) 
__THROW
;

459 #define 
	#fscanf
 
__isoc99_fscanf


	)

460 #define 
	#scanf
 
__isoc99_scanf


	)

461 #define 
	#sscanf
 
__isoc99_sscanf


	)

465 
__END_NAMESPACE_STD


467 #ifdef 
__USE_ISOC99


468 
__BEGIN_NAMESPACE_C99


473 extern int 
	$vfscanf
 (
FILE
 *
__restrict
 
__s
, 
__const
 char *__restrict 
__format
,

474 
_G_va_list
 
__arg
)

475 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

481 extern int 
	$vscanf
 (
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

482 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

485 extern int 
	$vsscanf
 (
__const
 char *
__restrict
 
__s
,

486 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

487 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

489 #if !
defined
 
__USE_GNU
 \

490 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

491 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

492 #ifdef 
__REDIRECT


496 extern int 
	`__REDIRECT
 (
vfscanf
,

497 (
FILE
 *
__restrict
 
__s
,

498 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
),

499 
__isoc99_vfscanf
)

500 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

501 extern int 
	`__REDIRECT
 (
vscanf
, (
__const
 char *
__restrict
 
__format
,

502 
_G_va_list
 
__arg
), 
__isoc99_vscanf
)

503 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

504 extern int 
	`__REDIRECT_NTH
 (
vsscanf
,

505 (
__const
 char *
__restrict
 
__s
,

506 
__const
 char *
__restrict
 
__format
,

507 
_G_va_list
 
__arg
), 
__isoc99_vsscanf
)

508 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

510 extern int 
	$__isoc99_vfscanf
 (
FILE
 *
__restrict
 
__s
,

511 
__const
 char *
__restrict
 
__format
,

512 
_G_va_list
 
__arg
) 
__wur
;

513 extern int 
	$__isoc99_vscanf
 (
__const
 char *
__restrict
 
__format
,

514 
_G_va_list
 
__arg
) 
__wur
;

515 extern int 
	$__isoc99_vsscanf
 (
__const
 char *
__restrict
 
__s
,

516 
__const
 char *
__restrict
 
__format
,

517 
_G_va_list
 
__arg
) 
__THROW
;

518 #define 
	#vfscanf
 
__isoc99_vfscanf


	)

519 #define 
	#vscanf
 
__isoc99_vscanf


	)

520 #define 
	#vsscanf
 
__isoc99_vsscanf


	)

524 
__END_NAMESPACE_C99


528 
__BEGIN_NAMESPACE_STD


533 extern int 
	`fgetc
 (
FILE
 *
__stream
);

534 extern int 
	`getc
 (
FILE
 *
__stream
);

540 extern int 
	`getchar
 (void);

541 
__END_NAMESPACE_STD


545 #define 
	#getc
(
_fp
) 
	`_IO_getc
 (_fp)

	)

547 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


552 extern int 
	`getc_unlocked
 (
FILE
 *
__stream
);

553 extern int 
	`getchar_unlocked
 (void);

556 #ifdef 
__USE_MISC


563 extern int 
	`fgetc_unlocked
 (
FILE
 *
__stream
);

567 
__BEGIN_NAMESPACE_STD


575 extern int 
	`fputc
 (int 
__c
, 
FILE
 *
__stream
);

576 extern int 
	`putc
 (int 
__c
, 
FILE
 *
__stream
);

582 extern int 
	`putchar
 (int 
__c
);

583 
__END_NAMESPACE_STD


587 #define 
	#putc
(
_ch
, 
_fp
) 
	`_IO_putc
 (_ch, _fp)

	)

589 #ifdef 
__USE_MISC


596 extern int 
	`fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

599 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


604 extern int 
	`putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

605 extern int 
	`putchar_unlocked
 (int 
__c
);

609 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 \

610 || (
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

612 extern int 
	`getw
 (
FILE
 *
__stream
);

615 extern int 
	`putw
 (int 
__w
, 
FILE
 *
__stream
);

619 
__BEGIN_NAMESPACE_STD


624 extern char *
	$fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

625 
__wur
;

632 extern char *
	$gets
 (char *
__s
) 
__wur
;

633 
__END_NAMESPACE_STD


635 #ifdef 
__USE_GNU


642 extern char *
	$fgets_unlocked
 (char *
__restrict
 
__s
, int 
__n
,

643 
FILE
 *
__restrict
 
__stream
) 
__wur
;

647 #ifdef 
__USE_XOPEN2K8


658 extern 
_IO_ssize_t
 
	$__getdelim
 (char **
__restrict
 
__lineptr
,

659 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

660 
FILE
 *
__restrict
 
__stream
) 
__wur
;

661 extern 
_IO_ssize_t
 
	$getdelim
 (char **
__restrict
 
__lineptr
,

662 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

663 
FILE
 *
__restrict
 
__stream
) 
__wur
;

671 extern 
_IO_ssize_t
 
	$getline
 (char **
__restrict
 
__lineptr
,

672 
size_t
 *
__restrict
 
__n
,

673 
FILE
 *
__restrict
 
__stream
) 
__wur
;

677 
__BEGIN_NAMESPACE_STD


682 extern int 
	`fputs
 (
__const
 char *
__restrict
 
__s
, 
FILE
 *__restrict 
__stream
);

688 extern int 
	`puts
 (
__const
 char *
__s
);

695 extern int 
	`ungetc
 (int 
__c
, 
FILE
 *
__stream
);

702 extern 
size_t
 
	$fread
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

703 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

708 extern 
size_t
 
	`fwrite
 (
__const
 void *
__restrict
 
__ptr
, size_t 
__size
,

709 
size_t
 
__n
, 
FILE
 *
__restrict
 
__s
);

710 
__END_NAMESPACE_STD


712 #ifdef 
__USE_GNU


719 extern int 
	`fputs_unlocked
 (
__const
 char *
__restrict
 
__s
,

720 
FILE
 *
__restrict
 
__stream
);

723 #ifdef 
__USE_MISC


730 extern 
size_t
 
	$fread_unlocked
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

731 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

732 extern 
size_t
 
	`fwrite_unlocked
 (
__const
 void *
__restrict
 
__ptr
, size_t 
__size
,

733 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
);

737 
__BEGIN_NAMESPACE_STD


742 extern int 
	`fseek
 (
FILE
 *
__stream
, long int 
__off
, int 
__whence
);

747 extern long int 
	$ftell
 (
FILE
 *
__stream
) 
__wur
;

752 extern void 
	`rewind
 (
FILE
 *
__stream
);

753 
__END_NAMESPACE_STD


760 #if 
defined
 
__USE_LARGEFILE
 || defined 
__USE_XOPEN2K


761 #ifndef 
__USE_FILE_OFFSET64


766 extern int 
	`fseeko
 (
FILE
 *
__stream
, 
__off_t
 
__off
, int 
__whence
);

771 extern 
__off_t
 
	$ftello
 (
FILE
 *
__stream
) 
__wur
;

773 #ifdef 
__REDIRECT


774 extern int 
	`__REDIRECT
 (
fseeko
,

775 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
),

776 
fseeko64
);

777 extern 
__off64_t
 
	`__REDIRECT
 (
ftello
, (
FILE
 *
__stream
), 
ftello64
);

779 #define 
	#fseeko
 
fseeko64


	)

780 #define 
	#ftello
 
ftello64


	)

785 
__BEGIN_NAMESPACE_STD


786 #ifndef 
__USE_FILE_OFFSET64


791 extern int 
	`fgetpos
 (
FILE
 *
__restrict
 
__stream
, 
fpos_t
 *__restrict 
__pos
);

796 extern int 
	`fsetpos
 (
FILE
 *
__stream
, 
__const
 
fpos_t
 *
__pos
);

798 #ifdef 
__REDIRECT


799 extern int 
	`__REDIRECT
 (
fgetpos
, (
FILE
 *
__restrict
 
__stream
,

800 
fpos_t
 *
__restrict
 
__pos
), 
fgetpos64
);

801 extern int 
	`__REDIRECT
 (
fsetpos
,

802 (
FILE
 *
__stream
, 
__const
 
fpos_t
 *
__pos
), 
fsetpos64
);

804 #define 
	#fgetpos
 
fgetpos64


	)

805 #define 
	#fsetpos
 
fsetpos64


	)

808 
__END_NAMESPACE_STD


810 #ifdef 
__USE_LARGEFILE64


811 extern int 
	`fseeko64
 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
);

812 extern 
__off64_t
 
	$ftello64
 (
FILE
 *
__stream
) 
__wur
;

813 extern int 
	`fgetpos64
 (
FILE
 *
__restrict
 
__stream
, 
fpos64_t
 *__restrict 
__pos
);

814 extern int 
	`fsetpos64
 (
FILE
 *
__stream
, 
__const
 
fpos64_t
 *
__pos
);

817 
__BEGIN_NAMESPACE_STD


819 extern void 
	$clearerr
 (
FILE
 *
__stream
) 
__THROW
;

821 extern int 
	$feof
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

823 extern int 
	$ferror
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

824 
__END_NAMESPACE_STD


826 #ifdef 
__USE_MISC


828 extern void 
	$clearerr_unlocked
 (
FILE
 *
__stream
) 
__THROW
;

829 extern int 
	$feof_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

830 extern int 
	$ferror_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

834 
__BEGIN_NAMESPACE_STD


839 extern void 
	`perror
 (
__const
 char *
__s
);

840 
__END_NAMESPACE_STD


846 #include 
	~<bits/sys_errlist.h
>

849 #ifdef 
__USE_POSIX


851 extern int 
	$fileno
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

854 #ifdef 
__USE_MISC


856 extern int 
	$fileno_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

860 #if (
defined
 
__USE_POSIX2
 || defined 
__USE_SVID
 || defined 
__USE_BSD
 || \

861 
defined
 
__USE_MISC
)

866 extern 
FILE
 *
	$popen
 (
__const
 char *
__command
, __const char *
__modes
) 
__wur
;

872 extern int 
	`pclose
 (
FILE
 *
__stream
);

876 #ifdef 
__USE_POSIX


878 extern char *
	$ctermid
 (char *
__s
) 
__THROW
;

882 #ifdef 
__USE_XOPEN


884 extern char *
	`cuserid
 (char *
__s
);

888 #ifdef 
__USE_GNU


889 struct 
obstack
;

892 extern int 
	$obstack_printf
 (struct 
obstack
 *
__restrict
 
__obstack
,

893 
__const
 char *
__restrict
 
__format
, ...)

894 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

895 extern int 
	$obstack_vprintf
 (struct 
obstack
 *
__restrict
 
__obstack
,

896 
__const
 char *
__restrict
 
__format
,

897 
_G_va_list
 
__args
)

898 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

902 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


906 extern void 
	$flockfile
 (
FILE
 *
__stream
) 
__THROW
;

910 extern int 
	$ftrylockfile
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

913 extern void 
	$funlockfile
 (
FILE
 *
__stream
) 
__THROW
;

916 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
 && !defined 
__USE_GNU


920 #define 
	#__need_getopt


	)

921 #include 
	~<getopt.h
>

926 #ifdef 
__USE_EXTERN_INLINES


927 #include 
	~<bits/stdio.h
>

929 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


930 #include 
	~<bits/stdio2.h
>

932 #ifdef 
__LDBL_COMPAT


933 #include 
	~<bits/stdio-ldbl.h
>

936 
__END_DECLS


	@/usr/include/stdio_ext.h

23 #ifndef 
_STDIO_EXT_H


24 #define 
	#_STDIO_EXT_H
 1

	)

26 #include 
	~<stdio.h
>

31 
	mFSETLOCKING_QUERY
 = 0,

32 #define 
	#FSETLOCKING_QUERY
 
FSETLOCKING_QUERY


	)

35 
	mFSETLOCKING_INTERNAL
,

36 #define 
	#FSETLOCKING_INTERNAL
 
FSETLOCKING_INTERNAL


	)

38 
	mFSETLOCKING_BYCALLER


39 #define 
	#FSETLOCKING_BYCALLER
 
FSETLOCKING_BYCALLER


	)

43 
__BEGIN_DECLS


47 extern 
size_t
 
	$__fbufsize
 (
FILE
 *
__fp
) 
__THROW
;

52 extern int 
	$__freading
 (
FILE
 *
__fp
) 
__THROW
;

57 extern int 
	$__fwriting
 (
FILE
 *
__fp
) 
__THROW
;

62 extern int 
	$__freadable
 (
FILE
 *
__fp
) 
__THROW
;

65 extern int 
	$__fwritable
 (
FILE
 *
__fp
) 
__THROW
;

69 extern int 
	$__flbf
 (
FILE
 *
__fp
) 
__THROW
;

73 extern void 
	$__fpurge
 (
FILE
 *
__fp
) 
__THROW
;

76 extern 
size_t
 
	$__fpending
 (
FILE
 *
__fp
) 
__THROW
;

79 extern void 
	`_flushlbf
 (void);

83 extern int 
	$__fsetlocking
 (
FILE
 *
__fp
, int 
__type
) 
__THROW
;

85 
__END_DECLS


	@/usr/include/stdlib.h

23 #ifndef 
_STDLIB_H


25 #include 
	~<features.h
>

28 #define 
	#__need_size_t


	)

29 #ifndef 
__need_malloc_and_calloc


30 #define 
	#__need_wchar_t


	)

31 #define 
	#__need_NULL


	)

33 #include 
	~<stddef.h
>

35 
	g__BEGIN_DECLS


37 #ifndef 
__need_malloc_and_calloc


38 #define 
	#_STDLIB_H
 1

	)

40 #if (
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8
) && !defined 
_SYS_WAIT_H


42 #include 
	~<bits/waitflags.h
>

43 #include 
	~<bits/waitstatus.h
>

45 #ifdef 
__USE_BSD


50 #if 
defined
 
__GNUC__
 && !defined 
__cplusplus


51 #define 
	#__WAIT_INT
(
status
) \

52 (
	`__extension__
 (((union { 
	`__typeof
(
status
) 
__in
; int 
__i
; }) \

53 { .
__in
 = (
status
) }).
__i
))

	)

55 #define 
	#__WAIT_INT
(
status
) (*(int *) &(status))

	)

63 #if !
defined
 
__GNUC__
 || __GNUC__ < 2 || defined 
__cplusplus


64 #define 
	#__WAIT_STATUS
 void *

	)

65 #define 
	#__WAIT_STATUS_DEFN
 void *

	)

70 union 
wait
 *
	m__uptr
;

71 int *
	m__iptr
;

72 } 
	t__WAIT_STATUS
 
	t__attribute__
 ((
	t__transparent_union__
));

73 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

78 #define 
	#__WAIT_INT
(
status
) (status)

	)

79 #define 
	#__WAIT_STATUS
 int *

	)

80 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

85 #define 
	#WEXITSTATUS
(
status
) 
	`__WEXITSTATUS
 (
	`__WAIT_INT
 (status))

	)

86 #define 
	#WTERMSIG
(
status
) 
	`__WTERMSIG
 (
	`__WAIT_INT
 (status))

	)

87 #define 
	#WSTOPSIG
(
status
) 
	`__WSTOPSIG
 (
	`__WAIT_INT
 (status))

	)

88 #define 
	#WIFEXITED
(
status
) 
	`__WIFEXITED
 (
	`__WAIT_INT
 (status))

	)

89 #define 
	#WIFSIGNALED
(
status
) 
	`__WIFSIGNALED
 (
	`__WAIT_INT
 (status))

	)

90 #define 
	#WIFSTOPPED
(
status
) 
	`__WIFSTOPPED
 (
	`__WAIT_INT
 (status))

	)

91 #ifdef 
__WIFCONTINUED


92 #define 
	#WIFCONTINUED
(
status
) 
	`__WIFCONTINUED
 (
	`__WAIT_INT
 (status))

	)

96 
__BEGIN_NAMESPACE_STD


100 int 
	mquot
;

101 int 
	mrem
;

102 } 
	tdiv_t
;

105 #ifndef 
__ldiv_t_defined


108 long int 
	mquot
;

109 long int 
	mrem
;

110 } 
	tldiv_t
;

111 #define 
	#__ldiv_t_defined
 1

	)

113 
	g__END_NAMESPACE_STD


115 #if 
defined
 
__USE_ISOC99
 && !defined 
__lldiv_t_defined


116 
__BEGIN_NAMESPACE_C99


118 
__extension__
 typedef struct

120 long long int 
	mquot
;

121 long long int 
	mrem
;

122 } 
	tlldiv_t
;

123 #define 
	#__lldiv_t_defined
 1

	)

124 
	g__END_NAMESPACE_C99


129 #define 
	#RAND_MAX
 2147483647

	)

134 #define 
	#EXIT_FAILURE
 1

	)

135 #define 
	#EXIT_SUCCESS
 0

	)

139 #define 
	#MB_CUR_MAX
 (
	`__ctype_get_mb_cur_max
 ())

	)

140 extern 
size_t
 
	$__ctype_get_mb_cur_max
 (void) 
__THROW
 
__wur
;

143 
__BEGIN_NAMESPACE_STD


145 extern double 
	$atof
 (
__const
 char *
__nptr
)

146 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

148 extern int 
	$atoi
 (
__const
 char *
__nptr
)

149 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

151 extern long int 
	$atol
 (
__const
 char *
__nptr
)

152 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

153 
__END_NAMESPACE_STD


155 #if 
defined
 
__USE_ISOC99
 || (defined 
__GLIBC_HAVE_LONG_LONG
 && defined 
__USE_MISC
)

156 
__BEGIN_NAMESPACE_C99


158 
__extension__
 extern long long int 
	$atoll
 (
__const
 char *
__nptr
)

159 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

160 
__END_NAMESPACE_C99


163 
__BEGIN_NAMESPACE_STD


165 extern double 
	$strtod
 (
__const
 char *
__restrict
 
__nptr
,

166 char **
__restrict
 
__endptr
)

167 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

168 
__END_NAMESPACE_STD


170 #ifdef 
__USE_ISOC99


171 
__BEGIN_NAMESPACE_C99


173 extern float 
	$strtof
 (
__const
 char *
__restrict
 
__nptr
,

174 char **
__restrict
 
__endptr
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

176 extern long double 
	$strtold
 (
__const
 char *
__restrict
 
__nptr
,

177 char **
__restrict
 
__endptr
)

178 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

179 
__END_NAMESPACE_C99


182 
__BEGIN_NAMESPACE_STD


184 extern long int 
	$strtol
 (
__const
 char *
__restrict
 
__nptr
,

185 char **
__restrict
 
__endptr
, int 
__base
)

186 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

188 extern unsigned long int 
	$strtoul
 (
__const
 char *
__restrict
 
__nptr
,

189 char **
__restrict
 
__endptr
, int 
__base
)

190 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

191 
__END_NAMESPACE_STD


193 #if 
defined
 
__GLIBC_HAVE_LONG_LONG
 && defined 
__USE_BSD


195 
__extension__


196 extern long long int 
	$strtoq
 (
__const
 char *
__restrict
 
__nptr
,

197 char **
__restrict
 
__endptr
, int 
__base
)

198 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

200 
__extension__


201 extern unsigned long long int 
	$strtouq
 (
__const
 char *
__restrict
 
__nptr
,

202 char **
__restrict
 
__endptr
, int 
__base
)

203 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

206 #if 
defined
 
__USE_ISOC99
 || (defined 
__GLIBC_HAVE_LONG_LONG
 && defined 
__USE_MISC
)

207 
__BEGIN_NAMESPACE_C99


209 
__extension__


210 extern long long int 
	$strtoll
 (
__const
 char *
__restrict
 
__nptr
,

211 char **
__restrict
 
__endptr
, int 
__base
)

212 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

214 
__extension__


215 extern unsigned long long int 
	$strtoull
 (
__const
 char *
__restrict
 
__nptr
,

216 char **
__restrict
 
__endptr
, int 
__base
)

217 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

218 
__END_NAMESPACE_C99


222 #ifdef 
__USE_GNU


236 #include 
	~<xlocale.h
>

240 extern long int 
	$strtol_l
 (
__const
 char *
__restrict
 
__nptr
,

241 char **
__restrict
 
__endptr
, int 
__base
,

242 
__locale_t
 
__loc
) 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

244 extern unsigned long int 
	$strtoul_l
 (
__const
 char *
__restrict
 
__nptr
,

245 char **
__restrict
 
__endptr
,

246 int 
__base
, 
__locale_t
 
__loc
)

247 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

249 
__extension__


250 extern long long int 
	$strtoll_l
 (
__const
 char *
__restrict
 
__nptr
,

251 char **
__restrict
 
__endptr
, int 
__base
,

252 
__locale_t
 
__loc
)

253 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

255 
__extension__


256 extern unsigned long long int 
	$strtoull_l
 (
__const
 char *
__restrict
 
__nptr
,

257 char **
__restrict
 
__endptr
,

258 int 
__base
, 
__locale_t
 
__loc
)

259 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

261 extern double 
	$strtod_l
 (
__const
 char *
__restrict
 
__nptr
,

262 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

263 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

265 extern float 
	$strtof_l
 (
__const
 char *
__restrict
 
__nptr
,

266 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

267 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

269 extern long double 
	$strtold_l
 (
__const
 char *
__restrict
 
__nptr
,

270 char **
__restrict
 
__endptr
,

271 
__locale_t
 
__loc
)

272 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

276 #ifdef 
__USE_EXTERN_INLINES


277 
__BEGIN_NAMESPACE_STD


278 
__extern_inline
 double

279 
	`__NTH
 (
	$atof
 (
__const
 char *
__nptr
))

281 return 
	`strtod
 (
__nptr
, (char **) 
NULL
);

282 
	}
}

283 
__extern_inline
 int

284 
__NTH
 (
	$atoi
 (
__const
 char *
__nptr
))

286 return (int) 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

287 
	}
}

288 
__extern_inline
 long int

289 
__NTH
 (
	$atol
 (
__const
 char *
__nptr
))

291 return 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

292 
	}
}

293 
	g__END_NAMESPACE_STD


295 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


296 
__BEGIN_NAMESPACE_C99


297 
__extension__
 
__extern_inline
 long long int

298 
__NTH
 (
	$atoll
 (
__const
 char *
__nptr
))

300 return 
	`strtoll
 (
__nptr
, (char **) 
NULL
, 10);

301 
	}
}

302 
	g__END_NAMESPACE_C99


307 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED


311 extern char *
	$l64a
 (long int 
__n
) 
__THROW
 
__wur
;

314 extern long int 
	$a64l
 (
__const
 char *
__s
)

315 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

319 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_BSD


320 #include 
	~<sys/types.h
>

327 extern long int 
	$random
 (void) 
__THROW
;

330 extern void 
	$srandom
 (unsigned int 
__seed
) 
__THROW
;

336 extern char *
	$initstate
 (unsigned int 
__seed
, char *
__statebuf
,

337 
size_t
 
__statelen
) 
__THROW
 
	`__nonnull
 ((2));

341 extern char *
	$setstate
 (char *
__statebuf
) 
__THROW
 
	`__nonnull
 ((1));

344 #ifdef 
__USE_MISC


349 struct 
	srandom_data


351 
int32_t
 *
fptr
;

352 
int32_t
 *
rptr
;

353 
int32_t
 *
state
;

354 int 
rand_type
;

355 int 
rand_deg
;

356 int 
rand_sep
;

357 
int32_t
 *
end_ptr
;

360 extern int 
	$random_r
 (struct 
random_data
 *
__restrict
 
__buf
,

361 
int32_t
 *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

363 extern int 
	$srandom_r
 (unsigned int 
__seed
, struct 
random_data
 *
__buf
)

364 
__THROW
 
	`__nonnull
 ((2));

366 extern int 
	$initstate_r
 (unsigned int 
__seed
, char *
__restrict
 
__statebuf
,

367 
size_t
 
__statelen
,

368 struct 
random_data
 *
__restrict
 
__buf
)

369 
__THROW
 
	`__nonnull
 ((2, 4));

371 extern int 
	$setstate_r
 (char *
__restrict
 
__statebuf
,

372 struct 
random_data
 *
__restrict
 
__buf
)

373 
__THROW
 
	`__nonnull
 ((1, 2));

378 
__BEGIN_NAMESPACE_STD


380 extern int 
	$rand
 (void) 
__THROW
;

382 extern void 
	$srand
 (unsigned int 
__seed
) 
__THROW
;

383 
__END_NAMESPACE_STD


385 #ifdef 
__USE_POSIX


387 extern int 
	$rand_r
 (unsigned int *
__seed
) 
__THROW
;

391 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


395 extern double 
	$drand48
 (void) 
__THROW
;

396 extern double 
	$erand48
 (unsigned short int 
__xsubi
[3]) 
__THROW
 
	`__nonnull
 ((1));

399 extern long int 
	$lrand48
 (void) 
__THROW
;

400 extern long int 
	$nrand48
 (unsigned short int 
__xsubi
[3])

401 
__THROW
 
	`__nonnull
 ((1));

404 extern long int 
	$mrand48
 (void) 
__THROW
;

405 extern long int 
	$jrand48
 (unsigned short int 
__xsubi
[3])

406 
__THROW
 
	`__nonnull
 ((1));

409 extern void 
	$srand48
 (long int 
__seedval
) 
__THROW
;

410 extern unsigned short int *
	$seed48
 (unsigned short int 
__seed16v
[3])

411 
__THROW
 
	`__nonnull
 ((1));

412 extern void 
	$lcong48
 (unsigned short int 
__param
[7]) 
__THROW
 
	`__nonnull
 ((1));

414 #ifdef 
__USE_MISC


418 struct 
	sdrand48_data


420 unsigned short int 
__x
[3];

421 unsigned short int 
__old_x
[3];

422 unsigned short int 
__c
;

423 unsigned short int 
__init
;

424 unsigned long long int 
__a
;

428 extern int 
	$drand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

429 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

430 extern int 
	$erand48_r
 (unsigned short int 
__xsubi
[3],

431 struct 
drand48_data
 *
__restrict
 
__buffer
,

432 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

435 extern int 
	$lrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

436 long int *
__restrict
 
__result
)

437 
__THROW
 
	`__nonnull
 ((1, 2));

438 extern int 
	$nrand48_r
 (unsigned short int 
__xsubi
[3],

439 struct 
drand48_data
 *
__restrict
 
__buffer
,

440 long int *
__restrict
 
__result
)

441 
__THROW
 
	`__nonnull
 ((1, 2));

444 extern int 
	$mrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

445 long int *
__restrict
 
__result
)

446 
__THROW
 
	`__nonnull
 ((1, 2));

447 extern int 
	$jrand48_r
 (unsigned short int 
__xsubi
[3],

448 struct 
drand48_data
 *
__restrict
 
__buffer
,

449 long int *
__restrict
 
__result
)

450 
__THROW
 
	`__nonnull
 ((1, 2));

453 extern int 
	$srand48_r
 (long int 
__seedval
, struct 
drand48_data
 *
__buffer
)

454 
__THROW
 
	`__nonnull
 ((2));

456 extern int 
	$seed48_r
 (unsigned short int 
__seed16v
[3],

457 struct 
drand48_data
 *
__buffer
) 
__THROW
 
	`__nonnull
 ((1, 2));

459 extern int 
	$lcong48_r
 (unsigned short int 
__param
[7],

460 struct 
drand48_data
 *
__buffer
)

461 
__THROW
 
	`__nonnull
 ((1, 2));

467 #ifndef 
__malloc_and_calloc_defined


468 #define 
	#__malloc_and_calloc_defined


	)

469 
__BEGIN_NAMESPACE_STD


471 extern void *
	$malloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

473 extern void *
	$calloc
 (
size_t
 
__nmemb
, size_t 
__size
)

474 
__THROW
 
__attribute_malloc__
 
__wur
;

475 
__END_NAMESPACE_STD


478 #ifndef 
__need_malloc_and_calloc


479 
__BEGIN_NAMESPACE_STD


485 extern void *
	$realloc
 (void *
__ptr
, 
size_t
 
__size
)

486 
__THROW
 
__attribute_warn_unused_result__
;

488 extern void 
	$free
 (void *
__ptr
) 
__THROW
;

489 
__END_NAMESPACE_STD


491 #ifdef 
__USE_MISC


493 extern void 
	$cfree
 (void *
__ptr
) 
__THROW
;

496 #if 
defined
 
__USE_GNU
 || defined 
__USE_BSD
 || defined 
__USE_MISC


497 #include 
	~<alloca.h
>

500 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

501 || 
defined
 
__USE_BSD


503 extern void *
	$valloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

506 #ifdef 
__USE_XOPEN2K


508 extern int 
	$posix_memalign
 (void **
__memptr
, 
size_t
 
__alignment
, size_t 
__size
)

509 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

512 
__BEGIN_NAMESPACE_STD


514 extern void 
	$abort
 (void) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

518 extern int 
	`atexit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

520 #ifdef 
__USE_GNU


524 #ifdef 
__cplusplus


525 extern "C++" int 
	`at_quick_exit
 (void (*
__func
) (void))

526 
__THROW
 
	`__asm
 ("at_quick_exit") 
	`__nonnull
 ((1));

528 extern int 
	`at_quick_exit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

531 
__END_NAMESPACE_STD


533 #ifdef 
__USE_MISC


536 extern int 
	`on_exit
 (void (*
__func
) (int 
__status
, void *
__arg
), void *__arg)

537 
__THROW
 
	`__nonnull
 ((1));

540 
__BEGIN_NAMESPACE_STD


544 extern void 
	$exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

546 #ifdef 
__USE_GNU


552 extern void 
	$quick_exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

554 
__END_NAMESPACE_STD


556 #ifdef 
__USE_ISOC99


557 
__BEGIN_NAMESPACE_C99


560 extern void 
	$_Exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

561 
__END_NAMESPACE_C99


565 
__BEGIN_NAMESPACE_STD


567 extern char *
	$getenv
 (
__const
 char *
__name
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

568 
__END_NAMESPACE_STD


572 extern char *
	$__secure_getenv
 (
__const
 char *
__name
)

573 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

575 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


579 extern int 
	$putenv
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

582 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K


585 extern int 
	$setenv
 (
__const
 char *
__name
, __const char *
__value
, int 
__replace
)

586 
__THROW
 
	`__nonnull
 ((2));

589 extern int 
	$unsetenv
 (
__const
 char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

592 #ifdef 
__USE_MISC


596 extern int 
	$clearenv
 (void) 
__THROW
;

600 #if 
defined
 
__USE_MISC
 \

601 || (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
)

606 extern char *
	$mktemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

609 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 \

610 || 
defined
 
__USE_XOPEN2K8


619 #ifndef 
__USE_FILE_OFFSET64


620 extern int 
	$mkstemp
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

622 #ifdef 
__REDIRECT


623 extern int 
	`__REDIRECT
 (
mkstemp
, (char *
__template
), 
mkstemp64
)

624 
	`__nonnull
 ((1)) 
__wur
;

626 #define 
	#mkstemp
 
mkstemp64


	)

629 #ifdef 
__USE_LARGEFILE64


630 extern int 
	$mkstemp64
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

634 #ifdef 
__USE_MISC


641 #ifndef 
__USE_FILE_OFFSET64


642 extern int 
	$mkstemps
 (char *
__template
, int 
__suffixlen
) 
	`__nonnull
 ((1)) 
__wur
;

644 #ifdef 
__REDIRECT


645 extern int 
	`__REDIRECT
 (
mkstemps
, (char *
__template
, int 
__suffixlen
),

646 
mkstemps64
) 
	`__nonnull
 ((1)) 
__wur
;

648 #define 
	#mkstemps
 
mkstemps64


	)

651 #ifdef 
__USE_LARGEFILE64


652 extern int 
	$mkstemps64
 (char *
__template
, int 
__suffixlen
)

653 
	`__nonnull
 ((1)) 
__wur
;

657 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K8


663 extern char *
	$mkdtemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

666 #ifdef 
__USE_GNU


673 #ifndef 
__USE_FILE_OFFSET64


674 extern int 
	$mkostemp
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

676 #ifdef 
__REDIRECT


677 extern int 
	`__REDIRECT
 (
mkostemp
, (char *
__template
, int 
__flags
), 
mkostemp64
)

678 
	`__nonnull
 ((1)) 
__wur
;

680 #define 
	#mkostemp
 
mkostemp64


	)

683 #ifdef 
__USE_LARGEFILE64


684 extern int 
	$mkostemp64
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

693 #ifndef 
__USE_FILE_OFFSET64


694 extern int 
	$mkostemps
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

695 
	`__nonnull
 ((1)) 
__wur
;

697 #ifdef 
__REDIRECT


698 extern int 
	`__REDIRECT
 (
mkostemps
, (char *
__template
, int 
__suffixlen
,

699 int 
__flags
), 
mkostemps64
)

700 
	`__nonnull
 ((1)) 
__wur
;

702 #define 
	#mkostemps
 
mkostemps64


	)

705 #ifdef 
__USE_LARGEFILE64


706 extern int 
	$mkostemps64
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

707 
	`__nonnull
 ((1)) 
__wur
;

712 
__BEGIN_NAMESPACE_STD


717 extern int 
	$system
 (
__const
 char *
__command
) 
__wur
;

718 
__END_NAMESPACE_STD


721 #ifdef 
__USE_GNU


724 extern char *
	$canonicalize_file_name
 (
__const
 char *
__name
)

725 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

728 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


734 extern char *
	$realpath
 (
__const
 char *
__restrict
 
__name
,

735 char *
__restrict
 
__resolved
) 
__THROW
 
__wur
;

740 #ifndef 
__COMPAR_FN_T


741 #define 
	#__COMPAR_FN_T


	)

742 typedef int (*
	t__compar_fn_t
) (
	t__const
 void *, __const void *);

744 #ifdef 
__USE_GNU


745 typedef 
__compar_fn_t
 
	tcomparison_fn_t
;

748 #ifdef 
__USE_GNU


749 typedef int (*
	t__compar_d_fn_t
) (
	t__const
 void *, __const void *, void *);

752 
__BEGIN_NAMESPACE_STD


755 extern void *
	$bsearch
 (
__const
 void *
__key
, __const void *
__base
,

756 
size_t
 
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
)

757 
	`__nonnull
 ((1, 2, 5)) 
__wur
;

761 extern void 
	$qsort
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

762 
__compar_fn_t
 
__compar
) 
	`__nonnull
 ((1, 4));

763 #ifdef 
__USE_GNU


764 extern void 
	$qsort_r
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

765 
__compar_d_fn_t
 
__compar
, void *
__arg
)

766 
	`__nonnull
 ((1, 4));

771 extern int 
	$abs
 (int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

772 extern long int 
	$labs
 (long int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

773 
__END_NAMESPACE_STD


775 #ifdef 
__USE_ISOC99


776 
__extension__
 extern long long int 
	$llabs
 (long long int 
__x
)

777 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

781 
__BEGIN_NAMESPACE_STD


785 extern 
div_t
 
	$div
 (int 
__numer
, int 
__denom
)

786 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

787 extern 
ldiv_t
 
	$ldiv
 (long int 
__numer
, long int 
__denom
)

788 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

789 
__END_NAMESPACE_STD


791 #ifdef 
__USE_ISOC99


792 
__BEGIN_NAMESPACE_C99


793 
__extension__
 extern 
lldiv_t
 
	$lldiv
 (long long int 
__numer
,

794 long long int 
__denom
)

795 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

796 
__END_NAMESPACE_C99


800 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

801 || 
defined
 
__USE_SVID


808 extern char *
	$ecvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

809 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

814 extern char *
	$fcvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

815 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

820 extern char *
	$gcvt
 (double 
__value
, int 
__ndigit
, char *
__buf
)

821 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

824 #ifdef 
__USE_MISC


826 extern char *
	$qecvt
 (long double 
__value
, int 
__ndigit
,

827 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

828 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

829 extern char *
	$qfcvt
 (long double 
__value
, int 
__ndigit
,

830 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

831 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

832 extern char *
	$qgcvt
 (long double 
__value
, int 
__ndigit
, char *
__buf
)

833 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

838 extern int 
	$ecvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

839 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

840 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

841 extern int 
	$fcvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

842 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

843 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

845 extern int 
	$qecvt_r
 (long double 
__value
, int 
__ndigit
,

846 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

847 char *
__restrict
 
__buf
, 
size_t
 
__len
)

848 
__THROW
 
	`__nonnull
 ((3, 4, 5));

849 extern int 
	$qfcvt_r
 (long double 
__value
, int 
__ndigit
,

850 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

851 char *
__restrict
 
__buf
, 
size_t
 
__len
)

852 
__THROW
 
	`__nonnull
 ((3, 4, 5));

857 
__BEGIN_NAMESPACE_STD


860 extern int 
	$mblen
 (
__const
 char *
__s
, 
size_t
 
__n
) 
__THROW
 
__wur
;

863 extern int 
	$mbtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

864 
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
 
__wur
;

867 extern int 
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
) 
__THROW
 
__wur
;

871 extern 
size_t
 
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__pwcs
,

872 
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
;

874 extern 
size_t
 
	$wcstombs
 (char *
__restrict
 
__s
,

875 
__const
 
wchar_t
 *
__restrict
 
__pwcs
, 
size_t
 
__n
)

876 
__THROW
;

877 
__END_NAMESPACE_STD


880 #ifdef 
__USE_SVID


885 extern int 
	$rpmatch
 (
__const
 char *
__response
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

889 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


896 extern int 
	$getsubopt
 (char **
__restrict
 
__optionp
,

897 char *
__const
 *
__restrict
 
__tokens
,

898 char **
__restrict
 
__valuep
)

899 
__THROW
 
	`__nonnull
 ((1, 2, 3)) 
__wur
;

903 #ifdef 
__USE_XOPEN


905 extern void 
	$setkey
 (
__const
 char *
__key
) 
__THROW
 
	`__nonnull
 ((1));

911 #ifdef 
__USE_XOPEN2KXSI


913 extern int 
	$posix_openpt
 (int 
__oflag
) 
__wur
;

916 #ifdef 
__USE_XOPEN


921 extern int 
	$grantpt
 (int 
__fd
) 
__THROW
;

925 extern int 
	$unlockpt
 (int 
__fd
) 
__THROW
;

930 extern char *
	$ptsname
 (int 
__fd
) 
__THROW
 
__wur
;

933 #ifdef 
__USE_GNU


937 extern int 
	$ptsname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

938 
__THROW
 
	`__nonnull
 ((2));

941 extern int 
	`getpt
 (void);

944 #ifdef 
__USE_BSD


948 extern int 
	$getloadavg
 (double 
__loadavg
[], int 
__nelem
)

949 
__THROW
 
	`__nonnull
 ((1));

954 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


955 #include 
	~<bits/stdlib.h
>

957 #ifdef 
__LDBL_COMPAT


958 #include 
	~<bits/stdlib-ldbl.h
>

962 #undef 
__need_malloc_and_calloc


964 
__END_DECLS


	@/usr/include/string.h

24 #ifndef 
_STRING_H


25 #define 
	#_STRING_H
 1

	)

27 #include 
	~<features.h
>

29 
	g__BEGIN_DECLS


32 #define 
	#__need_size_t


	)

33 #define 
	#__need_NULL


	)

34 #include 
	~<stddef.h
>

37 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

38 #define 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

42 
__BEGIN_NAMESPACE_STD


44 extern void *
	$memcpy
 (void *
__restrict
 
__dest
,

45 
__const
 void *
__restrict
 
__src
, 
size_t
 
__n
)

46 
__THROW
 
	`__nonnull
 ((1, 2));

49 extern void *
	$memmove
 (void *
__dest
, 
__const
 void *
__src
, 
size_t
 
__n
)

50 
__THROW
 
	`__nonnull
 ((1, 2));

51 
__END_NAMESPACE_STD


56 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN


57 extern void *
	$memccpy
 (void *
__restrict
 
__dest
, 
__const
 void *__restrict 
__src
,

58 int 
__c
, 
size_t
 
__n
)

59 
__THROW
 
	`__nonnull
 ((1, 2));

63 
__BEGIN_NAMESPACE_STD


65 extern void *
	$memset
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

68 extern int 
	$memcmp
 (
__const
 void *
__s1
, __const void *
__s2
, 
size_t
 
__n
)

69 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

72 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


75 extern void *
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

76 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

77 extern 
__const
 void *
	`memchr
 (__const void *
__s
, int 
__c
, 
size_t
 
__n
)

78 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

80 #ifdef 
__OPTIMIZE__


81 
__extern_always_inline
 void *

82 
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


84 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

87 
__extern_always_inline
 
__const
 void *

88 
	`memchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


90 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

93 
	}
}

95 extern void *
	$memchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
)

96 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

98 
__END_NAMESPACE_STD


100 #ifdef 
__USE_GNU


103 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


104 extern "C++" void *
	$rawmemchr
 (void *
__s
, int 
__c
)

105 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

106 extern "C++" 
__const
 void *
	$rawmemchr
 (
__const
 void *
__s
, int 
__c
)

107 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

109 extern void *
	$rawmemchr
 (
__const
 void *
__s
, int 
__c
)

110 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

114 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


115 extern "C++" void *
	$memrchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

116 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

117 extern "C++" 
__const
 void *
	$memrchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
)

118 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

120 extern void *
	$memrchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
)

121 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

126 
__BEGIN_NAMESPACE_STD


128 extern char *
	$strcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

129 
__THROW
 
	`__nonnull
 ((1, 2));

131 extern char *
	$strncpy
 (char *
__restrict
 
__dest
,

132 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

133 
__THROW
 
	`__nonnull
 ((1, 2));

136 extern char *
	$strcat
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

137 
__THROW
 
	`__nonnull
 ((1, 2));

139 extern char *
	$strncat
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
,

140 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

143 extern int 
	$strcmp
 (
__const
 char *
__s1
, __const char *
__s2
)

144 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

146 extern int 
	$strncmp
 (
__const
 char *
__s1
, __const char *
__s2
, 
size_t
 
__n
)

147 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

150 extern int 
	$strcoll
 (
__const
 char *
__s1
, __const char *
__s2
)

151 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

153 extern 
size_t
 
	$strxfrm
 (char *
__restrict
 
__dest
,

154 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

155 
__THROW
 
	`__nonnull
 ((2));

156 
__END_NAMESPACE_STD


158 #ifdef 
__USE_XOPEN2K8


162 #include 
	~<xlocale.h
>

165 extern int 
	$strcoll_l
 (
__const
 char *
__s1
, __const char *
__s2
, 
__locale_t
 
__l
)

166 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

168 extern 
size_t
 
	$strxfrm_l
 (char *
__dest
, 
__const
 char *
__src
, 
size_t
 
__n
,

169 
__locale_t
 
__l
) 
__THROW
 
	`__nonnull
 ((2, 4));

172 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 \

173 || 
defined
 
__USE_XOPEN2K8


175 extern char *
	$strdup
 (
__const
 char *
__s
)

176 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

182 #if 
defined
 
__USE_XOPEN2K8


183 extern char *
	$strndup
 (
__const
 char *
__string
, 
size_t
 
__n
)

184 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

187 #if 
defined
 
__USE_GNU
 && defined 
__GNUC__


189 #define 
	#strdupa
(
s
) \

190 (
__extension__
 \

192 
__const
 char *
__old
 = (
s
); \

193 
size_t
 
__len
 = 
	`strlen
 (
__old
) + 1; \

194 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
); \

195 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

196 
	}
}))

	)

199 #define 
	#strndupa
(
s
, 
n
) \

200 (
__extension__
 \

202 
__const
 char *
__old
 = (
s
); \

203 
size_t
 
__len
 = 
	`strnlen
 (
__old
, (
n
)); \

204 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
 + 1); \

205 
__new
[
__len
] = '\0'; \

206 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

207 }))

	)

210 
	g__BEGIN_NAMESPACE_STD


212 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


215 extern char *
strchr
 (char *
__s
, int 
__c
)

216 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

217 extern 
__const
 char *
strchr
 (__const char *
__s
, int 
__c
)

218 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

220 #ifdef 
__OPTIMIZE__


221 
__extern_always_inline
 char *

222 
strchr
 (char *
__s
, int 
__c
) 
	g__THROW


224 return 
__builtin_strchr
 (
__s
, 
__c
);

227 
__extern_always_inline
 
__const
 char *

228 
strchr
 (
__const
 char *
__s
, int 
__c
) 
	g__THROW


230 return 
__builtin_strchr
 (
__s
, 
__c
);

235 extern char *
	$strchr
 (
__const
 char *
__s
, int 
__c
)

236 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

239 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


242 extern char *
	`strrchr
 (char *
__s
, int 
__c
)

243 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

244 extern 
__const
 char *
	`strrchr
 (__const char *
__s
, int 
__c
)

245 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

247 #ifdef 
__OPTIMIZE__


248 
__extern_always_inline
 char *

249 
	`strrchr
 (char *
__s
, int 
__c
) 
__THROW


251 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

254 
__extern_always_inline
 
__const
 char *

255 
	`strrchr
 (
__const
 char *
__s
, int 
__c
) 
__THROW


257 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

260 
	}
}

262 extern char *
	$strrchr
 (
__const
 char *
__s
, int 
__c
)

263 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

265 
__END_NAMESPACE_STD


267 #ifdef 
__USE_GNU


270 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


271 extern "C++" char *
	$strchrnul
 (char *
__s
, int 
__c
)

272 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

273 extern "C++" 
__const
 char *
	$strchrnul
 (
__const
 char *
__s
, int 
__c
)

274 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

276 extern char *
	$strchrnul
 (
__const
 char *
__s
, int 
__c
)

277 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

281 
__BEGIN_NAMESPACE_STD


284 extern 
size_t
 
	$strcspn
 (
__const
 char *
__s
, __const char *
__reject
)

285 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

288 extern 
size_t
 
	$strspn
 (
__const
 char *
__s
, __const char *
__accept
)

289 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

291 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


294 extern char *
	`strpbrk
 (char *
__s
, 
__const
 char *
__accept
)

295 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

296 extern 
__const
 char *
	`strpbrk
 (__const char *
__s
, __const char *
__accept
)

297 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

299 #ifdef 
__OPTIMIZE__


300 
__extern_always_inline
 char *

301 
	`strpbrk
 (char *
__s
, 
__const
 char *
__accept
) 
__THROW


303 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

306 
__extern_always_inline
 
__const
 char *

307 
	`strpbrk
 (
__const
 char *
__s
, __const char *
__accept
) 
__THROW


309 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

312 
	}
}

314 extern char *
	$strpbrk
 (
__const
 char *
__s
, __const char *
__accept
)

315 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

318 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


321 extern char *
	`strstr
 (char *
__haystack
, 
__const
 char *
__needle
)

322 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

323 extern 
__const
 char *
	`strstr
 (__const char *
__haystack
,

324 
__const
 char *
__needle
)

325 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

327 #ifdef 
__OPTIMIZE__


328 
__extern_always_inline
 char *

329 
	`strstr
 (char *
__haystack
, 
__const
 char *
__needle
) 
__THROW


331 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

334 
__extern_always_inline
 
__const
 char *

335 
	`strstr
 (
__const
 char *
__haystack
, __const char *
__needle
) 
__THROW


337 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

340 
	}
}

342 extern char *
	$strstr
 (
__const
 char *
__haystack
, __const char *
__needle
)

343 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

348 extern char *
	$strtok
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__delim
)

349 
__THROW
 
	`__nonnull
 ((2));

350 
__END_NAMESPACE_STD


354 extern char *
	$__strtok_r
 (char *
__restrict
 
__s
,

355 
__const
 char *
__restrict
 
__delim
,

356 char **
__restrict
 
__save_ptr
)

357 
__THROW
 
	`__nonnull
 ((2, 3));

358 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


359 extern char *
	$strtok_r
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__delim
,

360 char **
__restrict
 
__save_ptr
)

361 
__THROW
 
	`__nonnull
 ((2, 3));

364 #ifdef 
__USE_GNU


366 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


367 extern "C++" char *
	$strcasestr
 (char *
__haystack
, 
__const
 char *
__needle
)

368 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

369 extern "C++" 
__const
 char *
	$strcasestr
 (
__const
 char *
__haystack
,

370 
__const
 char *
__needle
)

371 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

373 extern char *
	$strcasestr
 (
__const
 char *
__haystack
, __const char *
__needle
)

374 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

378 #ifdef 
__USE_GNU


382 extern void *
	$memmem
 (
__const
 void *
__haystack
, 
size_t
 
__haystacklen
,

383 
__const
 void *
__needle
, 
size_t
 
__needlelen
)

384 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 3));

388 extern void *
	$__mempcpy
 (void *
__restrict
 
__dest
,

389 
__const
 void *
__restrict
 
__src
, 
size_t
 
__n
)

390 
__THROW
 
	`__nonnull
 ((1, 2));

391 extern void *
	$mempcpy
 (void *
__restrict
 
__dest
,

392 
__const
 void *
__restrict
 
__src
, 
size_t
 
__n
)

393 
__THROW
 
	`__nonnull
 ((1, 2));

397 
__BEGIN_NAMESPACE_STD


399 extern 
size_t
 
	$strlen
 (
__const
 char *
__s
)

400 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

401 
__END_NAMESPACE_STD


403 #ifdef 
__USE_XOPEN2K8


406 extern 
size_t
 
	$strnlen
 (
__const
 char *
__string
, 
size_t
 
__maxlen
)

407 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

411 
__BEGIN_NAMESPACE_STD


413 extern char *
	$strerror
 (int 
__errnum
) 
__THROW
;

414 
__END_NAMESPACE_STD


415 #if 
defined
 
__USE_XOPEN2K
 || defined 
__USE_MISC


423 #if 
defined
 
__USE_XOPEN2K
 && !defined 
__USE_GNU


426 #ifdef 
__REDIRECT_NTH


427 extern int 
	`__REDIRECT_NTH
 (
strerror_r
,

428 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
),

429 
__xpg_strerror_r
) 
	`__nonnull
 ((2));

431 extern int 
	$__xpg_strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

432 
__THROW
 
	`__nonnull
 ((2));

433 #define 
	#strerror_r
 
__xpg_strerror_r


	)

438 extern char *
	$strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

439 
__THROW
 
	`__nonnull
 ((2));

443 #ifdef 
__USE_XOPEN2K8


445 extern char *
	$strerror_l
 (int 
__errnum
, 
__locale_t
 
__l
) 
__THROW
;

451 extern void 
	$__bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

453 #ifdef 
__USE_BSD


455 extern void 
	$bcopy
 (
__const
 void *
__src
, void *
__dest
, 
size_t
 
__n
)

456 
__THROW
 
	`__nonnull
 ((1, 2));

459 extern void 
	$bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

462 extern int 
	$bcmp
 (
__const
 void *
__s1
, __const void *
__s2
, 
size_t
 
__n
)

463 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

466 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


469 extern char *
	`index
 (char *
__s
, int 
__c
)

470 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

471 extern 
__const
 char *
	`index
 (__const char *
__s
, int 
__c
)

472 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

474 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


475 
__extern_always_inline
 char *

476 
	`index
 (char *
__s
, int 
__c
) 
__THROW


478 return 
	`__builtin_index
 (
__s
, 
__c
);

481 
__extern_always_inline
 
__const
 char *

482 
	`index
 (
__const
 char *
__s
, int 
__c
) 
__THROW


484 return 
	`__builtin_index
 (
__s
, 
__c
);

487 
	}
}

489 extern char *
	$index
 (
__const
 char *
__s
, int 
__c
)

490 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

494 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


497 extern char *
	`rindex
 (char *
__s
, int 
__c
)

498 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

499 extern 
__const
 char *
	`rindex
 (__const char *
__s
, int 
__c
)

500 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

502 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


503 
__extern_always_inline
 char *

504 
	`rindex
 (char *
__s
, int 
__c
) 
__THROW


506 return 
	`__builtin_rindex
 (
__s
, 
__c
);

509 
__extern_always_inline
 
__const
 char *

510 
	`rindex
 (
__const
 char *
__s
, int 
__c
) 
__THROW


512 return 
	`__builtin_rindex
 (
__s
, 
__c
);

515 
	}
}

517 extern char *
	$rindex
 (
__const
 char *
__s
, int 
__c
)

518 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

523 extern int 
	$ffs
 (int 
__i
) 
__THROW
 
	`__attribute__
 ((
__const__
));

527 #ifdef 
__USE_GNU


528 extern int 
	$ffsl
 (long int 
__l
) 
__THROW
 
	`__attribute__
 ((
__const__
));

529 #ifdef 
__GNUC__


530 
__extension__
 extern int 
	$ffsll
 (long long int 
__ll
)

531 
__THROW
 
	`__attribute__
 ((
__const__
));

536 extern int 
	$strcasecmp
 (
__const
 char *
__s1
, __const char *
__s2
)

537 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

540 extern int 
	$strncasecmp
 (
__const
 char *
__s1
, __const char *
__s2
, 
size_t
 
__n
)

541 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

544 #ifdef 
__USE_GNU


547 extern int 
	$strcasecmp_l
 (
__const
 char *
__s1
, __const char *
__s2
,

548 
__locale_t
 
__loc
)

549 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

551 extern int 
	$strncasecmp_l
 (
__const
 char *
__s1
, __const char *
__s2
,

552 
size_t
 
__n
, 
__locale_t
 
__loc
)

553 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 4));

556 #ifdef 
__USE_BSD


559 extern char *
	$strsep
 (char **
__restrict
 
__stringp
,

560 
__const
 char *
__restrict
 
__delim
)

561 
__THROW
 
	`__nonnull
 ((1, 2));

564 #ifdef 
__USE_XOPEN2K8


566 extern char *
	$strsignal
 (int 
__sig
) 
__THROW
;

569 extern char *
	$__stpcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

570 
__THROW
 
	`__nonnull
 ((1, 2));

571 extern char *
	$stpcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

572 
__THROW
 
	`__nonnull
 ((1, 2));

576 extern char *
	$__stpncpy
 (char *
__restrict
 
__dest
,

577 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

578 
__THROW
 
	`__nonnull
 ((1, 2));

579 extern char *
	$stpncpy
 (char *
__restrict
 
__dest
,

580 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

581 
__THROW
 
	`__nonnull
 ((1, 2));

584 #ifdef 
__USE_GNU


586 extern int 
	$strverscmp
 (
__const
 char *
__s1
, __const char *
__s2
)

587 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

590 extern char *
	$strfry
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

593 extern void *
	$memfrob
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

595 #ifndef 
basename


600 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


601 extern "C++" char *
	$basename
 (char *
__filename
)

602 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

603 extern "C++" 
__const
 char *
	$basename
 (
__const
 char *
__filename
)

604 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

606 extern char *
	$basename
 (
__const
 char *
__filename
) 
__THROW
 
	`__nonnull
 ((1));

612 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

613 #if 
defined
 
__OPTIMIZE__
 && !defined 
__OPTIMIZE_SIZE__
 \

614 && !
defined
 
__NO_INLINE__
 && !defined 
__cplusplus


634 #include 
	~<bits/string.h
>

637 #include 
	~<bits/string2.h
>

640 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


642 #include 
	~<bits/string3.h
>

646 
__END_DECLS


	@/usr/include/strings.h

20 #ifndef 
_STRINGS_H


21 #define 
	#_STRINGS_H
 1

	)

26 #if !
defined
 
_STRING_H
 || !defined 
__USE_BSD


28 #include 
	~<features.h
>

29 #define 
	#__need_size_t


	)

30 #include 
	~<stddef.h
>

33 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

34 #define 
	#__CORRECT_ISO_CPP_STRINGS_H_PROTO


	)

37 
	g__BEGIN_DECLS


39 #if 
defined
 
__USE_MISC
 || !defined 
__USE_XOPEN2K8


41 extern int 
	$bcmp
 (
__const
 void *
__s1
, __const void *
__s2
, 
size_t
 
__n
)

42 
__THROW
 
__attribute_pure__
;

45 extern void 
	$bcopy
 (
__const
 void *
__src
, void *
__dest
, 
size_t
 
__n
) 
__THROW
;

48 extern void 
	$bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
;

51 #ifdef 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


54 extern char *
	`index
 (char *
__s
, int 
__c
)

55 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

56 extern 
__const
 char *
	`index
 (__const char *
__s
, int 
__c
)

57 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

59 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRING_H_PROTO


60 
__extern_always_inline
 char *

61 
	`index
 (char *
__s
, int 
__c
) 
__THROW


63 return 
	`__builtin_index
 (
__s
, 
__c
);

66 
__extern_always_inline
 
__const
 char *

67 
	`index
 (
__const
 char *
__s
, int 
__c
) 
__THROW


69 return 
	`__builtin_index
 (
__s
, 
__c
);

72 
	}
}

74 extern char *
	$index
 (
__const
 char *
__s
, int 
__c
)

75 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

79 #ifdef 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


82 extern char *
	`rindex
 (char *
__s
, int 
__c
)

83 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

84 extern 
__const
 char *
	`rindex
 (__const char *
__s
, int 
__c
)

85 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

87 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRING_H_PROTO


88 
__extern_always_inline
 char *

89 
	`rindex
 (char *
__s
, int 
__c
) 
__THROW


91 return 
	`__builtin_rindex
 (
__s
, 
__c
);

94 
__extern_always_inline
 
__const
 char *

95 
	`rindex
 (
__const
 char *
__s
, int 
__c
) 
__THROW


97 return 
	`__builtin_rindex
 (
__s
, 
__c
);

100 
	}
}

102 extern char *
	$rindex
 (
__const
 char *
__s
, int 
__c
)

103 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

107 #if 
defined
 
__USE_MISC
 || !defined 
__USE_XOPEN2K8
 || defined 
__USE_XOPEN2K8XSI


110 extern int 
	$ffs
 (int 
__i
) 
__THROW
 
	`__attribute__
 ((const));

114 extern int 
	$strcasecmp
 (
__const
 char *
__s1
, __const char *
__s2
)

115 
__THROW
 
__attribute_pure__
;

118 extern int 
	$strncasecmp
 (
__const
 char *
__s1
, __const char *
__s2
, 
size_t
 
__n
)

119 
__THROW
 
__attribute_pure__
;

121 #ifdef 
__USE_XOPEN2K8


125 #include 
	~<xlocale.h
>

129 extern int 
	$strcasecmp_l
 (
__const
 char *
__s1
, __const char *
__s2
,

130 
__locale_t
 
__loc
)

131 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

133 extern int 
	$strncasecmp_l
 (
__const
 char *
__s1
, __const char *
__s2
,

134 
size_t
 
__n
, 
__locale_t
 
__loc
)

135 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 4));

138 
__END_DECLS


	@/usr/include/time.h

23 #ifndef 
_TIME_H


25 #if (! 
defined
 
__need_time_t
 && !defined 
__need_clock_t
 && \

26 ! 
defined
 
	g__need_timespec
)

27 #define 
	#_TIME_H
 1

	)

28 #include 
	~<features.h
>

30 
	g__BEGIN_DECLS


34 #ifdef 
_TIME_H


36 #define 
	#__need_size_t


	)

37 #define 
	#__need_NULL


	)

38 #include 
	~<stddef.h
>

42 #include 
	~<bits/time.h
>

45 #if !
defined
 
__STRICT_ANSI__
 && !defined 
__USE_XOPEN2K


46 #ifndef 
CLK_TCK


47 #define 
	#CLK_TCK
 
CLOCKS_PER_SEC


	)

53 #if !
defined
 
__clock_t_defined
 && (defined 
_TIME_H
 || defined 
__need_clock_t
)

54 #define 
	#__clock_t_defined
 1

	)

56 #include 
	~<bits/types.h
>

58 
__BEGIN_NAMESPACE_STD


60 typedef 
__clock_t
 
	tclock_t
;

61 
	g__END_NAMESPACE_STD


62 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_POSIX
 || defined 
__USE_MISC


63 
	$__USING_NAMESPACE_STD
(
clock_t
)

67 #undef 
__need_clock_t


69 #if !
defined
 
__time_t_defined
 && (defined 
_TIME_H
 || defined 
__need_time_t
)

70 #define 
	#__time_t_defined
 1

	)

72 #include 
	~<bits/types.h
>

74 
__BEGIN_NAMESPACE_STD


76 typedef 
__time_t
 
	ttime_t
;

77 
__END_NAMESPACE_STD


78 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC
 || defined 
__USE_SVID


79 
	$__USING_NAMESPACE_STD
(
time_t
)

83 #undef 
__need_time_t


85 #if !
defined
 
__clockid_t_defined
 && \

86 ((
defined
 
_TIME_H
 && defined 
__USE_POSIX199309
) || defined 
__need_clockid_t
)

87 #define 
	#__clockid_t_defined
 1

	)

89 #include 
	~<bits/types.h
>

92 typedef 
__clockid_t
 
	tclockid_t
;

95 #undef 
__clockid_time_t


97 #if !
defined
 
__timer_t_defined
 && \

98 ((
defined
 
_TIME_H
 && defined 
__USE_POSIX199309
) || defined 
__need_timer_t
)

99 #define 
	#__timer_t_defined
 1

	)

101 #include 
	~<bits/types.h
>

104 typedef 
__timer_t
 
	ttimer_t
;

107 #undef 
__need_timer_t


110 #if !
defined
 
__timespec_defined
 && \

111 ((
defined
 
_TIME_H
 && \

112 (
defined
 
__USE_POSIX199309
 || defined 
__USE_MISC
)) || \

113 
defined
 
__need_timespec
)

114 #define 
	#__timespec_defined
 1

	)

116 #include 
	~<bits/types.h
>

120 struct 
	stimespec


122 
__time_t
 
tv_sec
;

123 long int 
tv_nsec
;

127 #undef 
__need_timespec


130 #ifdef 
_TIME_H


131 
__BEGIN_NAMESPACE_STD


133 struct 
	stm


135 int 
tm_sec
;

136 int 
tm_min
;

137 int 
tm_hour
;

138 int 
tm_mday
;

139 int 
tm_mon
;

140 int 
tm_year
;

141 int 
tm_wday
;

142 int 
tm_yday
;

143 int 
tm_isdst
;

145 #ifdef 
__USE_BSD


146 long int 
tm_gmtoff
;

147 
__const
 char *
tm_zone
;

149 long int 
__tm_gmtoff
;

150 
__const
 char *
__tm_zone
;

153 
__END_NAMESPACE_STD


154 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_POSIX
 || defined 
__USE_MISC


155 
	$__USING_NAMESPACE_STD
(
tm
)

159 #ifdef 
__USE_POSIX199309


161 struct 
	sitimerspec


163 struct 
timespec
 
it_interval
;

164 struct 
timespec
 
it_value
;

168 struct 
sigevent
;

172 #ifdef 
__USE_XOPEN2K


173 #ifndef 
__pid_t_defined


174 typedef 
__pid_t
 
	tpid_t
;

175 #define 
	#__pid_t_defined


	)

180 
__BEGIN_NAMESPACE_STD


183 extern 
clock_t
 
	$clock
 (void) 
__THROW
;

186 extern 
time_t
 
	$time
 (
time_t
 *
__timer
) 
__THROW
;

189 extern double 
	$difftime
 (
time_t
 
__time1
, time_t 
__time0
)

190 
__THROW
 
	`__attribute__
 ((
__const__
));

193 extern 
time_t
 
	$mktime
 (struct 
tm
 *
__tp
) 
__THROW
;

199 extern 
size_t
 
	$strftime
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

200 
__const
 char *
__restrict
 
__format
,

201 
__const
 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

202 
__END_NAMESPACE_STD


204 #ifdef 
__USE_XOPEN


207 extern char *
	$strptime
 (
__const
 char *
__restrict
 
__s
,

208 
__const
 char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
)

209 
__THROW
;

212 #ifdef 
__USE_XOPEN2K8


215 #include 
	~<xlocale.h
>

217 extern 
size_t
 
	$strftime_l
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

218 
__const
 char *
__restrict
 
__format
,

219 
__const
 struct 
tm
 *
__restrict
 
__tp
,

220 
__locale_t
 
__loc
) 
__THROW
;

223 #ifdef 
__USE_GNU


224 extern char *
	$strptime_l
 (
__const
 char *
__restrict
 
__s
,

225 
__const
 char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
,

226 
__locale_t
 
__loc
) 
__THROW
;

230 
__BEGIN_NAMESPACE_STD


233 extern struct 
tm
 *
	$gmtime
 (
__const
 
time_t
 *
__timer
) 
__THROW
;

237 extern struct 
tm
 *
	$localtime
 (
__const
 
time_t
 *
__timer
) 
__THROW
;

238 
__END_NAMESPACE_STD


240 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


243 extern struct 
tm
 *
	$gmtime_r
 (
__const
 
time_t
 *
__restrict
 
__timer
,

244 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

248 extern struct 
tm
 *
	$localtime_r
 (
__const
 
time_t
 *
__restrict
 
__timer
,

249 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

252 
__BEGIN_NAMESPACE_STD


255 extern char *
	$asctime
 (
__const
 struct 
tm
 *
__tp
) 
__THROW
;

258 extern char *
	$ctime
 (
__const
 
time_t
 *
__timer
) 
__THROW
;

259 
__END_NAMESPACE_STD


261 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


266 extern char *
	$asctime_r
 (
__const
 struct 
tm
 *
__restrict
 
__tp
,

267 char *
__restrict
 
__buf
) 
__THROW
;

270 extern char *
	$ctime_r
 (
__const
 
time_t
 *
__restrict
 
__timer
,

271 char *
__restrict
 
__buf
) 
__THROW
;

276 extern char *
__tzname
[2];

277 extern int 
__daylight
;

278 extern long int 
__timezone
;

281 #ifdef 
__USE_POSIX


283 extern char *
tzname
[2];

287 extern void 
	$tzset
 (void) 
__THROW
;

290 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


291 extern int 
daylight
;

292 extern long int 
timezone
;

295 #ifdef 
__USE_SVID


298 extern int 
	$stime
 (
__const
 
time_t
 *
__when
) 
__THROW
;

304 #define 
	#__isleap
(
year
) \

305 ((
year
) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))

	)

308 #ifdef 
__USE_MISC


313 extern 
time_t
 
	$timegm
 (struct 
tm
 *
__tp
) 
__THROW
;

316 extern 
time_t
 
	$timelocal
 (struct 
tm
 *
__tp
) 
__THROW
;

319 extern int 
	$dysize
 (int 
__year
) 
__THROW
 
	`__attribute__
 ((
__const__
));

323 #ifdef 
__USE_POSIX199309


328 extern int 
	`nanosleep
 (
__const
 struct 
timespec
 *
__requested_time
,

329 struct 
timespec
 *
__remaining
);

333 extern int 
	$clock_getres
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__res
) 
__THROW
;

336 extern int 
	$clock_gettime
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__tp
) 
__THROW
;

339 extern int 
	$clock_settime
 (
clockid_t
 
__clock_id
, 
__const
 struct 
timespec
 *
__tp
)

340 
__THROW
;

342 #ifdef 
__USE_XOPEN2K


347 extern int 
	`clock_nanosleep
 (
clockid_t
 
__clock_id
, int 
__flags
,

348 
__const
 struct 
timespec
 *
__req
,

349 struct 
timespec
 *
__rem
);

352 extern int 
	$clock_getcpuclockid
 (
pid_t
 
__pid
, 
clockid_t
 *
__clock_id
) 
__THROW
;

357 extern int 
	$timer_create
 (
clockid_t
 
__clock_id
,

358 struct 
sigevent
 *
__restrict
 
__evp
,

359 
timer_t
 *
__restrict
 
__timerid
) 
__THROW
;

362 extern int 
	$timer_delete
 (
timer_t
 
__timerid
) 
__THROW
;

365 extern int 
	$timer_settime
 (
timer_t
 
__timerid
, int 
__flags
,

366 
__const
 struct 
itimerspec
 *
__restrict
 
__value
,

367 struct 
itimerspec
 *
__restrict
 
__ovalue
) 
__THROW
;

370 extern int 
	$timer_gettime
 (
timer_t
 
__timerid
, struct 
itimerspec
 *
__value
)

371 
__THROW
;

374 extern int 
	$timer_getoverrun
 (
timer_t
 
__timerid
) 
__THROW
;

378 #ifdef 
__USE_XOPEN_EXTENDED


390 extern int 
getdate_err
;

399 extern struct 
tm
 *
	`getdate
 (
__const
 char *
__string
);

402 #ifdef 
__USE_GNU


413 extern int 
	`getdate_r
 (
__const
 char *
__restrict
 
__string
,

414 struct 
tm
 *
__restrict
 
__resbufp
);

417 
__END_DECLS


	@/usr/include/unistd.h

23 #ifndef 
_UNISTD_H


24 #define 
	#_UNISTD_H
 1

	)

26 #include 
	~<features.h
>

28 
	g__BEGIN_DECLS


33 #ifdef 
__USE_XOPEN2K8


35 #define 
	#_POSIX_VERSION
 200809L

	)

36 #elif 
defined
 
__USE_XOPEN2K


38 #define 
	#_POSIX_VERSION
 200112L

	)

39 #elif 
defined
 
__USE_POSIX199506


41 #define 
	#_POSIX_VERSION
 199506L

	)

42 #elif 
defined
 
__USE_POSIX199309


44 #define 
	#_POSIX_VERSION
 199309L

	)

47 #define 
	#_POSIX_VERSION
 199009L

	)

53 #ifdef 
__USE_XOPEN2K8


54 #define 
	#__POSIX2_THIS_VERSION
 200809L

	)

56 #elif 
defined
 
__USE_XOPEN2K


58 #define 
	#__POSIX2_THIS_VERSION
 200112L

	)

59 #elif 
defined
 
__USE_POSIX199506


61 #define 
	#__POSIX2_THIS_VERSION
 199506L

	)

64 #define 
	#__POSIX2_THIS_VERSION
 199209L

	)

68 #define 
	#_POSIX2_VERSION
 
__POSIX2_THIS_VERSION


	)

72 #define 
	#_POSIX2_C_BIND
 
__POSIX2_THIS_VERSION


	)

76 #define 
	#_POSIX2_C_DEV
 
__POSIX2_THIS_VERSION


	)

80 #define 
	#_POSIX2_SW_DEV
 
__POSIX2_THIS_VERSION


	)

84 #define 
	#_POSIX2_LOCALEDEF
 
__POSIX2_THIS_VERSION


	)

87 #ifdef 
__USE_XOPEN2K8


88 #define 
	#_XOPEN_VERSION
 700

	)

89 #elif 
defined
 
__USE_XOPEN2K


90 #define 
	#_XOPEN_VERSION
 600

	)

91 #elif 
defined
 
__USE_UNIX98


92 #define 
	#_XOPEN_VERSION
 500

	)

94 #define 
	#_XOPEN_VERSION
 4

	)

98 #define 
	#_XOPEN_XCU_VERSION
 4

	)

101 #define 
	#_XOPEN_XPG2
 1

	)

102 #define 
	#_XOPEN_XPG3
 1

	)

103 #define 
	#_XOPEN_XPG4
 1

	)

106 #define 
	#_XOPEN_UNIX
 1

	)

109 #define 
	#_XOPEN_CRYPT
 1

	)

113 #define 
	#_XOPEN_ENH_I18N
 1

	)

116 #define 
	#_XOPEN_LEGACY
 1

	)

203 #include 
	~<bits/posix_opt.h
>

206 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


207 #include 
	~<bits/environments.h
>

211 #define 
	#STDIN_FILENO
 0

	)

212 #define 
	#STDOUT_FILENO
 1

	)

213 #define 
	#STDERR_FILENO
 2

	)

218 #include 
	~<bits/types.h
>

220 #ifndef 
__ssize_t_defined


221 typedef 
__ssize_t
 
	tssize_t
;

222 #define 
	#__ssize_t_defined


	)

225 #define 
	#__need_size_t


	)

226 #define 
	#__need_NULL


	)

227 #include 
	~<stddef.h
>

229 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K


232 #ifndef 
__gid_t_defined


233 typedef 
__gid_t
 
	tgid_t
;

234 #define 
	#__gid_t_defined


	)

237 #ifndef 
__uid_t_defined


238 typedef 
__uid_t
 
	tuid_t
;

239 #define 
	#__uid_t_defined


	)

242 #ifndef 
__off_t_defined


243 #ifndef 
__USE_FILE_OFFSET64


244 typedef 
__off_t
 
	toff_t
;

246 typedef 
__off64_t
 
	toff_t
;

248 #define 
	#__off_t_defined


	)

250 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


251 typedef 
__off64_t
 
	toff64_t
;

252 #define 
	#__off64_t_defined


	)

255 #ifndef 
__useconds_t_defined


256 typedef 
__useconds_t
 
	tuseconds_t
;

257 #define 
	#__useconds_t_defined


	)

260 #ifndef 
__pid_t_defined


261 typedef 
__pid_t
 
	tpid_t
;

262 #define 
	#__pid_t_defined


	)

266 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K


267 #ifndef 
__intptr_t_defined


268 typedef 
__intptr_t
 
	tintptr_t
;

269 #define 
	#__intptr_t_defined


	)

273 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN


274 #ifndef 
__socklen_t_defined


275 typedef 
__socklen_t
 
	tsocklen_t
;

276 #define 
	#__socklen_t_defined


	)

282 #define 
	#R_OK
 4

	)

283 #define 
	#W_OK
 2

	)

284 #define 
	#X_OK
 1

	)

285 #define 
	#F_OK
 0

	)

288 extern int 
	$access
 (
__const
 char *
__name
, int 
__type
) 
__THROW
 
	`__nonnull
 ((1));

290 #ifdef 
__USE_GNU


293 extern int 
	$euidaccess
 (
__const
 char *
__name
, int 
__type
)

294 
__THROW
 
	`__nonnull
 ((1));

297 extern int 
	$eaccess
 (
__const
 char *
__name
, int 
__type
)

298 
__THROW
 
	`__nonnull
 ((1));

301 #ifdef 
__USE_ATFILE


305 extern int 
	$faccessat
 (int 
__fd
, 
__const
 char *
__file
, int 
__type
, int 
__flag
)

306 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

311 #ifndef 
_STDIO_H


312 #define 
	#SEEK_SET
 0

	)

313 #define 
	#SEEK_CUR
 1

	)

314 #define 
	#SEEK_END
 2

	)

317 #if 
defined
 
__USE_BSD
 && !defined 
L_SET


319 #define 
	#L_SET
 
SEEK_SET


	)

320 #define 
	#L_INCR
 
SEEK_CUR


	)

321 #define 
	#L_XTND
 
SEEK_END


	)

330 #ifndef 
__USE_FILE_OFFSET64


331 extern 
__off_t
 
	$lseek
 (int 
__fd
, 
__off_t
 
__offset
, int 
__whence
) 
__THROW
;

333 #ifdef 
__REDIRECT_NTH


334 extern 
__off64_t
 
	`__REDIRECT_NTH
 (
lseek
,

335 (int 
__fd
, 
__off64_t
 
__offset
, int 
__whence
),

336 
lseek64
);

338 #define 
	#lseek
 
lseek64


	)

341 #ifdef 
__USE_LARGEFILE64


342 extern 
__off64_t
 
	$lseek64
 (int 
__fd
, 
__off64_t
 
__offset
, int 
__whence
)

343 
__THROW
;

350 extern int 
	`close
 (int 
__fd
);

357 extern 
ssize_t
 
	$read
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
) 
__wur
;

363 extern 
ssize_t
 
	$write
 (int 
__fd
, 
__const
 void *
__buf
, 
size_t
 
__n
) 
__wur
;

365 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


366 #ifndef 
__USE_FILE_OFFSET64


373 extern 
ssize_t
 
	$pread
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
,

374 
__off_t
 
__offset
) 
__wur
;

381 extern 
ssize_t
 
	$pwrite
 (int 
__fd
, 
__const
 void *
__buf
, 
size_t
 
__n
,

382 
__off_t
 
__offset
) 
__wur
;

384 #ifdef 
__REDIRECT


385 extern 
ssize_t
 
	`__REDIRECT
 (
pread
, (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
,

386 
__off64_t
 
__offset
),

387 
pread64
) 
__wur
;

388 extern 
ssize_t
 
	`__REDIRECT
 (
pwrite
, (int 
__fd
, 
__const
 void *
__buf
,

389 
size_t
 
__nbytes
, 
__off64_t
 
__offset
),

390 
pwrite64
) 
__wur
;

392 #define 
	#pread
 
pread64


	)

393 #define 
	#pwrite
 
pwrite64


	)

397 #ifdef 
__USE_LARGEFILE64


401 extern 
ssize_t
 
	$pread64
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
,

402 
__off64_t
 
__offset
) 
__wur
;

405 extern 
ssize_t
 
	$pwrite64
 (int 
__fd
, 
__const
 void *
__buf
, 
size_t
 
__n
,

406 
__off64_t
 
__offset
) 
__wur
;

414 extern int 
	$pipe
 (int 
__pipedes
[2]) 
__THROW
 
__wur
;

416 #ifdef 
__USE_GNU


419 extern int 
	$pipe2
 (int 
__pipedes
[2], int 
__flags
) 
__THROW
 
__wur
;

429 extern unsigned int 
	$alarm
 (unsigned int 
__seconds
) 
__THROW
;

441 extern unsigned int 
	`sleep
 (unsigned int 
__seconds
);

443 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

444 || 
defined
 
__USE_BSD


449 extern 
__useconds_t
 
	$ualarm
 (
__useconds_t
 
__value
, __useconds_t 
__interval
)

450 
__THROW
;

457 extern int 
	`usleep
 (
__useconds_t
 
__useconds
);

466 extern int 
	`pause
 (void);

470 extern int 
	$chown
 (
__const
 char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

471 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

473 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


475 extern int 
	$fchown
 (int 
__fd
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
) 
__THROW
 
__wur
;

480 extern int 
	$lchown
 (
__const
 char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

481 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

485 #ifdef 
__USE_ATFILE


488 extern int 
	$fchownat
 (int 
__fd
, 
__const
 char *
__file
, 
__uid_t
 
__owner
,

489 
__gid_t
 
__group
, int 
__flag
)

490 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

494 extern int 
	$chdir
 (
__const
 char *
__path
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

496 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


498 extern int 
	$fchdir
 (int 
__fd
) 
__THROW
 
__wur
;

508 extern char *
	$getcwd
 (char *
__buf
, 
size_t
 
__size
) 
__THROW
 
__wur
;

510 #ifdef 
__USE_GNU


514 extern char *
	$get_current_dir_name
 (void) 
__THROW
;

517 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

518 || 
defined
 
__USE_BSD


522 extern char *
	$getwd
 (char *
__buf
)

523 
__THROW
 
	`__nonnull
 ((1)) 
__attribute_deprecated__
 
__wur
;

528 extern int 
	$dup
 (int 
__fd
) 
__THROW
 
__wur
;

531 extern int 
	$dup2
 (int 
__fd
, int 
__fd2
) 
__THROW
;

533 #ifdef 
__USE_GNU


536 extern int 
	$dup3
 (int 
__fd
, int 
__fd2
, int 
__flags
) 
__THROW
;

540 extern char **
__environ
;

541 #ifdef 
__USE_GNU


542 extern char **
environ
;

548 extern int 
	$execve
 (
__const
 char *
__path
, char *__const 
__argv
[],

549 char *
__const
 
__envp
[]) 
__THROW
 
	`__nonnull
 ((1, 2));

551 #ifdef 
__USE_XOPEN2K8


554 extern int 
	$fexecve
 (int 
__fd
, char *
__const
 
__argv
[], char *__const 
__envp
[])

555 
__THROW
 
	`__nonnull
 ((2));

560 extern int 
	$execv
 (
__const
 char *
__path
, char *__const 
__argv
[])

561 
__THROW
 
	`__nonnull
 ((1, 2));

565 extern int 
	$execle
 (
__const
 char *
__path
, __const char *
__arg
, ...)

566 
__THROW
 
	`__nonnull
 ((1, 2));

570 extern int 
	$execl
 (
__const
 char *
__path
, __const char *
__arg
, ...)

571 
__THROW
 
	`__nonnull
 ((1, 2));

575 extern int 
	$execvp
 (
__const
 char *
__file
, char *__const 
__argv
[])

576 
__THROW
 
	`__nonnull
 ((1, 2));

581 extern int 
	$execlp
 (
__const
 char *
__file
, __const char *
__arg
, ...)

582 
__THROW
 
	`__nonnull
 ((1, 2));

584 #ifdef 
__USE_GNU


587 extern int 
	$execvpe
 (
__const
 char *
__file
, char *__const 
__argv
[],

588 char *
__const
 
__envp
[])

589 
__THROW
 
	`__nonnull
 ((1, 2));

593 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


595 extern int 
	$nice
 (int 
__inc
) 
__THROW
 
__wur
;

600 extern void 
	$_exit
 (int 
__status
) 
	`__attribute__
 ((
__noreturn__
));

606 #include 
	~<bits/confname.h
>

609 extern long int 
	$pathconf
 (
__const
 char *
__path
, int 
__name
)

610 
__THROW
 
	`__nonnull
 ((1));

613 extern long int 
	$fpathconf
 (int 
__fd
, int 
__name
) 
__THROW
;

616 extern long int 
	$sysconf
 (int 
__name
) 
__THROW
;

618 #ifdef 
__USE_POSIX2


620 extern 
size_t
 
	$confstr
 (int 
__name
, char *
__buf
, 
size_t
 
__len
) 
__THROW
;

625 extern 
__pid_t
 
	$getpid
 (void) 
__THROW
;

628 extern 
__pid_t
 
	$getppid
 (void) 
__THROW
;

632 #ifndef 
__FAVOR_BSD


633 extern 
__pid_t
 
	$getpgrp
 (void) 
__THROW
;

635 #ifdef 
__REDIRECT_NTH


636 extern 
__pid_t
 
	`__REDIRECT_NTH
 (
getpgrp
, (__pid_t 
__pid
), 
__getpgid
);

638 #define 
	#getpgrp
 
__getpgid


	)

643 extern 
__pid_t
 
	$__getpgid
 (
__pid_t
 
__pid
) 
__THROW
;

644 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


645 extern 
__pid_t
 
	$getpgid
 (
__pid_t
 
__pid
) 
__THROW
;

652 extern int 
	$setpgid
 (
__pid_t
 
__pid
, __pid_t 
__pgid
) 
__THROW
;

654 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


665 #ifndef 
__FAVOR_BSD


669 extern int 
	$setpgrp
 (void) 
__THROW
;

674 #ifdef 
__REDIRECT_NTH


675 extern int 
	`__REDIRECT_NTH
 (
setpgrp
, (
__pid_t
 
__pid
, __pid_t 
__pgrp
), 
setpgid
);

677 #define 
	#setpgrp
 
setpgid


	)

686 extern 
__pid_t
 
	$setsid
 (void) 
__THROW
;

688 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


690 extern 
__pid_t
 
	$getsid
 (
__pid_t
 
__pid
) 
__THROW
;

694 extern 
__uid_t
 
	$getuid
 (void) 
__THROW
;

697 extern 
__uid_t
 
	$geteuid
 (void) 
__THROW
;

700 extern 
__gid_t
 
	$getgid
 (void) 
__THROW
;

703 extern 
__gid_t
 
	$getegid
 (void) 
__THROW
;

708 extern int 
	$getgroups
 (int 
__size
, 
__gid_t
 
__list
[]) 
__THROW
 
__wur
;

710 #ifdef 
__USE_GNU


712 extern int 
	$group_member
 (
__gid_t
 
__gid
) 
__THROW
;

719 extern int 
	$setuid
 (
__uid_t
 
__uid
) 
__THROW
;

721 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


724 extern int 
	$setreuid
 (
__uid_t
 
__ruid
, __uid_t 
__euid
) 
__THROW
;

727 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K


729 extern int 
	$seteuid
 (
__uid_t
 
__uid
) 
__THROW
;

736 extern int 
	$setgid
 (
__gid_t
 
__gid
) 
__THROW
;

738 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


741 extern int 
	$setregid
 (
__gid_t
 
__rgid
, __gid_t 
__egid
) 
__THROW
;

744 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K


746 extern int 
	$setegid
 (
__gid_t
 
__gid
) 
__THROW
;

749 #ifdef 
__USE_GNU


752 extern int 
	$getresuid
 (
__uid_t
 *
__ruid
, __uid_t *
__euid
, __uid_t *
__suid
)

753 
__THROW
;

757 extern int 
	$getresgid
 (
__gid_t
 *
__rgid
, __gid_t *
__egid
, __gid_t *
__sgid
)

758 
__THROW
;

762 extern int 
	$setresuid
 (
__uid_t
 
__ruid
, __uid_t 
__euid
, __uid_t 
__suid
)

763 
__THROW
;

767 extern int 
	$setresgid
 (
__gid_t
 
__rgid
, __gid_t 
__egid
, __gid_t 
__sgid
)

768 
__THROW
;

775 extern 
__pid_t
 
	$fork
 (void) 
__THROW
;

777 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

778 || 
defined
 
__USE_BSD


783 extern 
__pid_t
 
	$vfork
 (void) 
__THROW
;

789 extern char *
	$ttyname
 (int 
__fd
) 
__THROW
;

793 extern int 
	$ttyname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

794 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

798 extern int 
	$isatty
 (int 
__fd
) 
__THROW
;

800 #if 
defined
 
__USE_BSD
 \

801 || (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_UNIX98
)

804 extern int 
	$ttyslot
 (void) 
__THROW
;

809 extern int 
	$link
 (
__const
 char *
__from
, __const char *
__to
)

810 
__THROW
 
	`__nonnull
 ((1, 2)) 
__wur
;

812 #ifdef 
__USE_ATFILE


815 extern int 
	$linkat
 (int 
__fromfd
, 
__const
 char *
__from
, int 
__tofd
,

816 
__const
 char *
__to
, int 
__flags
)

817 
__THROW
 
	`__nonnull
 ((2, 4)) 
__wur
;

820 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K


822 extern int 
	$symlink
 (
__const
 char *
__from
, __const char *
__to
)

823 
__THROW
 
	`__nonnull
 ((1, 2)) 
__wur
;

828 extern 
ssize_t
 
	$readlink
 (
__const
 char *
__restrict
 
__path
,

829 char *
__restrict
 
__buf
, 
size_t
 
__len
)

830 
__THROW
 
	`__nonnull
 ((1, 2)) 
__wur
;

833 #ifdef 
__USE_ATFILE


835 extern int 
	$symlinkat
 (
__const
 char *
__from
, int 
__tofd
,

836 
__const
 char *
__to
) 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

839 extern 
ssize_t
 
	$readlinkat
 (int 
__fd
, 
__const
 char *
__restrict
 
__path
,

840 char *
__restrict
 
__buf
, 
size_t
 
__len
)

841 
__THROW
 
	`__nonnull
 ((2, 3)) 
__wur
;

845 extern int 
	$unlink
 (
__const
 char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

847 #ifdef 
__USE_ATFILE


849 extern int 
	$unlinkat
 (int 
__fd
, 
__const
 char *
__name
, int 
__flag
)

850 
__THROW
 
	`__nonnull
 ((2));

854 extern int 
	$rmdir
 (
__const
 char *
__path
) 
__THROW
 
	`__nonnull
 ((1));

858 extern 
__pid_t
 
	$tcgetpgrp
 (int 
__fd
) 
__THROW
;

861 extern int 
	$tcsetpgrp
 (int 
__fd
, 
__pid_t
 
__pgrp_id
) 
__THROW
;

868 extern char *
	`getlogin
 (void);

869 #if 
defined
 
__USE_REENTRANT
 || defined 
__USE_POSIX199506


876 extern int 
	$getlogin_r
 (char *
__name
, 
size_t
 
__name_len
) 
	`__nonnull
 ((1));

879 #ifdef 
__USE_BSD


881 extern int 
	$setlogin
 (
__const
 char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

885 #ifdef 
__USE_POSIX2


889 #define 
	#__need_getopt


	)

890 #include 
	~<getopt.h
>

894 #if 
defined
 
__USE_BSD
 || defined 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


898 extern int 
	$gethostname
 (char *
__name
, 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((1));

902 #if 
defined
 
__USE_BSD
 || (defined 
__USE_XOPEN
 && !defined 
__USE_UNIX98
)

905 extern int 
	$sethostname
 (
__const
 char *
__name
, 
size_t
 
__len
)

906 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

910 extern int 
	$sethostid
 (long int 
__id
) 
__THROW
 
__wur
;

916 extern int 
	$getdomainname
 (char *
__name
, 
size_t
 
__len
)

917 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

918 extern int 
	$setdomainname
 (
__const
 char *
__name
, 
size_t
 
__len
)

919 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

925 extern int 
	$vhangup
 (void) 
__THROW
;

928 extern int 
	$revoke
 (
__const
 char *
__file
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

936 extern int 
	$profil
 (unsigned short int *
__sample_buffer
, 
size_t
 
__size
,

937 
size_t
 
__offset
, unsigned int 
__scale
)

938 
__THROW
 
	`__nonnull
 ((1));

944 extern int 
	$acct
 (
__const
 char *
__name
) 
__THROW
;

948 extern char *
	$getusershell
 (void) 
__THROW
;

949 extern void 
	$endusershell
 (void) 
__THROW
;

950 extern void 
	$setusershell
 (void) 
__THROW
;

956 extern int 
	$daemon
 (int 
__nochdir
, int 
__noclose
) 
__THROW
 
__wur
;

960 #if 
defined
 
__USE_BSD
 || (defined 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

963 extern int 
	$chroot
 (
__const
 char *
__path
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

967 extern char *
	$getpass
 (
__const
 char *
__prompt
) 
	`__nonnull
 ((1));

971 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN
 || defined 
__USE_XOPEN2K


976 extern int 
	`fsync
 (int 
__fd
);

980 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


983 extern long int 
	`gethostid
 (void);

986 extern void 
	$sync
 (void) 
__THROW
;

989 #if 
defined
 
__USE_BSD
 || !defined 
__USE_XOPEN2K


992 extern int 
	$getpagesize
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

997 extern int 
	$getdtablesize
 (void) 
__THROW
;

1003 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


1006 #ifndef 
__USE_FILE_OFFSET64


1007 extern int 
	$truncate
 (
__const
 char *
__file
, 
__off_t
 
__length
)

1008 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

1010 #ifdef 
__REDIRECT_NTH


1011 extern int 
	`__REDIRECT_NTH
 (
truncate
,

1012 (
__const
 char *
__file
, 
__off64_t
 
__length
),

1013 
truncate64
) 
	`__nonnull
 ((1)) 
__wur
;

1015 #define 
	#truncate
 
truncate64


	)

1018 #ifdef 
__USE_LARGEFILE64


1019 extern int 
	$truncate64
 (
__const
 char *
__file
, 
__off64_t
 
__length
)

1020 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

1025 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K


1028 #ifndef 
__USE_FILE_OFFSET64


1029 extern int 
	$ftruncate
 (int 
__fd
, 
__off_t
 
__length
) 
__THROW
 
__wur
;

1031 #ifdef 
__REDIRECT_NTH


1032 extern int 
	`__REDIRECT_NTH
 (
ftruncate
, (int 
__fd
, 
__off64_t
 
__length
),

1033 
ftruncate64
) 
__wur
;

1035 #define 
	#ftruncate
 
ftruncate64


	)

1038 #ifdef 
__USE_LARGEFILE64


1039 extern int 
	$ftruncate64
 (int 
__fd
, 
__off64_t
 
__length
) 
__THROW
 
__wur
;

1045 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

1046 || 
defined
 
__USE_MISC


1050 extern int 
	$brk
 (void *
__addr
) 
__THROW
 
__wur
;

1056 extern void *
	$sbrk
 (
intptr_t
 
__delta
) 
__THROW
;

1060 #ifdef 
__USE_MISC


1071 extern long int 
	$syscall
 (long int 
__sysno
, ...) 
__THROW
;

1076 #if (
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
) && !defined 
F_LOCK


1088 #define 
	#F_ULOCK
 0

	)

1089 #define 
	#F_LOCK
 1

	)

1090 #define 
	#F_TLOCK
 2

	)

1091 #define 
	#F_TEST
 3

	)

1093 #ifndef 
__USE_FILE_OFFSET64


1094 extern int 
	$lockf
 (int 
__fd
, int 
__cmd
, 
__off_t
 
__len
) 
__wur
;

1096 #ifdef 
__REDIRECT


1097 extern int 
	`__REDIRECT
 (
lockf
, (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
),

1098 
lockf64
) 
__wur
;

1100 #define 
	#lockf
 
lockf64


	)

1103 #ifdef 
__USE_LARGEFILE64


1104 extern int 
	$lockf64
 (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
) 
__wur
;

1109 #ifdef 
__USE_GNU


1114 #define 
	#TEMP_FAILURE_RETRY
(
expression
) \

1115 (
__extension__
 \

1116 ({ long int 
__result
; \

1117 do 
__result
 = (long int) (
expression
); \

1118 while (
__result
 == -1L && 
errno
 == 
EINTR
); \

1119 
__result
; 
	}
}))

	)

1122 #if 
defined
 
__USE_POSIX199309
 || defined 
__USE_UNIX98


1125 extern int 
fdatasync
 (int 
__fildes
);

1131 #ifdef 
__USE_XOPEN


1133 extern char *
	$crypt
 (
__const
 char *
__key
, __const char *
__salt
)

1134 
__THROW
 
	`__nonnull
 ((1, 2));

1138 extern void 
	$encrypt
 (char *
__libc_block
, int 
__edflag
) 
__THROW
 
	`__nonnull
 ((1));

1145 extern void 
	$swab
 (
__const
 void *
__restrict
 
__from
, void *__restrict 
__to
,

1146 
ssize_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

1152 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


1154 extern char *
	$ctermid
 (char *
__s
) 
__THROW
;

1159 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


1160 #include 
	~<bits/unistd.h
>

1163 
__END_DECLS


	@/usr/include/wchar.h

24 #ifndef 
_WCHAR_H


26 #if !
defined
 
__need_mbstate_t
 && !defined 
__need_wint_t


27 #define 
	#_WCHAR_H
 1

	)

28 #include 
	~<features.h
>

31 #ifdef 
_WCHAR_H


33 #define 
	#__need___FILE


	)

34 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


35 #define 
	#__need_FILE


	)

37 #include 
	~<stdio.h
>

39 #define 
	#__need___va_list


	)

40 #include 
	~<stdarg.h
>

42 #include 
	~<bits/wchar.h
>

45 #define 
	#__need_size_t


	)

46 #define 
	#__need_wchar_t


	)

47 #define 
	#__need_NULL


	)

49 #if 
defined
 
_WCHAR_H
 || defined 
__need_wint_t
 || !defined 
__WINT_TYPE__


50 #undef 
__need_wint_t


51 #define 
	#__need_wint_t


	)

52 #include 
	~<stddef.h
>

56 #ifndef 
_WINT_T


61 #define 
	#_WINT_T


	)

62 typedef unsigned int 
	twint_t
;

66 #if 
defined
 
__cplusplus
 && defined 
_GLIBCPP_USE_NAMESPACES
 \

67 && 
defined
 
__WINT_TYPE__


68 
__BEGIN_NAMESPACE_STD


69 typedef 
__WINT_TYPE__
 
	twint_t
;

70 
	g__END_NAMESPACE_STD


75 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

76 #define 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

80 #if (
defined
 
_WCHAR_H
 || defined 
__need_mbstate_t
) && !defined 
__mbstate_t_defined


81 #define 
	#__mbstate_t_defined
 1

	)

85 int 
	m__count
;

88 #ifdef 
__WINT_TYPE__


89 
__WINT_TYPE__
 
	m__wch
;

91 
wint_t
 
	m__wch
;

93 char 
	m__wchb
[4];

94 } 
	m__value
;

95 } 
	t__mbstate_t
;

97 #undef 
__need_mbstate_t


102 #ifdef 
_WCHAR_H


104 
__BEGIN_NAMESPACE_C99


106 typedef 
__mbstate_t
 
	tmbstate_t
;

107 
	g__END_NAMESPACE_C99


108 #ifdef 
__USE_GNU


109 
	$__USING_NAMESPACE_C99
(
mbstate_t
)

112 #ifndef 
WCHAR_MIN


114 #define 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

115 #define 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

118 #ifndef 
WEOF


119 #define 
	#WEOF
 (0xffffffffu)

	)

124 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_UNIX98


125 #include 
	~<wctype.h
>

129 
__BEGIN_DECLS


131 
__BEGIN_NAMESPACE_STD


134 struct 
tm
;

135 
__END_NAMESPACE_STD


139 
	$__USING_NAMESPACE_STD
(
tm
)

142 
__BEGIN_NAMESPACE_STD


144 extern 
wchar_t
 *
	$wcscpy
 (
wchar_t
 *
__restrict
 
__dest
,

145 
__const
 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

147 extern 
wchar_t
 *
	$wcsncpy
 (
wchar_t
 *
__restrict
 
__dest
,

148 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

149 
__THROW
;

152 extern 
wchar_t
 *
	$wcscat
 (
wchar_t
 *
__restrict
 
__dest
,

153 
__const
 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

155 extern 
wchar_t
 *
	$wcsncat
 (
wchar_t
 *
__restrict
 
__dest
,

156 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

157 
__THROW
;

160 extern int 
	$wcscmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
)

161 
__THROW
 
__attribute_pure__
;

163 extern int 
	$wcsncmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
, 
size_t
 
__n
)

164 
__THROW
 
__attribute_pure__
;

165 
__END_NAMESPACE_STD


167 #ifdef 
__USE_XOPEN2K8


169 extern int 
	$wcscasecmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
) 
__THROW
;

172 extern int 
	$wcsncasecmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

173 
size_t
 
__n
) 
__THROW
;

177 #include 
	~<xlocale.h
>

179 extern int 
	$wcscasecmp_l
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

180 
__locale_t
 
__loc
) 
__THROW
;

182 extern int 
	$wcsncasecmp_l
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

183 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

186 
__BEGIN_NAMESPACE_STD


189 extern int 
	$wcscoll
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
) 
__THROW
;

193 extern 
size_t
 
	$wcsxfrm
 (
wchar_t
 *
__restrict
 
__s1
,

194 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

195 
__END_NAMESPACE_STD


197 #ifdef 
__USE_XOPEN2K8


203 extern int 
	$wcscoll_l
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

204 
__locale_t
 
__loc
) 
__THROW
;

209 extern 
size_t
 
	$wcsxfrm_l
 (
wchar_t
 *
__s1
, 
__const
 wchar_t *
__s2
,

210 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

213 extern 
wchar_t
 *
	$wcsdup
 (
__const
 
wchar_t
 *
__s
) 
__THROW
 
__attribute_malloc__
;

216 
__BEGIN_NAMESPACE_STD


218 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


219 extern "C++" 
wchar_t
 *
	$wcschr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

220 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

221 extern "C++" 
__const
 
wchar_t
 *
	$wcschr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

222 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

224 extern 
wchar_t
 *
	$wcschr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

225 
__THROW
 
__attribute_pure__
;

228 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


229 extern "C++" 
wchar_t
 *
	$wcsrchr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

230 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

231 extern "C++" 
__const
 
wchar_t
 *
	$wcsrchr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

232 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

234 extern 
wchar_t
 *
	$wcsrchr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

235 
__THROW
 
__attribute_pure__
;

237 
__END_NAMESPACE_STD


239 #ifdef 
__USE_GNU


242 extern 
wchar_t
 *
	$wcschrnul
 (
__const
 
wchar_t
 *
__s
, wchar_t 
__wc
)

243 
__THROW
 
__attribute_pure__
;

246 
__BEGIN_NAMESPACE_STD


249 extern 
size_t
 
	$wcscspn
 (
__const
 
wchar_t
 *
__wcs
, __const wchar_t *
__reject
)

250 
__THROW
 
__attribute_pure__
;

253 extern 
size_t
 
	$wcsspn
 (
__const
 
wchar_t
 *
__wcs
, __const wchar_t *
__accept
)

254 
__THROW
 
__attribute_pure__
;

256 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


257 extern "C++" 
wchar_t
 *
	$wcspbrk
 (
wchar_t
 *
__wcs
, 
__const
 wchar_t *
__accept
)

258 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

259 extern "C++" 
__const
 
wchar_t
 *
	$wcspbrk
 (
__const
 
wchar_t
 *
__wcs
,

260 
__const
 
wchar_t
 *
__accept
)

261 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

263 extern 
wchar_t
 *
	$wcspbrk
 (
__const
 
wchar_t
 *
__wcs
, __const wchar_t *
__accept
)

264 
__THROW
 
__attribute_pure__
;

267 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


268 extern "C++" 
wchar_t
 *
	$wcsstr
 (
wchar_t
 *
__haystack
, 
__const
 wchar_t *
__needle
)

269 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

270 extern "C++" 
__const
 
wchar_t
 *
	$wcsstr
 (
__const
 
wchar_t
 *
__haystack
,

271 
__const
 
wchar_t
 *
__needle
)

272 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

274 extern 
wchar_t
 *
	$wcsstr
 (
__const
 
wchar_t
 *
__haystack
, __const wchar_t *
__needle
)

275 
__THROW
 
__attribute_pure__
;

279 extern 
wchar_t
 *
	$wcstok
 (
wchar_t
 *
__restrict
 
__s
,

280 
__const
 
wchar_t
 *
__restrict
 
__delim
,

281 
wchar_t
 **
__restrict
 
__ptr
) 
__THROW
;

284 extern 
size_t
 
	$wcslen
 (
__const
 
wchar_t
 *
__s
) 
__THROW
 
__attribute_pure__
;

285 
__END_NAMESPACE_STD


287 #ifdef 
__USE_XOPEN


289 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


290 extern "C++" 
wchar_t
 *
	$wcswcs
 (
wchar_t
 *
__haystack
, 
__const
 wchar_t *
__needle
)

291 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

292 extern "C++" 
__const
 
wchar_t
 *
	$wcswcs
 (
__const
 
wchar_t
 *
__haystack
,

293 
__const
 
wchar_t
 *
__needle
)

294 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

296 extern 
wchar_t
 *
	$wcswcs
 (
__const
 
wchar_t
 *
__haystack
, __const wchar_t *
__needle
)

297 
__THROW
 
__attribute_pure__
;

301 #ifdef 
__USE_XOPEN2K8


303 extern 
size_t
 
	$wcsnlen
 (
__const
 
wchar_t
 *
__s
, 
size_t
 
__maxlen
)

304 
__THROW
 
__attribute_pure__
;

308 
__BEGIN_NAMESPACE_STD


310 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


311 extern "C++" 
wchar_t
 *
	$wmemchr
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

312 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

313 extern "C++" 
__const
 
wchar_t
 *
	$wmemchr
 (
__const
 
wchar_t
 *
__s
, wchar_t 
__c
,

314 
size_t
 
__n
)

315 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

317 extern 
wchar_t
 *
	$wmemchr
 (
__const
 
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

318 
__THROW
 
__attribute_pure__
;

322 extern int 
	$wmemcmp
 (
__const
 
wchar_t
 *
__restrict
 
__s1
,

323 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
)

324 
__THROW
 
__attribute_pure__
;

327 extern 
wchar_t
 *
	$wmemcpy
 (
wchar_t
 *
__restrict
 
__s1
,

328 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

332 extern 
wchar_t
 *
	$wmemmove
 (
wchar_t
 *
__s1
, 
__const
 wchar_t *
__s2
, 
size_t
 
__n
)

333 
__THROW
;

336 extern 
wchar_t
 *
	$wmemset
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
) 
__THROW
;

337 
__END_NAMESPACE_STD


339 #ifdef 
__USE_GNU


342 extern 
wchar_t
 *
	$wmempcpy
 (
wchar_t
 *
__restrict
 
__s1
,

343 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
)

344 
__THROW
;

348 
__BEGIN_NAMESPACE_STD


351 extern 
wint_t
 
	$btowc
 (int 
__c
) 
__THROW
;

355 extern int 
	$wctob
 (
wint_t
 
__c
) 
__THROW
;

359 extern int 
	$mbsinit
 (
__const
 
mbstate_t
 *
__ps
) 
__THROW
 
__attribute_pure__
;

363 extern 
size_t
 
	$mbrtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

364 
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

365 
mbstate_t
 *
__p
) 
__THROW
;

368 extern 
size_t
 
	$wcrtomb
 (char *
__restrict
 
__s
, 
wchar_t
 
__wc
,

369 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

372 extern 
size_t
 
	$__mbrlen
 (
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

373 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

374 extern 
size_t
 
	$mbrlen
 (
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

375 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

376 
__END_NAMESPACE_STD


378 #ifdef 
__USE_EXTERN_INLINES


384 extern 
wint_t
 
	$__btowc_alias
 (int 
__c
) 
	`__asm
 ("btowc");

385 
__extern_inline
 
wint_t


386 
	`__NTH
 (
	$btowc
 (int 
__c
))

387 { return (
	`__builtin_constant_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

388 ? (
wint_t
) 
__c
 : 
	`__btowc_alias
 (__c)); 
	}
}

390 extern int 
	$__wctob_alias
 (
wint_t
 
__c
) 
	`__asm
 ("wctob");

391 
__extern_inline
 int

392 
	`__NTH
 (
	$wctob
 (
wint_t
 
__wc
))

393 { return (
	`__builtin_constant_p
 (
__wc
) && __wc >= 
L
'\0' && __wc <= L'\x7f'

394 ? (int) 
__wc
 : 
	`__wctob_alias
 (__wc)); 
	}
}

396 
__extern_inline
 
size_t


397 
__NTH
 (
	$mbrlen
 (
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

398 
mbstate_t
 *
__restrict
 
__ps
))

399 { return (
__ps
 != 
NULL


400 ? 
	`mbrtowc
 (
NULL
, 
__s
, 
__n
, 
__ps
) : 
	`__mbrlen
 (__s, __n, NULL)); 
	}
}

403 
__BEGIN_NAMESPACE_STD


406 extern 
size_t
 
	$mbsrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

407 
__const
 char **
__restrict
 
__src
, 
size_t
 
__len
,

408 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

412 extern 
size_t
 
	$wcsrtombs
 (char *
__restrict
 
__dst
,

413 
__const
 
wchar_t
 **
__restrict
 
__src
, 
size_t
 
__len
,

414 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

415 
__END_NAMESPACE_STD


418 #ifdef 
__USE_XOPEN2K8


421 extern 
size_t
 
	$mbsnrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

422 
__const
 char **
__restrict
 
__src
, 
size_t
 
__nmc
,

423 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

427 extern 
size_t
 
	$wcsnrtombs
 (char *
__restrict
 
__dst
,

428 
__const
 
wchar_t
 **
__restrict
 
__src
,

429 
size_t
 
__nwc
, size_t 
__len
,

430 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

435 #ifdef 
__USE_XOPEN


437 extern int 
	$wcwidth
 (
wchar_t
 
__c
) 
__THROW
;

441 extern int 
	$wcswidth
 (
__const
 
wchar_t
 *
__s
, 
size_t
 
__n
) 
__THROW
;

445 
__BEGIN_NAMESPACE_STD


448 extern double 
	$wcstod
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

449 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

450 
__END_NAMESPACE_STD


452 #ifdef 
__USE_ISOC99


453 
__BEGIN_NAMESPACE_C99


455 extern float 
	$wcstof
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

456 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

457 extern long double 
	$wcstold
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

458 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

459 
__END_NAMESPACE_C99


463 
__BEGIN_NAMESPACE_STD


466 extern long int 
	$wcstol
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

467 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

471 extern unsigned long int 
	$wcstoul
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

472 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

473 
__THROW
;

474 
__END_NAMESPACE_STD


476 #if 
defined
 
__USE_ISOC99
 || (defined 
__GNUC__
 && defined 
__USE_GNU
)

477 
__BEGIN_NAMESPACE_C99


480 
__extension__


481 extern long long int 
	$wcstoll
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

482 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

483 
__THROW
;

487 
__extension__


488 extern unsigned long long int 
	$wcstoull
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

489 
wchar_t
 **
__restrict
 
__endptr
,

490 int 
__base
) 
__THROW
;

491 
__END_NAMESPACE_C99


494 #if 
defined
 
__GNUC__
 && defined 
__USE_GNU


497 
__extension__


498 extern long long int 
	$wcstoq
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

499 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

500 
__THROW
;

504 
__extension__


505 extern unsigned long long int 
	$wcstouq
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

506 
wchar_t
 **
__restrict
 
__endptr
,

507 int 
__base
) 
__THROW
;

510 #ifdef 
__USE_GNU


524 #include 
	~<xlocale.h
>

528 extern long int 
	$wcstol_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

529 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
,

530 
__locale_t
 
__loc
) 
__THROW
;

532 extern unsigned long int 
	$wcstoul_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

533 
wchar_t
 **
__restrict
 
__endptr
,

534 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

536 
__extension__


537 extern long long int 
	$wcstoll_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

538 
wchar_t
 **
__restrict
 
__endptr
,

539 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

541 
__extension__


542 extern unsigned long long int 
	$wcstoull_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

543 
wchar_t
 **
__restrict
 
__endptr
,

544 int 
__base
, 
__locale_t
 
__loc
)

545 
__THROW
;

547 extern double 
	$wcstod_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

548 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

549 
__THROW
;

551 extern float 
	$wcstof_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

552 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

553 
__THROW
;

555 extern long double 
	$wcstold_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

556 
wchar_t
 **
__restrict
 
__endptr
,

557 
__locale_t
 
__loc
) 
__THROW
;

562 extern 
wchar_t
 *
	$wcpcpy
 (
wchar_t
 *
__restrict
 
__dest
,

563 
__const
 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

567 extern 
wchar_t
 *
	$wcpncpy
 (
wchar_t
 *
__restrict
 
__dest
,

568 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

569 
__THROW
;

575 #ifdef 
__USE_XOPEN2K8


578 extern 
__FILE
 *
	$open_wmemstream
 (
wchar_t
 **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
;

581 #if 
defined
 
__USE_ISOC95
 || defined 
__USE_UNIX98


582 
__BEGIN_NAMESPACE_STD


585 extern int 
	$fwide
 (
__FILE
 *
__fp
, int 
__mode
) 
__THROW
;

592 extern int 
	`fwprintf
 (
__FILE
 *
__restrict
 
__stream
,

593 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

599 extern int 
	`wprintf
 (
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

602 extern int 
	$swprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

603 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

604 
__THROW
 ;

610 extern int 
	`vfwprintf
 (
__FILE
 *
__restrict
 
__s
,

611 
__const
 
wchar_t
 *
__restrict
 
__format
,

612 
__gnuc_va_list
 
__arg
)

618 extern int 
	`vwprintf
 (
__const
 
wchar_t
 *
__restrict
 
__format
,

619 
__gnuc_va_list
 
__arg
)

623 extern int 
	$vswprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

624 
__const
 
wchar_t
 *
__restrict
 
__format
,

625 
__gnuc_va_list
 
__arg
)

626 
__THROW
 ;

633 extern int 
	`fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

634 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

640 extern int 
	`wscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

643 extern int 
	$swscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

644 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

645 
__THROW
 ;

647 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

648 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

649 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

650 #ifdef 
__REDIRECT


654 extern int 
	`__REDIRECT
 (
fwscanf
, (
__FILE
 *
__restrict
 
__stream
,

655 
__const
 
wchar_t
 *
__restrict
 
__format
, ...),

656 
__isoc99_fwscanf
)

658 extern int 
	`__REDIRECT
 (
wscanf
, (
__const
 
wchar_t
 *
__restrict
 
__format
, ...),

659 
__isoc99_wscanf
)

661 extern int 
	`__REDIRECT_NTH
 (
swscanf
, (
__const
 
wchar_t
 *
__restrict
 
__s
,

662 
__const
 
wchar_t
 *
__restrict
 
__format
,

663 ...), 
__isoc99_swscanf
)

666 extern int 
	`__isoc99_fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

667 
__const
 
wchar_t
 *
__restrict
 
__format
, ...);

668 extern int 
	`__isoc99_wscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
, ...);

669 extern int 
	$__isoc99_swscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

670 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

671 
__THROW
;

672 #define 
	#fwscanf
 
__isoc99_fwscanf


	)

673 #define 
	#wscanf
 
__isoc99_wscanf


	)

674 #define 
	#swscanf
 
__isoc99_swscanf


	)

678 
__END_NAMESPACE_STD


681 #ifdef 
__USE_ISOC99


682 
__BEGIN_NAMESPACE_C99


687 extern int 
	`vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

688 
__const
 
wchar_t
 *
__restrict
 
__format
,

689 
__gnuc_va_list
 
__arg
)

695 extern int 
	`vwscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
,

696 
__gnuc_va_list
 
__arg
)

699 extern int 
	$vswscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

700 
__const
 
wchar_t
 *
__restrict
 
__format
,

701 
__gnuc_va_list
 
__arg
)

702 
__THROW
 ;

704 #if !
defined
 
__USE_GNU
 \

705 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

706 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

707 #ifdef 
__REDIRECT


708 extern int 
	`__REDIRECT
 (
vfwscanf
, (
__FILE
 *
__restrict
 
__s
,

709 
__const
 
wchar_t
 *
__restrict
 
__format
,

710 
__gnuc_va_list
 
__arg
), 
__isoc99_vfwscanf
)

712 extern int 
	`__REDIRECT
 (
vwscanf
, (
__const
 
wchar_t
 *
__restrict
 
__format
,

713 
__gnuc_va_list
 
__arg
), 
__isoc99_vwscanf
)

715 extern int 
	`__REDIRECT_NTH
 (
vswscanf
, (
__const
 
wchar_t
 *
__restrict
 
__s
,

716 
__const
 
wchar_t
 *
__restrict
 
__format
,

717 
__gnuc_va_list
 
__arg
), 
__isoc99_vswscanf
)

720 extern int 
	`__isoc99_vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

721 
__const
 
wchar_t
 *
__restrict
 
__format
,

722 
__gnuc_va_list
 
__arg
);

723 extern int 
	`__isoc99_vwscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
,

724 
__gnuc_va_list
 
__arg
);

725 extern int 
	$__isoc99_vswscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

726 
__const
 
wchar_t
 *
__restrict
 
__format
,

727 
__gnuc_va_list
 
__arg
) 
__THROW
;

728 #define 
	#vfwscanf
 
__isoc99_vfwscanf


	)

729 #define 
	#vwscanf
 
__isoc99_vwscanf


	)

730 #define 
	#vswscanf
 
__isoc99_vswscanf


	)

734 
__END_NAMESPACE_C99


738 
__BEGIN_NAMESPACE_STD


743 extern 
wint_t
 
	`fgetwc
 (
__FILE
 *
__stream
);

744 extern 
wint_t
 
	`getwc
 (
__FILE
 *
__stream
);

750 extern 
wint_t
 
	`getwchar
 (void);

757 extern 
wint_t
 
	`fputwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

758 extern 
wint_t
 
	`putwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

764 extern 
wint_t
 
	`putwchar
 (
wchar_t
 
__wc
);

772 extern 
wchar_t
 *
	`fgetws
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

773 
__FILE
 *
__restrict
 
__stream
);

779 extern int 
	`fputws
 (
__const
 
wchar_t
 *
__restrict
 
__ws
,

780 
__FILE
 *
__restrict
 
__stream
);

787 extern 
wint_t
 
	`ungetwc
 (wint_t 
__wc
, 
__FILE
 *
__stream
);

788 
__END_NAMESPACE_STD


791 #ifdef 
__USE_GNU


799 extern 
wint_t
 
	`getwc_unlocked
 (
__FILE
 *
__stream
);

800 extern 
wint_t
 
	`getwchar_unlocked
 (void);

808 extern 
wint_t
 
	`fgetwc_unlocked
 (
__FILE
 *
__stream
);

816 extern 
wint_t
 
	`fputwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

825 extern 
wint_t
 
	`putwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

826 extern 
wint_t
 
	`putwchar_unlocked
 (
wchar_t
 
__wc
);

835 extern 
wchar_t
 *
	`fgetws_unlocked
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

836 
__FILE
 *
__restrict
 
__stream
);

844 extern int 
	`fputws_unlocked
 (
__const
 
wchar_t
 *
__restrict
 
__ws
,

845 
__FILE
 *
__restrict
 
__stream
);

849 
__BEGIN_NAMESPACE_C99


853 extern 
size_t
 
	$wcsftime
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

854 
__const
 
wchar_t
 *
__restrict
 
__format
,

855 
__const
 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

856 
__END_NAMESPACE_C99


858 #ifdef 
__USE_GNU


859 #include 
	~<xlocale.h
>

863 extern 
size_t
 
	$wcsftime_l
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

864 
__const
 
wchar_t
 *
__restrict
 
__format
,

865 
__const
 struct 
tm
 *
__restrict
 
__tp
,

866 
__locale_t
 
__loc
) 
__THROW
;

875 #if 
defined
 
__USE_UNIX98
 && !defined 
__USE_GNU


876 #define 
	#__need_iswxxx


	)

877 #include 
	~<wctype.h
>

881 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


882 #include 
	~<bits/wchar2.h
>

885 #ifdef 
__LDBL_COMPAT


886 #include 
	~<bits/wchar-ldbl.h
>

889 
__END_DECLS


897 #undef 
__need_mbstate_t


898 #undef 
__need_wint_t


	@/usr/include/wctype.h

24 #ifndef 
_WCTYPE_H


26 #include 
	~<features.h
>

27 #include 
	~<bits/types.h
>

29 #ifndef 
__need_iswxxx


30 #define 
	#_WCTYPE_H
 1

	)

33 #define 
	#__need_wint_t


	)

34 #include 
	~<wchar.h
>

38 #ifndef 
WEOF


39 #define 
	#WEOF
 (0xffffffffu)

	)

42 #undef 
__need_iswxxx


47 #ifndef 
__iswxxx_defined


48 #define 
	#__iswxxx_defined
 1

	)

50 
__BEGIN_NAMESPACE_C99


53 typedef unsigned long int 
	twctype_t
;

54 
	g__END_NAMESPACE_C99


56 #ifndef 
_ISwbit


61 #include 
	~<endian.h
>

62 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


63 #define 
	#_ISwbit
(
bit
) (1 << (bit))

	)

65 #define 
	#_ISwbit
(
bit
) \

66 ((
bit
) < 8 ? (int) ((1UL << (bit)) << 24) \

67 : ((
bit
) < 16 ? (int) ((1UL << (bit)) << 8) \

68 : ((
bit
) < 24 ? (int) ((1UL << (bit)) >> 8) \

69 : (int) ((1UL << (
bit
)) >> 24))))

	)

74 
	m__ISwupper
 = 0,

75 
	m__ISwlower
 = 1,

76 
	m__ISwalpha
 = 2,

77 
	m__ISwdigit
 = 3,

78 
	m__ISwxdigit
 = 4,

79 
	m__ISwspace
 = 5,

80 
	m__ISwprint
 = 6,

81 
	m__ISwgraph
 = 7,

82 
	m__ISwblank
 = 8,

83 
	m__ISwcntrl
 = 9,

84 
	m__ISwpunct
 = 10,

85 
	m__ISwalnum
 = 11,

87 
	m_ISwupper
 = 
_ISwbit
 (
__ISwupper
),

88 
	m_ISwlower
 = 
_ISwbit
 (
__ISwlower
),

89 
	m_ISwalpha
 = 
_ISwbit
 (
__ISwalpha
),

90 
	m_ISwdigit
 = 
_ISwbit
 (
__ISwdigit
),

91 
	m_ISwxdigit
 = 
_ISwbit
 (
__ISwxdigit
),

92 
	m_ISwspace
 = 
_ISwbit
 (
__ISwspace
),

93 
	m_ISwprint
 = 
_ISwbit
 (
__ISwprint
),

94 
	m_ISwgraph
 = 
_ISwbit
 (
__ISwgraph
),

95 
	m_ISwblank
 = 
_ISwbit
 (
__ISwblank
),

96 
	m_ISwcntrl
 = 
_ISwbit
 (
__ISwcntrl
),

97 
	m_ISwpunct
 = 
_ISwbit
 (
__ISwpunct
),

98 
	m_ISwalnum
 = 
_ISwbit
 (
__ISwalnum
)

103 
__BEGIN_DECLS


105 
__BEGIN_NAMESPACE_C99


112 extern int 
	$iswalnum
 (
wint_t
 
__wc
) 
__THROW
;

118 extern int 
	$iswalpha
 (
wint_t
 
__wc
) 
__THROW
;

121 extern int 
	$iswcntrl
 (
wint_t
 
__wc
) 
__THROW
;

125 extern int 
	$iswdigit
 (
wint_t
 
__wc
) 
__THROW
;

129 extern int 
	$iswgraph
 (
wint_t
 
__wc
) 
__THROW
;

134 extern int 
	$iswlower
 (
wint_t
 
__wc
) 
__THROW
;

137 extern int 
	$iswprint
 (
wint_t
 
__wc
) 
__THROW
;

142 extern int 
	$iswpunct
 (
wint_t
 
__wc
) 
__THROW
;

147 extern int 
	$iswspace
 (
wint_t
 
__wc
) 
__THROW
;

152 extern int 
	$iswupper
 (
wint_t
 
__wc
) 
__THROW
;

157 extern int 
	$iswxdigit
 (
wint_t
 
__wc
) 
__THROW
;

162 #ifdef 
__USE_ISOC99


163 extern int 
	$iswblank
 (
wint_t
 
__wc
) 
__THROW
;

172 extern 
wctype_t
 
	$wctype
 (
__const
 char *
__property
) 
__THROW
;

176 extern int 
	$iswctype
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
) 
__THROW
;

177 
__END_NAMESPACE_C99


184 
__BEGIN_NAMESPACE_C99


187 typedef 
__const
 
	t__int32_t
 *
	twctrans_t
;

188 
__END_NAMESPACE_C99


189 #ifdef 
__USE_GNU


190 
	$__USING_NAMESPACE_C99
(
wctrans_t
)

193 
__BEGIN_NAMESPACE_C99


195 extern 
wint_t
 
	$towlower
 (
wint_t
 
__wc
) 
__THROW
;

198 extern 
wint_t
 
	$towupper
 (
wint_t
 
__wc
) 
__THROW
;

199 
__END_NAMESPACE_C99


201 
__END_DECLS


208 #ifdef 
_WCTYPE_H


214 
__BEGIN_DECLS


216 
__BEGIN_NAMESPACE_C99


219 extern 
wctrans_t
 
	$wctrans
 (
__const
 char *
__property
) 
__THROW
;

222 extern 
wint_t
 
	$towctrans
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
) 
__THROW
;

223 
__END_NAMESPACE_C99


225 #ifdef 
__USE_XOPEN2K8


227 #include 
	~<xlocale.h
>

231 extern int 
	$iswalnum_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

237 extern int 
	$iswalpha_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

240 extern int 
	$iswcntrl_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

244 extern int 
	$iswdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

248 extern int 
	$iswgraph_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

253 extern int 
	$iswlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

256 extern int 
	$iswprint_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

261 extern int 
	$iswpunct_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

266 extern int 
	$iswspace_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

271 extern int 
	$iswupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

276 extern int 
	$iswxdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

281 extern int 
	$iswblank_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

285 extern 
wctype_t
 
	$wctype_l
 (
__const
 char *
__property
, 
__locale_t
 
__locale
)

286 
__THROW
;

290 extern int 
	$iswctype_l
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
, 
__locale_t
 
__locale
)

291 
__THROW
;

299 extern 
wint_t
 
	$towlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

302 extern 
wint_t
 
	$towupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

306 extern 
wctrans_t
 
	$wctrans_l
 (
__const
 char *
__property
, 
__locale_t
 
__locale
)

307 
__THROW
;

310 extern 
wint_t
 
	$towctrans_l
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
,

311 
__locale_t
 
__locale
) 
__THROW
;

315 
__END_DECLS


	@/usr/include/xlocale.h

21 #ifndef 
_XLOCALE_H


22 #define 
	#_XLOCALE_H
 1

	)

28 typedef struct 
	s__locale_struct


31 struct 
__locale_data
 *
	m__locales
[13];

34 const unsigned short int *
	m__ctype_b
;

35 const int *
	m__ctype_tolower
;

36 const int *
	m__ctype_toupper
;

39 const char *
	m__names
[13];

40 } *
	t__locale_t
;

43 typedef 
__locale_t
 
	tlocale_t
;

	@/usr/include/endian.h

19 #ifndef 
_ENDIAN_H


20 #define 
	#_ENDIAN_H
 1

	)

22 #include 
	~<features.h
>

32 #define 
	#__LITTLE_ENDIAN
 1234

	)

33 #define 
	#__BIG_ENDIAN
 4321

	)

34 #define 
	#__PDP_ENDIAN
 3412

	)

37 #include 
	~<bits/endian.h
>

41 #ifndef 
__FLOAT_WORD_ORDER


42 #define 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

45 #ifdef 
__USE_BSD


46 #define 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

47 #define 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

48 #define 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

49 #define 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

52 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


53 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) LO, 
	)
HI

54 #elif 
__BYTE_ORDER
 == 
__BIG_ENDIAN


55 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) HI, 
	)
LO

59 #ifdef 
__USE_BSD


61 #include 
	~<bits/byteswap.h
>

63 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


64 #define 
	#htobe16
(
x
) 
	`__bswap_16
 (x)

	)

65 #define 
	#htole16
(
x
) (x)

	)

66 #define 
	#be16toh
(
x
) 
	`__bswap_16
 (x)

	)

67 #define 
	#le16toh
(
x
) (x)

	)

69 #define 
	#htobe32
(
x
) 
	`__bswap_32
 (x)

	)

70 #define 
	#htole32
(
x
) (x)

	)

71 #define 
	#be32toh
(
x
) 
	`__bswap_32
 (x)

	)

72 #define 
	#le32toh
(
x
) (x)

	)

74 #define 
	#htobe64
(
x
) 
	`__bswap_64
 (x)

	)

75 #define 
	#htole64
(
x
) (x)

	)

76 #define 
	#be64toh
(
x
) 
	`__bswap_64
 (x)

	)

77 #define 
	#le64toh
(
x
) (x)

	)

79 #define 
	#htobe16
(
x
) (x)

	)

80 #define 
	#htole16
(
x
) 
	`__bswap_16
 (x)

	)

81 #define 
	#be16toh
(
x
) (x)

	)

82 #define 
	#le16toh
(
x
) 
	`__bswap_16
 (x)

	)

84 #define 
	#htobe32
(
x
) (x)

	)

85 #define 
	#htole32
(
x
) 
	`__bswap_32
 (x)

	)

86 #define 
	#be32toh
(
x
) (x)

	)

87 #define 
	#le32toh
(
x
) 
	`__bswap_32
 (x)

	)

89 #define 
	#htobe64
(
x
) (x)

	)

90 #define 
	#htole64
(
x
) 
	`__bswap_64
 (x)

	)

91 #define 
	#be64toh
(
x
) (x)

	)

92 #define 
	#le64toh
(
x
) 
	`__bswap_64
 (x)

	)

	@/usr/include/libio.h

29 #ifndef 
_IO_STDIO_H


30 #define 
	#_IO_STDIO_H


	)

32 #include 
	~<_G_config.h
>

34 #define 
	#_IO_pos_t
 
_G_fpos_t


	)

35 #define 
	#_IO_fpos_t
 
_G_fpos_t


	)

36 #define 
	#_IO_fpos64_t
 
_G_fpos64_t


	)

37 #define 
	#_IO_size_t
 
_G_size_t


	)

38 #define 
	#_IO_ssize_t
 
_G_ssize_t


	)

39 #define 
	#_IO_off_t
 
_G_off_t


	)

40 #define 
	#_IO_off64_t
 
_G_off64_t


	)

41 #define 
	#_IO_pid_t
 
_G_pid_t


	)

42 #define 
	#_IO_uid_t
 
_G_uid_t


	)

43 #define 
	#_IO_iconv_t
 
_G_iconv_t


	)

44 #define 
	#_IO_HAVE_SYS_WAIT
 
_G_HAVE_SYS_WAIT


	)

45 #define 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

46 #define 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

47 #define 
	#_IO_va_list
 
_G_va_list


	)

48 #define 
	#_IO_wint_t
 
_G_wint_t


	)

50 #ifdef 
_G_NEED_STDARG_H


52 #define 
	#__need___va_list


	)

53 #include 
	~<stdarg.h
>

54 #ifdef 
__GNUC_VA_LIST


55 #undef 
_IO_va_list


56 #define 
	#_IO_va_list
 
__gnuc_va_list


	)

60 #ifndef 
__P


61 #if 
_G_HAVE_SYS_CDEFS


62 #include 
	~<sys/cdefs.h
>

64 #ifdef 
__STDC__


65 #define 
	#__P
(
p
) 
	)
p

66 #define 
	#__PMT
(
p
) 
	)
p

68 #define 
	#__P
(
p
) ()

	)

69 #define 
	#__PMT
(
p
) ()

	)

75 #ifndef 
_PARAMS


76 #define 
	#_PARAMS
(
protos
) 
	`__P
(protos)

	)

79 #ifndef 
__STDC__


81 #define const

	)

84 #define 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

85 #ifndef 
_G_HAVE_PRINTF_FP


86 #define 
	#_IO_USE_DTOA
 1

	)

89 #ifndef 
EOF


90 #define 
	#EOF
 (-1)

	)

92 #ifndef 
NULL


93 #if 
defined
 
__GNUG__
 && \

94 (
	g__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 8))

95 #define 
	#NULL
 (
__null
)

	)

97 #if !
defined
(
__cplusplus
)

98 #define 
	#NULL
 ((void*)0)

	)

100 #define 
	#NULL
 (0)

	)

105 #define 
	#_IOS_INPUT
 1

	)

106 #define 
	#_IOS_OUTPUT
 2

	)

107 #define 
	#_IOS_ATEND
 4

	)

108 #define 
	#_IOS_APPEND
 8

	)

109 #define 
	#_IOS_TRUNC
 16

	)

110 #define 
	#_IOS_NOCREATE
 32

	)

111 #define 
	#_IOS_NOREPLACE
 64

	)

112 #define 
	#_IOS_BIN
 128

	)

120 #define 
	#_IO_MAGIC
 0xFBAD0000

	)

121 #define 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

122 #define 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

123 #define 
	#_IO_USER_BUF
 1

	)

124 #define 
	#_IO_UNBUFFERED
 2

	)

125 #define 
	#_IO_NO_READS
 4

	)

126 #define 
	#_IO_NO_WRITES
 8

	)

127 #define 
	#_IO_EOF_SEEN
 0x10

	)

128 #define 
	#_IO_ERR_SEEN
 0x20

	)

129 #define 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

130 #define 
	#_IO_LINKED
 0x80

	)

131 #define 
	#_IO_IN_BACKUP
 0x100

	)

132 #define 
	#_IO_LINE_BUF
 0x200

	)

133 #define 
	#_IO_TIED_PUT_GET
 0x400

	)

134 #define 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

135 #define 
	#_IO_IS_APPENDING
 0x1000

	)

136 #define 
	#_IO_IS_FILEBUF
 0x2000

	)

137 #define 
	#_IO_BAD_SEEN
 0x4000

	)

138 #define 
	#_IO_USER_LOCK
 0x8000

	)

140 #define 
	#_IO_FLAGS2_MMAP
 1

	)

141 #define 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

142 #ifdef 
_LIBC


143 #define 
	#_IO_FLAGS2_FORTIFY
 4

	)

145 #define 
	#_IO_FLAGS2_USER_WBUF
 8

	)

146 #ifdef 
_LIBC


147 #define 
	#_IO_FLAGS2_SCANF_STD
 16

	)

151 #define 
	#_IO_SKIPWS
 01

	)

152 #define 
	#_IO_LEFT
 02

	)

153 #define 
	#_IO_RIGHT
 04

	)

154 #define 
	#_IO_INTERNAL
 010

	)

155 #define 
	#_IO_DEC
 020

	)

156 #define 
	#_IO_OCT
 040

	)

157 #define 
	#_IO_HEX
 0100

	)

158 #define 
	#_IO_SHOWBASE
 0200

	)

159 #define 
	#_IO_SHOWPOINT
 0400

	)

160 #define 
	#_IO_UPPERCASE
 01000

	)

161 #define 
	#_IO_SHOWPOS
 02000

	)

162 #define 
	#_IO_SCIENTIFIC
 04000

	)

163 #define 
	#_IO_FIXED
 010000

	)

164 #define 
	#_IO_UNITBUF
 020000

	)

165 #define 
	#_IO_STDIO
 040000

	)

166 #define 
	#_IO_DONT_CLOSE
 0100000

	)

167 #define 
	#_IO_BOOLALPHA
 0200000

	)

170 struct 
_IO_jump_t
; struct 
	g_IO_FILE
;

173 #ifdef 
_IO_MTSAFE_IO


174 #if 
defined
 
__GLIBC__
 && __GLIBC__ >= 2

175 #include 
	~<bits/stdio-lock.h
>

180 typedef void 
	t_IO_lock_t
;

186 struct 
	s_IO_marker
 {

187 struct 
_IO_marker
 *
	m_next
;

188 struct 
_IO_FILE
 *
	m_sbuf
;

192 int 
	m_pos
;

194 void 
set_streampos
(
streampos
 
sp
) { 
	m_spos
 = sp; }

195 void 
set_offset
(int 
offset
) { 
	m_pos
 = offset; 
	m_spos
 = (
streampos
)(-2); }

196 
	mpublic
:

197 
streammarker
(
streambuf
 *
sb
);

198 ~
streammarker
();

199 int 
saving
() { return 
	m_spos
 == -2; }

200 int 
delta
(
streammarker
&);

201 int 
delta
();

206 enum 
	e__codecvt_result


208 
	m__codecvt_ok
,

209 
	m__codecvt_partial
,

210 
	m__codecvt_error
,

211 
	m__codecvt_noconv


214 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


217 struct 
	s_IO_codecvt


219 void (*
	m__codecvt_destr
) (struct 
	m_IO_codecvt
 *);

220 enum 
__codecvt_result
 (*
__codecvt_do_out
) (struct 
	m_IO_codecvt
 *,

221 
	m__mbstate_t
 *,

222 const 
	mwchar_t
 *,

223 const 
	mwchar_t
 *,

224 const 
	mwchar_t
 **, char *,

226 enum 
__codecvt_result
 (*
__codecvt_do_unshift
) (struct 
	m_IO_codecvt
 *,

227 
	m__mbstate_t
 *, char *,

229 enum 
__codecvt_result
 (*
__codecvt_do_in
) (struct 
	m_IO_codecvt
 *,

230 
	m__mbstate_t
 *,

232 const char **, 
	mwchar_t
 *,

233 
	mwchar_t
 *, wchar_t **);

234 int (*
	m__codecvt_do_encoding
) (struct 
	m_IO_codecvt
 *);

235 int (*
	m__codecvt_do_always_noconv
) (struct 
	m_IO_codecvt
 *);

236 int (*
	m__codecvt_do_length
) (struct 
	m_IO_codecvt
 *, 
	m__mbstate_t
 *,

237 const char *, const char *, 
	m_IO_size_t
);

238 int (*
	m__codecvt_do_max_length
) (struct 
	m_IO_codecvt
 *);

240 
_IO_iconv_t
 
	m__cd_in
;

241 
_IO_iconv_t
 
	m__cd_out
;

245 struct 
	s_IO_wide_data


247 
wchar_t
 *
	m_IO_read_ptr
;

248 
wchar_t
 *
	m_IO_read_end
;

249 
wchar_t
 *
	m_IO_read_base
;

250 
wchar_t
 *
	m_IO_write_base
;

251 
wchar_t
 *
	m_IO_write_ptr
;

252 
wchar_t
 *
	m_IO_write_end
;

253 
wchar_t
 *
	m_IO_buf_base
;

254 
wchar_t
 *
	m_IO_buf_end
;

256 
wchar_t
 *
	m_IO_save_base
;

257 
wchar_t
 *
	m_IO_backup_base
;

259 
wchar_t
 *
	m_IO_save_end
;

261 
__mbstate_t
 
	m_IO_state
;

262 
__mbstate_t
 
	m_IO_last_state
;

263 struct 
_IO_codecvt
 
	m_codecvt
;

265 
wchar_t
 
	m_shortbuf
[1];

267 const struct 
_IO_jump_t
 *
	m_wide_vtable
;

271 struct 
	s_IO_FILE
 {

272 int 
	m_flags
;

273 #define 
	#_IO_file_flags
 
_flags


	)

277 char* 
	m_IO_read_ptr
;

278 char* 
	m_IO_read_end
;

279 char* 
	m_IO_read_base
;

280 char* 
	m_IO_write_base
;

281 char* 
	m_IO_write_ptr
;

282 char* 
	m_IO_write_end
;

283 char* 
	m_IO_buf_base
;

284 char* 
	m_IO_buf_end
;

286 char *
	m_IO_save_base
;

287 char *
	m_IO_backup_base
;

288 char *
	m_IO_save_end
;

290 struct 
_IO_marker
 *
	m_markers
;

292 struct 
_IO_FILE
 *
	m_chain
;

294 int 
	m_fileno
;

296 int 
	m_blksize
;

298 int 
	m_flags2
;

300 
_IO_off_t
 
	m_old_offset
;

302 #define 
	#__HAVE_COLUMN


	)

304 unsigned short 
	m_cur_column
;

305 signed char 
	m_vtable_offset
;

306 char 
	m_shortbuf
[1];

310 
_IO_lock_t
 *
	m_lock
;

311 #ifdef 
_IO_USE_OLD_IO_FILE


314 struct 
	s_IO_FILE_complete


316 struct 
_IO_FILE
 
	m_file
;

318 #if 
defined
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

319 
_IO_off64_t
 
	m_offset
;

320 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


322 struct 
_IO_codecvt
 *
	m_codecvt
;

323 struct 
_IO_wide_data
 *
	m_wide_data
;

324 struct 
_IO_FILE
 *
	m_freeres_list
;

325 void *
	m_freeres_buf
;

326 
size_t
 
	m_freeres_size
;

328 void *
	m__pad1
;

329 void *
	m__pad2
;

330 void *
	m__pad3
;

331 void *
	m__pad4
;

332 
size_t
 
	m__pad5
;

334 int 
	m_mode
;

336 char 
	m_unused2
[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (
size_t
)];

340 #ifndef 
__cplusplus


341 typedef struct 
_IO_FILE
 
	t_IO_FILE
;

344 struct 
	g_IO_FILE_plus
;

346 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdin_
;

347 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdout_
;

348 extern struct 
_IO_FILE_plus
 
_IO_2_1_stderr_
;

349 #ifndef 
_LIBC


350 #define 
	#_IO_stdin
 ((
_IO_FILE
*)(&
_IO_2_1_stdin_
))

	)

351 #define 
	#_IO_stdout
 ((
_IO_FILE
*)(&
_IO_2_1_stdout_
))

	)

352 #define 
	#_IO_stderr
 ((
_IO_FILE
*)(&
_IO_2_1_stderr_
))

	)

354 extern 
_IO_FILE
 *
_IO_stdin
 
attribute_hidden
;

355 extern 
_IO_FILE
 *
_IO_stdout
 
attribute_hidden
;

356 extern 
_IO_FILE
 *
_IO_stderr
 
attribute_hidden
;

364 typedef 
__ssize_t
 
	t__io_read_fn
 (void *
	t__cookie
, char *
	t__buf
, 
	tsize_t
 
	t__nbytes
);

372 typedef 
__ssize_t
 
	t__io_write_fn
 (void *
	t__cookie
, 
	t__const
 char *
	t__buf
,

373 
	tsize_t
 
	t__n
);

381 typedef int 
	t__io_seek_fn
 (void *
	t__cookie
, 
	t_IO_off64_t
 *
	t__pos
, int 
	t__w
);

384 typedef int 
	t__io_close_fn
 (void *
	t__cookie
);

387 #ifdef 
_GNU_SOURCE


389 typedef 
__io_read_fn
 
	tcookie_read_function_t
;

390 typedef 
__io_write_fn
 
	tcookie_write_function_t
;

391 typedef 
__io_seek_fn
 
	tcookie_seek_function_t
;

392 typedef 
__io_close_fn
 
	tcookie_close_function_t
;

397 
__io_read_fn
 *
	mread
;

398 
__io_write_fn
 *
	mwrite
;

399 
__io_seek_fn
 *
	mseek
;

400 
__io_close_fn
 *
	mclose
;

401 } 
	t_IO_cookie_io_functions_t
;

402 typedef 
_IO_cookie_io_functions_t
 
	tcookie_io_functions_t
;

404 struct 
	g_IO_cookie_file
;

407 extern void 
_IO_cookie_init
 (struct 
_IO_cookie_file
 *
__cfile
, int 
__read_write
,

408 void *
__cookie
, 
_IO_cookie_io_functions_t
 
__fns
);

412 #ifdef 
__cplusplus


416 extern int 
__underflow
 (
_IO_FILE
 *);

417 extern int 
__uflow
 (
_IO_FILE
 *);

418 extern int 
__overflow
 (
_IO_FILE
 *, int);

419 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


420 extern 
_IO_wint_t
 
__wunderflow
 (
_IO_FILE
 *);

421 extern 
_IO_wint_t
 
__wuflow
 (
_IO_FILE
 *);

422 extern 
_IO_wint_t
 
__woverflow
 (
_IO_FILE
 *, _IO_wint_t);

425 #if 
__GNUC__
 >= 3

426 #define 
	#_IO_BE
(
expr
, 
res
) 
	`__builtin_expect
 ((expr), res)

	)

428 #define 
	#_IO_BE
(
expr
, 
res
) (expr)

	)

431 #define 
	#_IO_getc_unlocked
(
_fp
) \

432 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

433 ? 
	`__uflow
 (
_fp
) : *(unsigned char *) (_fp)->
_IO_read_ptr
++)

	)

434 #define 
	#_IO_peekc_unlocked
(
_fp
) \

435 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

436 && 
	`__underflow
 (
_fp
) == 
EOF
 ? EOF \

437 : *(unsigned char *) (
_fp
)->
_IO_read_ptr
)

	)

438 #define 
	#_IO_putc_unlocked
(
_ch
, 
_fp
) \

439 (
	`_IO_BE
 ((
_fp
)->
_IO_write_ptr
 >= (_fp)->
_IO_write_end
, 0) \

440 ? 
	`__overflow
 (
_fp
, (unsigned char) (
_ch
)) \

441 : (unsigned char) (*(
_fp
)->
_IO_write_ptr
++ = (
_ch
)))

	)

443 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


444 #define 
	#_IO_getwc_unlocked
(
_fp
) \

445 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

446 || ((
_fp
)->
_wide_data
->
_IO_read_ptr
 \

447 >= (
_fp
)->
_wide_data
->
_IO_read_end
), 0) \

448 ? 
	`__wuflow
 (
_fp
) : (
_IO_wint_t
) *(_fp)->
_wide_data
->
_IO_read_ptr
++)

	)

449 #define 
	#_IO_putwc_unlocked
(
_wch
, 
_fp
) \

450 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

451 || ((
_fp
)->
_wide_data
->
_IO_write_ptr
 \

452 >= (
_fp
)->
_wide_data
->
_IO_write_end
), 0) \

453 ? 
	`__woverflow
 (
_fp
, 
_wch
) \

454 : (
_IO_wint_t
) (*(
_fp
)->
_wide_data
->
_IO_write_ptr
++ = (
_wch
)))

	)

457 #define 
	#_IO_feof_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_EOF_SEEN
) != 0)

	)

458 #define 
	#_IO_ferror_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_ERR_SEEN
) != 0)

	)

460 extern int 
_IO_getc
 (
_IO_FILE
 *
__fp
);

461 extern int 
_IO_putc
 (int 
__c
, 
_IO_FILE
 *
__fp
);

462 extern int 
_IO_feof
 (
_IO_FILE
 *
__fp
) 
__THROW
;

463 extern int 
_IO_ferror
 (
_IO_FILE
 *
__fp
) 
__THROW
;

465 extern int 
_IO_peekc_locked
 (
_IO_FILE
 *
__fp
);

468 #define 
	#_IO_PENDING_OUTPUT_COUNT
(
_fp
) \

469 ((
_fp
)->
_IO_write_ptr
 - (_fp)->
_IO_write_base
)

	)

471 extern void 
_IO_flockfile
 (
_IO_FILE
 *) 
__THROW
;

472 extern void 
_IO_funlockfile
 (
_IO_FILE
 *) 
__THROW
;

473 extern int 
_IO_ftrylockfile
 (
_IO_FILE
 *) 
__THROW
;

475 #ifdef 
_IO_MTSAFE_IO


476 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_locked
 (_fp)

	)

477 #define 
	#_IO_flockfile
(
_fp
) \

478 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_flockfile
 (_fp)

	)

479 #define 
	#_IO_funlockfile
(
_fp
) \

480 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_funlockfile
 (_fp)

	)

482 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_unlocked
 (_fp)

	)

483 #define 
	#_IO_flockfile
(
_fp
)

	)

484 #define 
	#_IO_funlockfile
(
_fp
)

	)

485 #define 
	#_IO_ftrylockfile
(
_fp
)

	)

486 #define 
	#_IO_cleanup_region_start
(
_fct
, 
_fp
)

	)

487 #define 
	#_IO_cleanup_region_end
(
_Doit
)

	)

490 extern int 
_IO_vfscanf
 (
_IO_FILE
 * 
__restrict
, const char * __restrict,

491 
_IO_va_list
, int *
__restrict
);

492 extern int 
_IO_vfprintf
 (
_IO_FILE
 *
__restrict
, const char *__restrict,

493 
_IO_va_list
);

494 extern 
_IO_ssize_t
 
_IO_padn
 (
_IO_FILE
 *, int, _IO_ssize_t);

495 extern 
_IO_size_t
 
_IO_sgetn
 (
_IO_FILE
 *, void *, _IO_size_t);

497 extern 
_IO_off64_t
 
_IO_seekoff
 (
_IO_FILE
 *, _IO_off64_t, int, int);

498 extern 
_IO_off64_t
 
_IO_seekpos
 (
_IO_FILE
 *, _IO_off64_t, int);

500 extern void 
_IO_free_backup_area
 (
_IO_FILE
 *) 
__THROW
;

502 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


503 extern 
_IO_wint_t
 
_IO_getwc
 (
_IO_FILE
 *
__fp
);

504 extern 
_IO_wint_t
 
_IO_putwc
 (
wchar_t
 
__wc
, 
_IO_FILE
 *
__fp
);

505 extern int 
_IO_fwide
 (
_IO_FILE
 *
__fp
, int 
__mode
) 
__THROW
;

506 #if 
__GNUC__
 >= 2

509 #if 
defined
 
_LIBC
 && defined 
SHARED


510 #include 
	~<shlib-compat.h
>

511 #if 
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

512 #define 
	#_IO_fwide_maybe_incompatible
 \

513 (
	`__builtin_expect
 (&
_IO_stdin_used
 == 
NULL
, 0))

	)

514 extern const int 
_IO_stdin_used
;

515 
weak_extern
 (
_IO_stdin_used
);

518 #ifndef 
_IO_fwide_maybe_incompatible


519 #define 
	#_IO_fwide_maybe_incompatible
 (0)

	)

523 #define 
	#_IO_fwide
(
__fp
, 
__mode
) \

524 ({ int 
__result
 = (
__mode
); \

525 if (
__result
 < 0 && ! 
_IO_fwide_maybe_incompatible
) \

527 if ((
__fp
)->
_mode
 == 0) \

529 (
__fp
)->
_mode
 = -1; \

530 
__result
 = (
__fp
)->
_mode
; \

532 else if (
	`__builtin_constant_p
 (
__mode
) && (__mode) == 0) \

533 
__result
 = 
_IO_fwide_maybe_incompatible
 ? -1 : (
__fp
)->
_mode
; \

535 
__result
 = 
	`_IO_fwide
 (
__fp
, __result); \

536 
__result
; })

	)

539 extern int 
_IO_vfwscanf
 (
_IO_FILE
 * 
__restrict
, const 
wchar_t
 * __restrict,

540 
_IO_va_list
, int *
__restrict
);

541 extern int 
_IO_vfwprintf
 (
_IO_FILE
 *
__restrict
, const 
wchar_t
 *__restrict,

542 
_IO_va_list
);

543 extern 
_IO_ssize_t
 
_IO_wpadn
 (
_IO_FILE
 *, 
wint_t
, _IO_ssize_t);

544 extern void 
_IO_free_wbackup_area
 (
_IO_FILE
 *) 
__THROW
;

547 #ifdef 
__LDBL_COMPAT


548 #include 
	~<bits/libio-ldbl.h
>

551 #ifdef 
__cplusplus


	@/usr/include/netinet/in.h

20 #ifndef 
_NETINET_IN_H


21 #define 
	#_NETINET_IN_H
 1

	)

23 #include 
	~<features.h
>

24 #include 
	~<stdint.h
>

25 #include 
	~<sys/socket.h
>

26 #include 
	~<bits/types.h
>

29 
__BEGIN_DECLS


34 
	mIPPROTO_IP
 = 0,

35 #define 
	#IPPROTO_IP
 
IPPROTO_IP


	)

36 
	mIPPROTO_HOPOPTS
 = 0,

37 #define 
	#IPPROTO_HOPOPTS
 
IPPROTO_HOPOPTS


	)

38 
	mIPPROTO_ICMP
 = 1,

39 #define 
	#IPPROTO_ICMP
 
IPPROTO_ICMP


	)

40 
	mIPPROTO_IGMP
 = 2,

41 #define 
	#IPPROTO_IGMP
 
IPPROTO_IGMP


	)

42 
	mIPPROTO_IPIP
 = 4,

43 #define 
	#IPPROTO_IPIP
 
IPPROTO_IPIP


	)

44 
	mIPPROTO_TCP
 = 6,

45 #define 
	#IPPROTO_TCP
 
IPPROTO_TCP


	)

46 
	mIPPROTO_EGP
 = 8,

47 #define 
	#IPPROTO_EGP
 
IPPROTO_EGP


	)

48 
	mIPPROTO_PUP
 = 12,

49 #define 
	#IPPROTO_PUP
 
IPPROTO_PUP


	)

50 
	mIPPROTO_UDP
 = 17,

51 #define 
	#IPPROTO_UDP
 
IPPROTO_UDP


	)

52 
	mIPPROTO_IDP
 = 22,

53 #define 
	#IPPROTO_IDP
 
IPPROTO_IDP


	)

54 
	mIPPROTO_TP
 = 29,

55 #define 
	#IPPROTO_TP
 
IPPROTO_TP


	)

56 
	mIPPROTO_DCCP
 = 33,

57 #define 
	#IPPROTO_DCCP
 
IPPROTO_DCCP


	)

58 
	mIPPROTO_IPV6
 = 41,

59 #define 
	#IPPROTO_IPV6
 
IPPROTO_IPV6


	)

60 
	mIPPROTO_ROUTING
 = 43,

61 #define 
	#IPPROTO_ROUTING
 
IPPROTO_ROUTING


	)

62 
	mIPPROTO_FRAGMENT
 = 44,

63 #define 
	#IPPROTO_FRAGMENT
 
IPPROTO_FRAGMENT


	)

64 
	mIPPROTO_RSVP
 = 46,

65 #define 
	#IPPROTO_RSVP
 
IPPROTO_RSVP


	)

66 
	mIPPROTO_GRE
 = 47,

67 #define 
	#IPPROTO_GRE
 
IPPROTO_GRE


	)

68 
	mIPPROTO_ESP
 = 50,

69 #define 
	#IPPROTO_ESP
 
IPPROTO_ESP


	)

70 
	mIPPROTO_AH
 = 51,

71 #define 
	#IPPROTO_AH
 
IPPROTO_AH


	)

72 
	mIPPROTO_ICMPV6
 = 58,

73 #define 
	#IPPROTO_ICMPV6
 
IPPROTO_ICMPV6


	)

74 
	mIPPROTO_NONE
 = 59,

75 #define 
	#IPPROTO_NONE
 
IPPROTO_NONE


	)

76 
	mIPPROTO_DSTOPTS
 = 60,

77 #define 
	#IPPROTO_DSTOPTS
 
IPPROTO_DSTOPTS


	)

78 
	mIPPROTO_MTP
 = 92,

79 #define 
	#IPPROTO_MTP
 
IPPROTO_MTP


	)

80 
	mIPPROTO_ENCAP
 = 98,

81 #define 
	#IPPROTO_ENCAP
 
IPPROTO_ENCAP


	)

82 
	mIPPROTO_PIM
 = 103,

83 #define 
	#IPPROTO_PIM
 
IPPROTO_PIM


	)

84 
	mIPPROTO_COMP
 = 108,

85 #define 
	#IPPROTO_COMP
 
IPPROTO_COMP


	)

86 
	mIPPROTO_SCTP
 = 132,

87 #define 
	#IPPROTO_SCTP
 
IPPROTO_SCTP


	)

88 
	mIPPROTO_UDPLITE
 = 136,

89 #define 
	#IPPROTO_UDPLITE
 
IPPROTO_UDPLITE


	)

90 
	mIPPROTO_RAW
 = 255,

91 #define 
	#IPPROTO_RAW
 
IPPROTO_RAW


	)

92 
	mIPPROTO_MAX


97 typedef 
uint16_t
 
	tin_port_t
;

102 
	mIPPORT_ECHO
 = 7,

103 
	mIPPORT_DISCARD
 = 9,

104 
	mIPPORT_SYSTAT
 = 11,

105 
	mIPPORT_DAYTIME
 = 13,

106 
	mIPPORT_NETSTAT
 = 15,

107 
	mIPPORT_FTP
 = 21,

108 
	mIPPORT_TELNET
 = 23,

109 
	mIPPORT_SMTP
 = 25,

110 
	mIPPORT_TIMESERVER
 = 37,

111 
	mIPPORT_NAMESERVER
 = 42,

112 
	mIPPORT_WHOIS
 = 43,

113 
	mIPPORT_MTP
 = 57,

115 
	mIPPORT_TFTP
 = 69,

116 
	mIPPORT_RJE
 = 77,

117 
	mIPPORT_FINGER
 = 79,

118 
	mIPPORT_TTYLINK
 = 87,

119 
	mIPPORT_SUPDUP
 = 95,

122 
	mIPPORT_EXECSERVER
 = 512,

123 
	mIPPORT_LOGINSERVER
 = 513,

124 
	mIPPORT_CMDSERVER
 = 514,

125 
	mIPPORT_EFSSERVER
 = 520,

128 
	mIPPORT_BIFFUDP
 = 512,

129 
	mIPPORT_WHOSERVER
 = 513,

130 
	mIPPORT_ROUTESERVER
 = 520,

133 
	mIPPORT_RESERVED
 = 1024,

136 
	mIPPORT_USERRESERVED
 = 5000

141 typedef 
uint32_t
 
	tin_addr_t
;

142 struct 
	sin_addr


144 
in_addr_t
 
	ms_addr
;

153 #define 
	#IN_CLASSA
(
a
) ((((
in_addr_t
)(a)) & 0x80000000) == 0)

	)

154 #define 
	#IN_CLASSA_NET
 0xff000000

	)

155 #define 
	#IN_CLASSA_NSHIFT
 24

	)

156 #define 
	#IN_CLASSA_HOST
 (0xffffffff & ~
IN_CLASSA_NET
)

	)

157 #define 
	#IN_CLASSA_MAX
 128

	)

159 #define 
	#IN_CLASSB
(
a
) ((((
in_addr_t
)(a)) & 0xc0000000) == 0x80000000)

	)

160 #define 
	#IN_CLASSB_NET
 0xffff0000

	)

161 #define 
	#IN_CLASSB_NSHIFT
 16

	)

162 #define 
	#IN_CLASSB_HOST
 (0xffffffff & ~
IN_CLASSB_NET
)

	)

163 #define 
	#IN_CLASSB_MAX
 65536

	)

165 #define 
	#IN_CLASSC
(
a
) ((((
in_addr_t
)(a)) & 0xe0000000) == 0xc0000000)

	)

166 #define 
	#IN_CLASSC_NET
 0xffffff00

	)

167 #define 
	#IN_CLASSC_NSHIFT
 8

	)

168 #define 
	#IN_CLASSC_HOST
 (0xffffffff & ~
IN_CLASSC_NET
)

	)

170 #define 
	#IN_CLASSD
(
a
) ((((
in_addr_t
)(a)) & 0xf0000000) == 0xe0000000)

	)

171 #define 
	#IN_MULTICAST
(
a
) 
	`IN_CLASSD
(a)

	)

173 #define 
	#IN_EXPERIMENTAL
(
a
) ((((
in_addr_t
)(a)) & 0xe0000000) == 0xe0000000)

	)

174 #define 
	#IN_BADCLASS
(
a
) ((((
in_addr_t
)(a)) & 0xf0000000) == 0xf0000000)

	)

177 #define 
	#INADDR_ANY
 ((
in_addr_t
) 0x00000000)

	)

179 #define 
	#INADDR_BROADCAST
 ((
in_addr_t
) 0xffffffff)

	)

181 #define 
	#INADDR_NONE
 ((
in_addr_t
) 0xffffffff)

	)

184 #define 
	#IN_LOOPBACKNET
 127

	)

186 #ifndef 
INADDR_LOOPBACK


187 #define 
	#INADDR_LOOPBACK
 ((
in_addr_t
) 0x7f000001)

	)

191 #define 
	#INADDR_UNSPEC_GROUP
 ((
in_addr_t
) 0xe0000000)

	)

192 #define 
	#INADDR_ALLHOSTS_GROUP
 ((
in_addr_t
) 0xe0000001)

	)

193 #define 
	#INADDR_ALLRTRS_GROUP
 ((
in_addr_t
) 0xe0000002)

	)

194 #define 
	#INADDR_MAX_LOCAL_GROUP
 ((
in_addr_t
) 0xe00000ff)

	)

198 struct 
	sin6_addr


202 
uint8_t
 
	m__u6_addr8
[16];

203 #if 
defined
 
__USE_MISC
 || defined 
__USE_GNU


204 
uint16_t
 
	m__u6_addr16
[8];

205 
uint32_t
 
	m__u6_addr32
[4];

207 } 
	m__in6_u
;

208 #define 
	#s6_addr
 
__in6_u
.
__u6_addr8


	)

209 #if 
defined
 
__USE_MISC
 || defined 
__USE_GNU


210 #define 
	#s6_addr16
 
__in6_u
.
__u6_addr16


	)

211 #define 
	#s6_addr32
 
__in6_u
.
__u6_addr32


	)

215 extern const struct 
in6_addr
 
in6addr_any
;

216 extern const struct 
in6_addr
 
in6addr_loopback
;

217 #define 
	#IN6ADDR_ANY_INIT
 { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }

	)

218 #define 
	#IN6ADDR_LOOPBACK_INIT
 { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

	)

220 #define 
	#INET_ADDRSTRLEN
 16

	)

221 #define 
	#INET6_ADDRSTRLEN
 46

	)

225 struct 
	ssockaddr_in


227 
__SOCKADDR_COMMON
 (
sin_
);

228 
in_port_t
 
	msin_port
;

229 struct 
in_addr
 
	msin_addr
;

232 unsigned char 
	msin_zero
[sizeof (struct 
sockaddr
) -

233 
__SOCKADDR_COMMON_SIZE
 -

234 sizeof (
in_port_t
) -

235 sizeof (struct 
in_addr
)];

239 struct 
	ssockaddr_in6


241 
__SOCKADDR_COMMON
 (
sin6_
);

242 
in_port_t
 
	msin6_port
;

243 
uint32_t
 
	msin6_flowinfo
;

244 struct 
in6_addr
 
	msin6_addr
;

245 
uint32_t
 
	msin6_scope_id
;

249 #if 
defined
 
__USE_MISC
 || defined 
__USE_GNU


251 struct 
	sip_mreq


254 struct 
in_addr
 
	mimr_multiaddr
;

257 struct 
in_addr
 
	mimr_interface
;

260 struct 
	sip_mreq_source


263 struct 
in_addr
 
	mimr_multiaddr
;

266 struct 
in_addr
 
	mimr_interface
;

269 struct 
in_addr
 
	mimr_sourceaddr
;

275 struct 
	sipv6_mreq


278 struct 
in6_addr
 
	mipv6mr_multiaddr
;

281 unsigned int 
	mipv6mr_interface
;

285 #if 
defined
 
__USE_MISC
 || defined 
__USE_GNU


287 struct 
	sgroup_req


290 
uint32_t
 
	mgr_interface
;

293 struct 
sockaddr_storage
 
	mgr_group
;

296 struct 
	sgroup_source_req


299 
uint32_t
 
	mgsr_interface
;

302 struct 
sockaddr_storage
 
	mgsr_group
;

305 struct 
sockaddr_storage
 
	mgsr_source
;

310 struct 
	sip_msfilter


313 struct 
in_addr
 
	mimsf_multiaddr
;

316 struct 
in_addr
 
	mimsf_interface
;

319 
uint32_t
 
	mimsf_fmode
;

322 
uint32_t
 
	mimsf_numsrc
;

324 struct 
in_addr
 
	mimsf_slist
[1];

327 #define 
	#IP_MSFILTER_SIZE
(
numsrc
) (sizeof (struct 
ip_msfilter
) \

328 - sizeof (struct 
in_addr
) \

329 + (
numsrc
) * sizeof (struct 
in_addr
))

	)

331 struct 
	sgroup_filter


334 
uint32_t
 
	mgf_interface
;

337 struct 
sockaddr_storage
 
	mgf_group
;

340 
uint32_t
 
	mgf_fmode
;

343 
uint32_t
 
	mgf_numsrc
;

345 struct 
sockaddr_storage
 
	mgf_slist
[1];

348 #define 
	#GROUP_FILTER_SIZE
(
numsrc
) (sizeof (struct 
group_filter
) \

349 - sizeof (struct 
sockaddr_storage
) \

350 + ((
numsrc
) \

351 * sizeof (struct 
sockaddr_storage
)))

	)

356 #include 
	~<bits/in.h
>

365 extern 
uint32_t
 
	$ntohl
 (
uint32_t
 
__netlong
) 
__THROW
 
	`__attribute__
 ((
__const__
));

366 extern 
uint16_t
 
	$ntohs
 (
uint16_t
 
__netshort
)

367 
__THROW
 
	`__attribute__
 ((
__const__
));

368 extern 
uint32_t
 
	$htonl
 (
uint32_t
 
__hostlong
)

369 
__THROW
 
	`__attribute__
 ((
__const__
));

370 extern 
uint16_t
 
	$htons
 (
uint16_t
 
__hostshort
)

371 
__THROW
 
	`__attribute__
 ((
__const__
));

373 #include 
	~<endian.h
>

376 #include 
	~<bits/byteswap.h
>

378 #ifdef 
__OPTIMIZE__


382 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


385 #define 
	#ntohl
(
x
) (x)

	)

386 #define 
	#ntohs
(
x
) (x)

	)

387 #define 
	#htonl
(
x
) (x)

	)

388 #define 
	#htons
(
x
) (x)

	)

390 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


391 #define 
	#ntohl
(
x
) 
	`__bswap_32
 (x)

	)

392 #define 
	#ntohs
(
x
) 
	`__bswap_16
 (x)

	)

393 #define 
	#htonl
(
x
) 
	`__bswap_32
 (x)

	)

394 #define 
	#htons
(
x
) 
	`__bswap_16
 (x)

	)

399 #define 
	#IN6_IS_ADDR_UNSPECIFIED
(
a
) \

400 (((
__const
 
uint32_t
 *) (
a
))[0] == 0 \

401 && ((
__const
 
uint32_t
 *) (
a
))[1] == 0 \

402 && ((
__const
 
uint32_t
 *) (
a
))[2] == 0 \

403 && ((
__const
 
uint32_t
 *) (
a
))[3] == 0)

	)

405 #define 
	#IN6_IS_ADDR_LOOPBACK
(
a
) \

406 (((
__const
 
uint32_t
 *) (
a
))[0] == 0 \

407 && ((
__const
 
uint32_t
 *) (
a
))[1] == 0 \

408 && ((
__const
 
uint32_t
 *) (
a
))[2] == 0 \

409 && ((
__const
 
uint32_t
 *) (
a
))[3] == 
	`htonl
 (1))

	)

411 #define 
	#IN6_IS_ADDR_MULTICAST
(
a
) (((
__const
 
uint8_t
 *) (a))[0] == 0xff)

	)

413 #define 
	#IN6_IS_ADDR_LINKLOCAL
(
a
) \

414 ((((
__const
 
uint32_t
 *) (
a
))[0] & 
	`htonl
 (0xffc00000)) \

415 == 
	`htonl
 (0xfe800000))

	)

417 #define 
	#IN6_IS_ADDR_SITELOCAL
(
a
) \

418 ((((
__const
 
uint32_t
 *) (
a
))[0] & 
	`htonl
 (0xffc00000)) \

419 == 
	`htonl
 (0xfec00000))

	)

421 #define 
	#IN6_IS_ADDR_V4MAPPED
(
a
) \

422 ((((
__const
 
uint32_t
 *) (
a
))[0] == 0) \

423 && (((
__const
 
uint32_t
 *) (
a
))[1] == 0) \

424 && (((
__const
 
uint32_t
 *) (
a
))[2] == 
	`htonl
 (0xffff)))

	)

426 #define 
	#IN6_IS_ADDR_V4COMPAT
(
a
) \

427 ((((
__const
 
uint32_t
 *) (
a
))[0] == 0) \

428 && (((
__const
 
uint32_t
 *) (
a
))[1] == 0) \

429 && (((
__const
 
uint32_t
 *) (
a
))[2] == 0) \

430 && (
	`ntohl
 (((
__const
 
uint32_t
 *) (
a
))[3]) > 1))

	)

432 #define 
	#IN6_ARE_ADDR_EQUAL
(
a
,
b
) \

433 ((((
__const
 
uint32_t
 *) (
a
))[0] == ((__const uint32_t *) (
b
))[0]) \

434 && (((
__const
 
uint32_t
 *) (
a
))[1] == ((__const uint32_t *) (
b
))[1]) \

435 && (((
__const
 
uint32_t
 *) (
a
))[2] == ((__const uint32_t *) (
b
))[2]) \

436 && (((
__const
 
uint32_t
 *) (
a
))[3] == ((__const uint32_t *) (
b
))[3]))

	)

438 #if 
defined
 
__USE_MISC
 || defined 
__USE_GNU


440 extern int 
	$bindresvport
 (int 
__sockfd
, struct 
sockaddr_in
 *
__sock_in
) 
__THROW
;

443 extern int 
	$bindresvport6
 (int 
__sockfd
, struct 
sockaddr_in6
 *
__sock_in
)

444 
__THROW
;

448 #define 
	#IN6_IS_ADDR_MC_NODELOCAL
(
a
) \

449 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

450 && ((((
__const
 
uint8_t
 *) (
a
))[1] & 0xf) == 0x1))

	)

452 #define 
	#IN6_IS_ADDR_MC_LINKLOCAL
(
a
) \

453 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

454 && ((((
__const
 
uint8_t
 *) (
a
))[1] & 0xf) == 0x2))

	)

456 #define 
	#IN6_IS_ADDR_MC_SITELOCAL
(
a
) \

457 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

458 && ((((
__const
 
uint8_t
 *) (
a
))[1] & 0xf) == 0x5))

	)

460 #define 
	#IN6_IS_ADDR_MC_ORGLOCAL
(
a
) \

461 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

462 && ((((
__const
 
uint8_t
 *) (
a
))[1] & 0xf) == 0x8))

	)

464 #define 
	#IN6_IS_ADDR_MC_GLOBAL
(
a
) \

465 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

466 && ((((
__const
 
uint8_t
 *) (
a
))[1] & 0xf) == 0xe))

	)

469 #ifdef 
__USE_GNU


471 struct 
	sin6_pktinfo


473 struct 
in6_addr
 
ipi6_addr
;

474 unsigned int 
ipi6_ifindex
;

478 struct 
	sip6_mtuinfo


480 struct 
sockaddr_in6
 
ip6m_addr
;

481 
uint32_t
 
ip6m_mtu
;

486 extern int 
	$inet6_option_space
 (int 
__nbytes
)

487 
__THROW
 
__attribute_deprecated__
;

488 extern int 
	$inet6_option_init
 (void *
__bp
, struct 
cmsghdr
 **
__cmsgp
,

489 int 
__type
) 
__THROW
 
__attribute_deprecated__
;

490 extern int 
	$inet6_option_append
 (struct 
cmsghdr
 *
__cmsg
,

491 
__const
 
uint8_t
 *
__typep
, int 
__multx
,

492 int 
__plusy
) 
__THROW
 
__attribute_deprecated__
;

493 extern 
uint8_t
 *
	$inet6_option_alloc
 (struct 
cmsghdr
 *
__cmsg
, int 
__datalen
,

494 int 
__multx
, int 
__plusy
)

495 
__THROW
 
__attribute_deprecated__
;

496 extern int 
	$inet6_option_next
 (
__const
 struct 
cmsghdr
 *
__cmsg
,

497 
uint8_t
 **
__tptrp
)

498 
__THROW
 
__attribute_deprecated__
;

499 extern int 
	$inet6_option_find
 (
__const
 struct 
cmsghdr
 *
__cmsg
,

500 
uint8_t
 **
__tptrp
, int 
__type
)

501 
__THROW
 
__attribute_deprecated__
;

505 extern int 
	$inet6_opt_init
 (void *
__extbuf
, 
socklen_t
 
__extlen
) 
__THROW
;

506 extern int 
	$inet6_opt_append
 (void *
__extbuf
, 
socklen_t
 
__extlen
, int 
__offset
,

507 
uint8_t
 
__type
, 
socklen_t
 
__len
, uint8_t 
__align
,

508 void **
__databufp
) 
__THROW
;

509 extern int 
	$inet6_opt_finish
 (void *
__extbuf
, 
socklen_t
 
__extlen
, int 
__offset
)

510 
__THROW
;

511 extern int 
	$inet6_opt_set_val
 (void *
__databuf
, int 
__offset
, void *
__val
,

512 
socklen_t
 
__vallen
) 
__THROW
;

513 extern int 
	$inet6_opt_next
 (void *
__extbuf
, 
socklen_t
 
__extlen
, int 
__offset
,

514 
uint8_t
 *
__typep
, 
socklen_t
 *
__lenp
,

515 void **
__databufp
) 
__THROW
;

516 extern int 
	$inet6_opt_find
 (void *
__extbuf
, 
socklen_t
 
__extlen
, int 
__offset
,

517 
uint8_t
 
__type
, 
socklen_t
 *
__lenp
,

518 void **
__databufp
) 
__THROW
;

519 extern int 
	$inet6_opt_get_val
 (void *
__databuf
, int 
__offset
, void *
__val
,

520 
socklen_t
 
__vallen
) 
__THROW
;

524 extern 
socklen_t
 
	$inet6_rth_space
 (int 
__type
, int 
__segments
) 
__THROW
;

525 extern void *
	$inet6_rth_init
 (void *
__bp
, 
socklen_t
 
__bp_len
, int 
__type
,

526 int 
__segments
) 
__THROW
;

527 extern int 
	$inet6_rth_add
 (void *
__bp
, 
__const
 struct 
in6_addr
 *
__addr
) 
__THROW
;

528 extern int 
	$inet6_rth_reverse
 (
__const
 void *
__in
, void *
__out
) 
__THROW
;

529 extern int 
	$inet6_rth_segments
 (
__const
 void *
__bp
) 
__THROW
;

530 extern struct 
in6_addr
 *
	$inet6_rth_getaddr
 (
__const
 void *
__bp
, int 
__index
)

531 
__THROW
;

537 extern int 
	$getipv4sourcefilter
 (int 
__s
, struct 
in_addr
 
__interface_addr
,

538 struct 
in_addr
 
__group
, 
uint32_t
 *
__fmode
,

539 
uint32_t
 *
__numsrc
, struct 
in_addr
 *
__slist
)

540 
__THROW
;

543 extern int 
	$setipv4sourcefilter
 (int 
__s
, struct 
in_addr
 
__interface_addr
,

544 struct 
in_addr
 
__group
, 
uint32_t
 
__fmode
,

545 
uint32_t
 
__numsrc
,

546 
__const
 struct 
in_addr
 *
__slist
)

547 
__THROW
;

551 extern int 
	$getsourcefilter
 (int 
__s
, 
uint32_t
 
__interface_addr
,

552 
__const
 struct 
sockaddr
 *
__group
,

553 
socklen_t
 
__grouplen
, 
uint32_t
 *
__fmode
,

554 
uint32_t
 *
__numsrc
,

555 struct 
sockaddr_storage
 *
__slist
) 
__THROW
;

558 extern int 
	$setsourcefilter
 (int 
__s
, 
uint32_t
 
__interface_addr
,

559 
__const
 struct 
sockaddr
 *
__group
,

560 
socklen_t
 
__grouplen
, 
uint32_t
 
__fmode
,

561 
uint32_t
 
__numsrc
,

562 
__const
 struct 
sockaddr_storage
 *
__slist
) 
__THROW
;

565 
__END_DECLS


	@/usr/include/nl_types.h

19 #ifndef 
_NL_TYPES_H


20 #define 
	#_NL_TYPES_H
 1

	)

22 #include 
	~<features.h
>

25 #define 
	#NL_SETD
 1

	)

28 #define 
	#NL_CAT_LOCALE
 1

	)

31 
__BEGIN_DECLS


34 typedef void *
	tnl_catd
;

37 typedef int 
	tnl_item
;

43 extern 
nl_catd
 
	$catopen
 (
__const
 char *
__cat_name
, int 
__flag
) 
	`__nonnull
 ((1));

47 extern char *
	$catgets
 (
nl_catd
 
__catalog
, int 
__set
, int 
__number
,

48 
__const
 char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

51 extern int 
	$catclose
 (
nl_catd
 
__catalog
) 
__THROW
 
	`__nonnull
 ((1));

53 
__END_DECLS


	@/usr/include/rpc/netdb.h

36 #ifndef 
_RPC_NETDB_H


37 #define 
	#_RPC_NETDB_H
 1

	)

39 #include 
	~<features.h
>

41 #define 
	#__need_size_t


	)

42 #include 
	~<stddef.h
>

44 
__BEGIN_DECLS


46 struct 
	srpcent


48 char *
	mr_name
;

49 char **
	mr_aliases
;

50 int 
	mr_number
;

53 extern void 
	$setrpcent
 (int 
__stayopen
) 
__THROW
;

54 extern void 
	$endrpcent
 (void) 
__THROW
;

55 extern struct 
rpcent
 *
	$getrpcbyname
 (
__const
 char *
__name
) 
__THROW
;

56 extern struct 
rpcent
 *
	$getrpcbynumber
 (int 
__number
) 
__THROW
;

57 extern struct 
rpcent
 *
	$getrpcent
 (void) 
__THROW
;

59 #ifdef 
__USE_MISC


60 extern int 
	$getrpcbyname_r
 (
__const
 char *
__name
, struct 
rpcent
 *
__result_buf
,

61 char *
__buffer
, 
size_t
 
__buflen
,

62 struct 
rpcent
 **
__result
) 
__THROW
;

64 extern int 
	$getrpcbynumber_r
 (int 
__number
, struct 
rpcent
 *
__result_buf
,

65 char *
__buffer
, 
size_t
 
__buflen
,

66 struct 
rpcent
 **
__result
) 
__THROW
;

68 extern int 
	$getrpcent_r
 (struct 
rpcent
 *
__result_buf
, char *
__buffer
,

69 
size_t
 
__buflen
, struct 
rpcent
 **
__result
) 
__THROW
;

72 
__END_DECLS


	@/usr/include/_G_config.h

4 #ifndef 
_G_config_h


5 #define 
	#_G_config_h
 1

	)

9 #include 
	~<bits/types.h
>

10 #define 
	#__need_size_t


	)

11 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


12 #define 
	#__need_wchar_t


	)

14 #define 
	#__need_NULL


	)

15 #include 
	~<stddef.h
>

16 #define 
	#__need_mbstate_t


	)

17 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


18 #define 
	#__need_wint_t


	)

20 #include 
	~<wchar.h
>

21 #define 
	#_G_size_t
 
size_t


	)

24 
__off_t
 
	m__pos
;

25 
__mbstate_t
 
	m__state
;

26 } 
	t_G_fpos_t
;

29 
__off64_t
 
	m__pos
;

30 
__mbstate_t
 
	m__state
;

31 } 
	t_G_fpos64_t
;

32 #define 
	#_G_ssize_t
 
__ssize_t


	)

33 #define 
	#_G_off_t
 
__off_t


	)

34 #define 
	#_G_off64_t
 
__off64_t


	)

35 #define 
	#_G_pid_t
 
__pid_t


	)

36 #define 
	#_G_uid_t
 
__uid_t


	)

37 #define 
	#_G_wchar_t
 
wchar_t


	)

38 #define 
	#_G_wint_t
 
wint_t


	)

39 #define 
	#_G_stat64
 
stat64


	)

40 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


41 #include 
	~<gconv.h
>

44 struct 
__gconv_info
 
	m__cd
;

47 struct 
__gconv_info
 
	m__cd
;

48 struct 
__gconv_step_data
 
	m__data
;

49 } 
	m__combined
;

50 } 
	t_G_iconv_t
;

53 typedef int 
	t_G_int16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

54 typedef int 
	t_G_int32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

55 typedef unsigned int 
	t_G_uint16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

56 typedef unsigned int 
	t_G_uint32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

58 #define 
	#_G_HAVE_BOOL
 1

	)

62 #define 
	#_G_HAVE_ATEXIT
 1

	)

63 #define 
	#_G_HAVE_SYS_CDEFS
 1

	)

64 #define 
	#_G_HAVE_SYS_WAIT
 1

	)

65 #define 
	#_G_NEED_STDARG_H
 1

	)

66 #define 
	#_G_va_list
 
__gnuc_va_list


	)

68 #define 
	#_G_HAVE_PRINTF_FP
 1

	)

69 #define 
	#_G_HAVE_MMAP
 1

	)

70 #define 
	#_G_HAVE_MREMAP
 1

	)

71 #define 
	#_G_HAVE_LONG_DOUBLE_IO
 1

	)

72 #define 
	#_G_HAVE_IO_FILE_OPEN
 1

	)

73 #define 
	#_G_HAVE_IO_GETLINE_INFO
 1

	)

75 #define 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

77 #define 
	#_G_OPEN64
 
__open64


	)

78 #define 
	#_G_LSEEK64
 
__lseek64


	)

79 #define 
	#_G_MMAP64
 
__mmap64


	)

80 #define 
	#_G_FSTAT64
(
fd
,
buf
) 
	`__fxstat64
 (
_STAT_VER
, fd, buf)

	)

83 #define 
	#_G_HAVE_ST_BLKSIZE
 
	`defined
 (
_STATBUF_ST_BLKSIZE
)

	)

85 #define 
	#_G_BUFSIZ
 8192

	)

88 #define 
	#_G_NAMES_HAVE_UNDERSCORE
 0

	)

89 #define 
	#_G_VTABLE_LABEL_HAS_LENGTH
 1

	)

90 #define 
	#_G_USING_THUNKS
 1

	)

91 #define 
	#_G_VTABLE_LABEL_PREFIX
 "__vt_"

	)

92 #define 
	#_G_VTABLE_LABEL_PREFIX_ID
 
__vt_


	)

95 #if 
defined
 
__cplusplus
 || defined 
__STDC__


96 #define 
	#_G_ARGS
(
ARGLIST
) 
	)
ARGLIST

98 #define 
	#_G_ARGS
(
ARGLIST
) ()

	)

	@/usr/include/gconv.h

23 #ifndef 
_GCONV_H


24 #define 
	#_GCONV_H
 1

	)

26 #include 
	~<features.h
>

27 #define 
	#__need_mbstate_t


	)

28 #define 
	#__need_wint_t


	)

29 #include 
	~<wchar.h
>

30 #define 
	#__need_size_t


	)

31 #define 
	#__need_wchar_t


	)

32 #include 
	~<stddef.h
>

35 #define 
	#__UNKNOWN_10646_CHAR
 ((
wchar_t
) 0xfffd)

	)

40 
	m__GCONV_OK
 = 0,

41 
	m__GCONV_NOCONV
,

42 
	m__GCONV_NODB
,

43 
	m__GCONV_NOMEM
,

45 
	m__GCONV_EMPTY_INPUT
,

46 
	m__GCONV_FULL_OUTPUT
,

47 
	m__GCONV_ILLEGAL_INPUT
,

48 
	m__GCONV_INCOMPLETE_INPUT
,

50 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

51 
	m__GCONV_INTERNAL_ERROR


58 
	m__GCONV_IS_LAST
 = 0x0001,

59 
	m__GCONV_IGNORE_ERRORS
 = 0x0002

64 struct 
	g__gconv_step
;

65 struct 
	g__gconv_step_data
;

66 struct 
	g__gconv_loaded_object
;

67 struct 
	g__gconv_trans_data
;

71 typedef int (*
	t__gconv_fct
) (struct 
	t__gconv_step
 *, struct 
	t__gconv_step_data
 *,

72 
	t__const
 unsigned char **, __const unsigned char *,

73 unsigned char **, 
	tsize_t
 *, int, int);

76 typedef 
	$wint_t
 (*
	t__gconv_btowc_fct
) (struct 
	t__gconv_step
 *, unsigned char);

79 typedef int (*
	t__gconv_init_fct
) (struct 
	t__gconv_step
 *);

80 typedef void (*
	t__gconv_end_fct
) (struct 
	t__gconv_step
 *);

84 typedef int (*
	t__gconv_trans_fct
) (struct 
	t__gconv_step
 *,

85 struct 
	t__gconv_step_data
 *, void *,

86 
	t__const
 unsigned char *,

87 
	t__const
 unsigned char **,

88 
	t__const
 unsigned char *, unsigned char **,

89 
	tsize_t
 *);

92 typedef int (*
	t__gconv_trans_context_fct
) (void *, 
	t__const
 unsigned char *,

93 
	t__const
 unsigned char *,

97 typedef int (*
	t__gconv_trans_query_fct
) (
	t__const
 char *, __const char ***,

98 
	tsize_t
 *);

101 typedef int (*
	t__gconv_trans_init_fct
) (void **, const char *);

102 typedef void (*
	t__gconv_trans_end_fct
) (void *);

104 struct 
	s__gconv_trans_data


107 
__gconv_trans_fct
 
__trans_fct
;

108 
__gconv_trans_context_fct
 
__trans_context_fct
;

109 
__gconv_trans_end_fct
 
__trans_end_fct
;

110 void *
__data
;

111 struct 
__gconv_trans_data
 *
__next
;

116 struct 
	s__gconv_step


118 struct 
__gconv_loaded_object
 *
__shlib_handle
;

119 
__const
 char *
__modname
;

121 int 
__counter
;

123 char *
__from_name
;

124 char *
__to_name
;

126 
__gconv_fct
 
__fct
;

127 
__gconv_btowc_fct
 
__btowc_fct
;

128 
__gconv_init_fct
 
__init_fct
;

129 
__gconv_end_fct
 
__end_fct
;

133 int 
__min_needed_from
;

134 int 
__max_needed_from
;

135 int 
__min_needed_to
;

136 int 
__max_needed_to
;

139 int 
__stateful
;

141 void *
__data
;

146 struct 
	s__gconv_step_data


148 unsigned char *
__outbuf
;

149 unsigned char *
__outbufend
;

153 int 
__flags
;

157 int 
__invocation_counter
;

161 int 
__internal_use
;

163 
__mbstate_t
 *
__statep
;

164 
__mbstate_t
 
__state
;

168 struct 
__gconv_trans_data
 *
__trans
;

173 typedef struct 
	s__gconv_info


175 
size_t
 
__nsteps
;

176 struct 
__gconv_step
 *
__steps
;

177 
__extension__
 struct 
__gconv_step_data
 
__data
 
__flexarr
;

178 } *
	t__gconv_t
;

	@
1
.
1
/usr/include
407
8601
build-aux/snippet/_Noreturn.h
build-aux/snippet/arg-nonnull.h
build-aux/snippet/c++defs.h
build-aux/snippet/unused-parameter.h
build-aux/snippet/warn-on-use.h
gnulib-tests/anytostr.c
gnulib-tests/asnprintf.c
gnulib-tests/close.c
gnulib-tests/dup2.c
gnulib-tests/fd-hook.c
gnulib-tests/fd-hook.h
gnulib-tests/fdopen.c
gnulib-tests/float+.h
gnulib-tests/float.c
gnulib-tests/float.in.h
gnulib-tests/fpucw.h
gnulib-tests/getcwd-lgpl.c
gnulib-tests/glthread/lock.c
gnulib-tests/glthread/lock.h
gnulib-tests/glthread/thread.c
gnulib-tests/glthread/thread.h
gnulib-tests/glthread/threadlib.c
gnulib-tests/glthread/yield.h
gnulib-tests/hash-pjw.c
gnulib-tests/hash-pjw.h
gnulib-tests/imaxtostr.c
gnulib-tests/inttostr.c
gnulib-tests/inttostr.h
gnulib-tests/itold.c
gnulib-tests/localename.c
gnulib-tests/localename.h
gnulib-tests/lstat.c
gnulib-tests/macros.h
gnulib-tests/offtostr.c
gnulib-tests/printf-args.c
gnulib-tests/printf-args.h
gnulib-tests/printf-parse.c
gnulib-tests/printf-parse.h
gnulib-tests/putenv.c
gnulib-tests/setenv.c
gnulib-tests/setlocale.c
gnulib-tests/signature.h
gnulib-tests/size_max.h
gnulib-tests/snprintf.c
gnulib-tests/stdio.in.h
gnulib-tests/symlink.c
gnulib-tests/test-alloca-opt.c
gnulib-tests/test-argmatch.c
gnulib-tests/test-binary-io.c
gnulib-tests/test-bitrotate.c
gnulib-tests/test-btowc.c
gnulib-tests/test-c-ctype.c
gnulib-tests/test-c-strcasecmp.c
gnulib-tests/test-c-strncasecmp.c
gnulib-tests/test-close.c
gnulib-tests/test-ctype.c
gnulib-tests/test-dirent.c
gnulib-tests/test-dirname.c
gnulib-tests/test-dup2.c
gnulib-tests/test-environ.c
gnulib-tests/test-errno.c
gnulib-tests/test-exclude.c
gnulib-tests/test-fcntl-h.c
gnulib-tests/test-fdopen.c
gnulib-tests/test-fgetc.c
gnulib-tests/test-float.c
gnulib-tests/test-fnmatch.c
gnulib-tests/test-fpending.c
gnulib-tests/test-fputc.c
gnulib-tests/test-fread.c
gnulib-tests/test-fstat.c
gnulib-tests/test-fwrite.c
gnulib-tests/test-getcwd-lgpl.c
gnulib-tests/test-getopt.c
gnulib-tests/test-getopt.h
gnulib-tests/test-getopt_long.h
gnulib-tests/test-hash.c
gnulib-tests/test-iconv-h.c
gnulib-tests/test-iconv.c
gnulib-tests/test-ignore-value.c
gnulib-tests/test-intprops.c
gnulib-tests/test-inttostr.c
gnulib-tests/test-inttypes.c
gnulib-tests/test-isblank.c
gnulib-tests/test-iswblank.c
gnulib-tests/test-langinfo.c
gnulib-tests/test-locale.c
gnulib-tests/test-localename.c
gnulib-tests/test-lock.c
gnulib-tests/test-lseek.c
gnulib-tests/test-lstat.c
gnulib-tests/test-lstat.h
gnulib-tests/test-malloc-gnu.c
gnulib-tests/test-malloca.c
gnulib-tests/test-mbrtowc-w32.c
gnulib-tests/test-mbrtowc.c
gnulib-tests/test-mbscasecmp.c
gnulib-tests/test-mbsinit.c
gnulib-tests/test-mbsrtowcs.c
gnulib-tests/test-mbsstr1.c
gnulib-tests/test-mbsstr2.c
gnulib-tests/test-mbsstr3.c
gnulib-tests/test-memchr.c
gnulib-tests/test-nl_langinfo.c
gnulib-tests/test-open.c
gnulib-tests/test-open.h
gnulib-tests/test-pathmax.c
gnulib-tests/test-quotearg-simple.c
gnulib-tests/test-quotearg.h
gnulib-tests/test-realloc-gnu.c
gnulib-tests/test-setenv.c
gnulib-tests/test-setlocale1.c
gnulib-tests/test-setlocale2.c
gnulib-tests/test-snprintf.c
gnulib-tests/test-stat.c
gnulib-tests/test-stat.h
gnulib-tests/test-stdbool.c
gnulib-tests/test-stddef.c
gnulib-tests/test-stdint.c
gnulib-tests/test-stdio.c
gnulib-tests/test-stdlib.c
gnulib-tests/test-strerror.c
gnulib-tests/test-striconv.c
gnulib-tests/test-string.c
gnulib-tests/test-strings.c
gnulib-tests/test-strnlen.c
gnulib-tests/test-strtoumax.c
gnulib-tests/test-symlink.c
gnulib-tests/test-symlink.h
gnulib-tests/test-sys_stat.c
gnulib-tests/test-sys_types.c
gnulib-tests/test-sys_wait.h
gnulib-tests/test-thread_create.c
gnulib-tests/test-thread_self.c
gnulib-tests/test-time.c
gnulib-tests/test-unistd.c
gnulib-tests/test-unsetenv.c
gnulib-tests/test-vasnprintf.c
gnulib-tests/test-verify.c
gnulib-tests/test-version-etc.c
gnulib-tests/test-wchar.c
gnulib-tests/test-wcrtomb-w32.c
gnulib-tests/test-wcrtomb.c
gnulib-tests/test-wctype-h.c
gnulib-tests/test-wcwidth.c
gnulib-tests/test-xalloc-die.c
gnulib-tests/test-xstrtol.c
gnulib-tests/test-xstrtoul.c
gnulib-tests/test-xstrtoumax.c
gnulib-tests/uinttostr.c
gnulib-tests/umaxtostr.c
gnulib-tests/unistr/test-u8-mbtoucr.c
gnulib-tests/unistr/test-u8-uctomb.c
gnulib-tests/uniwidth/test-uc_width.c
gnulib-tests/uniwidth/test-uc_width2.c
gnulib-tests/unsetenv.c
gnulib-tests/vasnprintf.c
gnulib-tests/vasnprintf.h
gnulib-tests/xsize.h
gnulib-tests/zerosize-ptr.h
lib/alloca.c
lib/alloca.in.h
lib/argmatch.c
lib/argmatch.h
lib/basename-lgpl.c
lib/basename.c
lib/binary-io.h
lib/bitrotate.h
lib/btowc.c
lib/c-ctype.c
lib/c-ctype.h
lib/c-strcase.h
lib/c-strcasecmp.c
lib/c-strncasecmp.c
lib/close-stream.c
lib/close-stream.h
lib/closeout.c
lib/closeout.h
lib/ctype.in.h
lib/dirent.in.h
lib/dirname-lgpl.c
lib/dirname.c
lib/dirname.h
lib/dosname.h
lib/errno.in.h
lib/error.c
lib/error.h
lib/exclude.c
lib/exclude.h
lib/exitfail.c
lib/exitfail.h
lib/fcntl.in.h
lib/fnmatch.c
lib/fnmatch.in.h
lib/fnmatch_loop.c
lib/fpending.c
lib/fpending.h
lib/fstat.c
lib/getopt.c
lib/getopt.in.h
lib/getopt1.c
lib/getopt_int.h
lib/getpagesize.c
lib/gettext.h
lib/hard-locale.c
lib/hard-locale.h
lib/hash.c
lib/hash.h
lib/iconv.c
lib/iconv.in.h
lib/iconv_close.c
lib/iconv_open-aix.h
lib/iconv_open-hpux.h
lib/iconv_open-irix.h
lib/iconv_open-osf.h
lib/iconv_open-solaris.h
lib/iconv_open.c
lib/ignore-value.h
lib/intprops.h
lib/inttypes.in.h
lib/isblank.c
lib/isdir.c
lib/isdir.h
lib/iswblank.c
lib/langinfo.in.h
lib/localcharset.c
lib/localcharset.h
lib/locale.in.h
lib/lseek.c
lib/malloc.c
lib/malloca.c
lib/malloca.h
lib/mbchar.c
lib/mbchar.h
lib/mbiter.h
lib/mbrlen.c
lib/mbrtowc.c
lib/mbscasecmp.c
lib/mbsinit.c
lib/mbslen.c
lib/mbsrtowcs-impl.h
lib/mbsrtowcs-state.c
lib/mbsrtowcs.c
lib/mbsstr.c
lib/mbtowc-impl.h
lib/mbtowc.c
lib/mbuiter.h
lib/memchr.c
lib/mempcpy.c
lib/minmax.h
lib/msvc-inval.c
lib/msvc-inval.h
lib/msvc-nothrow.c
lib/msvc-nothrow.h
lib/nl_langinfo.c
lib/obstack.c
lib/obstack.h
lib/open.c
lib/pathmax.h
lib/progname.c
lib/progname.h
lib/propername.c
lib/propername.h
lib/quote.c
lib/quote.h
lib/quotearg.c
lib/quotearg.h
lib/realloc.c
lib/regcomp.c
lib/regex.c
lib/regex.h
lib/regex_internal.c
lib/regex_internal.h
lib/regexec.c
lib/same-inode.h
lib/savedir.c
lib/savedir.h
lib/stat.c
lib/stdarg.in.h
lib/stdbool.in.h
lib/stddef.in.h
lib/stdint.in.h
lib/stdlib.in.h
lib/stpcpy.c
lib/str-kmp.h
lib/strcasecmp.c
lib/streq.h
lib/strerror-override.c
lib/strerror-override.h
lib/strerror.c
lib/striconv.c
lib/striconv.h
lib/string.in.h
lib/strings.in.h
lib/stripslash.c
lib/strncasecmp.c
lib/strndup.c
lib/strnlen.c
lib/strnlen1.c
lib/strnlen1.h
lib/strtoimax.c
lib/strtol.c
lib/strtoul.c
lib/strtoull.c
lib/strtoumax.c
lib/sys_stat.in.h
lib/sys_types.in.h
lib/time.in.h
lib/trim.c
lib/trim.h
lib/unistd.in.h
lib/unistr.in.h
lib/unistr/u8-mbtoucr.c
lib/unistr/u8-uctomb-aux.c
lib/unistr/u8-uctomb.c
lib/unitypes.in.h
lib/uniwidth.in.h
lib/uniwidth/cjk.h
lib/uniwidth/width.c
lib/unlocked-io.h
lib/verify.h
lib/version-etc-fsf.c
lib/version-etc.c
lib/version-etc.h
lib/wchar.in.h
lib/wcrtomb.c
lib/wctob.c
lib/wctomb-impl.h
lib/wctomb.c
lib/wctype.in.h
lib/wcwidth.c
lib/xalloc-die.c
lib/xalloc-oversized.h
lib/xalloc.h
lib/xmalloc.c
lib/xstriconv.c
lib/xstriconv.h
lib/xstrndup.c
lib/xstrndup.h
lib/xstrtol-error.c
lib/xstrtol.c
lib/xstrtol.h
lib/xstrtoul.c
lib/xstrtoumax.c
src/dfa.c
src/dfa.h
src/dfasearch.c
src/dosbuf.c
src/egrep.c
src/fgrep.c
src/grep.c
src/grep.h
src/kwsearch.c
src/kwset.c
src/kwset.h
src/main.c
src/mbsupport.h
src/pcresearch.c
src/search.h
src/searchutils.c
src/system.h
tests/get-mb-cur-max.c
/usr/include/alloca.h
/usr/include/assert.h
/usr/include/ctype.h
/usr/include/dirent.h
/usr/include/errno.h
/usr/include/error.h
/usr/include/fcntl.h
/usr/include/features.h
/usr/include/fnmatch.h
/usr/include/getopt.h
/usr/include/gnu-versions.h
/usr/include/iconv.h
/usr/include/inttypes.h
/usr/include/langinfo.h
/usr/include/libintl.h
/usr/include/limits.h
/usr/include/locale.h
/usr/include/malloc.h
/usr/include/math.h
/usr/include/netdb.h
/usr/include/obstack.h
/usr/include/pthread.h
/usr/include/regex.h
/usr/include/sched.h
/usr/include/search.h
/usr/include/setjmp.h
/usr/include/signal.h
/usr/include/stdint.h
/usr/include/stdio.h
/usr/include/stdio_ext.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/strings.h
/usr/include/time.h
/usr/include/unistd.h
/usr/include/wchar.h
/usr/include/wctype.h
/usr/include/xlocale.h
/usr/include/endian.h
/usr/include/libio.h
/usr/include/netinet/in.h
/usr/include/nl_types.h
/usr/include/rpc/netdb.h
/usr/include/_G_config.h
/usr/include/gconv.h
